diff --git a/scripts/beautify.sh b/scripts/beautify.sh
index fa7215ebc..d541f8c1c 100755
--- a/scripts/beautify.sh
+++ b/scripts/beautify.sh
@@ -6,7 +6,7 @@ ROOT_DIR=$SCRIPT_DIR/..
 
 FORMAT_CMD_UNCRUSTIFY="uncrustify -c "$ROOT_DIR/.uncrustify.cfg" --no-backup"
 #LLVM|GNU|Google|Chromium|Microsoft|Mozilla|WebKit
-FORMAT_CMD_CLANG="clang-format -i --style LLVM" 
+FORMAT_CMD_CLANG="clang-format -i --style Chromium" 
 FORMAT_CMD=$FORMAT_CMD_CLANG
 
 # Filter out any files that shouldn't be auto-formatted.
diff --git a/src/Cache.h b/src/Cache.h
index 3c801bd5e..05c0c35be 100644
--- a/src/Cache.h
+++ b/src/Cache.h
@@ -49,14 +49,15 @@
 #include "utils/printutils.h"
 
 template <class Key, class T>
-class Cache
-{
+class Cache {
   struct Node {
-    inline Node() : keyPtr(nullptr), t(nullptr), c(0), p(nullptr), n(nullptr) {
-    }
-    inline Node(T * data, size_t cost) : keyPtr(nullptr), t(data), c(cost), p(nullptr), n(nullptr) {
-    }
-    const Key *keyPtr; T *t; size_t c; Node *p, *n;
+    inline Node() : keyPtr(nullptr), t(nullptr), c(0), p(nullptr), n(nullptr) {}
+    inline Node(T* data, size_t cost)
+        : keyPtr(nullptr), t(data), c(cost), p(nullptr), n(nullptr) {}
+    const Key* keyPtr;
+    T* t;
+    size_t c;
+    Node *p, *n;
   };
   using map_type = typename std::unordered_map<Key, Node>;
   using iterator_type = typename map_type::iterator;
@@ -64,28 +65,36 @@ class Cache
 
   std::unordered_map<Key, Node> hash;
   Node *f, *l;
-  void *unused{nullptr};
+  void* unused{nullptr};
   size_t mx, total{0};
 
   inline void unlink(Node& n) {
-    if (n.p) n.p->n = n.n;
-    if (n.n) n.n->p = n.p;
-    if (l == &n) l = n.p;
-    if (f == &n) f = n.n;
+    if (n.p)
+      n.p->n = n.n;
+    if (n.n)
+      n.n->p = n.p;
+    if (l == &n)
+      l = n.p;
+    if (f == &n)
+      f = n.n;
     total -= n.c;
-    T *obj = n.t;
+    T* obj = n.t;
     hash.erase(*n.keyPtr);
     delete obj;
   }
-  inline T *relink(const Key& key) {
+  inline T* relink(const Key& key) {
     auto i = hash.find(key);
-    if (i == hash.end()) return nullptr;
+    if (i == hash.end())
+      return nullptr;
 
     Node& n = i->second;
     if (f != &n) {
-      if (n.p) n.p->n = n.n;
-      if (n.n) n.n->p = n.p;
-      if (l == &n) l = n.p;
+      if (n.p)
+        n.p->n = n.n;
+      if (n.n)
+        n.n->p = n.p;
+      if (l == &n)
+        l = n.p;
       n.p = nullptr;
       n.n = f;
       f->p = &n;
@@ -94,13 +103,16 @@ class Cache
     return n.t;
   }
 
-public:
+ public:
   inline explicit Cache(size_t maxCost = 100)
-    : f(nullptr), l(nullptr), mx(maxCost) { }
+      : f(nullptr), l(nullptr), mx(maxCost) {}
   inline ~Cache() { clear(); }
 
   [[nodiscard]] inline size_t maxCost() const { return mx; }
-  void setMaxCost(size_t m) { mx = m; trim(mx); }
+  void setMaxCost(size_t m) {
+    mx = m;
+    trim(mx);
+  }
   [[nodiscard]] inline size_t totalCost() const { return total; }
 
   [[nodiscard]] inline size_t size() const { return hash.size(); }
@@ -108,28 +120,32 @@ public:
 
   void clear() {
     while (f) {
-      delete f->t; f = f->n;
+      delete f->t;
+      f = f->n;
     }
     hash.clear();
     l = nullptr;
     total = 0;
   }
 
-  bool insert(const Key& key, T *object, size_t cost);
-  T *object(const Key& key) const { return const_cast<Cache<Key, T> *>(this)->relink(key); }
-  inline bool contains(const Key& key) const { return hash.find(key) != hash.end(); }
-  T *operator[](const Key& key) const { return object(key); }
+  bool insert(const Key& key, T* object, size_t cost);
+  T* object(const Key& key) const {
+    return const_cast<Cache<Key, T>*>(this)->relink(key);
+  }
+  inline bool contains(const Key& key) const {
+    return hash.find(key) != hash.end();
+  }
+  T* operator[](const Key& key) const { return object(key); }
 
   bool remove(const Key& key);
-  T *take(const Key& key);
+  T* take(const Key& key);
 
-private:
+ private:
   void trim(size_t m);
 };
 
 template <class Key, class T>
-inline bool Cache<Key, T>::remove(const Key& key)
-{
+inline bool Cache<Key, T>::remove(const Key& key) {
   auto i = hash.find(key);
   if (i == hash.end()) {
     return false;
@@ -140,21 +156,20 @@ inline bool Cache<Key, T>::remove(const Key& key)
 }
 
 template <class Key, class T>
-inline T *Cache<Key, T>::take(const Key& key)
-{
+inline T* Cache<Key, T>::take(const Key& key) {
   iterator_type i = hash.find(key);
-  if (i == hash.end()) return 0;
+  if (i == hash.end())
+    return 0;
 
   Node& n = *i;
-  T *t = n.t;
+  T* t = n.t;
   n.t = 0;
   unlink(n);
   return t;
 }
 
 template <class Key, class T>
-bool Cache<Key, T>::insert(const Key& akey, T *aobject, size_t acost)
-{
+bool Cache<Key, T>::insert(const Key& akey, T* aobject, size_t acost) {
   remove(akey);
   if (acost > mx) {
     delete aobject;
@@ -165,21 +180,22 @@ bool Cache<Key, T>::insert(const Key& akey, T *aobject, size_t acost)
   hash[akey] = node;
   auto i = hash.find(akey);
   total += acost;
-  Node *n = &i->second;
+  Node* n = &i->second;
   n->keyPtr = &i->first;
-  if (f) f->p = n;
+  if (f)
+    f->p = n;
   n->n = f;
   f = n;
-  if (!l) l = f;
+  if (!l)
+    l = f;
   return true;
 }
 
 template <class Key, class T>
-void Cache<Key, T>::trim(size_t m)
-{
-  Node *n = l;
+void Cache<Key, T>::trim(size_t m) {
+  Node* n = l;
   while (n && total > m) {
-    Node *u = n;
+    Node* u = n;
     n = n->p;
 #ifdef DEBUG
     LOG("Trimming cache: %1$s (%2$d bytes)", u->keyPtr->substr(0, 40), u->c);
diff --git a/src/Feature.cc b/src/Feature.cc
index 6b0075a7a..258aa5f9e 100644
--- a/src/Feature.cc
+++ b/src/Feature.cc
@@ -15,7 +15,7 @@
  * NOTE: All features double-register pointers to themselves in these two
  * structures, and can be accessed from either.
  */
-Feature::map_t Feature::feature_map;  // Double-listed values. ----v
+Feature::map_t Feature::feature_map;    // Double-listed values. ----v
 Feature::list_t Feature::feature_list;  // Double-listed values. --^
 
 /*
@@ -27,36 +27,51 @@ Feature::list_t Feature::feature_list;  // Double-listed values. --^
  * const Features listed below.
  */
 const Feature Feature::ExperimentalRoof("roof", "Enable <code>roof</code>");
-const Feature Feature::ExperimentalInputDriverDBus("input-driver-dbus", "Enable DBus input drivers (requires restart)");
-const Feature Feature::ExperimentalLazyUnion("lazy-union", "Enable lazy unions.");
-const Feature Feature::ExperimentalVxORenderersIndexing("vertex-object-renderers-indexing", "Enable indexing in vertex object renderers");
-const Feature Feature::ExperimentalTextMetricsFunctions("textmetrics", "Enable the <code>textmetrics()</code> and <code>fontmetrics()</code> functions.");
-const Feature Feature::ExperimentalImportFunction("import-function", "Enable import function returning data instead of geometry.");
-const Feature Feature::ExperimentalObjectFunction("object-function", "Enable object function to allow user creation of objects.");
-const Feature Feature::ExperimentalPredictibleOutput("predictible-output", "Attempt to produce predictible, diffable outputs (e.g. sorting the STL, or remeshing in a determined order)");
+const Feature Feature::ExperimentalInputDriverDBus(
+    "input-driver-dbus",
+    "Enable DBus input drivers (requires restart)");
+const Feature Feature::ExperimentalLazyUnion("lazy-union",
+                                             "Enable lazy unions.");
+const Feature Feature::ExperimentalVxORenderersIndexing(
+    "vertex-object-renderers-indexing",
+    "Enable indexing in vertex object renderers");
+const Feature Feature::ExperimentalTextMetricsFunctions(
+    "textmetrics",
+    "Enable the <code>textmetrics()</code> and <code>fontmetrics()</code> "
+    "functions.");
+const Feature Feature::ExperimentalImportFunction(
+    "import-function",
+    "Enable import function returning data instead of geometry.");
+const Feature Feature::ExperimentalObjectFunction(
+    "object-function",
+    "Enable object function to allow user creation of objects.");
+const Feature Feature::ExperimentalPredictibleOutput(
+    "predictible-output",
+    "Attempt to produce predictible, diffable outputs (e.g. sorting the STL, "
+    "or remeshing in a determined order)");
 #ifdef ENABLE_PYTHON
-const Feature Feature::ExperimentalPythonEngine("python-engine", "Enable experimental Python Engine (implies risk of malicious scripts downloaded).");
+const Feature Feature::ExperimentalPythonEngine(
+    "python-engine",
+    "Enable experimental Python Engine (implies risk of malicious scripts "
+    "downloaded).");
 #endif
 
 Feature::Feature(const std::string& name, std::string description, bool hidden)
-  : name(name), description(std::move(description))
-{
+    : name(name), description(std::move(description)) {
   feature_map[name] = this;
-  if (!hidden) feature_list.push_back(this);
+  if (!hidden)
+    feature_list.push_back(this);
 }
 
-const std::string& Feature::get_name() const
-{
+const std::string& Feature::get_name() const {
   return name;
 }
 
-const std::string& Feature::get_description() const
-{
+const std::string& Feature::get_description() const {
   return description;
 }
 
-bool Feature::is_enabled() const
-{
+bool Feature::is_enabled() const {
 #ifdef ENABLE_EXPERIMENTAL
   return enabled;
 #else
@@ -64,57 +79,54 @@ bool Feature::is_enabled() const
 #endif
 }
 
-void Feature::enable(bool status)
-{
+void Feature::enable(bool status) {
   enabled = status;
 }
 
 // Note, features are also accessed by iterator with begin/end.
-void Feature::enable_feature(const std::string& feature_name, bool status)
-{
+void Feature::enable_feature(const std::string& feature_name, bool status) {
   auto it = feature_map.find(feature_name);
   if (it != feature_map.end()) {
     it->second->enable(status);
   } else {
-    LOG(message_group::Warning, "Ignoring request to enable unknown feature '%1$s'.", feature_name);
+    LOG(message_group::Warning,
+        "Ignoring request to enable unknown feature '%1$s'.", feature_name);
   }
 }
 
-void Feature::enable_all(bool status)
-{
-  for (const auto& f : boost::make_iterator_range(Feature::begin(), Feature::end())) {
+void Feature::enable_all(bool status) {
+  for (const auto& f :
+       boost::make_iterator_range(Feature::begin(), Feature::end())) {
     f->enable(status);
   }
 }
 
-Feature::iterator Feature::begin()
-{
+Feature::iterator Feature::begin() {
   return feature_list.begin();
 }
 
-Feature::iterator Feature::end()
-{
+Feature::iterator Feature::end() {
   return feature_list.end();
 }
 
-std::string Feature::features()
-{
+std::string Feature::features() {
   const auto seq = boost::make_iterator_range(Feature::begin(), Feature::end());
-  const auto str = [](const Feature *const f) {
-      return (boost::format("%s%s") % f->get_name() % (f->is_enabled() ? "*" : "")).str();
-    };
+  const auto str = [](const Feature* const f) {
+    return (boost::format("%s%s") % f->get_name() %
+            (f->is_enabled() ? "*" : ""))
+        .str();
+  };
   return boost::algorithm::join(boost::adaptors::transform(seq, str), ", ");
 }
 
-ExperimentalFeatureException::ExperimentalFeatureException(const std::string& what_arg)
-  : EvaluationException(what_arg)
-{
+ExperimentalFeatureException::ExperimentalFeatureException(
+    const std::string& what_arg)
+    : EvaluationException(what_arg) {}
 
-}
-
-void ExperimentalFeatureException::check(const Feature& feature)
-{
+void ExperimentalFeatureException::check(const Feature& feature) {
   if (!feature.is_enabled()) {
-    throw ExperimentalFeatureException(STR("ERROR: Experimental feature not enabled: '", feature.get_name(), "'. Please check preferences."));
+    throw ExperimentalFeatureException(
+        STR("ERROR: Experimental feature not enabled: '", feature.get_name(),
+            "'. Please check preferences."));
   }
 }
diff --git a/src/Feature.h b/src/Feature.h
index d475de6f9..2d74fe111 100644
--- a/src/Feature.h
+++ b/src/Feature.h
@@ -1,15 +1,14 @@
 #pragma once
 
-#include <string>
 #include <map>
+#include <string>
 #include <vector>
 
 #include "utils/exceptions.h"
 
-class Feature
-{
-public:
-  using list_t = std::vector<Feature *>;
+class Feature {
+ public:
+  using list_t = std::vector<Feature*>;
   using iterator = list_t::iterator;
 
   static const Feature ExperimentalRoof;
@@ -25,9 +24,9 @@ public:
 #endif
 
 #ifdef ENABLE_GUI_TESTS
-  static constexpr bool HasGuiTesting {true};
+  static constexpr bool HasGuiTesting{true};
 #else
-  static constexpr bool HasGuiTesting {false};
+  static constexpr bool HasGuiTesting{false};
 #endif
 
   [[nodiscard]] const std::string& get_name() const;
@@ -40,28 +39,30 @@ public:
   static iterator end();
 
   static std::string features();
-  static void enable_feature(const std::string& feature_name, bool status = true);
+  static void enable_feature(const std::string& feature_name,
+                             bool status = true);
   static void enable_all(bool status = true);
 
-private:
+ private:
   bool enabled{false};
 
   const std::string name;
   const std::string description;
 
-  using map_t = std::map<std::string, Feature *>;
+  using map_t = std::map<std::string, Feature*>;
   static map_t feature_map;
   static list_t feature_list;
 
-  Feature(const std::string& name, std::string description, bool hidden = false);
+  Feature(const std::string& name,
+          std::string description,
+          bool hidden = false);
   virtual ~Feature() = default;
 };
 
-class ExperimentalFeatureException : public EvaluationException
-{
-public:
+class ExperimentalFeatureException : public EvaluationException {
+ public:
   static void check(const Feature& feature);
 
-private:
+ private:
   ExperimentalFeatureException(const std::string& what_arg);
 };
diff --git a/src/FontCache.cc b/src/FontCache.cc
index 39f440729..cd14079e3 100644
--- a/src/FontCache.cc
+++ b/src/FontCache.cc
@@ -27,8 +27,8 @@
 #include "FontCache.h"
 
 #include <cassert>
-#include <cstdlib>
 #include <cstdint>
+#include <cstdlib>
 #include <ctime>
 #include <filesystem>
 #include <iostream>
@@ -36,10 +36,10 @@
 #include <utility>
 #include <vector>
 
-#include <boost/algorithm/string.hpp>
-#include <hb.h>
 #include <fontconfig/fontconfig.h>
 #include <ft2build.h>
+#include <hb.h>
+#include <boost/algorithm/string.hpp>
 #include FT_FREETYPE_H
 #include FT_TYPES_H
 #include FT_TRUETYPE_IDS_H
@@ -53,37 +53,40 @@ std::vector<std::string> fontpath;
 
 namespace fs = std::filesystem;
 
-std::string get_fontconfig_version()
-{
+std::string get_fontconfig_version() {
   const unsigned int version = FcGetVersion();
 
-  const OpenSCAD::library_version_number header_version{FC_MAJOR, FC_MINOR, FC_REVISION};
-  const OpenSCAD::library_version_number runtime_version{version / 10000, (version / 100) % 100, version % 100};
+  const OpenSCAD::library_version_number header_version{FC_MAJOR, FC_MINOR,
+                                                        FC_REVISION};
+  const OpenSCAD::library_version_number runtime_version{
+      version / 10000, (version / 100) % 100, version % 100};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
-std::string get_harfbuzz_version()
-{
+std::string get_harfbuzz_version() {
   unsigned int major, minor, micro;
   hb_version(&major, &minor, &micro);
 
-  const OpenSCAD::library_version_number header_version{HB_VERSION_MAJOR, HB_VERSION_MINOR, HB_VERSION_MICRO};
+  const OpenSCAD::library_version_number header_version{
+      HB_VERSION_MAJOR, HB_VERSION_MINOR, HB_VERSION_MICRO};
   const OpenSCAD::library_version_number runtime_version{major, minor, micro};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
-std::string get_freetype_version()
-{
+std::string get_freetype_version() {
   return FontCache::instance()->get_freetype_version();
 }
 
-FontInfo::FontInfo(std::string family, std::string style, std::string file, uint32_t hash)
-  : family(std::move(family)), style(std::move(style)), file(std::move(file)), hash(hash)
-{
-}
+FontInfo::FontInfo(std::string family,
+                   std::string style,
+                   std::string file,
+                   uint32_t hash)
+    : family(std::move(family)),
+      style(std::move(style)),
+      file(std::move(file)),
+      hash(hash) {}
 
-bool FontInfo::operator<(const FontInfo& rhs) const
-{
+bool FontInfo::operator<(const FontInfo& rhs) const {
   if (family < rhs.family) {
     return true;
   }
@@ -93,29 +96,26 @@ bool FontInfo::operator<(const FontInfo& rhs) const
   return file < rhs.file;
 }
 
-const std::string& FontInfo::get_family() const
-{
+const std::string& FontInfo::get_family() const {
   return family;
 }
 
-const std::string& FontInfo::get_style() const
-{
+const std::string& FontInfo::get_style() const {
   return style;
 }
 
-const std::string& FontInfo::get_file() const
-{
+const std::string& FontInfo::get_file() const {
   return file;
 }
 
-const uint32_t FontInfo::get_hash() const
-{
+const uint32_t FontInfo::get_hash() const {
   return hash;
 }
 
-FontCache *FontCache::self = nullptr;
-FontCache::InitHandlerFunc *FontCache::cb_handler = FontCache::defaultInitHandler;
-void *FontCache::cb_userdata = nullptr;
+FontCache* FontCache::self = nullptr;
+FontCache::InitHandlerFunc* FontCache::cb_handler =
+    FontCache::defaultInitHandler;
+void* FontCache::cb_userdata = nullptr;
 const std::string FontCache::DEFAULT_FONT("Liberation Sans:style=Regular");
 
 /**
@@ -123,29 +123,30 @@ const std::string FontCache::DEFAULT_FONT("Liberation Sans:style=Regular");
  * handler is registered, the cache build is just called synchronously in the
  * current thread by this handler.
  */
-void FontCache::defaultInitHandler(FontCacheInitializer *initializer, void *)
-{
+void FontCache::defaultInitHandler(FontCacheInitializer* initializer, void*) {
   initializer->run();
 }
 
-FontCache::FontCache()
-{
+FontCache::FontCache() {
   this->init_ok = false;
   this->library = nullptr;
 
-  // If we've got a bundled fonts.conf, initialize fontconfig with our own config
-  // by overriding the built-in fontconfig path.
-  // For system installs and dev environments, we leave this alone
+  // If we've got a bundled fonts.conf, initialize fontconfig with our own
+  // config by overriding the built-in fontconfig path. For system installs and
+  // dev environments, we leave this alone
   const fs::path fontdir(PlatformUtils::resourcePath("fonts"));
   if (fs::is_regular_file(fontdir / "fonts.conf")) {
     auto abspath = fontdir.empty() ? fs::current_path() : fs::absolute(fontdir);
-    PlatformUtils::setenv("FONTCONFIG_PATH", (abspath.generic_string()).c_str(), 0);
+    PlatformUtils::setenv("FONTCONFIG_PATH", (abspath.generic_string()).c_str(),
+                          0);
   }
 
   // Just load the configs. We'll build the fonts once all configs are loaded
   this->config = FcInitLoadConfig();
   if (!this->config) {
-    LOG(message_group::Font_Warning, "Can't initialize fontconfig library, text() objects will not be rendered");
+    LOG(message_group::Font_Warning,
+        "Can't initialize fontconfig library, text() objects will not be "
+        "rendered");
     return;
   }
 
@@ -155,11 +156,14 @@ FontCache::FontCache()
 #ifndef __EMSCRIPTEN__
     builtinfontpath = fs::canonical(builtinfontpath);
 #endif
-    FcConfigParseAndLoad(this->config, reinterpret_cast<const FcChar8 *>(builtinfontpath.generic_string().c_str()), false);
+    FcConfigParseAndLoad(this->config,
+                         reinterpret_cast<const FcChar8*>(
+                             builtinfontpath.generic_string().c_str()),
+                         false);
     add_font_dir(builtinfontpath.generic_string());
   }
 
-  const char *home = getenv("HOME");
+  const char* home = getenv("HOME");
 
   // Add Linux font folders, the system folders are expected to be
   // configured by the system configuration for fontconfig.
@@ -167,12 +171,14 @@ FontCache::FontCache()
     add_font_dir(std::string(home) + "/.fonts");
   }
 
-  const char *env_font_path = getenv("OPENSCAD_FONT_PATH");
+  const char* env_font_path = getenv("OPENSCAD_FONT_PATH");
   if (env_font_path != nullptr) {
     std::string paths(env_font_path);
     const std::string sep = PlatformUtils::pathSeparatorChar();
     using string_split_iterator = boost::split_iterator<std::string::iterator>;
-    for (string_split_iterator it = boost::make_split_iterator(paths, boost::first_finder(sep, boost::is_iequal())); it != string_split_iterator(); ++it) {
+    for (string_split_iterator it = boost::make_split_iterator(
+             paths, boost::first_finder(sep, boost::is_iequal()));
+         it != string_split_iterator(); ++it) {
       const fs::path p(boost::copy_range<std::string>(*it));
       if (fs::exists(p) && fs::is_directory(p)) {
         const std::string path = fs::absolute(p).string();
@@ -185,31 +191,31 @@ FontCache::FontCache()
   cb_handler(&initializer, cb_userdata);
 
   // For use by LibraryInfo
-  FcStrList *dirs = FcConfigGetFontDirs(this->config);
-  while (FcChar8 *dir = FcStrListNext(dirs)) {
-    fontpath.emplace_back((const char *)dir);
+  FcStrList* dirs = FcConfigGetFontDirs(this->config);
+  while (FcChar8* dir = FcStrListNext(dirs)) {
+    fontpath.emplace_back((const char*)dir);
   }
   FcStrListDone(dirs);
 
   const FT_Error error = FT_Init_FreeType(&this->library);
   if (error) {
-    LOG(message_group::Font_Warning, "Can't initialize freetype library, text() objects will not be rendered");
+    LOG(message_group::Font_Warning,
+        "Can't initialize freetype library, text() objects will not be "
+        "rendered");
     return;
   }
 
   this->init_ok = true;
 }
 
-FontCache *FontCache::instance()
-{
+FontCache* FontCache::instance() {
   if (!self) {
     self = new FontCache();
   }
   return self;
 }
 
-const std::string FontCache::get_freetype_version() const
-{
+const std::string FontCache::get_freetype_version() const {
   if (!this->is_init_ok()) {
     return "(not initialized)";
   }
@@ -217,40 +223,43 @@ const std::string FontCache::get_freetype_version() const
   FT_Int major, minor, micro;
   FT_Library_Version(this->library, &major, &minor, &micro);
 
-  const OpenSCAD::library_version_number header_version{FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH};
-  const OpenSCAD::library_version_number runtime_version{static_cast<unsigned>(major), static_cast<unsigned>(minor), static_cast<unsigned>(micro)};
+  const OpenSCAD::library_version_number header_version{
+      FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH};
+  const OpenSCAD::library_version_number runtime_version{
+      static_cast<unsigned>(major), static_cast<unsigned>(minor),
+      static_cast<unsigned>(micro)};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
-void FontCache::registerProgressHandler(InitHandlerFunc *handler, void *userdata)
-{
+void FontCache::registerProgressHandler(InitHandlerFunc* handler,
+                                        void* userdata) {
   FontCache::cb_handler = handler;
   FontCache::cb_userdata = userdata;
 }
 
-void FontCache::register_font_file(const std::string& path)
-{
-  if (!FcConfigAppFontAddFile(this->config, reinterpret_cast<const FcChar8 *>(path.c_str()))) {
+void FontCache::register_font_file(const std::string& path) {
+  if (!FcConfigAppFontAddFile(this->config,
+                              reinterpret_cast<const FcChar8*>(path.c_str()))) {
     LOG("Can't register font '%1$s'", path);
   }
 }
 
-void FontCache::add_font_dir(const std::string& path)
-{
+void FontCache::add_font_dir(const std::string& path) {
   if (!fs::is_directory(path)) {
     return;
   }
-  if (!FcConfigAppFontAddDir(this->config, reinterpret_cast<const FcChar8 *>(path.c_str()))) {
+  if (!FcConfigAppFontAddDir(this->config,
+                             reinterpret_cast<const FcChar8*>(path.c_str()))) {
     LOG("Can't register font directory '%1$s'", path);
   }
 }
 
-std::vector<uint32_t> FontCache::filter(const std::u32string& str) const
-{
-  FcObjectSet *object_set = FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
-  FcPattern *pattern = FcPatternCreate();
+std::vector<uint32_t> FontCache::filter(const std::u32string& str) const {
+  FcObjectSet* object_set =
+      FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
+  FcPattern* pattern = FcPatternCreate();
   init_pattern(pattern);
-  FcCharSet *charSet = FcCharSetCreate();
+  FcCharSet* charSet = FcCharSetCreate();
   for (const char32_t a : str) {
     FcCharSetAddChar(charSet, a);
   }
@@ -259,7 +268,7 @@ std::vector<uint32_t> FontCache::filter(const std::u32string& str) const
   charSetValue.u.c = charSet;
   FcPatternAdd(pattern, FC_CHARSET, charSetValue, true);
 
-  FcFontSet *font_set = FcFontList(this->config, pattern, object_set);
+  FcFontSet* font_set = FcFontList(this->config, pattern, object_set);
   FcObjectSetDestroy(object_set);
   FcPatternDestroy(pattern);
   FcCharSetDestroy(charSet);
@@ -273,37 +282,37 @@ std::vector<uint32_t> FontCache::filter(const std::u32string& str) const
   return result;
 }
 
-FontInfoList *FontCache::list_fonts() const
-{
-  FcObjectSet *object_set = FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
-  FcPattern *pattern = FcPatternCreate();
+FontInfoList* FontCache::list_fonts() const {
+  FcObjectSet* object_set =
+      FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
+  FcPattern* pattern = FcPatternCreate();
   init_pattern(pattern);
-  FcFontSet *font_set = FcFontList(this->config, pattern, object_set);
+  FcFontSet* font_set = FcFontList(this->config, pattern, object_set);
   FcObjectSetDestroy(object_set);
   FcPatternDestroy(pattern);
 
-  auto *list = new FontInfoList();
+  auto* list = new FontInfoList();
   for (int a = 0; a < font_set->nfont; ++a) {
-    FcPattern *p = font_set->fonts[a];
+    FcPattern* p = font_set->fonts[a];
 
-    FcChar8 *file_value;
+    FcChar8* file_value;
     if (FcPatternGetString(p, FC_FILE, 0, &file_value) != FcResultMatch) {
       continue;
     }
 
-    FcChar8 *family_value;
+    FcChar8* family_value;
     if (FcPatternGetString(p, FC_FAMILY, 0, &family_value) != FcResultMatch) {
       continue;
     }
 
-    FcChar8 *style_value;
+    FcChar8* style_value;
     if (FcPatternGetString(p, FC_STYLE, 0, &style_value) != FcResultMatch) {
       continue;
     }
 
-    const std::string family((const char *) family_value);
-    const std::string style((const char *) style_value);
-    const std::string file((const char *) file_value);
+    const std::string family((const char*)family_value);
+    const std::string style((const char*)style_value);
+    const std::string file((const char*)file_value);
 
     list->emplace_back(family, style, file, FcPatternHash(p));
   }
@@ -312,18 +321,15 @@ FontInfoList *FontCache::list_fonts() const
   return list;
 }
 
-bool FontCache::is_init_ok() const
-{
+bool FontCache::is_init_ok() const {
   return this->init_ok;
 }
 
-void FontCache::clear()
-{
+void FontCache::clear() {
   this->cache.clear();
 }
 
-void FontCache::dump_cache(const std::string& info)
-{
+void FontCache::dump_cache(const std::string& info) {
   std::cout << info << ":";
   for (const auto& item : this->cache) {
     std::cout << " " << item.first << " (" << item.second.second << ")";
@@ -331,8 +337,7 @@ void FontCache::dump_cache(const std::string& info)
   std::cout << std::endl;
 }
 
-void FontCache::check_cleanup()
-{
+void FontCache::check_cleanup() {
   if (this->cache.size() < MAX_NR_OF_CACHE_ENTRIES) {
     return;
   }
@@ -347,8 +352,7 @@ void FontCache::check_cleanup()
   this->cache.erase(pos);
 }
 
-FontFacePtr FontCache::get_font(const std::string& font)
-{
+FontFacePtr FontCache::get_font(const std::string& font) {
   FontFacePtr face;
   auto it = this->cache.find(font);
   if (it == this->cache.end()) {
@@ -364,8 +368,7 @@ FontFacePtr FontCache::get_font(const std::string& font)
   return face;
 }
 
-FontFacePtr FontCache::find_face(const std::string& font) const
-{
+FontFacePtr FontCache::find_face(const std::string& font) const {
   std::string trimmed(font);
   boost::algorithm::trim(trimmed);
 
@@ -373,30 +376,29 @@ FontFacePtr FontCache::find_face(const std::string& font) const
   PRINTDB("font = \"%s\", lookup = \"%s\"", font % lookup);
   FontFacePtr face = find_face_fontconfig(lookup);
   if (face) {
-    PRINTDB("result = \"%s\", style = \"%s\"", face->face_->family_name % face->face_->style_name);
+    PRINTDB("result = \"%s\", style = \"%s\"",
+            face->face_->family_name % face->face_->style_name);
   } else {
     PRINTD("font not found");
   }
   return face;
 }
 
-void FontCache::init_pattern(FcPattern *pattern) const
-{
+void FontCache::init_pattern(FcPattern* pattern) const {
   assert(pattern);
   const FcValue true_value = {
-    .type = FcTypeBool,
-    .u = {.b = true},
+      .type = FcTypeBool,
+      .u = {.b = true},
   };
 
   FcPatternAdd(pattern, FC_OUTLINE, true_value, true);
   FcPatternAdd(pattern, FC_SCALABLE, true_value, true);
 }
 
-FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const
-{
+FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const {
   FcResult result;
 
-  FcPattern *pattern = FcNameParse((unsigned char *)font.c_str());
+  FcPattern* pattern = FcNameParse((unsigned char*)font.c_str());
   if (!pattern) {
     LOG(message_group::Font_Warning, "Could not parse font '%1$s'", font);
     return nullptr;
@@ -406,9 +408,9 @@ FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const
   FcConfigSubstitute(this->config, pattern, FcMatchPattern);
   FcDefaultSubstitute(pattern);
 
-  FcPattern *match = FcFontMatch(this->config, pattern, &result);
+  FcPattern* match = FcFontMatch(this->config, pattern, &result);
 
-  FcChar8 *file_value;
+  FcChar8* file_value;
   if (FcPatternGetString(match, FC_FILE, 0, &file_value) != FcResultMatch) {
     return nullptr;
   }
@@ -418,15 +420,17 @@ FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const
     return nullptr;
   }
 
-  FcChar8 *font_features;
+  FcChar8* font_features;
   std::string font_features_str;
-  if (FcPatternGetString(match, FC_FONT_FEATURES, 0, &font_features) == FcResultMatch) {
-    font_features_str = (const char *)(font_features);
+  if (FcPatternGetString(match, FC_FONT_FEATURES, 0, &font_features) ==
+      FcResultMatch) {
+    font_features_str = (const char*)(font_features);
     PRINTDB("Found font features: '%s'", font_features_str);
   }
 
   FT_Face ftFace;
-  const FT_Error error = FT_New_Face(this->library, (const char *)file_value, font_index, &ftFace);
+  const FT_Error error =
+      FT_New_Face(this->library, (const char*)file_value, font_index, &ftFace);
 
   FcPatternDestroy(pattern);
   FcPatternDestroy(match);
@@ -441,36 +445,56 @@ FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const
 
   for (int a = 0; a < face->face_->num_charmaps; ++a) {
     FT_CharMap charmap = face->face_->charmaps[a];
-    PRINTDB("charmap = %d: platform = %d, encoding = %d", a % charmap->platform_id % charmap->encoding_id);
+    PRINTDB("charmap = %d: platform = %d, encoding = %d",
+            a % charmap->platform_id % charmap->encoding_id);
   }
 
   if (FT_Select_Charmap(face->face_, ft_encoding_unicode) == 0) {
-    PRINTDB("Successfully selected unicode charmap: %s/%s", face->face_->family_name % face->face_->style_name);
+    PRINTDB("Successfully selected unicode charmap: %s/%s",
+            face->face_->family_name % face->face_->style_name);
   } else {
     bool charmap_set = false;
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_UNICODE_CS);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_10646);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_APPLE_UNICODE, -1);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_SYMBOL_CS);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MACINTOSH, TT_MAC_ID_ROMAN);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_8859_1);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_7BIT_ASCII);
-    if (!charmap_set) LOG(message_group::Font_Warning, "Could not select a char map for font '%1$s/%2$s'", face->face_->family_name, face->face_->style_name);
+    if (!charmap_set)
+      charmap_set =
+          try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_UNICODE_CS);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_10646);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_APPLE_UNICODE, -1);
+    if (!charmap_set)
+      charmap_set =
+          try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_SYMBOL_CS);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_MACINTOSH, TT_MAC_ID_ROMAN);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_8859_1);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_7BIT_ASCII);
+    if (!charmap_set)
+      LOG(message_group::Font_Warning,
+          "Could not select a char map for font '%1$s/%2$s'",
+          face->face_->family_name, face->face_->style_name);
   }
 
   return face;
 }
 
-bool FontCache::try_charmap(const FontFacePtr& face_ptr, int platform_id, int encoding_id) const
-{
+bool FontCache::try_charmap(const FontFacePtr& face_ptr,
+                            int platform_id,
+                            int encoding_id) const {
   FT_Face face = face_ptr->face_;
   for (int idx = 0; idx < face->num_charmaps; ++idx) {
     FT_CharMap charmap = face->charmaps[idx];
-    if ((charmap->platform_id == platform_id) && ((encoding_id < 0) || (charmap->encoding_id == encoding_id))) {
+    if ((charmap->platform_id == platform_id) &&
+        ((encoding_id < 0) || (charmap->encoding_id == encoding_id))) {
       if (FT_Set_Charmap(face, charmap) == 0) {
-        PRINTDB("Selected charmap: platform_id = %d, encoding_id = %d", charmap->platform_id % charmap->encoding_id);
+        PRINTDB("Selected charmap: platform_id = %d, encoding_id = %d",
+                charmap->platform_id % charmap->encoding_id);
         if (is_windows_symbol_font(face)) {
-          PRINTDB("Detected windows symbol font with character codes in the Private Use Area of Unicode at 0xf000: %s/%s", face->family_name % face->style_name);
+          PRINTDB(
+              "Detected windows symbol font with character codes in the "
+              "Private Use Area of Unicode at 0xf000: %s/%s",
+              face->family_name % face->style_name);
         }
         return true;
       }
@@ -479,8 +503,7 @@ bool FontCache::try_charmap(const FontFacePtr& face_ptr, int platform_id, int en
   return false;
 }
 
-bool FontCache::is_windows_symbol_font(const FT_Face& face) const
-{
+bool FontCache::is_windows_symbol_font(const FT_Face& face) const {
   if (face->charmap->platform_id != TT_PLATFORM_MICROSOFT) {
     return false;
   }
diff --git a/src/FontCache.h b/src/FontCache.h
index a4b69198d..4b93b9363 100644
--- a/src/FontCache.h
+++ b/src/FontCache.h
@@ -28,11 +28,10 @@
 #include <cstdint>
 #include <ctime>
 #include <map>
-#include <string>
+#include <memory>
 #include <string>
 #include <utility>
 #include <vector>
-#include <memory>
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
@@ -42,10 +41,12 @@ std::string get_fontconfig_version();
 std::string get_harfbuzz_version();
 std::string get_freetype_version();
 
-class FontInfo
-{
-public:
-  FontInfo(std::string family, std::string style, std::string file, uint32_t hash);
+class FontInfo {
+ public:
+  FontInfo(std::string family,
+           std::string style,
+           std::string file,
+           uint32_t hash);
   virtual ~FontInfo() = default;
 
   [[nodiscard]] const std::string& get_family() const;
@@ -53,7 +54,8 @@ public:
   [[nodiscard]] const std::string& get_file() const;
   [[nodiscard]] const uint32_t get_hash() const;
   bool operator<(const FontInfo& rhs) const;
-private:
+
+ private:
   std::string family;
   std::string style;
   std::string file;
@@ -67,34 +69,29 @@ using FontInfoList = std::vector<FontInfo>;
  * can be passed to the GUI to run in a separate thread while showing a
  * progress dialog.
  */
-class FontCacheInitializer
-{
-public:
-  FontCacheInitializer(FcConfig *config) : config(config) { }
+class FontCacheInitializer {
+ public:
+  FontCacheInitializer(FcConfig* config) : config(config) {}
   void run() { FcConfigBuildFonts(config); }
-private:
-  FcConfig *config;
+
+ private:
+  FcConfig* config;
 };
 
-struct FontFace
-{
+struct FontFace {
   FT_Face face_;
   std::vector<std::string> features_;
 
   FontFace(FT_Face face, std::vector<std::string> features)
-    : face_(face), features_(std::move(features)) {
-  }
+      : face_(face), features_(std::move(features)) {}
 
-  virtual ~FontFace() {
-    FT_Done_Face(face_);
-  }
+  virtual ~FontFace() { FT_Done_Face(face_); }
 };
 
 using FontFacePtr = std::shared_ptr<const FontFace>;
 
-class FontCache
-{
-public:
+class FontCache {
+ public:
   const static std::string DEFAULT_FONT;
   const static unsigned int MAX_NR_OF_CACHE_ENTRIES = 5;
 
@@ -106,38 +103,41 @@ public:
   [[nodiscard]] bool is_windows_symbol_font(const FT_Face& face) const;
   void register_font_file(const std::string& path);
   void clear();
-  [[nodiscard]] FontInfoList *list_fonts() const;
+  [[nodiscard]] FontInfoList* list_fonts() const;
   [[nodiscard]] std::vector<uint32_t> filter(const std::u32string&) const;
   [[nodiscard]] const std::string get_freetype_version() const;
 
-  static FontCache *instance();
+  static FontCache* instance();
 
-  using InitHandlerFunc = void (FontCacheInitializer *, void *);
-  static void registerProgressHandler(InitHandlerFunc *handler, void *userdata = nullptr);
+  using InitHandlerFunc = void(FontCacheInitializer*, void*);
+  static void registerProgressHandler(InitHandlerFunc* handler,
+                                      void* userdata = nullptr);
 
-private:
+ private:
   using cache_entry_t = std::pair<FontFacePtr, std::time_t>;
   using cache_t = std::map<std::string, cache_entry_t>;
 
-  static FontCache *self;
-  static InitHandlerFunc *cb_handler;
-  static void *cb_userdata;
+  static FontCache* self;
+  static InitHandlerFunc* cb_handler;
+  static void* cb_userdata;
 
-  static void defaultInitHandler(FontCacheInitializer *delegate, void *userdata);
+  static void defaultInitHandler(FontCacheInitializer* delegate,
+                                 void* userdata);
 
   bool init_ok;
   cache_t cache;
-  FcConfig *config;
+  FcConfig* config;
   FT_Library library;
 
   void check_cleanup();
   void dump_cache(const std::string& info);
 
   void add_font_dir(const std::string& path);
-  void init_pattern(FcPattern *pattern) const;
+  void init_pattern(FcPattern* pattern) const;
 
   [[nodiscard]] FontFacePtr find_face(const std::string& font) const;
   [[nodiscard]] FontFacePtr find_face_fontconfig(const std::string& font) const;
-  bool try_charmap(const FontFacePtr& face_ptr, int platform_id, int encoding_id) const;
+  bool try_charmap(const FontFacePtr& face_ptr,
+                   int platform_id,
+                   int encoding_id) const;
 };
-
diff --git a/src/LibraryInfo.cc b/src/LibraryInfo.cc
index 3b73daa22..9a925a583 100644
--- a/src/LibraryInfo.cc
+++ b/src/LibraryInfo.cc
@@ -6,14 +6,14 @@
 #include <vector>
 
 #include <clipper2/clipper.version.h>
-#include <Eigen/Core>
 #include <glib.h>
+#include <Eigen/Core>
 
 #include "io/lib3mf_utils.h"
 
 #ifndef OPENSCAD_NOGUI
-#include <QtGlobal>
 #include <Qsci/qsciglobal.h>
+#include <QtGlobal>
 #include "gui/input/InputDriverManager.h"
 #endif
 
@@ -26,9 +26,9 @@
 #if GCC_INT_VERSION > 40600 || defined(__clang__)
 #include <cxxabi.h>
 #define openscad_info_demangle_ 1
-#endif // GCC_INT_VERSION
-#endif // GNUG
-#endif // ENABLE_CGAL
+#endif  // GCC_INT_VERSION
+#endif  // GNUG
+#endif  // ENABLE_CGAL
 #ifdef ENABLE_PYTHON
 #include "python/python_public.h"
 #endif
@@ -53,26 +53,24 @@
 
 #ifdef ENABLE_MANIFOLD
 #include <manifold/version.h>  // if it is new enough for us, it has version.h
-#define MANIFOLD_VERSION_STRING \
-        TOSTRING(MANIFOLD_VERSION_MAJOR) "." \
-        TOSTRING(MANIFOLD_VERSION_MINOR) "." \
-        TOSTRING(MANIFOLD_VERSION_PATCH)
+#define MANIFOLD_VERSION_STRING    \
+  TOSTRING(MANIFOLD_VERSION_MAJOR) \
+  "." TOSTRING(MANIFOLD_VERSION_MINOR) "." TOSTRING(MANIFOLD_VERSION_PATCH)
 #else
 #define MANIFOLD_VERSION_STRING "<not enabled>"
 #endif
 
-#include "platform/PlatformUtils.h"
-#include "version.h"
 #include "Feature.h"
 #include "FontCache.h"
+#include "platform/PlatformUtils.h"
+#include "version.h"
 
 extern std::vector<std::string> librarypath;
 extern std::vector<std::string> fontpath;
 extern const std::string get_cairo_version();
-extern const char *LODEPNG_VERSION_STRING;
+extern const char* LODEPNG_VERSION_STRING;
 
-std::string LibraryInfo::info()
-{
+std::string LibraryInfo::info() {
   std::ostringstream s;
 
 #if defined(__x86_64__) || defined(_M_X64)
@@ -84,11 +82,14 @@ std::string LibraryInfo::info()
 #endif
 
 #if defined(__GNUG__) && !defined(__clang__)
-  const std::string compiler_info("GCC " + std::string(TOSTRING(__VERSION__)) + bits);
+  const std::string compiler_info("GCC " + std::string(TOSTRING(__VERSION__)) +
+                                  bits);
 #elif defined(_MSC_VER)
-  const std::string compiler_info("MSVC " + std::string(TOSTRING(_MSC_FULL_VER)) + bits);
+  const std::string compiler_info("MSVC " +
+                                  std::string(TOSTRING(_MSC_FULL_VER)) + bits);
 #elif defined(__clang__)
-  const std::string compiler_info("Clang " + std::string(TOSTRING(__clang_version__)) + bits);
+  const std::string compiler_info(
+      "Clang " + std::string(TOSTRING(__clang_version__)) + bits);
 #else
   const std::string compiler_info("unknown compiler");
 #endif
@@ -118,29 +119,32 @@ std::string LibraryInfo::info()
   std::string cgal_2d_kernel = typeid(CGAL_Kernel2).name();
 #if defined(openscad_info_demangle_)
   int status;
-  cgal_3d_kernel = std::string(abi::__cxa_demangle(cgal_3d_kernel.c_str(), nullptr, nullptr, &status) );
-  cgal_2d_kernel = std::string(abi::__cxa_demangle(cgal_2d_kernel.c_str(), nullptr, nullptr, &status) );
-#endif // demangle
+  cgal_3d_kernel = std::string(
+      abi::__cxa_demangle(cgal_3d_kernel.c_str(), nullptr, nullptr, &status));
+  cgal_2d_kernel = std::string(
+      abi::__cxa_demangle(cgal_2d_kernel.c_str(), nullptr, nullptr, &status));
+#endif  // demangle
   boost::replace_all(cgal_3d_kernel, "CGAL::", "");
   boost::replace_all(cgal_2d_kernel, "CGAL::", "");
-#else // ENABLE_CGAL
+#else   // ENABLE_CGAL
   std::string cgal_3d_kernel = "";
   std::string cgal_2d_kernel = "";
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
 
-  const char *env_path = getenv("OPENSCADPATH");
-  const char *env_font_path = getenv("OPENSCAD_FONT_PATH");
+  const char* env_path = getenv("OPENSCADPATH");
+  const char* env_font_path = getenv("OPENSCAD_FONT_PATH");
 
   s << "OpenSCAD Version: " << openscad_detailedversionnumber
     << "\nSystem information: " << PlatformUtils::sysinfo()
     << "\nUser Agent: " << PlatformUtils::user_agent()
-    << "\nCompiler: " << compiler_info
-    << "\nMinGW build: " << mingwstatus
+    << "\nCompiler: " << compiler_info << "\nMinGW build: " << mingwstatus
     << "\nDebug build: " << debugstatus
     << "\nBoost version: " << BOOST_LIB_VERSION
-    << "\nEigen version: " << EIGEN_WORLD_VERSION << "." << EIGEN_MAJOR_VERSION << "." << EIGEN_MINOR_VERSION
+    << "\nEigen version: " << EIGEN_WORLD_VERSION << "." << EIGEN_MAJOR_VERSION
+    << "." << EIGEN_MINOR_VERSION
 #ifdef ENABLE_CGAL
-    << "\nCGAL version, kernels: " << TOSTRING(CGAL_VERSION) << ", " << cgal_3d_kernel << ", " << cgal_2d_kernel
+    << "\nCGAL version, kernels: " << TOSTRING(CGAL_VERSION) << ", "
+    << cgal_3d_kernel << ", " << cgal_2d_kernel
 #endif
 #ifdef ENABLE_PYTHON
     << "\nPython Version: " << python_version()
@@ -153,7 +157,8 @@ std::string LibraryInfo::info()
     << "\nQScintilla version: " << QSCINTILLA_VERSION_STR
     << "\nInputDrivers: " << InputDriverManager::instance()->listDrivers()
 #endif
-    << "\nGLib version: " << GLIB_MAJOR_VERSION << "." << GLIB_MINOR_VERSION << "." << GLIB_MICRO_VERSION
+    << "\nGLib version: " << GLIB_MAJOR_VERSION << "." << GLIB_MINOR_VERSION
+    << "." << GLIB_MICRO_VERSION
     << "\nlodepng version: " << LODEPNG_VERSION_STRING
     << "\nlibzip version: " << LIBZIP_VERSION
     << "\nfontconfig version: " << get_fontconfig_version()
@@ -179,7 +184,8 @@ std::string LibraryInfo::info()
     s << "  " << path << "\n";
   }
 
-  s << "\nOPENSCAD_FONT_PATH: " << (env_font_path == nullptr ? "<not set>" : env_font_path)
+  s << "\nOPENSCAD_FONT_PATH: "
+    << (env_font_path == nullptr ? "<not set>" : env_font_path)
     << "\nOpenSCAD font path:\n";
 
   for (const auto& path : fontpath) {
diff --git a/src/RenderStatistic.cc b/src/RenderStatistic.cc
index ce95a7bd8..b339ffef0 100644
--- a/src/RenderStatistic.cc
+++ b/src/RenderStatistic.cc
@@ -23,7 +23,6 @@
  *
  */
 
-
 #include "RenderStatistic.h"
 
 #include <algorithm>
@@ -42,95 +41,101 @@
 
 #include "geometry/Geometry.h"
 #include "geometry/GeometryCache.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "glview/Camera.h"
 #include "utils/printutils.h"
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/CGALNefGeometry.h"
 #include "geometry/cgal/CGALCache.h"
-#endif // ENABLE_CGAL
+#include "geometry/cgal/CGALNefGeometry.h"
+#endif  // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "geometry/manifold/manifoldutils.h"
-#endif // ENABLE_MANIFOLD
-
+#endif  // ENABLE_MANIFOLD
 
 class GeometryList;
 
 namespace {
 
-struct StatisticVisitor : public GeometryVisitor
-{
+struct StatisticVisitor : public GeometryVisitor {
   StatisticVisitor(const std::vector<std::string>& options)
-    : all(std::find(options.begin(), options.end(), "all") != options.end()),
-    options(options) { }
+      : all(std::find(options.begin(), options.end(), "all") != options.end()),
+        options(options) {}
   virtual void printCamera(const Camera& camera) = 0;
   virtual void printCacheStatistic() = 0;
   virtual void printRenderingTime(std::chrono::milliseconds) = 0;
   virtual void finish() = 0;
-protected:
+
+ protected:
   bool is_enabled(const std::string& name) {
-    return all || std::find(options.begin(), options.end(), name) != options.end();
+    return all ||
+           std::find(options.begin(), options.end(), name) != options.end();
   }
-private:
+
+ private:
   bool all;
   std::vector<std::string> options;
 };
 
-struct LogVisitor : public StatisticVisitor
-{
-  LogVisitor(const std::vector<std::string>& options) : StatisticVisitor(options) { }
+struct LogVisitor : public StatisticVisitor {
+  LogVisitor(const std::vector<std::string>& options)
+      : StatisticVisitor(options) {}
   void visit(const GeometryList& node) override;
   void visit(const PolySet& node) override;
   void visit(const Polygon2d& node) override;
 #ifdef ENABLE_CGAL
   void visit(const CGALNefGeometry& node) override;
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
   void visit(const ManifoldGeometry& node) override;
-#endif // ENABLE_MANIFOLD
+#endif  // ENABLE_MANIFOLD
   void printCamera(const Camera& camera) override;
   void printCacheStatistic() override;
   void printRenderingTime(std::chrono::milliseconds) override;
   void finish() override;
-private:
+
+ private:
   void printBoundingBox3(const BoundingBox& bb);
 };
 
-struct StreamVisitor : public StatisticVisitor
-{
-  StreamVisitor(const std::vector<std::string>& options, std::ostream& stream) : StatisticVisitor(options), stream(stream) {}
-  StreamVisitor(const std::vector<std::string>& options, const std::string& filename) : StatisticVisitor(options), fstream(filename), stream(fstream) {}
+struct StreamVisitor : public StatisticVisitor {
+  StreamVisitor(const std::vector<std::string>& options, std::ostream& stream)
+      : StatisticVisitor(options), stream(stream) {}
+  StreamVisitor(const std::vector<std::string>& options,
+                const std::string& filename)
+      : StatisticVisitor(options), fstream(filename), stream(fstream) {}
   ~StreamVisitor() override {
-    if (fstream.is_open()) fstream.close();
+    if (fstream.is_open())
+      fstream.close();
   }
   void visit(const GeometryList& node) override;
   void visit(const PolySet& node) override;
   void visit(const Polygon2d& node) override;
 #ifdef ENABLE_CGAL
   void visit(const CGALNefGeometry& node) override;
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
   void visit(const ManifoldGeometry& node) override;
-#endif // ENABLE_MANIFOLD
+#endif  // ENABLE_MANIFOLD
   void printCamera(const Camera& camera) override;
   void printCacheStatistic() override;
   void printRenderingTime(std::chrono::milliseconds) override;
   void finish() override;
-private:
+
+ private:
   nlohmann::json json;
   std::ofstream fstream;
   std::ostream& stream;
 };
 
-static nlohmann::json getBoundingBox2d(const Geometry& geometry)
-{
+static nlohmann::json getBoundingBox2d(const Geometry& geometry) {
   const auto& bb = geometry.getBoundingBox();
-  const std::array<double, 2> min = { bb.min().x(), bb.min().y() };
-  const std::array<double, 2> max = { bb.max().x(), bb.max().y() };
-  const std::array<double, 2> size = { bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y() };
+  const std::array<double, 2> min = {bb.min().x(), bb.min().y()};
+  const std::array<double, 2> max = {bb.max().x(), bb.max().y()};
+  const std::array<double, 2> size = {bb.max().x() - bb.min().x(),
+                                      bb.max().y() - bb.min().y()};
   nlohmann::json bbJson;
   bbJson["min"] = min;
   bbJson["max"] = max;
@@ -138,12 +143,13 @@ static nlohmann::json getBoundingBox2d(const Geometry& geometry)
   return bbJson;
 }
 
-static nlohmann::json getBoundingBox3d(const Geometry& geometry)
-{
+static nlohmann::json getBoundingBox3d(const Geometry& geometry) {
   const auto& bb = geometry.getBoundingBox();
-  const std::array<double, 3> min = { bb.min().x(), bb.min().y(), bb.min().z() };
-  const std::array<double, 3> max = { bb.max().x(), bb.max().y(), bb.max().z() };
-  const std::array<double, 3> size = { bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y(), bb.max().z() - bb.min().z() };
+  const std::array<double, 3> min = {bb.min().x(), bb.min().y(), bb.min().z()};
+  const std::array<double, 3> max = {bb.max().x(), bb.max().y(), bb.max().z()};
+  const std::array<double, 3> size = {bb.max().x() - bb.min().x(),
+                                      bb.max().y() - bb.min().y(),
+                                      bb.max().z() - bb.min().z()};
   nlohmann::json bbJson;
   bbJson["min"] = min;
   bbJson["max"] = max;
@@ -152,8 +158,7 @@ static nlohmann::json getBoundingBox3d(const Geometry& geometry)
 }
 
 template <typename C>
-static nlohmann::json getCache(C cache)
-{
+static nlohmann::json getCache(C cache) {
   nlohmann::json cacheJson;
   cacheJson["entries"] = cache->size();
   cacheJson["bytes"] = cache->totalCost();
@@ -161,42 +166,40 @@ static nlohmann::json getCache(C cache)
   return cacheJson;
 }
 
-} // namespace
+}  // namespace
 
-RenderStatistic::RenderStatistic() : begin(std::chrono::steady_clock::now())
-{
-}
+RenderStatistic::RenderStatistic() : begin(std::chrono::steady_clock::now()) {}
 
-void RenderStatistic::start()
-{
+void RenderStatistic::start() {
   begin = std::chrono::steady_clock::now();
 }
 
-std::chrono::milliseconds RenderStatistic::ms()
-{
-  const std::chrono::steady_clock::time_point end{std::chrono::steady_clock::now()};
-  const std::chrono::milliseconds ms{std::chrono::duration_cast<std::chrono::milliseconds>(end - begin)};
+std::chrono::milliseconds RenderStatistic::ms() {
+  const std::chrono::steady_clock::time_point end{
+      std::chrono::steady_clock::now()};
+  const std::chrono::milliseconds ms{
+      std::chrono::duration_cast<std::chrono::milliseconds>(end - begin)};
   return ms;
 }
 
-void RenderStatistic::printCacheStatistic()
-{
+void RenderStatistic::printCacheStatistic() {
   LogVisitor visitor({});
   visitor.printCacheStatistic();
 }
 
-void RenderStatistic::printRenderingTime()
-{
+void RenderStatistic::printRenderingTime() {
   LogVisitor visitor({});
   visitor.printRenderingTime(ms());
 }
 
-void RenderStatistic::printAll(const std::shared_ptr<const Geometry>& geom, const Camera& camera, const std::vector<std::string>& options, const std::string& filename)
-{
-  //bool is_log = false;
+void RenderStatistic::printAll(const std::shared_ptr<const Geometry>& geom,
+                               const Camera& camera,
+                               const std::vector<std::string>& options,
+                               const std::string& filename) {
+  // bool is_log = false;
   std::unique_ptr<StatisticVisitor> visitor;
   if (filename.empty()) {
-    //is_log = true;
+    // is_log = true;
     visitor = std::make_unique<LogVisitor>(options);
   } else if (filename == "-") {
     visitor = std::make_unique<StreamVisitor>(options, std::cout);
@@ -213,15 +216,12 @@ void RenderStatistic::printAll(const std::shared_ptr<const Geometry>& geom, cons
   visitor->finish();
 }
 
-void LogVisitor::visit(const GeometryList& geomlist)
-{
+void LogVisitor::visit(const GeometryList& geomlist) {
   LOG("Top level object is a list of objects:");
-  LOG("   Objects:    %1$d",
-      geomlist.getChildren().size());
+  LOG("   Objects:    %1$d", geomlist.getChildren().size());
 }
 
-void LogVisitor::visit(const Polygon2d& poly)
-{
+void LogVisitor::visit(const Polygon2d& poly) {
   LOG("Top level object is a 2D object:");
   LOG("   Contours:   %1$6d", poly.outlines().size());
   if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
@@ -229,7 +229,8 @@ void LogVisitor::visit(const Polygon2d& poly)
     LOG("Bounding box:");
     LOG("   Min:  %1$.2f, %2$.2f", bb.min().x(), bb.min().y());
     LOG("   Max:  %1$.2f, %2$.2f", bb.max().x(), bb.max().y());
-    LOG("   Size: %1$.2f, %2$.2f", bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y());
+    LOG("   Size: %1$.2f, %2$.2f", bb.max().x() - bb.min().x(),
+        bb.max().y() - bb.min().y());
   }
   if (is_enabled(RenderStatistic::AREA)) {
     LOG("Measurements:");
@@ -237,18 +238,19 @@ void LogVisitor::visit(const Polygon2d& poly)
   }
 }
 
-void LogVisitor::printBoundingBox3(const BoundingBox& bb)
-{
+void LogVisitor::printBoundingBox3(const BoundingBox& bb) {
   if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
     LOG("Bounding box:");
-    LOG("   Min:  %1$.2f, %2$.2f, %3$.2f", bb.min().x(), bb.min().y(), bb.min().z());
-    LOG("   Max:  %1$.2f, %2$.2f, %3$.2f", bb.max().x(), bb.max().y(), bb.max().z());
-    LOG("   Size: %1$.2f, %2$.2f, %3$.2f", bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y(), bb.max().z() - bb.min().z());
+    LOG("   Min:  %1$.2f, %2$.2f, %3$.2f", bb.min().x(), bb.min().y(),
+        bb.min().z());
+    LOG("   Max:  %1$.2f, %2$.2f, %3$.2f", bb.max().x(), bb.max().y(),
+        bb.max().z());
+    LOG("   Size: %1$.2f, %2$.2f, %3$.2f", bb.max().x() - bb.min().x(),
+        bb.max().y() - bb.min().y(), bb.max().z() - bb.min().z());
   }
 }
 
-void LogVisitor::visit(const PolySet& ps)
-{
+void LogVisitor::visit(const PolySet& ps) {
   assert(ps.getDimension() == 3);
   LOG("Top level object is a 3D object (PolySet):");
   LOG("   Convex:       %1$s", (ps.isConvex() ? "yes" : "no"));
@@ -261,8 +263,7 @@ void LogVisitor::visit(const PolySet& ps)
 }
 
 #ifdef ENABLE_CGAL
-void LogVisitor::visit(const CGALNefGeometry& nef)
-{
+void LogVisitor::visit(const CGALNefGeometry& nef) {
   if (nef.getDimension() == 3) {
     const bool simple = nef.p3->is_simple();
     LOG("Top level object is a 3D object (Nef polyhedron):");
@@ -274,16 +275,16 @@ void LogVisitor::visit(const CGALNefGeometry& nef)
     LOG("   Facets:     %1$6d", nef.p3->number_of_facets());
     LOG("   Volumes:    %1$6d", nef.p3->number_of_volumes());
     if (!simple) {
-      LOG(message_group::UI_Warning, "Object may not be a valid 2-manifold and may need repair!");
+      LOG(message_group::UI_Warning,
+          "Object may not be a valid 2-manifold and may need repair!");
     }
     printBoundingBox3(nef.getBoundingBox());
   }
 }
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
 
 #ifdef ENABLE_MANIFOLD
-void LogVisitor::visit(const ManifoldGeometry& mani_geom)
-{
+void LogVisitor::visit(const ManifoldGeometry& mani_geom) {
   LOG("   Top level object is a 3D object (manifold):");
   auto& mani = mani_geom.getManifold();
 
@@ -293,21 +294,21 @@ void LogVisitor::visit(const ManifoldGeometry& mani_geom)
   LOG("   Facets:     %1$6d", mani.NumTri());
   printBoundingBox3(mani_geom.getBoundingBox());
 }
-#endif // ENABLE_MANIFOLD
+#endif  // ENABLE_MANIFOLD
 
-void LogVisitor::printCamera(const Camera& camera)
-{
+void LogVisitor::printCamera(const Camera& camera) {
   if (is_enabled(RenderStatistic::CAMERA)) {
     LOG("Camera:");
-    LOG("   Translation: %1$.2f, %2$.2f, %3$.2f", camera.getVpt().x(), camera.getVpt().y(), camera.getVpt().z());
-    LOG("   Rotation:    %1$.2f, %2$.2f, %3$.2f", camera.getVpr().x(), camera.getVpr().y(), camera.getVpr().z());
+    LOG("   Translation: %1$.2f, %2$.2f, %3$.2f", camera.getVpt().x(),
+        camera.getVpt().y(), camera.getVpt().z());
+    LOG("   Rotation:    %1$.2f, %2$.2f, %3$.2f", camera.getVpr().x(),
+        camera.getVpr().y(), camera.getVpr().z());
     LOG("   Distance:    %1$.2f", camera.zoomValue());
     LOG("   FOV:         %1$.2f", camera.fovValue());
   }
 }
 
-void LogVisitor::printCacheStatistic()
-{
+void LogVisitor::printCacheStatistic() {
   // always enabled
   GeometryCache::instance()->print();
 #ifdef ENABLE_CGAL
@@ -315,26 +316,18 @@ void LogVisitor::printCacheStatistic()
 #endif
 }
 
-void LogVisitor::printRenderingTime(const std::chrono::milliseconds ms)
-{
+void LogVisitor::printRenderingTime(const std::chrono::milliseconds ms) {
   // always enabled
   LOG("Total rendering time: %1$d:%2$02d:%3$02d.%4$03d",
-      (ms.count() / 1000 / 60 / 60),
-      (ms.count() / 1000 / 60 % 60),
-      (ms.count() / 1000 % 60),
-      (ms.count() % 1000));
+      (ms.count() / 1000 / 60 / 60), (ms.count() / 1000 / 60 % 60),
+      (ms.count() / 1000 % 60), (ms.count() % 1000));
 }
 
-void LogVisitor::finish()
-{
-}
+void LogVisitor::finish() {}
 
-void StreamVisitor::visit(const GeometryList& geomlist)
-{
-}
+void StreamVisitor::visit(const GeometryList& geomlist) {}
 
-void StreamVisitor::visit(const Polygon2d& poly)
-{
+void StreamVisitor::visit(const Polygon2d& poly) {
   if (is_enabled(RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 2;
@@ -347,8 +340,7 @@ void StreamVisitor::visit(const Polygon2d& poly)
   }
 }
 
-void StreamVisitor::visit(const PolySet& ps)
-{
+void StreamVisitor::visit(const PolySet& ps) {
   if (is_enabled(RenderStatistic::GEOMETRY)) {
     assert(ps.getDimension() == 3);
     nlohmann::json geometryJson;
@@ -364,8 +356,7 @@ void StreamVisitor::visit(const PolySet& ps)
 }
 
 #ifdef ENABLE_CGAL
-void StreamVisitor::visit(const CGALNefGeometry& nef)
-{
+void StreamVisitor::visit(const CGALNefGeometry& nef) {
   if (is_enabled(RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 3;
@@ -380,11 +371,10 @@ void StreamVisitor::visit(const CGALNefGeometry& nef)
     json["geometry"] = geometryJson;
   }
 }
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
 
 #ifdef ENABLE_MANIFOLD
-void StreamVisitor::visit(const ManifoldGeometry& mani)
-{
+void StreamVisitor::visit(const ManifoldGeometry& mani) {
   if (is_enabled(RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 3;
@@ -397,13 +387,14 @@ void StreamVisitor::visit(const ManifoldGeometry& mani)
     json["geometry"] = geometryJson;
   }
 }
-#endif // ENABLE_MANIFOLD
+#endif  // ENABLE_MANIFOLD
 
-void StreamVisitor::printCamera(const Camera& camera)
-{
+void StreamVisitor::printCamera(const Camera& camera) {
   if (is_enabled(RenderStatistic::CAMERA)) {
-    const std::array<double, 3> translation = { camera.getVpt().x(), camera.getVpt().y(), camera.getVpt().z() };
-    const std::array<double, 3> rotation = { camera.getVpr().x(), camera.getVpr().y(), camera.getVpr().z() };
+    const std::array<double, 3> translation = {
+        camera.getVpt().x(), camera.getVpt().y(), camera.getVpt().z()};
+    const std::array<double, 3> rotation = {
+        camera.getVpr().x(), camera.getVpr().y(), camera.getVpr().z()};
     nlohmann::json cameraJson;
     cameraJson["translation"] = translation;
     cameraJson["rotation"] = rotation;
@@ -413,27 +404,25 @@ void StreamVisitor::printCamera(const Camera& camera)
   }
 }
 
-void StreamVisitor::printCacheStatistic()
-{
+void StreamVisitor::printCacheStatistic() {
   if (is_enabled(RenderStatistic::CACHE)) {
     nlohmann::json cacheJson;
     cacheJson["geometry_cache"] = getCache(GeometryCache::instance());
 #ifdef ENABLE_CGAL
     cacheJson["cgal_cache"] = getCache(CGALCache::instance());
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
     json["cache"] = cacheJson;
   }
 }
 
-void StreamVisitor::printRenderingTime(const std::chrono::milliseconds ms)
-{
+void StreamVisitor::printRenderingTime(const std::chrono::milliseconds ms) {
   if (is_enabled(RenderStatistic::TIME)) {
     nlohmann::json timeJson;
-    timeJson["time"] = (boost::format("%1$d:%2$02d:%3$02d.%4$03d")
-                        % (ms.count() / 1000 / 60 / 60)
-                        % (ms.count() / 1000 / 60 % 60)
-                        % (ms.count() / 1000 % 60)
-                        % (ms.count() % 1000)).str();
+    timeJson["time"] =
+        (boost::format("%1$d:%2$02d:%3$02d.%4$03d") %
+         (ms.count() / 1000 / 60 / 60) % (ms.count() / 1000 / 60 % 60) %
+         (ms.count() / 1000 % 60) % (ms.count() % 1000))
+            .str();
     timeJson["total"] = ms.count();
     timeJson["milliseconds"] = ms.count() % 1000;
     timeJson["seconds"] = ms.count() / 1000 % 60;
@@ -443,7 +432,6 @@ void StreamVisitor::printRenderingTime(const std::chrono::milliseconds ms)
   }
 }
 
-void StreamVisitor::finish()
-{
+void StreamVisitor::finish() {
   stream << json;
 }
diff --git a/src/RenderStatistic.h b/src/RenderStatistic.h
index ebe2edd15..0fb80c38b 100644
--- a/src/RenderStatistic.h
+++ b/src/RenderStatistic.h
@@ -25,21 +25,20 @@
 
 #pragma once
 
-#include <memory>
 #include <chrono>
+#include <memory>
 #include <string>
 #include <vector>
 
-#include "glview/Camera.h"
 #include "geometry/Geometry.h"
+#include "glview/Camera.h"
 
 /**
  * An utility class to collect and print rendering statistics for the given
  * geometry
  */
-class RenderStatistic
-{
-public:
+class RenderStatistic {
+ public:
   constexpr static auto CACHE = "cache";
   constexpr static auto TIME = "time";
   constexpr static auto CAMERA = "camera";
@@ -64,8 +63,8 @@ public:
   std::chrono::milliseconds ms();
 
   /**
-   * Print some statistic on cache usage. Namely, stats on the @ref GeometryCache
-   * and @ref CGALCache (if enabled).
+   * Print some statistic on cache usage. Namely, stats on the @ref
+   * GeometryCache and @ref CGALCache (if enabled).
    */
   void printCacheStatistic();
 
@@ -77,8 +76,11 @@ public:
   /**
    * Print all available statistic information.
    */
-  void printAll(const std::shared_ptr<const Geometry>& geom, const Camera& camera, const std::vector<std::string>& options = {}, const std::string& filename = {});
+  void printAll(const std::shared_ptr<const Geometry>& geom,
+                const Camera& camera,
+                const std::vector<std::string>& options = {},
+                const std::string& filename = {});
 
-private:
+ private:
   std::chrono::steady_clock::time_point begin;
 };
diff --git a/src/core/AST.cc b/src/core/AST.cc
index 7cc82107a..b05893660 100644
--- a/src/core/AST.cc
+++ b/src/core/AST.cc
@@ -1,24 +1,26 @@
 #include "core/AST.h"
 #include <filesystem>
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <sstream>
 #include <string>
 #include "io/fileutils.h"
 
-const Location Location::NONE(0, 0, 0, 0, std::make_shared<fs::path>(fs::path{}));
+const Location Location::NONE(0,
+                              0,
+                              0,
+                              0,
+                              std::make_shared<fs::path>(fs::path{}));
 
-bool operator==(Location const& lhs, Location const& rhs){
-  return
-    lhs.firstLine() == rhs.firstLine() &&
-    lhs.firstColumn() == rhs.firstColumn() &&
-    lhs.lastLine() == rhs.lastLine() &&
-    lhs.lastColumn() == rhs.lastColumn() &&
-    lhs.filePath() == rhs.filePath();
+bool operator==(Location const& lhs, Location const& rhs) {
+  return lhs.firstLine() == rhs.firstLine() &&
+         lhs.firstColumn() == rhs.firstColumn() &&
+         lhs.lastLine() == rhs.lastLine() &&
+         lhs.lastColumn() == rhs.lastColumn() &&
+         lhs.filePath() == rhs.filePath();
 }
 
-bool operator!=(Location const& lhs, Location const& rhs)
-{
+bool operator!=(Location const& lhs, Location const& rhs) {
   return !(lhs == rhs);
 }
 
@@ -27,18 +29,18 @@ bool Location::isNone() const {
 }
 
 std::string Location::toRelativeString(const std::string& docPath) const {
-  if (this->isNone()) return "location unknown";
-  return "in file " + fs_uncomplete((*path), docPath).generic_string() + ", " + "line " + std::to_string(this->firstLine());
+  if (this->isNone())
+    return "location unknown";
+  return "in file " + fs_uncomplete((*path), docPath).generic_string() + ", " +
+         "line " + std::to_string(this->firstLine());
 }
 
-std::ostream& operator<<(std::ostream& stream, const ASTNode& ast)
-{
+std::ostream& operator<<(std::ostream& stream, const ASTNode& ast) {
   ast.print(stream, "");
   return stream;
 }
 
-std::string ASTNode::dump(const std::string& indent) const
-{
+std::string ASTNode::dump(const std::string& indent) const {
   std::ostringstream stream;
   print(stream, indent);
   return stream.str();
diff --git a/src/core/AST.h b/src/core/AST.h
index da3d8c7a2..406e8fb81 100644
--- a/src/core/AST.h
+++ b/src/core/AST.h
@@ -1,25 +1,30 @@
 #pragma once
 
+#include <filesystem>
+#include <memory>
 #include <ostream>
 #include <string>
-#include <memory>
-#include <filesystem>
 #include <utility>
 namespace fs = std::filesystem;
 
 #include <string>
 
-class Location
-{
-
-public:
-  Location(int firstLine, int firstCol, int lastLine, int lastCol,
+class Location {
+ public:
+  Location(int firstLine,
+           int firstCol,
+           int lastLine,
+           int lastCol,
            std::shared_ptr<fs::path> path)
-    : first_line(firstLine), first_col(firstCol), last_line(lastLine),
-    last_col(lastCol), path(std::move(path)) {
-  }
+      : first_line(firstLine),
+        first_col(firstCol),
+        last_line(lastLine),
+        last_col(lastCol),
+        path(std::move(path)) {}
 
-  [[nodiscard]] std::string fileName() const { return path ? path->generic_string() : ""; }
+  [[nodiscard]] std::string fileName() const {
+    return path ? path->generic_string() : "";
+  }
   [[nodiscard]] const fs::path& filePath() const { return *path; }
   [[nodiscard]] int firstLine() const { return first_line; }
   [[nodiscard]] int firstColumn() const { return first_col; }
@@ -33,7 +38,8 @@ public:
   bool operator!=(Location const& rhs);
 
   static const Location NONE;
-private:
+
+ private:
   int first_line;
   int first_col;
   int last_line;
@@ -41,9 +47,8 @@ private:
   std::shared_ptr<fs::path> path;
 };
 
-class ASTNode
-{
-public:
+class ASTNode {
+ public:
   ASTNode(Location loc) : loc(std::move(loc)) {}
   virtual ~ASTNode() = default;
 
@@ -53,7 +58,7 @@ public:
   [[nodiscard]] const Location& location() const { return loc; }
   void setLocation(const Location& loc) { this->loc = loc; }
 
-protected:
+ protected:
   Location loc;
 };
 
diff --git a/src/core/Arguments.cc b/src/core/Arguments.cc
index 658e89eae..aed9b8d13 100644
--- a/src/core/Arguments.cc
+++ b/src/core/Arguments.cc
@@ -26,23 +26,23 @@
 
 #include "core/Arguments.h"
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include "core/Expression.h"
 
-Arguments::Arguments(const AssignmentList& argument_expressions, const std::shared_ptr<const Context>& context) :
-  evaluation_session(context->session())
-{
+Arguments::Arguments(const AssignmentList& argument_expressions,
+                     const std::shared_ptr<const Context>& context)
+    : evaluation_session(context->session()) {
   for (const auto& argument_expression : argument_expressions) {
     emplace_back(
-      argument_expression->getName().empty() ? boost::none : boost::optional<std::string>(argument_expression->getName()),
-      argument_expression->getExpr()->evaluate(context)
-      );
+        argument_expression->getName().empty()
+            ? boost::none
+            : boost::optional<std::string>(argument_expression->getName()),
+        argument_expression->getExpr()->evaluate(context));
   }
 }
 
-Arguments Arguments::clone() const
-{
+Arguments Arguments::clone() const {
   Arguments output(evaluation_session);
   for (const Argument& argument : *this) {
     output.emplace_back(argument.name, argument.value.clone());
@@ -50,8 +50,7 @@ Arguments Arguments::clone() const
   return output;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Argument& argument)
-{
+std::ostream& operator<<(std::ostream& stream, const Argument& argument) {
   if (argument.name) {
     stream << *argument.name << " = ";
   }
@@ -59,8 +58,7 @@ std::ostream& operator<<(std::ostream& stream, const Argument& argument)
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Arguments& arguments)
-{
+std::ostream& operator<<(std::ostream& stream, const Arguments& arguments) {
   bool first = true;
   for (const auto& argument : arguments) {
     if (first) {
diff --git a/src/core/Arguments.h b/src/core/Arguments.h
index 120e8e88c..a89390ad6 100644
--- a/src/core/Arguments.h
+++ b/src/core/Arguments.h
@@ -1,11 +1,11 @@
 #pragma once
 
+#include <boost/optional.hpp>
 #include <memory>
 #include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
-#include <boost/optional.hpp>
 
 #include "core/Assignment.h"
 #include "core/Context.h"
@@ -14,39 +14,43 @@ struct Argument {
   boost::optional<std::string> name;
   Value value;
 
-  Argument(boost::optional<std::string> name, Value value) : name(std::move(name)), value(std::move(value)) {
-  }
+  Argument(boost::optional<std::string> name, Value value)
+      : name(std::move(name)), value(std::move(value)) {}
   Argument(Argument&& other) = default;
   Argument& operator=(Argument&& other) = default;
   Argument(const Argument& other) = delete;
   Argument& operator=(const Argument& other) = delete;
   ~Argument() = default;
 
-  const Value *operator->() const { return &value; }
-  Value *operator->() { return &value; }
+  const Value* operator->() const { return &value; }
+  Value* operator->() { return &value; }
 };
 
-class Arguments : public std::vector<Argument>
-{
-public:
-  Arguments(const AssignmentList& argument_expressions, const std::shared_ptr<const Context>& context);
+class Arguments : public std::vector<Argument> {
+ public:
+  Arguments(const AssignmentList& argument_expressions,
+            const std::shared_ptr<const Context>& context);
   Arguments(Arguments&& other) = default;
   Arguments& operator=(Arguments&& other) = default;
   Arguments(const Arguments& other) = delete;
   Arguments& operator=(const Arguments& other) = delete;
   ~Arguments() = default;
 
-private:
-  Arguments(EvaluationSession *session) : evaluation_session(session) {}
+ private:
+  Arguments(EvaluationSession* session) : evaluation_session(session) {}
 
-public:
+ public:
   [[nodiscard]] Arguments clone() const;
 
-  [[nodiscard]] EvaluationSession *session() const { return evaluation_session; }
-  [[nodiscard]] const std::string& documentRoot() const { return evaluation_session->documentRoot(); }
+  [[nodiscard]] EvaluationSession* session() const {
+    return evaluation_session;
+  }
+  [[nodiscard]] const std::string& documentRoot() const {
+    return evaluation_session->documentRoot();
+  }
 
-private:
-  EvaluationSession *evaluation_session;
+ private:
+  EvaluationSession* evaluation_session;
 };
 
 std::ostream& operator<<(std::ostream& stream, const Argument& argument);
diff --git a/src/core/Assignment.cc b/src/core/Assignment.cc
index 10860e0de..57a0e0f68 100644
--- a/src/core/Assignment.cc
+++ b/src/core/Assignment.cc
@@ -25,45 +25,43 @@
  */
 
 #include "core/Assignment.h"
-#include "core/customizer/Annotation.h"
-#include "core/Expression.h"
 #include <ostream>
 #include <string>
+#include "core/Expression.h"
+#include "core/customizer/Annotation.h"
 
-void Assignment::addAnnotations(AnnotationList *annotations)
-{
+void Assignment::addAnnotations(AnnotationList* annotations) {
   for (auto& annotation : *annotations) {
     this->annotations.insert({annotation.getName(), &annotation});
   }
 }
 
-bool Assignment::hasAnnotations() const
-{
+bool Assignment::hasAnnotations() const {
   return !annotations.empty();
 }
 
-const Annotation *Assignment::annotation(const std::string& name) const
-{
+const Annotation* Assignment::annotation(const std::string& name) const {
   auto found = annotations.find(name);
   return found == annotations.end() ? nullptr : found->second;
 }
 
-
-void Assignment::print(std::ostream& stream, const std::string& indent) const
-{
+void Assignment::print(std::ostream& stream, const std::string& indent) const {
   if (this->hasAnnotations()) {
-    const Annotation *group = this->annotation("Group");
-    if (group) group->print(stream, indent);
-    const Annotation *description = this->annotation("Description");
-    if (description) description->print(stream, indent);
-    const Annotation *parameter = this->annotation("Parameter");
-    if (parameter) parameter->print(stream, indent);
+    const Annotation* group = this->annotation("Group");
+    if (group)
+      group->print(stream, indent);
+    const Annotation* description = this->annotation("Description");
+    if (description)
+      description->print(stream, indent);
+    const Annotation* parameter = this->annotation("Parameter");
+    if (parameter)
+      parameter->print(stream, indent);
   }
   stream << indent << this->name << " = " << *this->expr << ";\n";
 }
 
-std::ostream& operator<<(std::ostream& stream, const AssignmentList& assignments)
-{
+std::ostream& operator<<(std::ostream& stream,
+                         const AssignmentList& assignments) {
   bool first = true;
   for (const auto& assignment : assignments) {
     if (first) {
diff --git a/src/core/Assignment.h b/src/core/Assignment.h
index 7a360fc6c..c29d64f66 100644
--- a/src/core/Assignment.h
+++ b/src/core/Assignment.h
@@ -1,24 +1,26 @@
 #pragma once
 
-#include <unordered_map>
 #include <memory>
 #include <ostream>
 #include <string>
+#include <unordered_map>
 #include <utility>
 #include <vector>
 
 #include "core/AST.h"
 #include "core/customizer/Annotation.h"
 
-class Assignment : public ASTNode
-{
-public:
+class Assignment : public ASTNode {
+ public:
   Assignment(std::string name, const Location& loc)
-    : ASTNode(loc), name(std::move(name)), locOfOverwrite(Location::NONE) { }
+      : ASTNode(loc), name(std::move(name)), locOfOverwrite(Location::NONE) {}
   Assignment(std::string name,
              std::shared_ptr<class Expression> expr = {},
              const Location& loc = Location::NONE)
-    : ASTNode(loc), name(std::move(name)), expr(std::move(expr)), locOfOverwrite(Location::NONE){ }
+      : ASTNode(loc),
+        name(std::move(name)),
+        expr(std::move(expr)),
+        locOfOverwrite(Location::NONE) {}
 
   void print(std::ostream& stream, const std::string& indent) const override;
   const std::string& getName() const { return name; }
@@ -27,25 +29,29 @@ public:
   // setExpr used by customizer ParameterObject etc.
   void setExpr(std::shared_ptr<Expression> e) { expr = std::move(e); }
 
-  virtual void addAnnotations(AnnotationList *annotations);
+  virtual void addAnnotations(AnnotationList* annotations);
   virtual bool hasAnnotations() const;
-  virtual const Annotation *annotation(const std::string& name) const;
+  virtual const Annotation* annotation(const std::string& name) const;
 
   const Location& locationOfOverwrite() const { return locOfOverwrite; }
-  void setLocationOfOverwrite(const Location& locOfOverwrite) { this->locOfOverwrite = locOfOverwrite; }
+  void setLocationOfOverwrite(const Location& locOfOverwrite) {
+    this->locOfOverwrite = locOfOverwrite;
+  }
 
-protected:
+ protected:
   const std::string name;
   std::shared_ptr<class Expression> expr;
   AnnotationMap annotations;
   Location locOfOverwrite;
 };
 
-template <class ... Args> std::shared_ptr<Assignment> assignment(Args... args) {
-  return std::make_shared<Assignment>(args ...);
+template <class... Args>
+std::shared_ptr<Assignment> assignment(Args... args) {
+  return std::make_shared<Assignment>(args...);
 }
 
 using AssignmentList = std::vector<std::shared_ptr<Assignment>>;
-using AssignmentMap = std::unordered_map<std::string, const Expression *>;
+using AssignmentMap = std::unordered_map<std::string, const Expression*>;
 
-std::ostream& operator<<(std::ostream& stream, const AssignmentList& assignments);
+std::ostream& operator<<(std::ostream& stream,
+                         const AssignmentList& assignments);
diff --git a/src/core/BaseVisitable.h b/src/core/BaseVisitable.h
index e78901a4f..aa1af06b4 100644
--- a/src/core/BaseVisitable.h
+++ b/src/core/BaseVisitable.h
@@ -1,33 +1,32 @@
 #pragma once
 
-
 // FIXME: Default constructor Response()
-enum class Response {ContinueTraversal, AbortTraversal, PruneTraversal};
+enum class Response { ContinueTraversal, AbortTraversal, PruneTraversal };
 
 class State;
 
-class BaseVisitor
-{
-public:
+class BaseVisitor {
+ public:
   virtual ~BaseVisitor() = default;
 };
 
 template <class T>
-class Visitor
-{
-public:
+class Visitor {
+ public:
   virtual Response visit(State& state, const T&) = 0;
 };
 
-class BaseVisitable
-{
-public:
+class BaseVisitable {
+ public:
   virtual ~BaseVisitable() = default;
   virtual Response accept(State&, BaseVisitor&) const = 0;
-protected:
+
+ protected:
   template <class T>
-  static Response acceptImpl(State& state, const T& node, BaseVisitor& visitor) {
-    if (auto *p = dynamic_cast<Visitor<T> *>(&visitor)) {
+  static Response acceptImpl(State& state,
+                             const T& node,
+                             BaseVisitor& visitor) {
+    if (auto* p = dynamic_cast<Visitor<T>*>(&visitor)) {
       return p->visit(state, node);
     }
     // FIXME: If we want to allow for missing nodes in visitors, we need
@@ -37,7 +36,7 @@ protected:
   }
 };
 
-#define VISITABLE() \
-        Response accept(State & state, BaseVisitor & visitor) const override { \
-          return acceptImpl(state, *this, visitor); \
-        }
+#define VISITABLE()                                                    \
+  Response accept(State& state, BaseVisitor& visitor) const override { \
+    return acceptImpl(state, *this, visitor);                          \
+  }
diff --git a/src/core/BuiltinContext.cc b/src/core/BuiltinContext.cc
index 76b3c7c46..d7a16cc79 100644
--- a/src/core/BuiltinContext.cc
+++ b/src/core/BuiltinContext.cc
@@ -8,44 +8,50 @@
 #include "core/function.h"
 #include "utils/printutils.h"
 
-BuiltinContext::BuiltinContext(EvaluationSession *session) : Context(session)
-{
-}
+BuiltinContext::BuiltinContext(EvaluationSession* session) : Context(session) {}
 
-void BuiltinContext::init()
-{
+void BuiltinContext::init() {
   for (const auto& assignment : Builtins::instance()->getAssignments()) {
-    this->set_variable(assignment->getName(), assignment->getExpr()->evaluate(shared_from_this()));
+    this->set_variable(assignment->getName(),
+                       assignment->getExpr()->evaluate(shared_from_this()));
   }
 
   this->set_variable("PI", M_PI);
 }
 
-boost::optional<CallableFunction> BuiltinContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
+boost::optional<CallableFunction> BuiltinContext::lookup_local_function(
+    const std::string& name,
+    const Location& loc) const {
   const auto& search = Builtins::instance()->getFunctions().find(name);
   if (search != Builtins::instance()->getFunctions().end()) {
-    BuiltinFunction *f = search->second;
+    BuiltinFunction* f = search->second;
     if (f->is_enabled()) {
       return CallableFunction{f};
     }
 
-    LOG(message_group::Warning, loc, documentRoot(), "Experimental builtin function '%1$s' is not enabled", name);
+    LOG(message_group::Warning, loc, documentRoot(),
+        "Experimental builtin function '%1$s' is not enabled", name);
   }
   return Context::lookup_local_function(name, loc);
 }
 
-boost::optional<InstantiableModule> BuiltinContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
+boost::optional<InstantiableModule> BuiltinContext::lookup_local_module(
+    const std::string& name,
+    const Location& loc) const {
   const auto& search = Builtins::instance()->getModules().find(name);
   if (search != Builtins::instance()->getModules().end()) {
-    AbstractModule *m = search->second;
+    AbstractModule* m = search->second;
     if (!m->is_enabled()) {
-      LOG(message_group::Warning, loc, documentRoot(), "Experimental builtin module '%1$s' is not enabled", name);
+      LOG(message_group::Warning, loc, documentRoot(),
+          "Experimental builtin module '%1$s' is not enabled", name);
     }
-    std::string replacement = Builtins::instance()->instance()->isDeprecated(name);
+    std::string replacement =
+        Builtins::instance()->instance()->isDeprecated(name);
     if (!replacement.empty()) {
-      LOG(message_group::Deprecated, loc, documentRoot(), "The %1$s() module will be removed in future releases. Use %2$s instead.", name, replacement);
+      LOG(message_group::Deprecated, loc, documentRoot(),
+          "The %1$s() module will be removed in future releases. Use %2$s "
+          "instead.",
+          name, replacement);
     }
     if (m->is_enabled()) {
       return InstantiableModule{get_shared_ptr(), m};
diff --git a/src/core/BuiltinContext.h b/src/core/BuiltinContext.h
index 4efdf4f17..e3acf4f89 100644
--- a/src/core/BuiltinContext.h
+++ b/src/core/BuiltinContext.h
@@ -5,15 +5,18 @@
 #include "core/AST.h"
 #include "core/Context.h"
 
-class BuiltinContext : public Context
-{
-public:
+class BuiltinContext : public Context {
+ public:
   void init() override;
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
+  boost::optional<CallableFunction> lookup_local_function(
+      const std::string& name,
+      const Location& loc) const override;
+  boost::optional<InstantiableModule> lookup_local_module(
+      const std::string& name,
+      const Location& loc) const override;
 
-protected:
-  BuiltinContext(EvaluationSession *session);
+ protected:
+  BuiltinContext(EvaluationSession* session);
 
   friend class Context;
 };
diff --git a/src/core/Builtins.cc b/src/core/Builtins.cc
index 4647fc951..b79e8ef83 100644
--- a/src/core/Builtins.cc
+++ b/src/core/Builtins.cc
@@ -1,20 +1,20 @@
 #include "core/Builtins.h"
 
-#include <unordered_map>
 #include <memory>
 #include <string>
+#include <unordered_map>
 #include <vector>
 
 #include "core/AST.h"
+#include "core/Expression.h"
 #include "core/function.h"
 #include "core/module.h"
-#include "core/Expression.h"
 
-std::unordered_map<std::string, const std::vector<std::string>> Builtins::keywordList;
+std::unordered_map<std::string, const std::vector<std::string>>
+    Builtins::keywordList;
 
-Builtins *Builtins::instance(bool erase)
-{
-  static auto *builtins = new Builtins;
+Builtins* Builtins::instance(bool erase) {
+  static auto* builtins = new Builtins;
   if (erase) {
     delete builtins;
     builtins = nullptr;
@@ -22,27 +22,31 @@ Builtins *Builtins::instance(bool erase)
   return builtins;
 }
 
-void Builtins::init(const std::string& name, class AbstractModule *module)
-{
+void Builtins::init(const std::string& name, class AbstractModule* module) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (module->is_experimental()) return;
+  if (module->is_experimental())
+    return;
 #endif
   Builtins::instance()->modules.emplace(name, module);
 }
 
-void Builtins::init(const std::string& name, AbstractModule *module, const std::vector<std::string>& calltipList)
-{
+void Builtins::init(const std::string& name,
+                    AbstractModule* module,
+                    const std::vector<std::string>& calltipList) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (module->is_experimental()) return;
+  if (module->is_experimental())
+    return;
 #endif
   Builtins::instance()->modules.emplace(name, module);
   Builtins::keywordList.insert({name, calltipList});
 }
 
-void Builtins::init(const std::string& name, BuiltinFunction *function, const std::vector<std::string>& calltipList)
-{
+void Builtins::init(const std::string& name,
+                    BuiltinFunction* function,
+                    const std::vector<std::string>& calltipList) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (function->is_experimental()) return;
+  if (function->is_experimental())
+    return;
 #endif
   Builtins::instance()->functions.emplace(name, function);
   Builtins::keywordList.insert({name, calltipList});
@@ -73,8 +77,7 @@ extern void initialize_builtin_dxf_dim();
    Registers all builtin functions.
    Call once for the whole app.
  */
-void Builtins::initialize()
-{
+void Builtins::initialize() {
   Builtins::initKeywordList();
 
   register_builtin_functions();
@@ -102,33 +105,38 @@ void Builtins::initialize()
   this->deprecations.emplace("assign", "a regular assignment");
 }
 
-std::string Builtins::isDeprecated(const std::string& name) const
-{
+std::string Builtins::isDeprecated(const std::string& name) const {
   if (this->deprecations.find(name) != this->deprecations.end()) {
     return this->deprecations.at(name);
   }
   return {};
 }
 
-Builtins::Builtins()
-{
-  this->assignments.emplace_back(new Assignment("$fn", std::make_shared<Literal>(0.0)) );
-  this->assignments.emplace_back(new Assignment("$fs", std::make_shared<Literal>(2.0)) );
-  this->assignments.emplace_back(new Assignment("$fa", std::make_shared<Literal>(12.0)) );
-  this->assignments.emplace_back(new Assignment("$t", std::make_shared<Literal>(0.0)) );
-  this->assignments.emplace_back(new Assignment("$preview", std::make_shared<Literal>()) ); //undef as should always be overwritten.
+Builtins::Builtins() {
+  this->assignments.emplace_back(
+      new Assignment("$fn", std::make_shared<Literal>(0.0)));
+  this->assignments.emplace_back(
+      new Assignment("$fs", std::make_shared<Literal>(2.0)));
+  this->assignments.emplace_back(
+      new Assignment("$fa", std::make_shared<Literal>(12.0)));
+  this->assignments.emplace_back(
+      new Assignment("$t", std::make_shared<Literal>(0.0)));
+  this->assignments.emplace_back(new Assignment(
+      "$preview",
+      std::make_shared<Literal>()));  // undef as should always be overwritten.
   auto zeroVector = std::make_shared<Vector>(Location::NONE);
   zeroVector->emplace_back(new Literal(0.0));
   zeroVector->emplace_back(new Literal(0.0));
   zeroVector->emplace_back(new Literal(0.0));
-  this->assignments.emplace_back(new Assignment("$vpt", zeroVector) );
-  this->assignments.emplace_back(new Assignment("$vpr", zeroVector) );
-  this->assignments.emplace_back(new Assignment("$vpd", std::make_shared<Literal>(500.0)) );
-  this->assignments.emplace_back(new Assignment("$vpf", std::make_shared<Literal>(22.5)) );
+  this->assignments.emplace_back(new Assignment("$vpt", zeroVector));
+  this->assignments.emplace_back(new Assignment("$vpr", zeroVector));
+  this->assignments.emplace_back(
+      new Assignment("$vpd", std::make_shared<Literal>(500.0)));
+  this->assignments.emplace_back(
+      new Assignment("$vpf", std::make_shared<Literal>(22.5)));
 }
 
-void Builtins::initKeywordList()
-{
+void Builtins::initKeywordList() {
   Builtins::keywordList.insert({"else", {}});
   Builtins::keywordList.insert({"each", {}});
   Builtins::keywordList.insert({"module", {}});
diff --git a/src/core/Builtins.h b/src/core/Builtins.h
index da90c2ada..1d01394d1 100644
--- a/src/core/Builtins.h
+++ b/src/core/Builtins.h
@@ -3,21 +3,24 @@
 #include <string>
 #include <unordered_map>
 #include <vector>
-#include "core/module.h"
 #include "core/Assignment.h"
+#include "core/module.h"
 
 class AbstractModule;
 class BuiltinFunction;
 
 void initialize_rng();
 
-class Builtins
-{
-public:
-  static Builtins *instance(bool erase = false);
-  static void init(const std::string& name, AbstractModule *module);
-  static void init(const std::string& name, AbstractModule *module, const std::vector<std::string>& calltipList);
-  static void init(const std::string& name, BuiltinFunction *function, const std::vector<std::string>& calltipList);
+class Builtins {
+ public:
+  static Builtins* instance(bool erase = false);
+  static void init(const std::string& name, AbstractModule* module);
+  static void init(const std::string& name,
+                   AbstractModule* module,
+                   const std::vector<std::string>& calltipList);
+  static void init(const std::string& name,
+                   BuiltinFunction* function,
+                   const std::vector<std::string>& calltipList);
   void initialize();
   std::string isDeprecated(const std::string& name) const;
 
@@ -25,17 +28,18 @@ public:
   const auto& getFunctions() const { return this->functions; }
   const auto& getModules() const { return this->modules; }
 
-  static std::unordered_map<std::string, const std::vector<std::string>> keywordList;
+  static std::unordered_map<std::string, const std::vector<std::string>>
+      keywordList;
 
-private:
+ private:
   Builtins();
   virtual ~Builtins() = default;
 
   static void initKeywordList();
 
   AssignmentList assignments;
-  std::unordered_map<std::string, BuiltinFunction *> functions;
-  std::unordered_map<std::string, AbstractModule *> modules;
+  std::unordered_map<std::string, BuiltinFunction*> functions;
+  std::unordered_map<std::string, AbstractModule*> modules;
 
   std::unordered_map<std::string, std::string> deprecations;
 };
diff --git a/src/core/CSGNode.cc b/src/core/CSGNode.cc
index d7d6bd691..ccc3211dd 100644
--- a/src/core/CSGNode.cc
+++ b/src/core/CSGNode.cc
@@ -29,8 +29,8 @@
 #include "geometry/linalg.h"
 
 #include <cassert>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <numeric>
 #include <sstream>
 #include <stack>
@@ -64,17 +64,23 @@
 /*!
    \class CSGProduct
 
-   A CSGProduct is a vector of intersections and a vector of subtractions, used for CSG rendering.
+   A CSGProduct is a vector of intersections and a vector of subtractions, used
+   for CSG rendering.
  */
 
 std::shared_ptr<CSGNode> CSGNode::createEmptySet() {
-  return std::shared_ptr<CSGNode>(new CSGLeaf(nullptr, Transform3d(), Color4f(), "empty()", 0));
+  return std::shared_ptr<CSGNode>(
+      new CSGLeaf(nullptr, Transform3d(), Color4f(), "empty()", 0));
 }
 
-std::shared_ptr<CSGNode> CSGOperation::createCSGNode(OpenSCADOperator type, std::shared_ptr<CSGNode> left, std::shared_ptr<CSGNode> right)
-{
-  // Note that std::shared_ptr<CSGNode> == nullptr is different from having a CSGNode with std::shared_ptr<Geometry> geom == nullptr
-  // The former indicates lack of a geometry node (could be echo or assert node), and the latter represents the empty set of geometry.
+std::shared_ptr<CSGNode> CSGOperation::createCSGNode(
+    OpenSCADOperator type,
+    std::shared_ptr<CSGNode> left,
+    std::shared_ptr<CSGNode> right) {
+  // Note that std::shared_ptr<CSGNode> == nullptr is different from having a
+  // CSGNode with std::shared_ptr<Geometry> geom == nullptr The former indicates
+  // lack of a geometry node (could be echo or assert node), and the latter
+  // represents the empty set of geometry.
   if (!left && !right) {
     return CSGNode::createEmptySet();
   } else if (!left && right) {
@@ -82,14 +88,20 @@ std::shared_ptr<CSGNode> CSGOperation::createCSGNode(OpenSCADOperator type, std:
   } else if (left && !right) {
     return left;
   } else {
-    // In case we're creating a CSG term from a pruned tree, left or right may be the empty set
+    // In case we're creating a CSG term from a pruned tree, left or right may
+    // be the empty set
     if (right->isEmptySet()) {
-      if (type == OpenSCADOperator::UNION || type == OpenSCADOperator::DIFFERENCE) return left;
-      else return right;
+      if (type == OpenSCADOperator::UNION ||
+          type == OpenSCADOperator::DIFFERENCE)
+        return left;
+      else
+        return right;
     }
     if (left->isEmptySet()) {
-      if (type == OpenSCADOperator::UNION) return right;
-      else return left;
+      if (type == OpenSCADOperator::UNION)
+        return right;
+      else
+        return left;
     }
   }
 
@@ -99,102 +111,107 @@ std::shared_ptr<CSGNode> CSGOperation::createCSGNode(OpenSCADOperator type, std:
   const auto& rightbox = right->getBoundingBox();
   Vector3d newmin, newmax;
   if (type == OpenSCADOperator::INTERSECTION) {
-    newmin = leftbox.min().array().cwiseMax(rightbox.min().array() );
-    newmax = leftbox.max().array().cwiseMin(rightbox.max().array() );
+    newmin = leftbox.min().array().cwiseMax(rightbox.min().array());
+    newmax = leftbox.max().array().cwiseMin(rightbox.max().array());
     BoundingBox newbox(newmin, newmax);
     if (newbox.isNull()) {
-      return CSGNode::createEmptySet(); // Prune entire product
+      return CSGNode::createEmptySet();  // Prune entire product
     }
   } else if (type == OpenSCADOperator::DIFFERENCE) {
-    newmin = leftbox.min().array().cwiseMax(rightbox.min().array() );
-    newmax = leftbox.max().array().cwiseMin(rightbox.max().array() );
+    newmin = leftbox.min().array().cwiseMax(rightbox.min().array());
+    newmax = leftbox.max().array().cwiseMin(rightbox.max().array());
     BoundingBox newbox(newmin, newmax);
     if (newbox.isNull()) {
-      return left; // Prune the negative component
+      return left;  // Prune the negative component
     }
   }
 
   return {new CSGOperation(type, left, right), CSGOperationDeleter()};
 }
 
-CSGLeaf::CSGLeaf(const std::shared_ptr<const PolySet>& ps, Transform3d matrix, Color4f color, std::string label, const int index)
-  : label(std::move(label)), matrix(std::move(matrix)), color(std::move(color)), index(index)
-{
-  if (ps && !ps->isEmpty()) this->polyset = ps;
+CSGLeaf::CSGLeaf(const std::shared_ptr<const PolySet>& ps,
+                 Transform3d matrix,
+                 Color4f color,
+                 std::string label,
+                 const int index)
+    : label(std::move(label)),
+      matrix(std::move(matrix)),
+      color(std::move(color)),
+      index(index) {
+  if (ps && !ps->isEmpty())
+    this->polyset = ps;
   CSGLeaf::initBoundingBox();
 }
 
-CSGOperation::CSGOperation(OpenSCADOperator type, const std::shared_ptr<CSGNode>& left, const std::shared_ptr<CSGNode>& right)
-  : type(type)
-{
+CSGOperation::CSGOperation(OpenSCADOperator type,
+                           const std::shared_ptr<CSGNode>& left,
+                           const std::shared_ptr<CSGNode>& right)
+    : type(type) {
   this->children.push_back(left);
   this->children.push_back(right);
   CSGOperation::initBoundingBox();
 }
 
-void CSGLeaf::initBoundingBox()
-{
-  if (!this->polyset) return;
+void CSGLeaf::initBoundingBox() {
+  if (!this->polyset)
+    return;
   this->bbox = this->matrix * this->polyset->getBoundingBox();
 }
 
-void CSGOperation::initBoundingBox()
-{
+void CSGOperation::initBoundingBox() {
   const auto& leftbox = this->left()->getBoundingBox();
   const auto& rightbox = this->right()->getBoundingBox();
   Vector3d newmin, newmax;
   switch (this->type) {
-  case OpenSCADOperator::UNION:
-    this->bbox = leftbox.merged(rightbox);
-    break;
-  case OpenSCADOperator::INTERSECTION:
-    this->bbox = leftbox.intersection(rightbox);
-    break;
-  case OpenSCADOperator::DIFFERENCE:
-    this->bbox = leftbox;
-    break;
-  default:
-    assert(false);
+    case OpenSCADOperator::UNION:
+      this->bbox = leftbox.merged(rightbox);
+      break;
+    case OpenSCADOperator::INTERSECTION:
+      this->bbox = leftbox.intersection(rightbox);
+      break;
+    case OpenSCADOperator::DIFFERENCE:
+      this->bbox = leftbox;
+      break;
+    default:
+      assert(false);
   }
 }
 
-bool CSGLeaf::isEmptySet() const
-{
+bool CSGLeaf::isEmptySet() const {
   return polyset == nullptr || polyset->isEmpty();
 }
 
-std::string CSGLeaf::dump() const
-{
+std::string CSGLeaf::dump() const {
   return this->label;
 }
 
-// Recursive traversal can cause stack overflow with very large loops of child nodes,
-// so tree is traverse iteratively, managing our own stack.
-std::string CSGOperation::dump() const
-{
+// Recursive traversal can cause stack overflow with very large loops of child
+// nodes, so tree is traverse iteratively, managing our own stack.
+std::string CSGOperation::dump() const {
   // tuple(node pointer, postfix string, ispostfix bool)
-  std::stack<std::tuple<const CSGOperation *, std::string, bool>> callstack;
+  std::stack<std::tuple<const CSGOperation*, std::string, bool>> callstack;
   callstack.emplace(this, "", false);
   std::ostringstream out;
-  const CSGOperation *node;
+  const CSGOperation* node;
   std::string postfixstr;
   bool ispostfix;
   do {
     std::tie(node, postfixstr, ispostfix) = callstack.top();
-    if (!ispostfix) { // handle left child. only right child uses a prefix string
+    if (!ispostfix) {  // handle left child. only right child uses a prefix
+                       // string
       std::string lpostfix;
       switch (node->type) {
-      case OpenSCADOperator::UNION:
-        lpostfix = " + ";
-        break;
-      case OpenSCADOperator::INTERSECTION:
-        lpostfix = " * ";
-        break;
-      case OpenSCADOperator::DIFFERENCE:
-        lpostfix = " - ";
-        break;
-      default:
-        assert(false);
+        case OpenSCADOperator::UNION:
+          lpostfix = " + ";
+          break;
+        case OpenSCADOperator::INTERSECTION:
+          lpostfix = " * ";
+          break;
+        case OpenSCADOperator::DIFFERENCE:
+          lpostfix = " - ";
+          break;
+        default:
+          assert(false);
       }
 
       out << '(';
@@ -226,9 +243,12 @@ std::string CSGOperation::dump() const
   return out.str();
 }
 
-void CSGProducts::import(std::shared_ptr<CSGNode> csgnode, OpenSCADOperator type, CSGNode::Flag flags)
-{
-  std::stack<std::tuple<std::shared_ptr<CSGNode>, OpenSCADOperator, CSGNode::Flag>> callstack;
+void CSGProducts::import(std::shared_ptr<CSGNode> csgnode,
+                         OpenSCADOperator type,
+                         CSGNode::Flag flags) {
+  std::stack<
+      std::tuple<std::shared_ptr<CSGNode>, OpenSCADOperator, CSGNode::Flag>>
+      callstack;
   callstack.push(std::make_tuple(csgnode, type, flags));
 
   do {
@@ -241,7 +261,8 @@ void CSGProducts::import(std::shared_ptr<CSGNode> csgnode, OpenSCADOperator type
     auto newflags = static_cast<CSGNode::Flag>(csgnode->getFlags() | flags);
 
     if (auto leaf = std::dynamic_pointer_cast<CSGLeaf>(csgnode)) {
-      if (type == OpenSCADOperator::UNION && this->currentproduct->intersections.size() > 0) {
+      if (type == OpenSCADOperator::UNION &&
+          this->currentproduct->intersections.size() > 0) {
         this->createProduct();
       } else if (type == OpenSCADOperator::DIFFERENCE) {
         this->currentlist = &this->currentproduct->subtractions;
@@ -257,13 +278,11 @@ void CSGProducts::import(std::shared_ptr<CSGNode> csgnode, OpenSCADOperator type
   } while (!callstack.empty());
 }
 
-std::string CSGProduct::dump() const
-{
+std::string CSGProduct::dump() const {
   std::ostringstream dump;
   dump << this->intersections.front().leaf->label;
-  for (const auto& csgobj :
-       boost::make_iterator_range(this->intersections.begin() + 1,
-                                  this->intersections.end())) {
+  for (const auto& csgobj : boost::make_iterator_range(
+           this->intersections.begin() + 1, this->intersections.end())) {
     dump << " *" << csgobj.leaf->label;
   }
   for (const auto& csgobj : this->subtractions) {
@@ -272,43 +291,35 @@ std::string CSGProduct::dump() const
   return dump.str();
 }
 
-BoundingBox CSGProduct::getBoundingBox(bool throwntogether) const
-{
+BoundingBox CSGProduct::getBoundingBox(bool throwntogether) const {
   BoundingBox bbox;
-  if (this->intersections.empty()) return bbox;
+  if (this->intersections.empty())
+    return bbox;
 
   if (throwntogether) {
-    bbox = std::accumulate(
-      this->intersections.cbegin() + 1,
-      this->intersections.cend(),
-      this->intersections.front().leaf->bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.merged(b.leaf->bbox);
-    }
-      );
-    bbox = std::accumulate(
-      this->subtractions.cbegin(),
-      this->subtractions.cend(),
-      bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.merged(b.leaf->bbox);
-    }
-      );
+    bbox = std::accumulate(this->intersections.cbegin() + 1,
+                           this->intersections.cend(),
+                           this->intersections.front().leaf->bbox,
+                           [](const BoundingBox& a, const CSGChainObject& b) {
+                             return a.merged(b.leaf->bbox);
+                           });
+    bbox = std::accumulate(this->subtractions.cbegin(),
+                           this->subtractions.cend(), bbox,
+                           [](const BoundingBox& a, const CSGChainObject& b) {
+                             return a.merged(b.leaf->bbox);
+                           });
   } else {
-    bbox = std::accumulate(
-      this->intersections.cbegin() + 1,
-      this->intersections.cend(),
-      this->intersections.front().leaf->bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.intersection(b.leaf->bbox);
-    }
-      );
+    bbox = std::accumulate(this->intersections.cbegin() + 1,
+                           this->intersections.cend(),
+                           this->intersections.front().leaf->bbox,
+                           [](const BoundingBox& a, const CSGChainObject& b) {
+                             return a.intersection(b.leaf->bbox);
+                           });
   }
   return bbox;
 }
 
-std::string CSGProducts::dump() const
-{
+std::string CSGProducts::dump() const {
   std::ostringstream dump;
 
   for (const auto& product : this->products) {
@@ -317,8 +328,7 @@ std::string CSGProducts::dump() const
   return dump.str();
 }
 
-BoundingBox CSGProducts::getBoundingBox(bool throwntogether) const
-{
+BoundingBox CSGProducts::getBoundingBox(bool throwntogether) const {
   BoundingBox bbox;
   for (const auto& product : this->products) {
     bbox.extend(product.getBoundingBox(throwntogether));
@@ -326,8 +336,7 @@ BoundingBox CSGProducts::getBoundingBox(bool throwntogether) const
   return bbox;
 }
 
-size_t CSGProducts::size() const
-{
+size_t CSGProducts::size() const {
   size_t count = 0;
   for (const auto& product : this->products) {
     count += product.intersections.size() + product.subtractions.size();
diff --git a/src/core/CSGNode.h b/src/core/CSGNode.h
index 6d11bd13c..2ddb754b3 100644
--- a/src/core/CSGNode.h
+++ b/src/core/CSGNode.h
@@ -1,23 +1,18 @@
 #pragma once
 
-#include <utility>
 #include <cstddef>
+#include <memory>
 #include <string>
+#include <utility>
 #include <vector>
-#include <memory>
-#include "geometry/linalg.h"
 #include "core/enums.h"
+#include "geometry/linalg.h"
 
 class PolySet;
 
-class CSGNode
-{
-public:
-  enum Flag {
-    FLAG_NONE = 0x00,
-    FLAG_BACKGROUND = 0x01,
-    FLAG_HIGHLIGHT = 0x02
-  };
+class CSGNode {
+ public:
+  enum Flag { FLAG_NONE = 0x00, FLAG_BACKGROUND = 0x01, FLAG_HIGHLIGHT = 0x02 };
 
   CSGNode(Flag flags = FLAG_NONE) : flags(flags) {}
   virtual ~CSGNode() = default;
@@ -26,14 +21,22 @@ public:
 
   [[nodiscard]] const BoundingBox& getBoundingBox() const { return this->bbox; }
   [[nodiscard]] unsigned int getFlags() const { return this->flags; }
-  [[nodiscard]] bool isHighlight() const { return this->flags & FLAG_HIGHLIGHT; }
-  [[nodiscard]] bool isBackground() const { return this->flags & FLAG_BACKGROUND; }
-  void setHighlight(bool on) { on ? this->flags |= FLAG_HIGHLIGHT : this->flags &= ~FLAG_HIGHLIGHT; }
-  void setBackground(bool on) { on ? this->flags |= FLAG_BACKGROUND : this->flags &= ~FLAG_BACKGROUND; }
+  [[nodiscard]] bool isHighlight() const {
+    return this->flags & FLAG_HIGHLIGHT;
+  }
+  [[nodiscard]] bool isBackground() const {
+    return this->flags & FLAG_BACKGROUND;
+  }
+  void setHighlight(bool on) {
+    on ? this->flags |= FLAG_HIGHLIGHT : this->flags &= ~FLAG_HIGHLIGHT;
+  }
+  void setBackground(bool on) {
+    on ? this->flags |= FLAG_BACKGROUND : this->flags &= ~FLAG_BACKGROUND;
+  }
 
   static std::shared_ptr<CSGNode> createEmptySet();
 
-protected:
+ protected:
   virtual void initBoundingBox() = 0;
 
   BoundingBox bbox;
@@ -43,32 +46,39 @@ protected:
   friend class CSGProducts;
 };
 
-class CSGOperation : public CSGNode
-{
-public:
+class CSGOperation : public CSGNode {
+ public:
   CSGOperation() = default;
   void initBoundingBox() override;
   [[nodiscard]] std::string dump() const override;
 
   std::shared_ptr<CSGNode>& left() { return this->children[0]; }
   std::shared_ptr<CSGNode>& right() { return this->children[1]; }
-  [[nodiscard]] const std::shared_ptr<CSGNode>& left() const { return this->children[0]; }
-  [[nodiscard]] const std::shared_ptr<CSGNode>& right() const { return this->children[1]; }
+  [[nodiscard]] const std::shared_ptr<CSGNode>& left() const {
+    return this->children[0];
+  }
+  [[nodiscard]] const std::shared_ptr<CSGNode>& right() const {
+    return this->children[1];
+  }
 
   [[nodiscard]] OpenSCADOperator getType() const { return this->type; }
 
-  static std::shared_ptr<CSGNode> createCSGNode(OpenSCADOperator type, std::shared_ptr<CSGNode> left, std::shared_ptr<CSGNode> right);
+  static std::shared_ptr<CSGNode> createCSGNode(OpenSCADOperator type,
+                                                std::shared_ptr<CSGNode> left,
+                                                std::shared_ptr<CSGNode> right);
 
-private:
-  CSGOperation(OpenSCADOperator type, const std::shared_ptr<CSGNode>& left, const std::shared_ptr<CSGNode>& right);
+ private:
+  CSGOperation(OpenSCADOperator type,
+               const std::shared_ptr<CSGNode>& left,
+               const std::shared_ptr<CSGNode>& right);
   OpenSCADOperator type;
   std::vector<std::shared_ptr<CSGNode>> children;
 };
 
-// very large lists of children can overflow stack due to recursive destruction of shared_ptr,
-// so move shared_ptrs into a temporary vector
+// very large lists of children can overflow stack due to recursive destruction
+// of shared_ptr, so move shared_ptrs into a temporary vector
 struct CSGOperationDeleter {
-  void operator()(CSGOperation *node) {
+  void operator()(CSGOperation* node) {
     std::vector<std::shared_ptr<CSGNode>> purge;
     purge.emplace_back(std::move(node->right()));
     purge.emplace_back(std::move(node->left()));
@@ -84,11 +94,14 @@ struct CSGOperationDeleter {
   }
 };
 
-class CSGLeaf : public CSGNode
-{
-public:
+class CSGLeaf : public CSGNode {
+ public:
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  CSGLeaf(const std::shared_ptr<const PolySet>& ps, Transform3d matrix, Color4f color, std::string label, const int index);
+  CSGLeaf(const std::shared_ptr<const PolySet>& ps,
+          Transform3d matrix,
+          Color4f color,
+          std::string label,
+          const int index);
   void initBoundingBox() override;
   [[nodiscard]] bool isEmptySet() const override;
   [[nodiscard]] std::string dump() const override;
@@ -106,19 +119,18 @@ public:
    Flags are accumulated in the CSG tree, so the rendered object may
    have different flags than the corresponding leaf node.
  */
-class CSGChainObject
-{
-public:
-  CSGChainObject(const std::shared_ptr<CSGLeaf>& leaf, CSGNode::Flag flags = CSGNode::FLAG_NONE)
-    : leaf(leaf), flags(flags) {}
+class CSGChainObject {
+ public:
+  CSGChainObject(const std::shared_ptr<CSGLeaf>& leaf,
+                 CSGNode::Flag flags = CSGNode::FLAG_NONE)
+      : leaf(leaf), flags(flags) {}
 
   std::shared_ptr<CSGLeaf> leaf;
   CSGNode::Flag flags;
 };
 
-class CSGProduct
-{
-public:
+class CSGProduct {
+ public:
   CSGProduct() = default;
 
   [[nodiscard]] std::string dump() const;
@@ -128,14 +140,13 @@ public:
   std::vector<CSGChainObject> subtractions;
 };
 
-class CSGProducts
-{
-public:
-  CSGProducts() {
-    this->createProduct();
-  }
+class CSGProducts {
+ public:
+  CSGProducts() { this->createProduct(); }
 
-  void import(std::shared_ptr<CSGNode> csgtree, OpenSCADOperator type = OpenSCADOperator::UNION, CSGNode::Flag flags = CSGNode::FLAG_NONE);
+  void import(std::shared_ptr<CSGNode> csgtree,
+              OpenSCADOperator type = OpenSCADOperator::UNION,
+              CSGNode::Flag flags = CSGNode::FLAG_NONE);
   [[nodiscard]] std::string dump() const;
   [[nodiscard]] BoundingBox getBoundingBox(bool throwntogether = false) const;
 
@@ -143,13 +154,13 @@ public:
 
   [[nodiscard]] size_t size() const;
 
-private:
+ private:
   void createProduct() {
     this->products.emplace_back();
     this->currentproduct = &this->products.back();
     this->currentlist = &this->currentproduct->intersections;
   }
 
-  std::vector<CSGChainObject> *currentlist;
-  CSGProduct *currentproduct;
+  std::vector<CSGChainObject>* currentlist;
+  CSGProduct* currentproduct;
 };
diff --git a/src/core/CSGTreeEvaluator.cc b/src/core/CSGTreeEvaluator.cc
index 278ef0d55..08044dffa 100644
--- a/src/core/CSGTreeEvaluator.cc
+++ b/src/core/CSGTreeEvaluator.cc
@@ -1,41 +1,42 @@
 #include "core/CSGTreeEvaluator.h"
-#include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "core/State.h"
-#include "core/CsgOpNode.h"
-#include "core/ModuleInstantiation.h"
 #include "core/CSGNode.h"
-#include "core/TransformNode.h"
+#include "core/CgalAdvNode.h"
 #include "core/ColorNode.h"
+#include "core/CsgOpNode.h"
+#include "core/ModuleInstantiation.h"
 #include "core/RenderNode.h"
-#include "core/CgalAdvNode.h"
-#include "utils/printutils.h"
+#include "core/State.h"
+#include "core/TransformNode.h"
+#include "geometry/Geometry.h"
 #include "geometry/GeometryEvaluator.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/linalg.h"
+#include "utils/printutils.h"
 
-#include <memory>
-#include <string>
-#include <map>
-#include <list>
+#include <boost/range/adaptor/reversed.hpp>
 #include <cassert>
 #include <cstddef>
-#include <boost/range/adaptor/reversed.hpp>
+#include <list>
+#include <map>
+#include <memory>
+#include <string>
 
 /*!
    \class CSGTreeEvaluator
 
-   A visitor responsible for creating a binary tree of CSGNode nodes used for rendering
-   with OpenCSG.
+   A visitor responsible for creating a binary tree of CSGNode nodes used for
+   rendering with OpenCSG.
  */
 
-std::shared_ptr<CSGNode> CSGTreeEvaluator::buildCSGTree(const AbstractNode& node)
-{
+std::shared_ptr<CSGNode> CSGTreeEvaluator::buildCSGTree(
+    const AbstractNode& node) {
   this->traverse(node);
 
   std::shared_ptr<CSGNode> t(this->stored_term[node.index()]);
   if (t) {
-    if (t->isHighlight()) this->highlightNodes.push_back(t);
+    if (t->isHighlight())
+      this->highlightNodes.push_back(t);
     if (t->isBackground()) {
       this->backgroundNodes.push_back(t);
       t.reset();
@@ -45,20 +46,23 @@ std::shared_ptr<CSGNode> CSGTreeEvaluator::buildCSGTree(const AbstractNode& node
   return this->rootNode = t;
 }
 
-void CSGTreeEvaluator::applyBackgroundAndHighlight(State& /*state*/, const AbstractNode& node)
-{
+void CSGTreeEvaluator::applyBackgroundAndHighlight(State& /*state*/,
+                                                   const AbstractNode& node) {
   for (const auto& chnode : this->visitedchildren[node.index()]) {
     std::shared_ptr<CSGNode> t(this->stored_term[chnode->index()]);
     this->stored_term.erase(chnode->index());
     if (t) {
-      if (t->isBackground()) this->backgroundNodes.push_back(t);
-      if (t->isHighlight()) this->highlightNodes.push_back(t);
+      if (t->isBackground())
+        this->backgroundNodes.push_back(t);
+      if (t->isHighlight())
+        this->highlightNodes.push_back(t);
     }
   }
 }
 
-void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, OpenSCADOperator op)
-{
+void CSGTreeEvaluator::applyToChildren(State& state,
+                                       const AbstractNode& node,
+                                       OpenSCADOperator op) {
   const auto& vc = this->visitedchildren[node.index()];
   if (vc.empty()) {
     this->stored_term[node.index()] = CSGNode::createEmptySet();
@@ -72,7 +76,6 @@ void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, O
     if (t2 && !t1) {
       t1 = t2;
     } else if (t2 && t1) {
-
       std::shared_ptr<CSGNode> t;
       // Handle background
       // Background objects are simply moved to backgroundNodes
@@ -87,56 +90,56 @@ void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, O
       }
       // Handle highlight
       switch (op) {
-      case OpenSCADOperator::DIFFERENCE:
-        if (t != t1 && t1->isHighlight()) {
-          t->setHighlight(true);
-        } else if (t != t2 && t2->isHighlight()) {
-          this->highlightNodes.push_back(t2);
-        }
-        break;
-      case OpenSCADOperator::INTERSECTION:
-        if (t && !t->isEmptySet() && t != t1 && t != t2 &&
-            t1->isHighlight() && t2->isHighlight()) {
-          t->setHighlight(true);
-        } else {
+        case OpenSCADOperator::DIFFERENCE:
           if (t != t1 && t1->isHighlight()) {
-            this->highlightNodes.push_back(t1);
+            t->setHighlight(true);
+          } else if (t != t2 && t2->isHighlight()) {
+            this->highlightNodes.push_back(t2);
           }
-          if (t != t2 && t2->isHighlight()) {
+          break;
+        case OpenSCADOperator::INTERSECTION:
+          if (t && !t->isEmptySet() && t != t1 && t != t2 &&
+              t1->isHighlight() && t2->isHighlight()) {
+            t->setHighlight(true);
+          } else {
+            if (t != t1 && t1->isHighlight()) {
+              this->highlightNodes.push_back(t1);
+            }
+            if (t != t2 && t2->isHighlight()) {
+              this->highlightNodes.push_back(t2);
+            }
+          }
+          break;
+        case OpenSCADOperator::UNION:
+          if (t != t1 && t != t2 && t1->isHighlight() && t2->isHighlight()) {
+            t->setHighlight(true);
+          } else if (t != t1 && t1->isHighlight()) {
+            this->highlightNodes.push_back(t1);
+            t = t2;
+          } else if (t != t2 && t2->isHighlight()) {
             this->highlightNodes.push_back(t2);
+            t = t1;
           }
-        }
-        break;
-      case OpenSCADOperator::UNION:
-        if (t != t1 && t != t2 &&
-            t1->isHighlight() && t2->isHighlight()) {
-          t->setHighlight(true);
-        } else if (t != t1 && t1->isHighlight()) {
-          this->highlightNodes.push_back(t1);
-          t = t2;
-        } else if (t != t2 && t2->isHighlight()) {
-          this->highlightNodes.push_back(t2);
-          t = t1;
-        }
-        break;
-      case OpenSCADOperator::MINKOWSKI:
-      case OpenSCADOperator::HULL:
-      case OpenSCADOperator::FILL:
-      case OpenSCADOperator::RESIZE:
-        break;
+          break;
+        case OpenSCADOperator::MINKOWSKI:
+        case OpenSCADOperator::HULL:
+        case OpenSCADOperator::FILL:
+        case OpenSCADOperator::RESIZE:
+          break;
       }
       t1 = t;
     }
   }
   if (t1) {
-    if (node.modinst->isBackground() || state.isBackground()) t1->setBackground(true);
-    if (node.modinst->isHighlight() || state.isHighlight()) t1->setHighlight(true);
+    if (node.modinst->isBackground() || state.isBackground())
+      t1->setBackground(true);
+    if (node.modinst->isHighlight() || state.isHighlight())
+      t1->setHighlight(true);
   }
   this->stored_term[node.index()] = t1;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractNode& node)
-{
+Response CSGTreeEvaluator::visit(State& state, const AbstractNode& node) {
   if (state.isPostfix()) {
     applyToChildren(state, node, OpenSCADOperator::UNION);
     addToParent(state, node);
@@ -144,8 +147,8 @@ Response CSGTreeEvaluator::visit(State& state, const AbstractNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractIntersectionNode& node)
-{
+Response CSGTreeEvaluator::visit(State& state,
+                                 const AbstractIntersectionNode& node) {
   if (state.isPostfix()) {
     applyToChildren(state, node, OpenSCADOperator::INTERSECTION);
     addToParent(state, node);
@@ -153,12 +156,13 @@ Response CSGTreeEvaluator::visit(State& state, const AbstractIntersectionNode& n
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const class ListNode &node)
-{
+Response CSGTreeEvaluator::visit(State& state, const class ListNode& node) {
   if (state.parent()) {
     if (state.isPrefix()) {
-      if (node.modinst->isHighlight()) state.setHighlight(true);
-      if (node.modinst->isBackground()) state.setBackground(true);
+      if (node.modinst->isHighlight())
+        state.setHighlight(true);
+      if (node.modinst->isBackground())
+        state.setBackground(true);
     }
     if (state.isPostfix()) {
       for (auto& chnode : this->visitedchildren[node.index()]) {
@@ -170,7 +174,6 @@ Response CSGTreeEvaluator::visit(State& state, const class ListNode &node)
     // Handle root modifier on ListNode just like a group
     return visit(state, (const AbstractNode&)node);
   }
-
 }
 
 // Creates a 1-unit-thick PolySet with dim==2 from a Polygon2d.
@@ -179,15 +182,15 @@ std::shared_ptr<const PolySet> polygon2dToPolySet(const Polygon2d& p2d) {
   constexpr int dim = 2;
   // Estimating num vertices and polygons: top + bottom + sides
   PolySetBuilder builder(ps->vertices.size() * 2,
-                         ps->indices.size() * 2 + ps->vertices.size(),
-                         dim, p2d.is_convex());
+                         ps->indices.size() * 2 + ps->vertices.size(), dim,
+                         p2d.is_convex());
   builder.setConvexity(p2d.getConvexity());
 
   // Create bottom face.
   for (const auto& poly : ps->indices) {
     builder.beginPolygon(poly.size());
     // Flip vertex ordering for bottom polygon
-    for (const auto& ind: boost::adaptors::reverse(poly)) {
+    for (const auto& ind : boost::adaptors::reverse(poly)) {
       builder.addVertex(ps->vertices[ind] - Vector3d(0, 0, 0.5));
     }
   }
@@ -195,7 +198,7 @@ std::shared_ptr<const PolySet> polygon2dToPolySet(const Polygon2d& p2d) {
   // Create top face.
   for (const auto& poly : ps->indices) {
     builder.beginPolygon(poly.size());
-    for (const auto& ind: poly) {
+    for (const auto& ind : poly) {
       builder.addVertex(ps->vertices[ind] + Vector3d(0, 0, 0.5));
     }
   }
@@ -206,10 +209,10 @@ std::shared_ptr<const PolySet> polygon2dToPolySet(const Polygon2d& p2d) {
       const Vector2d& prev = o.vertices[i];
       const Vector2d& curr = o.vertices[(i + 1) % o.vertices.size()];
       builder.appendPolygon({
-        Vector3d(prev[0], prev[1], -0.5),
-        Vector3d(curr[0], curr[1], -0.5),
-        Vector3d(curr[0], curr[1], 0.5),
-        Vector3d(prev[0], prev[1], 0.5),
+          Vector3d(prev[0], prev[1], -0.5),
+          Vector3d(curr[0], curr[1], -0.5),
+          Vector3d(curr[0], curr[1], 0.5),
+          Vector3d(prev[0], prev[1], 0.5),
       });
     }
   }
@@ -217,11 +220,11 @@ std::shared_ptr<const PolySet> polygon2dToPolySet(const Polygon2d& p2d) {
   return builder.build();
 }
 
-
 std::shared_ptr<CSGNode> CSGTreeEvaluator::evaluateCSGNodeFromGeometry(
-  State& state, const std::shared_ptr<const Geometry>& geom,
-  const ModuleInstantiation *modinst, const AbstractNode& node)
-{
+    State& state,
+    const std::shared_ptr<const Geometry>& geom,
+    const ModuleInstantiation* modinst,
+    const AbstractNode& node) {
   assert(geom);
   // We cannot render Polygon2d directly, so we convert it to a PolySet here
   std::shared_ptr<const PolySet> ps;
@@ -229,20 +232,24 @@ std::shared_ptr<CSGNode> CSGTreeEvaluator::evaluateCSGNodeFromGeometry(
     if (auto p2d = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
       ps = polygon2dToPolySet(*p2d);
     }
-    // 3D PolySets are tessellated before inserting into Geometry cache, inside GeometryEvaluator::evaluateGeometry
+    // 3D PolySets are tessellated before inserting into Geometry cache, inside
+    // GeometryEvaluator::evaluateGeometry
     else {
       ps = std::dynamic_pointer_cast<const PolySet>(geom);
     }
   }
 
-  std::shared_ptr<CSGNode> t(new CSGLeaf(ps, state.matrix(), state.color(), STR(node.name(), node.index()), node.index()));
-  if (modinst->isHighlight() || state.isHighlight()) t->setHighlight(true);
-  if (modinst->isBackground() || state.isBackground()) t->setBackground(true);
+  std::shared_ptr<CSGNode> t(new CSGLeaf(ps, state.matrix(), state.color(),
+                                         STR(node.name(), node.index()),
+                                         node.index()));
+  if (modinst->isHighlight() || state.isHighlight())
+    t->setHighlight(true);
+  if (modinst->isBackground() || state.isBackground())
+    t->setBackground(true);
   return t;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractPolyNode& node)
-{
+Response CSGTreeEvaluator::visit(State& state, const AbstractPolyNode& node) {
   if (state.isPostfix()) {
     std::shared_ptr<CSGNode> t1;
     if (this->geomevaluator) {
@@ -260,8 +267,7 @@ Response CSGTreeEvaluator::visit(State& state, const AbstractPolyNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const CsgOpNode& node)
-{
+Response CSGTreeEvaluator::visit(State& state, const CsgOpNode& node) {
   if (state.isPostfix()) {
     applyToChildren(state, node, node.type);
     addToParent(state, node);
@@ -269,11 +275,13 @@ Response CSGTreeEvaluator::visit(State& state, const CsgOpNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const TransformNode& node)
-{
+Response CSGTreeEvaluator::visit(State& state, const TransformNode& node) {
   if (state.isPrefix()) {
-    if (matrix_contains_infinity(node.matrix) || matrix_contains_nan(node.matrix)) {
-      LOG(message_group::Warning, "Transformation matrix contains Not-a-Number and/or Infinity - removing object.");
+    if (matrix_contains_infinity(node.matrix) ||
+        matrix_contains_nan(node.matrix)) {
+      LOG(message_group::Warning,
+          "Transformation matrix contains Not-a-Number and/or Infinity - "
+          "removing object.");
       return Response::PruneTraversal;
     }
     state.setMatrix(state.matrix() * node.matrix);
@@ -285,10 +293,10 @@ Response CSGTreeEvaluator::visit(State& state, const TransformNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const ColorNode& node)
-{
+Response CSGTreeEvaluator::visit(State& state, const ColorNode& node) {
   if (state.isPrefix()) {
-    if (!state.color().isValid()) state.setColor(node.color);
+    if (!state.color().isValid())
+      state.setColor(node.color);
   }
   if (state.isPostfix()) {
     applyToChildren(state, node, OpenSCADOperator::UNION);
@@ -297,9 +305,9 @@ Response CSGTreeEvaluator::visit(State& state, const ColorNode& node)
   return Response::ContinueTraversal;
 }
 
-// FIXME: If we've got CGAL support, render this node as a CGAL union into a PolySet
-Response CSGTreeEvaluator::visit(State& state, const RenderNode& node)
-{
+// FIXME: If we've got CGAL support, render this node as a CGAL union into a
+// PolySet
+Response CSGTreeEvaluator::visit(State& state, const RenderNode& node) {
   if (state.isPostfix()) {
     std::shared_ptr<CSGNode> t1;
     std::shared_ptr<const Geometry> geom;
@@ -318,11 +326,11 @@ Response CSGTreeEvaluator::visit(State& state, const RenderNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const CgalAdvNode& node)
-{
+Response CSGTreeEvaluator::visit(State& state, const CgalAdvNode& node) {
   if (state.isPostfix()) {
     std::shared_ptr<CSGNode> t1;
-    // FIXME: Calling evaluator directly since we're not a PolyNode. Generalize this.
+    // FIXME: Calling evaluator directly since we're not a PolyNode. Generalize
+    // this.
     std::shared_ptr<const Geometry> geom;
     if (this->geomevaluator) {
       geom = this->geomevaluator->evaluateGeometry(node, false);
@@ -343,12 +351,15 @@ Response CSGTreeEvaluator::visit(State& state, const CgalAdvNode& node)
 /*!
    Adds ourself to out parent's list of traversed children.
    Call this for _every_ node which affects output during traversal.
-    Usually, this should be called from the postfix stage, but for some nodes, we defer traversal letting other components (e.g. CGAL) render the subgraph, and we'll then call this from prefix and prune further traversal.
+    Usually, this should be called from the postfix stage, but for some nodes,
+   we defer traversal letting other components (e.g. CGAL) render the subgraph,
+   and we'll then call this from prefix and prune further traversal.
  */
-void CSGTreeEvaluator::addToParent(const State& state, const AbstractNode& node)
-{
+void CSGTreeEvaluator::addToParent(const State& state,
+                                   const AbstractNode& node) {
   this->visitedchildren.erase(node.index());
   if (state.parent()) {
-    this->visitedchildren[state.parent()->index()].push_back(node.shared_from_this());
+    this->visitedchildren[state.parent()->index()].push_back(
+        node.shared_from_this());
   }
 }
diff --git a/src/core/CSGTreeEvaluator.h b/src/core/CSGTreeEvaluator.h
index 2edd0d2f7..3334d671e 100644
--- a/src/core/CSGTreeEvaluator.h
+++ b/src/core/CSGTreeEvaluator.h
@@ -1,25 +1,23 @@
 #pragma once
 
-#include <map>
-#include <list>
-#include <vector>
 #include <cstddef>
-#include "core/NodeVisitor.h"
+#include <list>
+#include <map>
 #include <memory>
+#include <vector>
+#include "core/CSGNode.h"
 #include "core/ModuleInstantiation.h"
+#include "core/NodeVisitor.h"
 #include "geometry/Geometry.h"
-#include "core/CSGNode.h"
 
 class CSGNode;
 class GeometryEvaluator;
 class Tree;
 
-class CSGTreeEvaluator : public NodeVisitor
-{
-public:
-  CSGTreeEvaluator(const Tree& tree, GeometryEvaluator *geomevaluator = nullptr)
-    : tree(tree), geomevaluator(geomevaluator) {
-  }
+class CSGTreeEvaluator : public NodeVisitor {
+ public:
+  CSGTreeEvaluator(const Tree& tree, GeometryEvaluator* geomevaluator = nullptr)
+      : tree(tree), geomevaluator(geomevaluator) {}
 
   Response visit(State& state, const AbstractNode& node) override;
   Response visit(State& state, const AbstractIntersectionNode& node) override;
@@ -36,30 +34,36 @@ public:
   [[nodiscard]] const std::shared_ptr<CSGNode>& getRootNode() const {
     return this->rootNode;
   }
-  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>>& getHighlightNodes() const {
+  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>>& getHighlightNodes()
+      const {
     return this->highlightNodes;
   }
-  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>>& getBackgroundNodes() const {
+  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>>&
+  getBackgroundNodes() const {
     return this->backgroundNodes;
   }
 
-private:
+ private:
   void addToParent(const State& state, const AbstractNode& node);
-  void applyToChildren(State& state, const AbstractNode& node, OpenSCADOperator op);
-  std::shared_ptr<CSGNode> evaluateCSGNodeFromGeometry(State& state,
-                                                       const std::shared_ptr<const Geometry>& geom,
-                                                       const ModuleInstantiation *modinst,
-                                                       const AbstractNode& node);
+  void applyToChildren(State& state,
+                       const AbstractNode& node,
+                       OpenSCADOperator op);
+  std::shared_ptr<CSGNode> evaluateCSGNodeFromGeometry(
+      State& state,
+      const std::shared_ptr<const Geometry>& geom,
+      const ModuleInstantiation* modinst,
+      const AbstractNode& node);
   void applyBackgroundAndHighlight(State& state, const AbstractNode& node);
 
   using ChildList = std::list<std::shared_ptr<const AbstractNode>>;
   std::map<int, ChildList> visitedchildren;
 
-protected:
+ protected:
   const Tree& tree;
-  GeometryEvaluator *geomevaluator;
+  GeometryEvaluator* geomevaluator;
   std::shared_ptr<CSGNode> rootNode;
   std::vector<std::shared_ptr<CSGNode>> highlightNodes;
   std::vector<std::shared_ptr<CSGNode>> backgroundNodes;
-  std::map<int, std::shared_ptr<CSGNode>> stored_term; // The term evaluated from each node index
+  std::map<int, std::shared_ptr<CSGNode>>
+      stored_term;  // The term evaluated from each node index
 };
diff --git a/src/core/CgalAdvNode.cc b/src/core/CgalAdvNode.cc
index 9df2a48e3..21e3f0b21 100644
--- a/src/core/CgalAdvNode.cc
+++ b/src/core/CgalAdvNode.cc
@@ -25,67 +25,85 @@
  */
 
 #include "core/CgalAdvNode.h"
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
+#include <boost/assign/std/vector.hpp>
+#include <cassert>
+#include <memory>
+#include <sstream>
+#include <utility>
 #include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include <utility>
-#include <memory>
-#include <sstream>
-#include <cassert>
-#include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
+#include "core/module.h"
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_minkowski(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_minkowski(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::MINKOWSKI);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
   node->convexity = static_cast<int>(parameters["convexity"].toDouble());
 
   return children.instantiate(node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_hull(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_hull(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::HULL);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
   node->convexity = 0;
 
   return children.instantiate(node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_fill(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_fill(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::FILL);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
 
   return children.instantiate(node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_resize(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_resize(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::RESIZE);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"newsize", "auto", "convexity"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"newsize", "auto", "convexity"});
   node->convexity = static_cast<int>(parameters["convexity"].toDouble());
   node->newsize << 0, 0, 0;
   if (parameters["newsize"].type() == Value::Type::VECTOR) {
     const auto& vs = parameters["newsize"].toVector();
-    if (vs.size() >= 1) node->newsize[0] = vs[0].toDouble();
-    if (vs.size() >= 2) node->newsize[1] = vs[1].toDouble();
-    if (vs.size() >= 3) node->newsize[2] = vs[2].toDouble();
+    if (vs.size() >= 1)
+      node->newsize[0] = vs[0].toDouble();
+    if (vs.size() >= 2)
+      node->newsize[1] = vs[1].toDouble();
+    if (vs.size() >= 3)
+      node->newsize[2] = vs[2].toDouble();
   }
   const auto& autosize = parameters["auto"];
   node->autosize << false, false, false;
   if (autosize.type() == Value::Type::VECTOR) {
     const auto& va = autosize.toVector();
-    if (va.size() >= 1) node->autosize[0] = va[0].toBool();
-    if (va.size() >= 2) node->autosize[1] = va[1].toBool();
-    if (va.size() >= 3) node->autosize[2] = va[2].toBool();
+    if (va.size() >= 1)
+      node->autosize[0] = va[0].toBool();
+    if (va.size() >= 2)
+      node->autosize[1] = va[1].toBool();
+    if (va.size() >= 3)
+      node->autosize[2] = va[2].toBool();
   } else if (autosize.type() == Value::Type::BOOL) {
     node->autosize << autosize.toBool(), autosize.toBool(), autosize.toBool();
   }
@@ -93,77 +111,74 @@ static std::shared_ptr<AbstractNode> builtin_resize(const ModuleInstantiation *i
   return children.instantiate(node);
 }
 
-std::string CgalAdvNode::name() const
-{
+std::string CgalAdvNode::name() const {
   switch (this->type) {
-  case CgalAdvType::MINKOWSKI:
-    return "minkowski";
-    break;
-  case CgalAdvType::HULL:
-    return "hull";
-    break;
-  case CgalAdvType::FILL:
-    return "fill";
-    break;
-  case CgalAdvType::RESIZE:
-    return "resize";
-    break;
-  default:
-    assert(false);
+    case CgalAdvType::MINKOWSKI:
+      return "minkowski";
+      break;
+    case CgalAdvType::HULL:
+      return "hull";
+      break;
+    case CgalAdvType::FILL:
+      return "fill";
+      break;
+    case CgalAdvType::RESIZE:
+      return "resize";
+      break;
+    default:
+      assert(false);
   }
   return "internal_error";
 }
 
-std::string CgalAdvNode::toString() const
-{
+std::string CgalAdvNode::toString() const {
   std::ostringstream stream;
 
   stream << this->name();
   switch (type) {
-  case CgalAdvType::MINKOWSKI:
-    stream << "(convexity = " << this->convexity << ")";
-    break;
-  case CgalAdvType::HULL:
-  case CgalAdvType::FILL:
-    stream << "()";
-    break;
-  case CgalAdvType::RESIZE:
-    stream << "(newsize = ["
-           << this->newsize[0] << "," << this->newsize[1] << "," << this->newsize[2] << "]"
-           << ", auto = ["
-           << this->autosize[0] << "," << this->autosize[1] << "," << this->autosize[2] << "]"
-           << ", convexity = " << this->convexity
-           << ")";
-    break;
-  default:
-    assert(false);
+    case CgalAdvType::MINKOWSKI:
+      stream << "(convexity = " << this->convexity << ")";
+      break;
+    case CgalAdvType::HULL:
+    case CgalAdvType::FILL:
+      stream << "()";
+      break;
+    case CgalAdvType::RESIZE:
+      stream << "(newsize = [" << this->newsize[0] << "," << this->newsize[1]
+             << "," << this->newsize[2] << "]"
+             << ", auto = [" << this->autosize[0] << "," << this->autosize[1]
+             << "," << this->autosize[2] << "]"
+             << ", convexity = " << this->convexity << ")";
+      break;
+    default:
+      assert(false);
   }
 
   return stream.str();
 }
 
-void register_builtin_cgaladv()
-{
+void register_builtin_cgaladv() {
   Builtins::init("minkowski", new BuiltinModule(builtin_minkowski),
-  {
-    "minkowski(convexity = number)",
-  });
+                 {
+                     "minkowski(convexity = number)",
+                 });
 
   Builtins::init("hull", new BuiltinModule(builtin_hull),
-  {
-    "hull()",
-  });
+                 {
+                     "hull()",
+                 });
 
   Builtins::init("fill", new BuiltinModule(builtin_fill),
-  {
-    "fill()",
-  });
-
-  Builtins::init("resize", new BuiltinModule(builtin_resize),
-  {
-    "resize([x, y, z])",
-    "resize([x, y, z], boolean)",
-    "resize([x, y, z], [boolean, boolean, boolean])",
-    "resize([x, y, z], [boolean, boolean, boolean], convexity = number)",
-  });
+                 {
+                     "fill()",
+                 });
+
+  Builtins::init(
+      "resize", new BuiltinModule(builtin_resize),
+      {
+          "resize([x, y, z])",
+          "resize([x, y, z], boolean)",
+          "resize([x, y, z], [boolean, boolean, boolean])",
+          "resize([x, y, z], [boolean, boolean, boolean], convexity = number)",
+      });
 }
diff --git a/src/core/CgalAdvNode.h b/src/core/CgalAdvNode.h
index 32cd0f57e..5cb6e82a4 100644
--- a/src/core/CgalAdvNode.h
+++ b/src/core/CgalAdvNode.h
@@ -2,23 +2,17 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/linalg.h"
 
-enum class CgalAdvType {
-  MINKOWSKI,
-  HULL,
-  FILL,
-  RESIZE
-};
+enum class CgalAdvType { MINKOWSKI, HULL, FILL, RESIZE };
 
-class CgalAdvNode : public AbstractNode
-{
-public:
+class CgalAdvNode : public AbstractNode {
+ public:
   VISITABLE();
-  CgalAdvNode(const ModuleInstantiation *mi, CgalAdvType type) : AbstractNode(mi), type(type) {
-  }
+  CgalAdvNode(const ModuleInstantiation* mi, CgalAdvType type)
+      : AbstractNode(mi), type(type) {}
   std::string toString() const override;
   std::string name() const override;
 
diff --git a/src/core/Children.cc b/src/core/Children.cc
index b620dffc5..52ac251aa 100644
--- a/src/core/Children.cc
+++ b/src/core/Children.cc
@@ -26,23 +26,23 @@
 
 #include "core/Children.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <vector>
 
 #include "core/ScopeContext.h"
 
-std::shared_ptr<AbstractNode> Children::instantiate(const std::shared_ptr<AbstractNode>& target) const
-{
+std::shared_ptr<AbstractNode> Children::instantiate(
+    const std::shared_ptr<AbstractNode>& target) const {
   return children_scope->instantiateModules(*scopeContext(), target);
 }
 
-std::shared_ptr<AbstractNode> Children::instantiate(const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const
-{
+std::shared_ptr<AbstractNode> Children::instantiate(
+    const std::shared_ptr<AbstractNode>& target,
+    const std::vector<size_t>& indices) const {
   return children_scope->instantiateModules(*scopeContext(), target, indices);
 }
 
-ContextHandle<ScopeContext> Children::scopeContext() const
-{
+ContextHandle<ScopeContext> Children::scopeContext() const {
   return Context::create<ScopeContext>(context, children_scope);
 }
diff --git a/src/core/Children.h b/src/core/Children.h
index 99cb5d2ab..97d0ba4a6 100644
--- a/src/core/Children.h
+++ b/src/core/Children.h
@@ -1,8 +1,8 @@
 #pragma once
 
 #include <cstddef>
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 
 #include "core/Context.h"
@@ -11,13 +11,11 @@
 class AbstractNode;
 class ScopeContext;
 
-class Children
-{
-public:
-  Children(const LocalScope *children_scope, std::shared_ptr<const Context> context) :
-    children_scope(children_scope),
-    context(std::move(context))
-  {}
+class Children {
+ public:
+  Children(const LocalScope* children_scope,
+           std::shared_ptr<const Context> context)
+      : children_scope(children_scope), context(std::move(context)) {}
 
   Children(Children&& other) = default;
   Children& operator=(Children&& other) = default;
@@ -26,17 +24,25 @@ public:
   ~Children() = default;
 
   // NOLINTBEGIN(modernize-use-nodiscard)
-  // instantiate just returns a copy of target shared_ptr as a convenience, not crucial to use this value
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<AbstractNode>& target) const;
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const;
+  // instantiate just returns a copy of target shared_ptr as a convenience, not
+  // crucial to use this value
+  std::shared_ptr<AbstractNode> instantiate(
+      const std::shared_ptr<AbstractNode>& target) const;
+  std::shared_ptr<AbstractNode> instantiate(
+      const std::shared_ptr<AbstractNode>& target,
+      const std::vector<size_t>& indices) const;
   // NOLINTEND(modernize-use-nodiscard)
 
   [[nodiscard]] bool empty() const { return !children_scope->hasChildren(); }
-  [[nodiscard]] size_t size() const { return children_scope->moduleInstantiations.size(); }
-  [[nodiscard]] const std::shared_ptr<const Context>& getContext() const { return context; }
-
-private:
-  const LocalScope *children_scope;
+  [[nodiscard]] size_t size() const {
+    return children_scope->moduleInstantiations.size();
+  }
+  [[nodiscard]] const std::shared_ptr<const Context>& getContext() const {
+    return context;
+  }
+
+ private:
+  const LocalScope* children_scope;
   std::shared_ptr<const Context> context;
 
   [[nodiscard]] ContextHandle<ScopeContext> scopeContext() const;
diff --git a/src/core/ColorNode.cc b/src/core/ColorNode.cc
index 37b6c3ee1..00412f998 100644
--- a/src/core/ColorNode.cc
+++ b/src/core/ColorNode.cc
@@ -26,38 +26,44 @@
 
 #include "core/ColorNode.h"
 
-#include <utility>
-#include <memory>
+#include <boost/algorithm/string/case_conv.hpp>
+#include <boost/assign/list_of.hpp>
+#include <boost/assign/std/vector.hpp>
 #include <cctype>
 #include <cstddef>
+#include <memory>
 #include <string>
-#include <boost/algorithm/string/case_conv.hpp>
-#include <boost/assign/std/vector.hpp>
-#include <boost/assign/list_of.hpp>
+#include <utility>
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
-#include "core/Parameters.h"
 #include "core/ColorUtil.h"
+#include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/module.h"
 #include "geometry/linalg.h"
 #include "utils/printutils.h"
 
-using namespace boost::assign; // bring 'operator+=()' into scope
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_color(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_color(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<ColorNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"c", "alpha"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"c", "alpha"});
   if (parameters["c"].type() == Value::Type::VECTOR) {
     const auto& vec = parameters["c"].toVector();
     Vector4f color;
     for (size_t i = 0; i < 4; ++i) {
       color[i] = i < vec.size() ? (float)vec[i].toDouble() : 1.0f;
       if (color[i] > 1 || color[i] < 0) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "color() expects numbers between 0.0 and 1.0. Value of %1$.1f is out of range", color[i]);
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "color() expects numbers between 0.0 and 1.0. Value of %1$.1f is "
+            "out of range",
+            color[i]);
       }
     }
     node->color = color;
@@ -67,37 +73,39 @@ static std::shared_ptr<AbstractNode> builtin_color(const ModuleInstantiation *in
     if (parsed_color) {
       node->color = *parsed_color;
     } else {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to parse color \"%1$s\"", colorname);
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Unable to parse color \"%1$s\"", colorname);
       LOG("Please see https://en.wikipedia.org/wiki/Web_colors");
     }
   }
   if (parameters["alpha"].type() == Value::Type::NUMBER) {
     node->color.setAlpha(parameters["alpha"].toDouble());
     if (node->color.a() < 0.0f || node->color.a() > 1.0f) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "color() expects alpha between 0.0 and 1.0. Value of %1$.1f is out of range", node->color.a());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "color() expects alpha between 0.0 and 1.0. Value of %1$.1f is out "
+          "of range",
+          node->color.a());
     }
   }
 
   return children.instantiate(node);
 }
 
-std::string ColorNode::toString() const
-{
-  return STR("color([", this->color.r(), ", ", this->color.g(), ", ", this->color.b(), ", ", this->color.a(), "])");
+std::string ColorNode::toString() const {
+  return STR("color([", this->color.r(), ", ", this->color.g(), ", ",
+             this->color.b(), ", ", this->color.a(), "])");
 }
 
-std::string ColorNode::name() const
-{
+std::string ColorNode::name() const {
   return "color";
 }
 
-void register_builtin_color()
-{
+void register_builtin_color() {
   Builtins::init("color", new BuiltinModule(builtin_color),
-  {
-    "color(c = [r, g, b, a])",
-    "color(c = [r, g, b], alpha = 1.0)",
-    "color(\"#hexvalue\")",
-    "color(\"colorname\", 1.0)",
-  });
+                 {
+                     "color(c = [r, g, b, a])",
+                     "color(c = [r, g, b], alpha = 1.0)",
+                     "color(\"#hexvalue\")",
+                     "color(\"colorname\", 1.0)",
+                 });
 }
diff --git a/src/core/ColorNode.h b/src/core/ColorNode.h
index 002767312..2aa5966ce 100644
--- a/src/core/ColorNode.h
+++ b/src/core/ColorNode.h
@@ -3,15 +3,14 @@
 #include <string>
 
 #include "core/BaseVisitable.h"
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/linalg.h"
 
-class ColorNode : public AbstractNode
-{
-public:
+class ColorNode : public AbstractNode {
+ public:
   VISITABLE();
-  ColorNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  ColorNode(const ModuleInstantiation* mi) : AbstractNode(mi) {}
   std::string toString() const override;
   std::string name() const override;
 
diff --git a/src/core/ColorUtil.cc b/src/core/ColorUtil.cc
index 6bfd8fa42..dda782204 100644
--- a/src/core/ColorUtil.cc
+++ b/src/core/ColorUtil.cc
@@ -1,173 +1,170 @@
+#include "core/ColorUtil.h"
+#include <boost/algorithm/string/case_conv.hpp>
 #include <boost/spirit/home/support/common_terminals.hpp>
 #include <string>
 #include <unordered_map>
 #include "geometry/linalg.h"
-#include "core/ColorUtil.h"
 #include "utils/printutils.h"
-#include <boost/algorithm/string/case_conv.hpp>
 
 namespace {
 
 // Colors extracted from https://drafts.csswg.org/css-color/ on 2015-08-02
 // CSS Color Module Level 4 - Editors Draft, 29 May 2015
 std::unordered_map<std::string, Color4f> webcolors{
-  {"aliceblue", {240, 248, 255}},
-  {"antiquewhite", {250, 235, 215}},
-  {"aqua", {0, 255, 255}},
-  {"aquamarine", {127, 255, 212}},
-  {"azure", {240, 255, 255}},
-  {"beige", {245, 245, 220}},
-  {"bisque", {255, 228, 196}},
-  {"black", {0, 0, 0}},
-  {"blanchedalmond", {255, 235, 205}},
-  {"blue", {0, 0, 255}},
-  {"blueviolet", {138, 43, 226}},
-  {"brown", {165, 42, 42}},
-  {"burlywood", {222, 184, 135}},
-  {"cadetblue", {95, 158, 160}},
-  {"chartreuse", {127, 255, 0}},
-  {"chocolate", {210, 105, 30}},
-  {"coral", {255, 127, 80}},
-  {"cornflowerblue", {100, 149, 237}},
-  {"cornsilk", {255, 248, 220}},
-  {"crimson", {220, 20, 60}},
-  {"cyan", {0, 255, 255}},
-  {"darkblue", {0, 0, 139}},
-  {"darkcyan", {0, 139, 139}},
-  {"darkgoldenrod", {184, 134, 11}},
-  {"darkgray", {169, 169, 169}},
-  {"darkgreen", {0, 100, 0}},
-  {"darkgrey", {169, 169, 169}},
-  {"darkkhaki", {189, 183, 107}},
-  {"darkmagenta", {139, 0, 139}},
-  {"darkolivegreen", {85, 107, 47}},
-  {"darkorange", {255, 140, 0}},
-  {"darkorchid", {153, 50, 204}},
-  {"darkred", {139, 0, 0}},
-  {"darksalmon", {233, 150, 122}},
-  {"darkseagreen", {143, 188, 143}},
-  {"darkslateblue", {72, 61, 139}},
-  {"darkslategray", {47, 79, 79}},
-  {"darkslategrey", {47, 79, 79}},
-  {"darkturquoise", {0, 206, 209}},
-  {"darkviolet", {148, 0, 211}},
-  {"deeppink", {255, 20, 147}},
-  {"deepskyblue", {0, 191, 255}},
-  {"dimgray", {105, 105, 105}},
-  {"dimgrey", {105, 105, 105}},
-  {"dodgerblue", {30, 144, 255}},
-  {"firebrick", {178, 34, 34}},
-  {"floralwhite", {255, 250, 240}},
-  {"forestgreen", {34, 139, 34}},
-  {"fuchsia", {255, 0, 255}},
-  {"gainsboro", {220, 220, 220}},
-  {"ghostwhite", {248, 248, 255}},
-  {"gold", {255, 215, 0}},
-  {"goldenrod", {218, 165, 32}},
-  {"gray", {128, 128, 128}},
-  {"green", {0, 128, 0}},
-  {"greenyellow", {173, 255, 47}},
-  {"grey", {128, 128, 128}},
-  {"honeydew", {240, 255, 240}},
-  {"hotpink", {255, 105, 180}},
-  {"indianred", {205, 92, 92}},
-  {"indigo", {75, 0, 130}},
-  {"ivory", {255, 255, 240}},
-  {"khaki", {240, 230, 140}},
-  {"lavender", {230, 230, 250}},
-  {"lavenderblush", {255, 240, 245}},
-  {"lawngreen", {124, 252, 0}},
-  {"lemonchiffon", {255, 250, 205}},
-  {"lightblue", {173, 216, 230}},
-  {"lightcoral", {240, 128, 128}},
-  {"lightcyan", {224, 255, 255}},
-  {"lightgoldenrodyellow", {250, 250, 210}},
-  {"lightgray", {211, 211, 211}},
-  {"lightgreen", {144, 238, 144}},
-  {"lightgrey", {211, 211, 211}},
-  {"lightpink", {255, 182, 193}},
-  {"lightsalmon", {255, 160, 122}},
-  {"lightseagreen", {32, 178, 170}},
-  {"lightskyblue", {135, 206, 250}},
-  {"lightslategray", {119, 136, 153}},
-  {"lightslategrey", {119, 136, 153}},
-  {"lightsteelblue", {176, 196, 222}},
-  {"lightyellow", {255, 255, 224}},
-  {"lime", {0, 255, 0}},
-  {"limegreen", {50, 205, 50}},
-  {"linen", {250, 240, 230}},
-  {"magenta", {255, 0, 255}},
-  {"maroon", {128, 0, 0}},
-  {"mediumaquamarine", {102, 205, 170}},
-  {"mediumblue", {0, 0, 205}},
-  {"mediumorchid", {186, 85, 211}},
-  {"mediumpurple", {147, 112, 219}},
-  {"mediumseagreen", {60, 179, 113}},
-  {"mediumslateblue", {123, 104, 238}},
-  {"mediumspringgreen", {0, 250, 154}},
-  {"mediumturquoise", {72, 209, 204}},
-  {"mediumvioletred", {199, 21, 133}},
-  {"midnightblue", {25, 25, 112}},
-  {"mintcream", {245, 255, 250}},
-  {"mistyrose", {255, 228, 225}},
-  {"moccasin", {255, 228, 181}},
-  {"navajowhite", {255, 222, 173}},
-  {"navy", {0, 0, 128}},
-  {"oldlace", {253, 245, 230}},
-  {"olive", {128, 128, 0}},
-  {"olivedrab", {107, 142, 35}},
-  {"orange", {255, 165, 0}},
-  {"orangered", {255, 69, 0}},
-  {"orchid", {218, 112, 214}},
-  {"palegoldenrod", {238, 232, 170}},
-  {"palegreen", {152, 251, 152}},
-  {"paleturquoise", {175, 238, 238}},
-  {"palevioletred", {219, 112, 147}},
-  {"papayawhip", {255, 239, 213}},
-  {"peachpuff", {255, 218, 185}},
-  {"peru", {205, 133, 63}},
-  {"pink", {255, 192, 203}},
-  {"plum", {221, 160, 221}},
-  {"powderblue", {176, 224, 230}},
-  {"purple", {128, 0, 128}},
-  {"rebeccapurple", {102, 51, 153}},
-  {"red", {255, 0, 0}},
-  {"rosybrown", {188, 143, 143}},
-  {"royalblue", {65, 105, 225}},
-  {"saddlebrown", {139, 69, 19}},
-  {"salmon", {250, 128, 114}},
-  {"sandybrown", {244, 164, 96}},
-  {"seagreen", {46, 139, 87}},
-  {"seashell", {255, 245, 238}},
-  {"sienna", {160, 82, 45}},
-  {"silver", {192, 192, 192}},
-  {"skyblue", {135, 206, 235}},
-  {"slateblue", {106, 90, 205}},
-  {"slategray", {112, 128, 144}},
-  {"slategrey", {112, 128, 144}},
-  {"snow", {255, 250, 250}},
-  {"springgreen", {0, 255, 127}},
-  {"steelblue", {70, 130, 180}},
-  {"tan", {210, 180, 140}},
-  {"teal", {0, 128, 128}},
-  {"thistle", {216, 191, 216}},
-  {"tomato", {255, 99, 71}},
-  {"turquoise", {64, 224, 208}},
-  {"violet", {238, 130, 238}},
-  {"wheat", {245, 222, 179}},
-  {"white", {255, 255, 255}},
-  {"whitesmoke", {245, 245, 245}},
-  {"yellow", {255, 255, 0}},
-  {"yellowgreen", {154, 205, 50}},
-
-  // additional OpenSCAD specific entry
-  {"transparent", {0, 0, 0, 0}}
-};
+    {"aliceblue", {240, 248, 255}},
+    {"antiquewhite", {250, 235, 215}},
+    {"aqua", {0, 255, 255}},
+    {"aquamarine", {127, 255, 212}},
+    {"azure", {240, 255, 255}},
+    {"beige", {245, 245, 220}},
+    {"bisque", {255, 228, 196}},
+    {"black", {0, 0, 0}},
+    {"blanchedalmond", {255, 235, 205}},
+    {"blue", {0, 0, 255}},
+    {"blueviolet", {138, 43, 226}},
+    {"brown", {165, 42, 42}},
+    {"burlywood", {222, 184, 135}},
+    {"cadetblue", {95, 158, 160}},
+    {"chartreuse", {127, 255, 0}},
+    {"chocolate", {210, 105, 30}},
+    {"coral", {255, 127, 80}},
+    {"cornflowerblue", {100, 149, 237}},
+    {"cornsilk", {255, 248, 220}},
+    {"crimson", {220, 20, 60}},
+    {"cyan", {0, 255, 255}},
+    {"darkblue", {0, 0, 139}},
+    {"darkcyan", {0, 139, 139}},
+    {"darkgoldenrod", {184, 134, 11}},
+    {"darkgray", {169, 169, 169}},
+    {"darkgreen", {0, 100, 0}},
+    {"darkgrey", {169, 169, 169}},
+    {"darkkhaki", {189, 183, 107}},
+    {"darkmagenta", {139, 0, 139}},
+    {"darkolivegreen", {85, 107, 47}},
+    {"darkorange", {255, 140, 0}},
+    {"darkorchid", {153, 50, 204}},
+    {"darkred", {139, 0, 0}},
+    {"darksalmon", {233, 150, 122}},
+    {"darkseagreen", {143, 188, 143}},
+    {"darkslateblue", {72, 61, 139}},
+    {"darkslategray", {47, 79, 79}},
+    {"darkslategrey", {47, 79, 79}},
+    {"darkturquoise", {0, 206, 209}},
+    {"darkviolet", {148, 0, 211}},
+    {"deeppink", {255, 20, 147}},
+    {"deepskyblue", {0, 191, 255}},
+    {"dimgray", {105, 105, 105}},
+    {"dimgrey", {105, 105, 105}},
+    {"dodgerblue", {30, 144, 255}},
+    {"firebrick", {178, 34, 34}},
+    {"floralwhite", {255, 250, 240}},
+    {"forestgreen", {34, 139, 34}},
+    {"fuchsia", {255, 0, 255}},
+    {"gainsboro", {220, 220, 220}},
+    {"ghostwhite", {248, 248, 255}},
+    {"gold", {255, 215, 0}},
+    {"goldenrod", {218, 165, 32}},
+    {"gray", {128, 128, 128}},
+    {"green", {0, 128, 0}},
+    {"greenyellow", {173, 255, 47}},
+    {"grey", {128, 128, 128}},
+    {"honeydew", {240, 255, 240}},
+    {"hotpink", {255, 105, 180}},
+    {"indianred", {205, 92, 92}},
+    {"indigo", {75, 0, 130}},
+    {"ivory", {255, 255, 240}},
+    {"khaki", {240, 230, 140}},
+    {"lavender", {230, 230, 250}},
+    {"lavenderblush", {255, 240, 245}},
+    {"lawngreen", {124, 252, 0}},
+    {"lemonchiffon", {255, 250, 205}},
+    {"lightblue", {173, 216, 230}},
+    {"lightcoral", {240, 128, 128}},
+    {"lightcyan", {224, 255, 255}},
+    {"lightgoldenrodyellow", {250, 250, 210}},
+    {"lightgray", {211, 211, 211}},
+    {"lightgreen", {144, 238, 144}},
+    {"lightgrey", {211, 211, 211}},
+    {"lightpink", {255, 182, 193}},
+    {"lightsalmon", {255, 160, 122}},
+    {"lightseagreen", {32, 178, 170}},
+    {"lightskyblue", {135, 206, 250}},
+    {"lightslategray", {119, 136, 153}},
+    {"lightslategrey", {119, 136, 153}},
+    {"lightsteelblue", {176, 196, 222}},
+    {"lightyellow", {255, 255, 224}},
+    {"lime", {0, 255, 0}},
+    {"limegreen", {50, 205, 50}},
+    {"linen", {250, 240, 230}},
+    {"magenta", {255, 0, 255}},
+    {"maroon", {128, 0, 0}},
+    {"mediumaquamarine", {102, 205, 170}},
+    {"mediumblue", {0, 0, 205}},
+    {"mediumorchid", {186, 85, 211}},
+    {"mediumpurple", {147, 112, 219}},
+    {"mediumseagreen", {60, 179, 113}},
+    {"mediumslateblue", {123, 104, 238}},
+    {"mediumspringgreen", {0, 250, 154}},
+    {"mediumturquoise", {72, 209, 204}},
+    {"mediumvioletred", {199, 21, 133}},
+    {"midnightblue", {25, 25, 112}},
+    {"mintcream", {245, 255, 250}},
+    {"mistyrose", {255, 228, 225}},
+    {"moccasin", {255, 228, 181}},
+    {"navajowhite", {255, 222, 173}},
+    {"navy", {0, 0, 128}},
+    {"oldlace", {253, 245, 230}},
+    {"olive", {128, 128, 0}},
+    {"olivedrab", {107, 142, 35}},
+    {"orange", {255, 165, 0}},
+    {"orangered", {255, 69, 0}},
+    {"orchid", {218, 112, 214}},
+    {"palegoldenrod", {238, 232, 170}},
+    {"palegreen", {152, 251, 152}},
+    {"paleturquoise", {175, 238, 238}},
+    {"palevioletred", {219, 112, 147}},
+    {"papayawhip", {255, 239, 213}},
+    {"peachpuff", {255, 218, 185}},
+    {"peru", {205, 133, 63}},
+    {"pink", {255, 192, 203}},
+    {"plum", {221, 160, 221}},
+    {"powderblue", {176, 224, 230}},
+    {"purple", {128, 0, 128}},
+    {"rebeccapurple", {102, 51, 153}},
+    {"red", {255, 0, 0}},
+    {"rosybrown", {188, 143, 143}},
+    {"royalblue", {65, 105, 225}},
+    {"saddlebrown", {139, 69, 19}},
+    {"salmon", {250, 128, 114}},
+    {"sandybrown", {244, 164, 96}},
+    {"seagreen", {46, 139, 87}},
+    {"seashell", {255, 245, 238}},
+    {"sienna", {160, 82, 45}},
+    {"silver", {192, 192, 192}},
+    {"skyblue", {135, 206, 235}},
+    {"slateblue", {106, 90, 205}},
+    {"slategray", {112, 128, 144}},
+    {"slategrey", {112, 128, 144}},
+    {"snow", {255, 250, 250}},
+    {"springgreen", {0, 255, 127}},
+    {"steelblue", {70, 130, 180}},
+    {"tan", {210, 180, 140}},
+    {"teal", {0, 128, 128}},
+    {"thistle", {216, 191, 216}},
+    {"tomato", {255, 99, 71}},
+    {"turquoise", {64, 224, 208}},
+    {"violet", {238, 130, 238}},
+    {"wheat", {245, 222, 179}},
+    {"white", {255, 255, 255}},
+    {"whitesmoke", {245, 245, 245}},
+    {"yellow", {255, 255, 0}},
+    {"yellowgreen", {154, 205, 50}},
 
+    // additional OpenSCAD specific entry
+    {"transparent", {0, 0, 0, 0}}};
 
 // See http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
-void rgbtohsv(float r, float g, float b, float& h, float& s, float& v)
-{
+void rgbtohsv(float r, float g, float b, float& h, float& s, float& v) {
   float K = 0.f;
 
   if (g < b) {
@@ -186,25 +183,27 @@ void rgbtohsv(float r, float g, float b, float& h, float& s, float& v)
   v = r;
 }
 
-// Parses hex colors according to: https://drafts.csswg.org/css-color/#typedef-hex-color.
-// If the input is invalid, returns boost::none.
-// Supports the following formats:
+// Parses hex colors according to:
+// https://drafts.csswg.org/css-color/#typedef-hex-color. If the input is
+// invalid, returns boost::none. Supports the following formats:
 // * "#rrggbb"
 // * "#rrggbbaa"
 // * "#rgb"
 // * "#rgba"
 std::optional<Color4f> parse_hex_color(const std::string& hex) {
-  // validate size. short syntax uses one hex digit per color channel instead of 2.
+  // validate size. short syntax uses one hex digit per color channel instead
+  // of 2.
   const bool short_syntax = hex.size() == 4 || hex.size() == 5;
   const bool long_syntax = hex.size() == 7 || hex.size() == 9;
-  if (!short_syntax && !long_syntax) return {};
+  if (!short_syntax && !long_syntax)
+    return {};
 
   // validate
-  if (hex[0] != '#') return {};
-  if (!std::all_of(std::begin(hex) + 1, std::end(hex),
-                   [](char c) {
-      return std::isxdigit(static_cast<unsigned char>(c));
-    })) {
+  if (hex[0] != '#')
+    return {};
+  if (!std::all_of(std::begin(hex) + 1, std::end(hex), [](char c) {
+        return std::isxdigit(static_cast<unsigned char>(c));
+      })) {
     return {};
   }
 
@@ -213,7 +212,7 @@ std::optional<Color4f> parse_hex_color(const std::string& hex) {
   const float channel_max = short_syntax ? 15.0f : 255.0f;
 
   Vector4f rgba;
-  rgba[3] = 1.0; // default alpha to 100%
+  rgba[3] = 1.0;  // default alpha to 100%
 
   for (unsigned i = 0; i < (hex.size() - 1) / stride; ++i) {
     const std::string chunk = hex.substr(1 + i * stride, stride);
@@ -233,7 +232,7 @@ std::optional<Color4f> parse_web_color(const std::string& col) {
   return {};
 }
 
-} // namespace
+}  // namespace
 
 namespace OpenSCAD {
 
@@ -251,20 +250,19 @@ std::optional<Color4f> parse_color(const std::string& col) {
   return {};
 }
 
-Color4f getColor(const std::string& col, const Color4f& defaultcolor)
-{
+Color4f getColor(const std::string& col, const Color4f& defaultcolor) {
   const auto parsed = parse_color(col);
 
   if (!parsed) {
-    LOG(message_group::Warning, "Unable to parse color \"%1$s\", reverting to default color.", col);
+    LOG(message_group::Warning,
+        "Unable to parse color \"%1$s\", reverting to default color.", col);
     LOG("Please see https://en.wikipedia.org/wiki/Web_colors");
   }
 
   return parsed.value_or(defaultcolor);
 }
 
-Vector4f getColorHSV(const Color4f& col)
-{
+Vector4f getColorHSV(const Color4f& col) {
   float h, s, v;
   ::rgbtohsv(col.r(), col.g(), col.b(), h, s, v);
   return {h, s, v, col.a()};
@@ -277,8 +275,7 @@ Vector4f getColorHSV(const Color4f& col)
  * @param col the input color
  * @return a color with high contrast to the input color
  */
-Color4f getContrastColor(const Color4f& col)
-{
+Color4f getContrastColor(const Color4f& col) {
   const auto hsv = getColorHSV(col);
   float Y = 0.2126f * col.r() + 0.7152f * col.g() + 0.0722f * col.b();
   float S = hsv[1];
@@ -290,13 +287,13 @@ Color4f getContrastColor(const Color4f& col)
   } else {
     float H = 360 * hsv[0];
     if ((H < 60) || (H > 300)) {
-      return {0.0f, 1.0f, 1.0f, 1.0f}; // red -> cyan
+      return {0.0f, 1.0f, 1.0f, 1.0f};  // red -> cyan
     } else if (H < 180) {
-      return {1.0f, 0.0f, 1.0f, 1.0f}; // green -> magenta
+      return {1.0f, 0.0f, 1.0f, 1.0f};  // green -> magenta
     } else {
-      return {1.0f, 1.0f, 0.0f, 1.0f}; // blue -> yellow
+      return {1.0f, 1.0f, 0.0f, 1.0f};  // blue -> yellow
     }
   }
 }
 
-} // namespace OpenSCAD
+}  // namespace OpenSCAD
diff --git a/src/core/ColorUtil.h b/src/core/ColorUtil.h
index f2402bfff..4ac0a094c 100644
--- a/src/core/ColorUtil.h
+++ b/src/core/ColorUtil.h
@@ -1,13 +1,13 @@
 #pragma once
 
-#include <string>
 #include <optional>
+#include <string>
 
 #include "geometry/linalg.h"
 
 namespace OpenSCAD {
 
-inline Color4f CORNFIELD_FACE_COLOR{ 0xf9, 0xd7, 0x2c, 0xff };
+inline Color4f CORNFIELD_FACE_COLOR{0xf9, 0xd7, 0x2c, 0xff};
 
 std::optional<Color4f> parse_color(const std::string& col);
 
@@ -17,4 +17,4 @@ Color4f getContrastColor(const Color4f& col);
 
 Vector4f getColorHSV(const Color4f& col);
 
-} // namespace OpenSCAD
+}  // namespace OpenSCAD
diff --git a/src/core/Context.cc b/src/core/Context.cc
index 8b039ea01..6601b278b 100644
--- a/src/core/Context.cc
+++ b/src/core/Context.cc
@@ -26,35 +26,30 @@
 
 #include "core/Context.h"
 
-#include <utility>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include "core/AST.h"
 #include "core/function.h"
 #include "utils/printutils.h"
 
-Context::Context(EvaluationSession *session) :
-  ContextFrame(session),
-  parent(nullptr)
-{}
+Context::Context(EvaluationSession* session)
+    : ContextFrame(session), parent(nullptr) {}
 
-Context::Context(const std::shared_ptr<const Context>& parent) :
-  ContextFrame(parent->evaluation_session),
-  parent(parent)
-{}
+Context::Context(const std::shared_ptr<const Context>& parent)
+    : ContextFrame(parent->evaluation_session), parent(parent) {}
 
-Context::~Context()
-{
+Context::~Context() {
   Context::clear();
-  if (accountingAdded)   // avoiding bad accounting where exception threw in constructor issue #3871
+  if (accountingAdded)  // avoiding bad accounting where exception threw in
+                        // constructor issue #3871
     session()->contextMemoryManager().releaseContext();
 }
 
-const Children *Context::user_module_children() const
-{
+const Children* Context::user_module_children() const {
   if (parent) {
     return parent->user_module_children();
   } else {
@@ -62,21 +57,22 @@ const Children *Context::user_module_children() const
   }
 }
 
-std::vector<const std::shared_ptr<const Context> *> Context::list_referenced_contexts() const
-{
-  std::vector<const std::shared_ptr<const Context> *> output;
+std::vector<const std::shared_ptr<const Context>*>
+Context::list_referenced_contexts() const {
+  std::vector<const std::shared_ptr<const Context>*> output;
   if (parent) {
     output.push_back(&parent);
   }
   return output;
 }
 
-boost::optional<const Value&> Context::try_lookup_variable(const std::string& name) const
-{
+boost::optional<const Value&> Context::try_lookup_variable(
+    const std::string& name) const {
   if (is_config_variable(name)) {
     return session()->try_lookup_special_variable(name);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
+  for (const Context* context = this; context != nullptr;
+       context = context->getParent().get()) {
     boost::optional<const Value&> result = context->lookup_local_variable(name);
     if (result) {
       return result;
@@ -85,48 +81,56 @@ boost::optional<const Value&> Context::try_lookup_variable(const std::string& na
   return boost::none;
 }
 
-const Value& Context::lookup_variable(const std::string& name, const Location& loc) const
-{
+const Value& Context::lookup_variable(const std::string& name,
+                                      const Location& loc) const {
   boost::optional<const Value&> result = try_lookup_variable(name);
   if (!result) {
-    LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown variable %1$s", quoteVar(name));
+    LOG(message_group::Warning, loc, documentRoot(),
+        "Ignoring unknown variable %1$s", quoteVar(name));
     return Value::undefined;
   }
   return *result;
 }
 
-boost::optional<CallableFunction> Context::lookup_function(const std::string& name, const Location& loc) const
-{
+boost::optional<CallableFunction> Context::lookup_function(
+    const std::string& name,
+    const Location& loc) const {
   if (is_config_variable(name)) {
     return session()->lookup_special_function(name, loc);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
-    boost::optional<CallableFunction> result = context->lookup_local_function(name, loc);
+  for (const Context* context = this; context != nullptr;
+       context = context->getParent().get()) {
+    boost::optional<CallableFunction> result =
+        context->lookup_local_function(name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown function '%1$s'", name);
+  LOG(message_group::Warning, loc, documentRoot(),
+      "Ignoring unknown function '%1$s'", name);
   return boost::none;
 }
 
-boost::optional<InstantiableModule> Context::lookup_module(const std::string& name, const Location& loc) const
-{
+boost::optional<InstantiableModule> Context::lookup_module(
+    const std::string& name,
+    const Location& loc) const {
   if (is_config_variable(name)) {
     return session()->lookup_special_module(name, loc);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
-    boost::optional<InstantiableModule> result = context->lookup_local_module(name, loc);
+  for (const Context* context = this; context != nullptr;
+       context = context->getParent().get()) {
+    boost::optional<InstantiableModule> result =
+        context->lookup_local_module(name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, this->documentRoot(), "Ignoring unknown module '%1$s'", name);
+  LOG(message_group::Warning, loc, this->documentRoot(),
+      "Ignoring unknown module '%1$s'", name);
   return boost::none;
 }
 
-bool Context::set_variable(const std::string& name, Value&& value)
-{
+bool Context::set_variable(const std::string& name, Value&& value) {
   bool new_variable = ContextFrame::set_variable(name, std::move(value));
   if (new_variable) {
     session()->accounting().addContextVariable();
@@ -134,23 +138,21 @@ bool Context::set_variable(const std::string& name, Value&& value)
   return new_variable;
 }
 
-size_t Context::clear()
-{
+size_t Context::clear() {
   size_t removed = ContextFrame::clear();
   session()->accounting().removeContextVariable(removed);
   return removed;
 }
 
 #ifdef DEBUG
-std::string Context::dump() const
-{
+std::string Context::dump() const {
   std::ostringstream s;
   s << boost::format("Context %p:\n") % this;
-  Context const *context = this;
+  Context const* context = this;
   while (context) {
     s << "  " << context->dumpFrame();
     context = context->getParent().get();
   }
   return s.str();
 }
-#endif // ifdef DEBUG
+#endif  // ifdef DEBUG
diff --git a/src/core/Context.h b/src/core/Context.h
index e09bf768f..a923ce0b8 100644
--- a/src/core/Context.h
+++ b/src/core/Context.h
@@ -1,13 +1,13 @@
 #pragma once
 
 #include <cassert>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
 #include <vector>
 
-#include "core/ContextFrame.h"
 #include "core/AST.h"
+#include "core/ContextFrame.h"
 #include "core/ContextMemoryManager.h"
 
 /**
@@ -16,13 +16,10 @@
  * The Context objects can hang around for longer, e.g. in case of closures.
  */
 template <typename T>
-class ContextHandle : ContextFrameHandle
-{
-public:
-  ContextHandle(std::shared_ptr<T>&& context) :
-    ContextFrameHandle(context.get()),
-    context(std::move(context))
-  {
+class ContextHandle : ContextFrameHandle {
+ public:
+  ContextHandle(std::shared_ptr<T>&& context)
+      : ContextFrameHandle(context.get()), context(std::move(context)) {
     try {
       this->context->init();
     } catch (...) {
@@ -31,8 +28,7 @@ public:
     }
   }
 
-  ~ContextHandle()
-  {
+  ~ContextHandle() {
     assert(!!session == !!context);
     if (session) {
       session->contextMemoryManager().addContext(std::move(this->context));
@@ -50,7 +46,7 @@ public:
     assert(other.context);
     assert(other.session);
 
-    //session->contextMemoryManager().releaseContext();
+    // session->contextMemoryManager().releaseContext();
     session->contextMemoryManager().addContext(std::move(this->context));
     other.release();
     context = std::move(other.context);
@@ -58,53 +54,66 @@ public:
     return *this;
   }
 
-  const T *operator->() const { return context.get(); }
-  T *operator->() { return context.get(); }
+  const T* operator->() const { return context.get(); }
+  T* operator->() { return context.get(); }
   std::shared_ptr<const T> operator*() const { return context; }
 
-private:
+ private:
   std::shared_ptr<T> context;
 };
 
-class Context : public ContextFrame, public std::enable_shared_from_this<Context>
-{
-protected:
-  Context(EvaluationSession *session);
+class Context : public ContextFrame,
+                public std::enable_shared_from_this<Context> {
+ protected:
+  Context(EvaluationSession* session);
   Context(const std::shared_ptr<const Context>& parent);
 
-public:
+ public:
   ~Context() override;
 
-  template <typename C, typename ... T>
-  static ContextHandle<C> create(T&& ... t) {
+  template <typename C, typename... T>
+  static ContextHandle<C> create(T&&... t) {
     return ContextHandle<C>{std::shared_ptr<C>(new C(std::forward<T>(t)...))};
   }
 
-  virtual void init() { }
+  virtual void init() {}
 
-  std::shared_ptr<const Context> get_shared_ptr() const { return shared_from_this(); }
-  virtual const class Children *user_module_children() const;
-  virtual std::vector<const std::shared_ptr<const Context> *> list_referenced_contexts() const;
-
-  boost::optional<const Value&> try_lookup_variable(const std::string& name) const;
-  const Value& lookup_variable(const std::string& name, const Location& loc) const;
-  boost::optional<CallableFunction> lookup_function(const std::string& name, const Location& loc) const;
-  boost::optional<InstantiableModule> lookup_module(const std::string& name, const Location& loc) const;
+  std::shared_ptr<const Context> get_shared_ptr() const {
+    return shared_from_this();
+  }
+  virtual const class Children* user_module_children() const;
+  virtual std::vector<const std::shared_ptr<const Context>*>
+  list_referenced_contexts() const;
+
+  boost::optional<const Value&> try_lookup_variable(
+      const std::string& name) const;
+  const Value& lookup_variable(const std::string& name,
+                               const Location& loc) const;
+  boost::optional<CallableFunction> lookup_function(const std::string& name,
+                                                    const Location& loc) const;
+  boost::optional<InstantiableModule> lookup_module(const std::string& name,
+                                                    const Location& loc) const;
   bool set_variable(const std::string& name, Value&& value) override;
   size_t clear() override;
 
-  const std::shared_ptr<const Context>& getParent() const { return this->parent; }
-  // This modifies the semantics of the context in an error-prone way. Use with caution.
-  void setParent(const std::shared_ptr<const Context>& parent) { this->parent = parent; }
+  const std::shared_ptr<const Context>& getParent() const {
+    return this->parent;
+  }
+  // This modifies the semantics of the context in an error-prone way. Use with
+  // caution.
+  void setParent(const std::shared_ptr<const Context>& parent) {
+    this->parent = parent;
+  }
 
   void setAccountingAdded() { accountingAdded = true; }
 
-protected:
+ protected:
   std::shared_ptr<const Context> parent;
 
-  bool accountingAdded = false;   // avoiding bad accounting when exception threw in constructor issue #3871
+  bool accountingAdded = false;  // avoiding bad accounting when exception threw
+                                 // in constructor issue #3871
 
-public:
+ public:
 #ifdef DEBUG
   std::string dump() const;
 #endif
diff --git a/src/core/ContextFrame.cc b/src/core/ContextFrame.cc
index 238c40b01..1d3bd7513 100644
--- a/src/core/ContextFrame.cc
+++ b/src/core/ContextFrame.cc
@@ -24,21 +24,19 @@
  *
  */
 
-#include "core/AST.h"
 #include "core/ContextFrame.h"
+#include "core/AST.h"
 
-#include <utility>
 #include <cstddef>
 #include <string>
+#include <utility>
 #include <vector>
 
+ContextFrame::ContextFrame(EvaluationSession* session)
+    : evaluation_session(session) {}
 
-ContextFrame::ContextFrame(EvaluationSession *session) :
-  evaluation_session(session)
-{}
-
-boost::optional<const Value&> ContextFrame::lookup_local_variable(const std::string& name) const
-{
+boost::optional<const Value&> ContextFrame::lookup_local_variable(
+    const std::string& name) const {
   if (is_config_variable(name)) {
     auto result = config_variables.find(name);
     if (result != config_variables.end()) {
@@ -53,8 +51,9 @@ boost::optional<const Value&> ContextFrame::lookup_local_variable(const std::str
   return boost::none;
 }
 
-boost::optional<CallableFunction> ContextFrame::lookup_local_function(const std::string& name, const Location& /*loc*/) const
-{
+boost::optional<CallableFunction> ContextFrame::lookup_local_function(
+    const std::string& name,
+    const Location& /*loc*/) const {
   boost::optional<const Value&> value = lookup_local_variable(name);
   if (value && value->type() == Value::Type::FUNCTION) {
     return CallableFunction{&*value};
@@ -62,14 +61,14 @@ boost::optional<CallableFunction> ContextFrame::lookup_local_function(const std:
   return boost::none;
 }
 
-boost::optional<InstantiableModule> ContextFrame::lookup_local_module(const std::string& /*name*/, const Location& /*loc*/) const
-{
+boost::optional<InstantiableModule> ContextFrame::lookup_local_module(
+    const std::string& /*name*/,
+    const Location& /*loc*/) const {
   return boost::none;
 }
 
-std::vector<const Value *> ContextFrame::list_embedded_values() const
-{
-  std::vector<const Value *> output;
+std::vector<const Value*> ContextFrame::list_embedded_values() const {
+  std::vector<const Value*> output;
   for (const auto& variable : lexical_variables) {
     output.push_back(&variable.second);
   }
@@ -79,16 +78,14 @@ std::vector<const Value *> ContextFrame::list_embedded_values() const
   return output;
 }
 
-size_t ContextFrame::clear()
-{
+size_t ContextFrame::clear() {
   size_t removed = lexical_variables.size() + config_variables.size();
   lexical_variables.clear();
   config_variables.clear();
   return removed;
 }
 
-bool ContextFrame::set_variable(const std::string& name, Value&& value)
-{
+bool ContextFrame::set_variable(const std::string& name, Value&& value) {
   if (is_config_variable(name)) {
     return config_variables.insert_or_assign(name, std::move(value)).second;
   } else {
@@ -96,55 +93,46 @@ bool ContextFrame::set_variable(const std::string& name, Value&& value)
   }
 }
 
-void ContextFrame::apply_variables(const ValueMap& variables)
-{
+void ContextFrame::apply_variables(const ValueMap& variables) {
   for (const auto& variable : variables) {
     set_variable(variable.first, variable.second.clone());
   }
 }
 
-void ContextFrame::apply_lexical_variables(const ContextFrame& other)
-{
+void ContextFrame::apply_lexical_variables(const ContextFrame& other) {
   apply_variables(other.lexical_variables);
 }
 
-void ContextFrame::apply_config_variables(const ContextFrame& other)
-{
+void ContextFrame::apply_config_variables(const ContextFrame& other) {
   apply_variables(other.config_variables);
 }
 
-void ContextFrame::apply_variables(ValueMap&& variables)
-{
+void ContextFrame::apply_variables(ValueMap&& variables) {
   for (auto& variable : variables) {
     set_variable(variable.first, std::move(variable.second));
   }
   variables.clear();
 }
 
-void ContextFrame::apply_lexical_variables(ContextFrame&& other)
-{
+void ContextFrame::apply_lexical_variables(ContextFrame&& other) {
   apply_variables(std::move(other.lexical_variables));
 }
 
-void ContextFrame::apply_config_variables(ContextFrame&& other)
-{
+void ContextFrame::apply_config_variables(ContextFrame&& other) {
   apply_variables(std::move(other.config_variables));
 }
 
-void ContextFrame::apply_variables(ContextFrame&& other)
-{
+void ContextFrame::apply_variables(ContextFrame&& other) {
   apply_variables(std::move(other.lexical_variables));
   apply_variables(std::move(other.config_variables));
 }
 
-bool ContextFrame::is_config_variable(const std::string& name)
-{
+bool ContextFrame::is_config_variable(const std::string& name) {
   return name[0] == '$' && name != "$children";
 }
 
 #ifdef DEBUG
-std::string ContextFrame::dumpFrame() const
-{
+std::string ContextFrame::dumpFrame() const {
   std::ostringstream s;
   s << boost::format("ContextFrame %p:\n") % this;
   for (const auto& v : lexical_variables) {
@@ -155,4 +143,4 @@ std::string ContextFrame::dumpFrame() const
   }
   return s.str();
 }
-#endif // ifdef DEBUG
+#endif  // ifdef DEBUG
diff --git a/src/core/ContextFrame.h b/src/core/ContextFrame.h
index ffae22b31..a79e26518 100644
--- a/src/core/ContextFrame.h
+++ b/src/core/ContextFrame.h
@@ -5,23 +5,27 @@
 #include <string>
 #include <vector>
 
-#include "core/EvaluationSession.h"
 #include "core/AST.h"
+#include "core/EvaluationSession.h"
 #include "core/ValueMap.h"
 
-class ContextFrame
-{
-public:
-  ContextFrame(EvaluationSession *session);
+class ContextFrame {
+ public:
+  ContextFrame(EvaluationSession* session);
   virtual ~ContextFrame() = default;
 
   ContextFrame(ContextFrame&& other) = default;
 
-  virtual boost::optional<const Value&> lookup_local_variable(const std::string& name) const;
-  virtual boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const;
-  virtual boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const;
+  virtual boost::optional<const Value&> lookup_local_variable(
+      const std::string& name) const;
+  virtual boost::optional<CallableFunction> lookup_local_function(
+      const std::string& name,
+      const Location& loc) const;
+  virtual boost::optional<InstantiableModule> lookup_local_module(
+      const std::string& name,
+      const Location& loc) const;
 
-  virtual std::vector<const Value *> list_embedded_values() const;
+  virtual std::vector<const Value*> list_embedded_values() const;
   virtual size_t clear();
 
   virtual bool set_variable(const std::string& name, Value&& value);
@@ -41,15 +45,17 @@ public:
 
   static bool is_config_variable(const std::string& name);
 
-  EvaluationSession *session() const { return evaluation_session; }
-  const std::string& documentRoot() const { return evaluation_session->documentRoot(); }
+  EvaluationSession* session() const { return evaluation_session; }
+  const std::string& documentRoot() const {
+    return evaluation_session->documentRoot();
+  }
 
-protected:
+ protected:
   ValueMap lexical_variables;
   ValueMap config_variables;
-  EvaluationSession *evaluation_session;
+  EvaluationSession* evaluation_session;
 
-public:
+ public:
 #ifdef DEBUG
   virtual std::string dumpFrame() const;
 #endif
@@ -59,47 +65,37 @@ public:
  * A ContextFrameHandle stores a reference to a ContextFrame, and keeps it on
  * the special variable stack for the lifetime of the handle.
  */
-class ContextFrameHandle
-{
-public:
-  ContextFrameHandle(ContextFrame *frame) :
-    session(frame->session())
-  {
+class ContextFrameHandle {
+ public:
+  ContextFrameHandle(ContextFrame* frame) : session(frame->session()) {
     frame_index = session->push_frame(frame);
   }
-  ~ContextFrameHandle()
-  {
-    release();
-  }
+  ~ContextFrameHandle() { release(); }
 
   ContextFrameHandle(const ContextFrameHandle&) = delete;
   ContextFrameHandle& operator=(const ContextFrameHandle&) = delete;
   ContextFrameHandle& operator=(ContextFrameHandle&&) = delete;
 
-  ContextFrameHandle(ContextFrameHandle&& other) noexcept :
-    session(other.session),
-    frame_index(other.frame_index)
-  {
+  ContextFrameHandle(ContextFrameHandle&& other) noexcept
+      : session(other.session), frame_index(other.frame_index) {
     other.session = nullptr;
   }
 
-  ContextFrameHandle& operator=(ContextFrame *frame)
-  {
+  ContextFrameHandle& operator=(ContextFrame* frame) {
     assert(session == frame->session());
     session->replace_frame(frame_index, frame);
     return *this;
   }
 
   // Valid only if handle is on the top of the stack.
-  void release()
-  {
+  void release() {
     if (session) {
       session->pop_frame(frame_index);
       session = nullptr;
     }
   }
 
-protected:
-  EvaluationSession *session;
+ protected:
+  EvaluationSession* session;
   size_t frame_index;
 };
diff --git a/src/core/ContextMemoryManager.cc b/src/core/ContextMemoryManager.cc
index 070ee8e6d..b952f29fc 100644
--- a/src/core/ContextMemoryManager.cc
+++ b/src/core/ContextMemoryManager.cc
@@ -26,13 +26,13 @@
 
 #include "core/ContextMemoryManager.h"
 
-#include <variant>
 #include <cassert>
-#include <utility>
-#include <memory>
 #include <deque>
 #include <map>
+#include <memory>
 #include <unordered_set>
+#include <utility>
+#include <variant>
 #include <vector>
 
 #include "core/Context.h"
@@ -52,30 +52,46 @@
  * - the use_count() of the shared object;
  * - the list of values stored, and contexts referenced.
  */
-using ValueIdentifier = void *;
+using ValueIdentifier = void*;
 
-struct IdentifierVisitor
-{
-  ValueIdentifier operator()(const VectorType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const EmbeddedVectorType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const ObjectType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const FunctionPtr& value) const { return value.get().get(); }
+struct IdentifierVisitor {
+  ValueIdentifier operator()(const VectorType& value) const {
+    return value.ptr.get();
+  }
+  ValueIdentifier operator()(const EmbeddedVectorType& value) const {
+    return value.ptr.get();
+  }
+  ValueIdentifier operator()(const ObjectType& value) const {
+    return value.ptr.get();
+  }
+  ValueIdentifier operator()(const FunctionPtr& value) const {
+    return value.get().get();
+  }
 
   // all types without identity
-  template <typename T> ValueIdentifier operator()(const T&) const {
+  template <typename T>
+  ValueIdentifier operator()(const T&) const {
     return nullptr;
   }
 };
 
-struct UseCountVisitor
-{
-  int operator()(const VectorType& value) const { return value.ptr.use_count(); }
-  int operator()(const EmbeddedVectorType& value) const { return value.ptr.use_count(); }
-  int operator()(const ObjectType& value) const { return value.ptr.use_count(); }
-  int operator()(const FunctionPtr& value) const { return value.get().use_count(); }
+struct UseCountVisitor {
+  int operator()(const VectorType& value) const {
+    return value.ptr.use_count();
+  }
+  int operator()(const EmbeddedVectorType& value) const {
+    return value.ptr.use_count();
+  }
+  int operator()(const ObjectType& value) const {
+    return value.ptr.use_count();
+  }
+  int operator()(const FunctionPtr& value) const {
+    return value.get().use_count();
+  }
 
   // all types without use count
-  template <typename T> int operator()(const T&) const {
+  template <typename T>
+  int operator()(const T&) const {
     return 0;
   }
 };
@@ -86,13 +102,18 @@ struct EmbeddedValuesVisitor {
   explicit EmbeddedValuesVisitor(F&& func) : func(std::forward<F>(func)) {}
 
   void operator()(const VectorType& value) const { call_each(value.ptr->vec); }
-  void operator()(const EmbeddedVectorType& value) const { call_each(value.ptr->vec); }
-  void operator()(const ObjectType& value) const { call_each(value.ptr->values); }
+  void operator()(const EmbeddedVectorType& value) const {
+    call_each(value.ptr->vec);
+  }
+  void operator()(const ObjectType& value) const {
+    call_each(value.ptr->values);
+  }
 
   // unused types
-  template <typename T> void operator()(const T&) const {}
+  template <typename T>
+  void operator()(const T&) const {}
 
-private:
+ private:
   void call_each(const std::vector<Value>& vector) const {
     for (const Value& member : vector) {
       func(member);
@@ -100,18 +121,19 @@ private:
   }
 };
 
-struct ReferencedContextVisitor
-{
-  const std::shared_ptr<const Context> *operator()(const FunctionPtr& value) const { return &value->getContext(); }
+struct ReferencedContextVisitor {
+  const std::shared_ptr<const Context>* operator()(
+      const FunctionPtr& value) const {
+    return &value->getContext();
+  }
 
   // unused types
-  template <typename T> const std::shared_ptr<const Context> *operator()(const T&) const {
+  template <typename T>
+  const std::shared_ptr<const Context>* operator()(const T&) const {
     return nullptr;
   }
 };
 
-
-
 /*
  * Finds all contexts that have an inbound reference from something that is not
  * another context.
@@ -125,76 +147,82 @@ struct ReferencedContextVisitor
  *
  * Implemented as a breadth first search to save on stack space.
  */
-static std::vector<Context *> findRootContexts(const std::vector<std::shared_ptr<Context>>& managedContexts)
-{
+static std::vector<Context*> findRootContexts(
+    const std::vector<std::shared_ptr<Context>>& managedContexts) {
   std::map<ValueIdentifier, int> accountedValueReferences;
-  std::map<const Context *, int> accountedContextReferences;
-  std::unordered_set<const Context *> fullyAccountedContexts;
+  std::map<const Context*, int> accountedContextReferences;
+  std::unordered_set<const Context*> fullyAccountedContexts;
 
-  std::deque<const Value *> valueQueue;
-  std::deque<const std::shared_ptr<const Context> *> contextQueue;
+  std::deque<const Value*> valueQueue;
+  std::deque<const std::shared_ptr<const Context>*> contextQueue;
 
   auto visitValue = [&](const Value& value) {
-      ValueIdentifier identifier = std::visit(IdentifierVisitor(), value.getVariant());
-      if (!identifier) {
-        return;
-      }
+    ValueIdentifier identifier =
+        std::visit(IdentifierVisitor(), value.getVariant());
+    if (!identifier) {
+      return;
+    }
 
-      if (!accountedValueReferences.count(identifier)) {
-        accountedValueReferences[identifier] = 0;
-      }
-      const int accountedReferences = ++accountedValueReferences[identifier];
-      const int requiredReferences = std::visit(UseCountVisitor(), value.getVariant());
-      assert(accountedReferences <= requiredReferences);
-
-      if (accountedReferences == requiredReferences) {
-        std::visit(EmbeddedValuesVisitor{[&](const Value& v) {
-                                           valueQueue.push_back(&v);
-                                         }}, value.getVariant());
-
-        const std::shared_ptr<const Context> *referencedContext = std::visit(ReferencedContextVisitor(), value.getVariant());
-        if (referencedContext) {
-          contextQueue.push_back(referencedContext);
-        }
+    if (!accountedValueReferences.count(identifier)) {
+      accountedValueReferences[identifier] = 0;
+    }
+    const int accountedReferences = ++accountedValueReferences[identifier];
+    const int requiredReferences =
+        std::visit(UseCountVisitor(), value.getVariant());
+    assert(accountedReferences <= requiredReferences);
+
+    if (accountedReferences == requiredReferences) {
+      std::visit(EmbeddedValuesVisitor{[&](const Value& v) {
+                   valueQueue.push_back(&v);
+                 }},
+                 value.getVariant());
+
+      const std::shared_ptr<const Context>* referencedContext =
+          std::visit(ReferencedContextVisitor(), value.getVariant());
+      if (referencedContext) {
+        contextQueue.push_back(referencedContext);
       }
-    };
+    }
+  };
 
   auto visitContext = [&](const std::shared_ptr<const Context>& context) {
-      if (!accountedContextReferences.count(context.get())) {
-        accountedContextReferences[context.get()] = 0;
-      }
-      const int accountedReferences = ++accountedContextReferences[context.get()];
-      const int requiredReferences = context.use_count();
-      assert(accountedReferences <= requiredReferences);
-      if (accountedReferences == requiredReferences) {
-        fullyAccountedContexts.insert(context.get());
-      }
-    };
+    if (!accountedContextReferences.count(context.get())) {
+      accountedContextReferences[context.get()] = 0;
+    }
+    const int accountedReferences = ++accountedContextReferences[context.get()];
+    const int requiredReferences = context.use_count();
+    assert(accountedReferences <= requiredReferences);
+    if (accountedReferences == requiredReferences) {
+      fullyAccountedContexts.insert(context.get());
+    }
+  };
 
   for (const std::shared_ptr<Context>& context : managedContexts) {
-    std::vector<const Value *> values = context->list_embedded_values();
+    std::vector<const Value*> values = context->list_embedded_values();
     valueQueue.insert(valueQueue.end(), values.begin(), values.end());
 
-    std::vector<const std::shared_ptr<const Context> *> referencedContexts = context->list_referenced_contexts();
-    contextQueue.insert(contextQueue.end(), referencedContexts.begin(), referencedContexts.end());
+    std::vector<const std::shared_ptr<const Context>*> referencedContexts =
+        context->list_referenced_contexts();
+    contextQueue.insert(contextQueue.end(), referencedContexts.begin(),
+                        referencedContexts.end());
 
     accountedContextReferences[context.get()] = 1;
   }
 
   while (!valueQueue.empty() || !contextQueue.empty()) {
     if (!valueQueue.empty()) {
-      const Value *value = valueQueue.front();
+      const Value* value = valueQueue.front();
       valueQueue.pop_front();
       visitValue(*value);
     } else {
       assert(!contextQueue.empty());
-      const std::shared_ptr<const Context> *context = contextQueue.front();
+      const std::shared_ptr<const Context>* context = contextQueue.front();
       contextQueue.pop_front();
       visitContext(*context);
     }
   }
 
-  std::vector<Context *> rootContexts;
+  std::vector<Context*> rootContexts;
   for (const std::shared_ptr<Context>& context : managedContexts) {
     if (!fullyAccountedContexts.count(context.get())) {
       rootContexts.push_back(context.get());
@@ -203,65 +231,67 @@ static std::vector<Context *> findRootContexts(const std::vector<std::shared_ptr
   return rootContexts;
 }
 
-
-
 /*
  * Finds all contexts reachable from a set of root contexts.
  *
  * Implemented as a breadth first search to save on stack space.
  */
-static std::unordered_set<const Context *> findReachableContexts(const std::vector<Context *>& rootContexts)
-{
+static std::unordered_set<const Context*> findReachableContexts(
+    const std::vector<Context*>& rootContexts) {
   std::unordered_set<ValueIdentifier> valuesSeen;
-  std::unordered_set<const Context *> contextsSeen;
+  std::unordered_set<const Context*> contextsSeen;
 
-  std::deque<const Value *> valueQueue;
-  std::deque<const Context *> contextQueue;
+  std::deque<const Value*> valueQueue;
+  std::deque<const Context*> contextQueue;
 
   auto visitValue = [&](const Value& value) {
-      ValueIdentifier identifier = std::visit(IdentifierVisitor(), value.getVariant());
-      if (!identifier) {
-        return;
-      }
-      if (!valuesSeen.count(identifier)) {
-        valuesSeen.insert(identifier);
-        valueQueue.push_back(&value);
-      }
-    };
-  auto visitContext = [&](const Context *context) {
-      if (!contextsSeen.count(context)) {
-        contextsSeen.insert(context);
-        contextQueue.push_back(context);
-      }
-    };
+    ValueIdentifier identifier =
+        std::visit(IdentifierVisitor(), value.getVariant());
+    if (!identifier) {
+      return;
+    }
+    if (!valuesSeen.count(identifier)) {
+      valuesSeen.insert(identifier);
+      valueQueue.push_back(&value);
+    }
+  };
+  auto visitContext = [&](const Context* context) {
+    if (!contextsSeen.count(context)) {
+      contextsSeen.insert(context);
+      contextQueue.push_back(context);
+    }
+  };
 
   contextsSeen.insert(rootContexts.begin(), rootContexts.end());
-  contextQueue.insert(contextQueue.end(), rootContexts.begin(), rootContexts.end());
+  contextQueue.insert(contextQueue.end(), rootContexts.begin(),
+                      rootContexts.end());
   while (!valueQueue.empty() || !contextQueue.empty()) {
     if (!valueQueue.empty()) {
-      const Value *value = valueQueue.front();
+      const Value* value = valueQueue.front();
       valueQueue.pop_front();
 
-      std::visit(EmbeddedValuesVisitor{[&](const Value& v) {
-                                         visitValue(v);
-                                       }}, value->getVariant());
+      std::visit(EmbeddedValuesVisitor{[&](const Value& v) { visitValue(v); }},
+                 value->getVariant());
 
-      const std::shared_ptr<const Context> *referencedContext = std::visit(ReferencedContextVisitor(), value->getVariant());
+      const std::shared_ptr<const Context>* referencedContext =
+          std::visit(ReferencedContextVisitor(), value->getVariant());
       if (referencedContext) {
         visitContext(referencedContext->get());
       }
     } else {
       assert(!contextQueue.empty());
-      const Context *context = contextQueue.front();
+      const Context* context = contextQueue.front();
       contextQueue.pop_front();
 
-      const std::vector<const Value *> values = context->list_embedded_values();
-      for (const Value *value : values) {
+      const std::vector<const Value*> values = context->list_embedded_values();
+      for (const Value* value : values) {
         visitValue(*value);
       }
 
-      const std::vector<const std::shared_ptr<const Context> *> referencedContexts = context->list_referenced_contexts();
-      for (const std::shared_ptr<const Context> *referencedContext : referencedContexts) {
+      const std::vector<const std::shared_ptr<const Context>*>
+          referencedContexts = context->list_referenced_contexts();
+      for (const std::shared_ptr<const Context>* referencedContext :
+           referencedContexts) {
         visitContext(referencedContext->get());
       }
     }
@@ -270,13 +300,11 @@ static std::unordered_set<const Context *> findReachableContexts(const std::vect
   return contextsSeen;
 }
 
-
-
 /*
  * Clean up all unreachable contexts.
  */
-static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
-{
+static void collectGarbage(
+    std::vector<std::weak_ptr<Context>>& managedContexts) {
   /*
    * Garbage collection consists of three phases.
    *
@@ -306,9 +334,10 @@ static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
     }
   }
 
-  const std::vector<Context *> rootContexts = findRootContexts(allContexts);
+  const std::vector<Context*> rootContexts = findRootContexts(allContexts);
 
-  const std::unordered_set<const Context *> reachableContexts = findReachableContexts(rootContexts);
+  const std::unordered_set<const Context*> reachableContexts =
+      findReachableContexts(rootContexts);
 
 #ifdef DEBUG
   std::vector<std::weak_ptr<Context>> removedContexts;
@@ -347,19 +376,16 @@ static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
 #endif
 }
 
-
-
-ContextMemoryManager::~ContextMemoryManager()
-{
+ContextMemoryManager::~ContextMemoryManager() {
   collectGarbage(managedContexts);
   assert(managedContexts.empty());
   assert(heapSizeAccounting.size() == 0);
 }
 
-void ContextMemoryManager::addContext(const std::shared_ptr<Context>& context)
-{
+void ContextMemoryManager::addContext(const std::shared_ptr<Context>& context) {
   heapSizeAccounting.addContext();
-  context->setAccountingAdded();   // avoiding bad accounting when an exception threw in constructor issue #3871
+  context->setAccountingAdded();  // avoiding bad accounting when an exception
+                                  // threw in constructor issue #3871
 
   /*
    * If we are holding the last copy to this context, no point in invoking
diff --git a/src/core/ContextMemoryManager.h b/src/core/ContextMemoryManager.h
index 9884acef4..a90756452 100644
--- a/src/core/ContextMemoryManager.h
+++ b/src/core/ContextMemoryManager.h
@@ -15,9 +15,8 @@ class Context;
  * Counts one point for each context, each context variable, and each element
  * in a VectorType value.
  */
-class HeapSizeAccounting
-{
-public:
+class HeapSizeAccounting {
+ public:
   void addContext(size_t number = 1) { count += number; }
   void removeContext(size_t number = 1) { count -= number; }
   void addContextVariable(size_t number = 1) { count += number; }
@@ -27,13 +26,12 @@ public:
 
   [[nodiscard]] size_t size() const { return count; }
 
-private:
+ private:
   size_t count = 0;
 };
 
-class ContextMemoryManager
-{
-public:
+class ContextMemoryManager {
+ public:
   ~ContextMemoryManager();
 
   void addContext(const std::shared_ptr<Context>& context);
@@ -41,7 +39,7 @@ public:
 
   HeapSizeAccounting& accounting() { return heapSizeAccounting; }
 
-private:
+ private:
   std::vector<std::weak_ptr<Context>> managedContexts;
   HeapSizeAccounting heapSizeAccounting;
   size_t nextGarbageCollectSize = 0;
diff --git a/src/core/CsgOpNode.cc b/src/core/CsgOpNode.cc
index 78118dab5..47541f831 100644
--- a/src/core/CsgOpNode.cc
+++ b/src/core/CsgOpNode.cc
@@ -26,72 +26,81 @@
 
 #include "core/CsgOpNode.h"
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
 
-#include <utility>
+#include <cassert>
 #include <memory>
 #include <string>
-#include <cassert>
+#include <utility>
 
-static std::shared_ptr<AbstractNode> builtin_union(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::UNION));
+static std::shared_ptr<AbstractNode> builtin_union(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
+  return children.instantiate(
+      std::make_shared<CsgOpNode>(inst, OpenSCADOperator::UNION));
 }
 
-static std::shared_ptr<AbstractNode> builtin_difference(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::DIFFERENCE));
+static std::shared_ptr<AbstractNode> builtin_difference(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
+  return children.instantiate(
+      std::make_shared<CsgOpNode>(inst, OpenSCADOperator::DIFFERENCE));
 }
 
-static std::shared_ptr<AbstractNode> builtin_intersection(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::INTERSECTION));
+static std::shared_ptr<AbstractNode> builtin_intersection(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
+  return children.instantiate(
+      std::make_shared<CsgOpNode>(inst, OpenSCADOperator::INTERSECTION));
 }
 
-std::string CsgOpNode::toString() const
-{
+std::string CsgOpNode::toString() const {
   return this->name() + "()";
 }
 
-std::string CsgOpNode::name() const
-{
+std::string CsgOpNode::name() const {
   switch (this->type) {
-  case OpenSCADOperator::UNION:
-    return "union";
-    break;
-  case OpenSCADOperator::DIFFERENCE:
-    return "difference";
-    break;
-  case OpenSCADOperator::INTERSECTION:
-    return "intersection";
-    break;
-  default:
-    assert(false);
+    case OpenSCADOperator::UNION:
+      return "union";
+      break;
+    case OpenSCADOperator::DIFFERENCE:
+      return "difference";
+      break;
+    case OpenSCADOperator::INTERSECTION:
+      return "intersection";
+      break;
+    default:
+      assert(false);
   }
   return "internal_error";
 }
 
-void register_builtin_csgops()
-{
+void register_builtin_csgops() {
   Builtins::init("union", new BuiltinModule(builtin_union),
-  {
-    "union()",
-  });
+                 {
+                     "union()",
+                 });
 
   Builtins::init("difference", new BuiltinModule(builtin_difference),
-  {
-    "difference()",
-  });
+                 {
+                     "difference()",
+                 });
 
   Builtins::init("intersection", new BuiltinModule(builtin_intersection),
-  {
-    "intersection()",
-  });
+                 {
+                     "intersection()",
+                 });
 }
diff --git a/src/core/CsgOpNode.h b/src/core/CsgOpNode.h
index 236f9e976..52c0bdb6f 100644
--- a/src/core/CsgOpNode.h
+++ b/src/core/CsgOpNode.h
@@ -2,16 +2,16 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/enums.h"
+#include "core/node.h"
 
-class CsgOpNode : public AbstractNode
-{
-public:
+class CsgOpNode : public AbstractNode {
+ public:
   VISITABLE();
   OpenSCADOperator type;
-  CsgOpNode(const ModuleInstantiation *mi, OpenSCADOperator type) : AbstractNode(mi), type(type) { }
+  CsgOpNode(const ModuleInstantiation* mi, OpenSCADOperator type)
+      : AbstractNode(mi), type(type) {}
   std::string toString() const override;
   std::string name() const override;
 };
diff --git a/src/core/DrawingCallback.cc b/src/core/DrawingCallback.cc
index 48e2be283..402b8586b 100644
--- a/src/core/DrawingCallback.cc
+++ b/src/core/DrawingCallback.cc
@@ -25,31 +25,30 @@
  */
 #include "core/DrawingCallback.h"
 
-#include <memory>
 #include <cmath>
+#include <memory>
 #include <vector>
 
 #include "geometry/Polygon2d.h"
 
-DrawingCallback::DrawingCallback(unsigned long fn, double size) :
-  pen(Vector2d(0, 0)), offset(Vector2d(0, 0)), advance(Vector2d(0, 0)), fn(fn), size(size)
-{
-}
+DrawingCallback::DrawingCallback(unsigned long fn, double size)
+    : pen(Vector2d(0, 0)),
+      offset(Vector2d(0, 0)),
+      advance(Vector2d(0, 0)),
+      fn(fn),
+      size(size) {}
 
-DrawingCallback::~DrawingCallback()
-{
-}
+DrawingCallback::~DrawingCallback() {}
 
-void DrawingCallback::start_glyph()
-{
+void DrawingCallback::start_glyph() {
   this->polygon = std::make_shared<Polygon2d>();
   // FIXME: Why do we think that a glyph is sanitized?
-  // This is technically not true, since we don't maintain correct values for the 'positive' flag.
+  // This is technically not true, since we don't maintain correct values for
+  // the 'positive' flag.
   this->polygon->setSanitized(true);
 }
 
-void DrawingCallback::finish_glyph()
-{
+void DrawingCallback::finish_glyph() {
   if (this->outline.vertices.size() > 0) {
     this->polygon->addOutline(this->outline);
     this->outline.vertices.clear();
@@ -63,28 +62,23 @@ void DrawingCallback::finish_glyph()
   }
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> DrawingCallback::get_result()
-{
+std::vector<std::shared_ptr<const Polygon2d>> DrawingCallback::get_result() {
   return this->polygons;
 }
 
-void DrawingCallback::set_glyph_offset(double offset_x, double offset_y)
-{
+void DrawingCallback::set_glyph_offset(double offset_x, double offset_y) {
   offset = Vector2d(offset_x, offset_y);
 }
 
-void DrawingCallback::add_glyph_advance(double advance_x, double advance_y)
-{
+void DrawingCallback::add_glyph_advance(double advance_x, double advance_y) {
   advance += Vector2d(advance_x, advance_y);
 }
 
-void DrawingCallback::add_vertex(const Vector2d& v)
-{
+void DrawingCallback::add_vertex(const Vector2d& v) {
   this->outline.vertices.push_back(size * (v + offset + advance));
 }
 
-void DrawingCallback::move_to(const Vector2d& to)
-{
+void DrawingCallback::move_to(const Vector2d& to) {
   if (this->outline.vertices.size() > 0) {
     this->polygon->addOutline(this->outline);
     this->outline.vertices.clear();
@@ -93,35 +87,33 @@ void DrawingCallback::move_to(const Vector2d& to)
   pen = to;
 }
 
-void DrawingCallback::line_to(const Vector2d& to)
-{
+void DrawingCallback::line_to(const Vector2d& to) {
   add_vertex(to);
   pen = to;
 }
 
 // Quadric Bezier curve
-void DrawingCallback::curve_to(const Vector2d& c1, const Vector2d& to)
-{
-  // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
+void DrawingCallback::curve_to(const Vector2d& c1, const Vector2d& to) {
+  // NOTE - this could be done better using a chord length iteration (uniform in
+  // space) to implement $fa (lot of work, little gain)
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    add_vertex(pen * pow(1 - a, 2) +
-               c1 * 2 * pow(1 - a, 1) * a +
+    add_vertex(pen * pow(1 - a, 2) + c1 * 2 * pow(1 - a, 1) * a +
                to * pow(a, 2));
   }
   pen = to;
 }
 
 // Cubic Bezier curve
-void DrawingCallback::curve_to(const Vector2d& c1, const Vector2d& c2, const Vector2d& to)
-{
-  // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
+void DrawingCallback::curve_to(const Vector2d& c1,
+                               const Vector2d& c2,
+                               const Vector2d& to) {
+  // NOTE - this could be done better using a chord length iteration (uniform in
+  // space) to implement $fa (lot of work, little gain)
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    add_vertex(pen * pow(1 - a, 3) +
-               c1 * 3 * pow(1 - a, 2) * a +
-               c2 * 3 * pow(1 - a, 1) * pow(a, 2) +
-               to * pow(a, 3));
+    add_vertex(pen * pow(1 - a, 3) + c1 * 3 * pow(1 - a, 2) * a +
+               c2 * 3 * pow(1 - a, 1) * pow(a, 2) + to * pow(a, 3));
   }
   pen = to;
 }
diff --git a/src/core/DrawingCallback.h b/src/core/DrawingCallback.h
index 79fdd8289..458a1c930 100644
--- a/src/core/DrawingCallback.h
+++ b/src/core/DrawingCallback.h
@@ -25,19 +25,18 @@
  */
 #pragma once
 
+#include <Eigen/Core>
+#include <cmath>
 #include <memory>
 #include <vector>
-#include <cmath>
-#include <Eigen/Core>
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
 class Polygon2d;
 class Geometry;
 
-class DrawingCallback
-{
-public:
+class DrawingCallback {
+ public:
   DrawingCallback(unsigned long fn, double size);
   virtual ~DrawingCallback();
 
@@ -51,7 +50,8 @@ public:
   void line_to(const Vector2d& to);
   void curve_to(const Vector2d& c1, const Vector2d& to);
   void curve_to(const Vector2d& c1, const Vector2d& c2, const Vector2d& to);
-private:
+
+ private:
   Vector2d pen;
   Vector2d offset;
   Vector2d advance;
diff --git a/src/core/EvaluationSession.cc b/src/core/EvaluationSession.cc
index aa5c96fc7..d44a9a5c3 100644
--- a/src/core/EvaluationSession.cc
+++ b/src/core/EvaluationSession.cc
@@ -34,27 +34,24 @@
 #include "core/ContextFrame.h"
 #include "utils/printutils.h"
 
-size_t EvaluationSession::push_frame(ContextFrame *frame)
-{
+size_t EvaluationSession::push_frame(ContextFrame* frame) {
   size_t index = stack.size();
   stack.push_back(frame);
   return index;
 }
 
-void EvaluationSession::replace_frame(size_t index, ContextFrame *frame)
-{
+void EvaluationSession::replace_frame(size_t index, ContextFrame* frame) {
   assert(index < stack.size());
   stack[index] = frame;
 }
 
-void EvaluationSession::pop_frame(size_t index)
-{
+void EvaluationSession::pop_frame(size_t index) {
   stack.pop_back();
   assert(stack.size() == index);
 }
 
-boost::optional<const Value&> EvaluationSession::try_lookup_special_variable(const std::string& name) const
-{
+boost::optional<const Value&> EvaluationSession::try_lookup_special_variable(
+    const std::string& name) const {
   for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
     boost::optional<const Value&> result = (*it)->lookup_local_variable(name);
     if (result) {
@@ -64,36 +61,44 @@ boost::optional<const Value&> EvaluationSession::try_lookup_special_variable(con
   return boost::none;
 }
 
-const Value& EvaluationSession::lookup_special_variable(const std::string& name, const Location& loc) const
-{
+const Value& EvaluationSession::lookup_special_variable(
+    const std::string& name,
+    const Location& loc) const {
   boost::optional<const Value&> result = try_lookup_special_variable(name);
   if (!result) {
-    LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown variable %1$s", quoteVar(name));
+    LOG(message_group::Warning, loc, documentRoot(),
+        "Ignoring unknown variable %1$s", quoteVar(name));
     return Value::undefined;
   }
   return *result;
 }
 
-boost::optional<CallableFunction> EvaluationSession::lookup_special_function(const std::string& name, const Location& loc) const
-{
+boost::optional<CallableFunction> EvaluationSession::lookup_special_function(
+    const std::string& name,
+    const Location& loc) const {
   for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
-    boost::optional<CallableFunction> result = (*it)->lookup_local_function(name, loc);
+    boost::optional<CallableFunction> result =
+        (*it)->lookup_local_function(name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown function '%1$s'", name);
+  LOG(message_group::Warning, loc, documentRoot(),
+      "Ignoring unknown function '%1$s'", name);
   return boost::none;
 }
 
-boost::optional<InstantiableModule> EvaluationSession::lookup_special_module(const std::string& name, const Location& loc) const
-{
+boost::optional<InstantiableModule> EvaluationSession::lookup_special_module(
+    const std::string& name,
+    const Location& loc) const {
   for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
-    boost::optional<InstantiableModule> result = (*it)->lookup_local_module(name, loc);
+    boost::optional<InstantiableModule> result =
+        (*it)->lookup_local_module(name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown module '%1$s'", name);
+  LOG(message_group::Warning, loc, documentRoot(),
+      "Ignoring unknown module '%1$s'", name);
   return boost::none;
 }
diff --git a/src/core/EvaluationSession.h b/src/core/EvaluationSession.h
index b83b4a7b1..27a3edfa5 100644
--- a/src/core/EvaluationSession.h
+++ b/src/core/EvaluationSession.h
@@ -1,41 +1,51 @@
 #pragma once
 
+#include <boost/optional.hpp>
 #include <cstddef>
 #include <string>
 #include <utility>
 #include <vector>
-#include <boost/optional.hpp>
 
-#include "core/ContextMemoryManager.h"
 #include "core/AST.h"
+#include "core/ContextMemoryManager.h"
+#include "core/Value.h"
 #include "core/function.h"
 #include "core/module.h"
-#include "core/Value.h"
 
 class ContextFrame;
 
-class EvaluationSession
-{
-public:
-  EvaluationSession(std::string documentRoot) :
-    document_root(std::move(documentRoot))
-  {}
+class EvaluationSession {
+ public:
+  EvaluationSession(std::string documentRoot)
+      : document_root(std::move(documentRoot)) {}
 
-  size_t push_frame(ContextFrame *frame);
-  void replace_frame(size_t index, ContextFrame *frame);
+  size_t push_frame(ContextFrame* frame);
+  void replace_frame(size_t index, ContextFrame* frame);
   void pop_frame(size_t index);
 
-  [[nodiscard]] boost::optional<const Value&> try_lookup_special_variable(const std::string& name) const;
-  [[nodiscard]] const Value& lookup_special_variable(const std::string& name, const Location& loc) const;
-  [[nodiscard]] boost::optional<CallableFunction> lookup_special_function(const std::string& name, const Location& loc) const;
-  [[nodiscard]] boost::optional<InstantiableModule> lookup_special_module(const std::string& name, const Location& loc) const;
-
-  [[nodiscard]] const std::string& documentRoot() const { return document_root; }
-  ContextMemoryManager& contextMemoryManager() { return context_memory_manager; }
-  HeapSizeAccounting& accounting() { return context_memory_manager.accounting(); }
-
-private:
+  [[nodiscard]] boost::optional<const Value&> try_lookup_special_variable(
+      const std::string& name) const;
+  [[nodiscard]] const Value& lookup_special_variable(const std::string& name,
+                                                     const Location& loc) const;
+  [[nodiscard]] boost::optional<CallableFunction> lookup_special_function(
+      const std::string& name,
+      const Location& loc) const;
+  [[nodiscard]] boost::optional<InstantiableModule> lookup_special_module(
+      const std::string& name,
+      const Location& loc) const;
+
+  [[nodiscard]] const std::string& documentRoot() const {
+    return document_root;
+  }
+  ContextMemoryManager& contextMemoryManager() {
+    return context_memory_manager;
+  }
+  HeapSizeAccounting& accounting() {
+    return context_memory_manager.accounting();
+  }
+
+ private:
   std::string document_root;
-  std::vector<ContextFrame *> stack;
+  std::vector<ContextFrame*> stack;
   ContextMemoryManager context_memory_manager;
 };
diff --git a/src/core/Expression.cc b/src/core/Expression.cc
index 67f97dc6d..4521a7de7 100644
--- a/src/core/Expression.cc
+++ b/src/core/Expression.cc
@@ -25,67 +25,72 @@
  */
 #include "core/Expression.h"
 
-#include "utils/compiler_specific.h"
-#include "core/Value.h"
-#include <set>
-#include <functional>
-#include <ostream>
-#include <cstdint>
-#include <cmath>
+#include <algorithm>
+#include <boost/assign/std/vector.hpp>
+#include <boost/regex.hpp>
 #include <cassert>
+#include <cmath>
 #include <cstddef>
+#include <cstdint>
+#include <functional>
 #include <memory>
+#include <ostream>
+#include <set>
 #include <sstream>
-#include <algorithm>
 #include <typeinfo>
 #include <utility>
 #include <variant>
-#include "utils/printutils.h"
-#include "utils/StackCheck.h"
 #include "core/Context.h"
-#include "utils/exceptions.h"
 #include "core/Parameters.h"
-#include "utils/printutils.h"
+#include "core/Value.h"
+#include "utils/StackCheck.h"
 #include "utils/boost-utils.h"
-#include <boost/regex.hpp>
-#include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
-
-Value Expression::checkUndef(Value&& val, const std::shared_ptr<const Context>& context) const {
-  if (val.isUncheckedUndef()) LOG(message_group::Warning, loc, context->documentRoot(), "%1$s", val.toUndefString());
+#include "utils/compiler_specific.h"
+#include "utils/exceptions.h"
+#include "utils/printutils.h"
+using namespace boost::assign;  // bring 'operator+=()' into scope
+
+Value Expression::checkUndef(
+    Value&& val,
+    const std::shared_ptr<const Context>& context) const {
+  if (val.isUncheckedUndef())
+    LOG(message_group::Warning, loc, context->documentRoot(), "%1$s",
+        val.toUndefString());
   return std::move(val);
 }
 
-bool Expression::isLiteral() const
-{
+bool Expression::isLiteral() const {
   return false;
 }
 
-UnaryOp::UnaryOp(UnaryOp::Op op, Expression *expr, const Location& loc) : Expression(loc), op(op), expr(expr)
-{
-}
+UnaryOp::UnaryOp(UnaryOp::Op op, Expression* expr, const Location& loc)
+    : Expression(loc), op(op), expr(expr) {}
 
-Value UnaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value UnaryOp::evaluate(const std::shared_ptr<const Context>& context) const {
   switch (this->op) {
-  case (Op::Not):    return !this->expr->evaluate(context).toBool();
-  case (Op::Negate): return checkUndef(-this->expr->evaluate(context), context);
-  case (Op::BinaryNot): return checkUndef(~this->expr->evaluate(context), context);
-  default:
-    assert(false && "Non-existent unary operator!");
-    throw EvaluationException("Non-existent unary operator!");
+    case (Op::Not):
+      return !this->expr->evaluate(context).toBool();
+    case (Op::Negate):
+      return checkUndef(-this->expr->evaluate(context), context);
+    case (Op::BinaryNot):
+      return checkUndef(~this->expr->evaluate(context), context);
+    default:
+      assert(false && "Non-existent unary operator!");
+      throw EvaluationException("Non-existent unary operator!");
   }
 }
 
-const char *UnaryOp::opString() const
-{
+const char* UnaryOp::opString() const {
   switch (this->op) {
-  case Op::Not:    return "!";
-  case Op::Negate: return "-";
-  case Op::BinaryNot: return "~";
-  default:
-    assert(false && "Non-existent unary operator!");
-    throw EvaluationException("Non-existent unary operator!");
+    case Op::Not:
+      return "!";
+    case Op::Negate:
+      return "-";
+    case Op::BinaryNot:
+      return "~";
+    default:
+      assert(false && "Non-existent unary operator!");
+      throw EvaluationException("Non-existent unary operator!");
   }
 }
 
@@ -93,146 +98,194 @@ bool UnaryOp::isLiteral() const {
   return this->expr->isLiteral();
 }
 
-void UnaryOp::print(std::ostream& stream, const std::string&) const
-{
+void UnaryOp::print(std::ostream& stream, const std::string&) const {
   stream << opString() << *this->expr;
 }
 
-BinaryOp::BinaryOp(Expression *left, BinaryOp::Op op, Expression *right, const Location& loc) :
-  Expression(loc), op(op), left(left), right(right)
-{
-}
+BinaryOp::BinaryOp(Expression* left,
+                   BinaryOp::Op op,
+                   Expression* right,
+                   const Location& loc)
+    : Expression(loc), op(op), left(left), right(right) {}
 
-Value BinaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value BinaryOp::evaluate(const std::shared_ptr<const Context>& context) const {
   switch (this->op) {
-  case Op::LogicalAnd:
-    return this->left->evaluate(context).toBool() && this->right->evaluate(context).toBool();
-  case Op::LogicalOr:
-    return this->left->evaluate(context).toBool() || this->right->evaluate(context).toBool();
-  case Op::Exponent:
-    return checkUndef(this->left->evaluate(context) ^ this->right->evaluate(context), context);
-  case Op::Multiply:
-    return checkUndef(this->left->evaluate(context) * this->right->evaluate(context), context);
-  case Op::Divide:
-    return checkUndef(this->left->evaluate(context) / this->right->evaluate(context), context);
-  case Op::Modulo:
-    return checkUndef(this->left->evaluate(context) % this->right->evaluate(context), context);
-  case Op::Plus:
-    return checkUndef(this->left->evaluate(context) + this->right->evaluate(context), context);
-  case Op::Minus:
-    return checkUndef(this->left->evaluate(context) - this->right->evaluate(context), context);
-  case Op::ShiftLeft:
-    return checkUndef(this->left->evaluate(context) << this->right->evaluate(context), context);
-  case Op::ShiftRight:
-    return checkUndef(this->left->evaluate(context) >> this->right->evaluate(context), context);
-  case Op::BinaryAnd:
-    return checkUndef(this->left->evaluate(context) & this->right->evaluate(context), context);
-  case Op::BinaryOr:
-    return checkUndef(this->left->evaluate(context) | this->right->evaluate(context), context);
-  case Op::Less:
-    return checkUndef(this->left->evaluate(context) < this->right->evaluate(context), context);
-  case Op::LessEqual:
-    return checkUndef(this->left->evaluate(context) <= this->right->evaluate(context), context);
-  case Op::Greater:
-    return checkUndef(this->left->evaluate(context) > this->right->evaluate(context), context);
-  case Op::GreaterEqual:
-    return checkUndef(this->left->evaluate(context) >= this->right->evaluate(context), context);
-  case Op::Equal:
-    return checkUndef(this->left->evaluate(context) == this->right->evaluate(context), context);
-  case Op::NotEqual:
-    return checkUndef(this->left->evaluate(context) != this->right->evaluate(context), context);
-  default:
-    assert(false && "Non-existent binary operator!");
-    throw EvaluationException("Non-existent binary operator!");
+    case Op::LogicalAnd:
+      return this->left->evaluate(context).toBool() &&
+             this->right->evaluate(context).toBool();
+    case Op::LogicalOr:
+      return this->left->evaluate(context).toBool() ||
+             this->right->evaluate(context).toBool();
+    case Op::Exponent:
+      return checkUndef(
+          this->left->evaluate(context) ^ this->right->evaluate(context),
+          context);
+    case Op::Multiply:
+      return checkUndef(
+          this->left->evaluate(context) * this->right->evaluate(context),
+          context);
+    case Op::Divide:
+      return checkUndef(
+          this->left->evaluate(context) / this->right->evaluate(context),
+          context);
+    case Op::Modulo:
+      return checkUndef(
+          this->left->evaluate(context) % this->right->evaluate(context),
+          context);
+    case Op::Plus:
+      return checkUndef(
+          this->left->evaluate(context) + this->right->evaluate(context),
+          context);
+    case Op::Minus:
+      return checkUndef(
+          this->left->evaluate(context) - this->right->evaluate(context),
+          context);
+    case Op::ShiftLeft:
+      return checkUndef(this->left->evaluate(context)
+                            << this->right->evaluate(context),
+                        context);
+    case Op::ShiftRight:
+      return checkUndef(
+          this->left->evaluate(context) >> this->right->evaluate(context),
+          context);
+    case Op::BinaryAnd:
+      return checkUndef(
+          this->left->evaluate(context) & this->right->evaluate(context),
+          context);
+    case Op::BinaryOr:
+      return checkUndef(
+          this->left->evaluate(context) | this->right->evaluate(context),
+          context);
+    case Op::Less:
+      return checkUndef(
+          this->left->evaluate(context) < this->right->evaluate(context),
+          context);
+    case Op::LessEqual:
+      return checkUndef(
+          this->left->evaluate(context) <= this->right->evaluate(context),
+          context);
+    case Op::Greater:
+      return checkUndef(
+          this->left->evaluate(context) > this->right->evaluate(context),
+          context);
+    case Op::GreaterEqual:
+      return checkUndef(
+          this->left->evaluate(context) >= this->right->evaluate(context),
+          context);
+    case Op::Equal:
+      return checkUndef(
+          this->left->evaluate(context) == this->right->evaluate(context),
+          context);
+    case Op::NotEqual:
+      return checkUndef(
+          this->left->evaluate(context) != this->right->evaluate(context),
+          context);
+    default:
+      assert(false && "Non-existent binary operator!");
+      throw EvaluationException("Non-existent binary operator!");
   }
 }
 
-const char *BinaryOp::opString() const
-{
+const char* BinaryOp::opString() const {
   switch (this->op) {
-  case Op::LogicalAnd:   return "&&";
-  case Op::LogicalOr:    return "||";
-  case Op::Exponent:     return "^";
-  case Op::Multiply:     return "*";
-  case Op::Divide:       return "/";
-  case Op::Modulo:       return "%";
-  case Op::Plus:         return "+";
-  case Op::Minus:        return "-";
-  case Op::Less:         return "<";
-  case Op::LessEqual:    return "<=";
-  case Op::Greater:      return ">";
-  case Op::GreaterEqual: return ">=";
-  case Op::Equal:        return "==";
-  case Op::NotEqual:     return "!=";
-  case Op::BinaryOr:     return "|";
-  case Op::BinaryAnd:     return "&";
-  case Op::ShiftLeft:     return "<<";
-  case Op::ShiftRight:     return ">>";
-  default:
-    assert(false && "Non-existent binary operator!");
-    throw EvaluationException("Non-existent binary operator!");
+    case Op::LogicalAnd:
+      return "&&";
+    case Op::LogicalOr:
+      return "||";
+    case Op::Exponent:
+      return "^";
+    case Op::Multiply:
+      return "*";
+    case Op::Divide:
+      return "/";
+    case Op::Modulo:
+      return "%";
+    case Op::Plus:
+      return "+";
+    case Op::Minus:
+      return "-";
+    case Op::Less:
+      return "<";
+    case Op::LessEqual:
+      return "<=";
+    case Op::Greater:
+      return ">";
+    case Op::GreaterEqual:
+      return ">=";
+    case Op::Equal:
+      return "==";
+    case Op::NotEqual:
+      return "!=";
+    case Op::BinaryOr:
+      return "|";
+    case Op::BinaryAnd:
+      return "&";
+    case Op::ShiftLeft:
+      return "<<";
+    case Op::ShiftRight:
+      return ">>";
+    default:
+      assert(false && "Non-existent binary operator!");
+      throw EvaluationException("Non-existent binary operator!");
   }
 }
 
-void BinaryOp::print(std::ostream& stream, const std::string&) const
-{
-  stream << "(" << *this->left << " " << opString() << " " << *this->right << ")";
+void BinaryOp::print(std::ostream& stream, const std::string&) const {
+  stream << "(" << *this->left << " " << opString() << " " << *this->right
+         << ")";
 }
 
-TernaryOp::TernaryOp(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc)
-  : Expression(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr)
-{
-}
+TernaryOp::TernaryOp(Expression* cond,
+                     Expression* ifexpr,
+                     Expression* elseexpr,
+                     const Location& loc)
+    : Expression(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr) {}
 
-const Expression *TernaryOp::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
-  return this->cond->evaluate(context).toBool() ? this->ifexpr.get() : this->elseexpr.get();
+const Expression* TernaryOp::evaluateStep(
+    const std::shared_ptr<const Context>& context) const {
+  return this->cond->evaluate(context).toBool() ? this->ifexpr.get()
+                                                : this->elseexpr.get();
 }
 
-Value TernaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value TernaryOp::evaluate(const std::shared_ptr<const Context>& context) const {
   return evaluateStep(context)->evaluate(context);
 }
 
-void TernaryOp::print(std::ostream& stream, const std::string&) const
-{
-  stream << "(" << *this->cond << " ? " << *this->ifexpr << " : " << *this->elseexpr << ")";
+void TernaryOp::print(std::ostream& stream, const std::string&) const {
+  stream << "(" << *this->cond << " ? " << *this->ifexpr << " : "
+         << *this->elseexpr << ")";
 }
 
-ArrayLookup::ArrayLookup(Expression *array, Expression *index, const Location& loc)
-  : Expression(loc), array(array), index(index)
-{
-}
+ArrayLookup::ArrayLookup(Expression* array,
+                         Expression* index,
+                         const Location& loc)
+    : Expression(loc), array(array), index(index) {}
 
-Value ArrayLookup::evaluate(const std::shared_ptr<const Context>& context) const {
+Value ArrayLookup::evaluate(
+    const std::shared_ptr<const Context>& context) const {
   return this->array->evaluate(context)[this->index->evaluate(context)];
 }
 
-void ArrayLookup::print(std::ostream& stream, const std::string&) const
-{
+void ArrayLookup::print(std::ostream& stream, const std::string&) const {
   stream << *array << "[" << *index << "]";
 }
 
-Value Literal::evaluate(const std::shared_ptr<const Context>&) const
-{
+Value Literal::evaluate(const std::shared_ptr<const Context>&) const {
   return value.clone();
 }
 
-void Literal::print(std::ostream& stream, const std::string&) const
-{
+void Literal::print(std::ostream& stream, const std::string&) const {
   stream << value;
 }
 
-Range::Range(Expression *begin, Expression *end, const Location& loc)
-  : Expression(loc), begin(begin), end(end)
-{
-}
+Range::Range(Expression* begin, Expression* end, const Location& loc)
+    : Expression(loc), begin(begin), end(end) {}
 
-Range::Range(Expression *begin, Expression *step, Expression *end, const Location& loc)
-  : Expression(loc), begin(begin), step(step), end(end)
-{
-}
+Range::Range(Expression* begin,
+             Expression* step,
+             Expression* end,
+             const Location& loc)
+    : Expression(loc), begin(begin), step(step), end(end) {}
 
 /**
  * This is separated because PRINT uses quite a lot of stack space and
@@ -241,16 +294,20 @@ Range::Range(Expression *begin, Expression *step, Expression *end, const Locatio
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_range_err(const std::string& begin, const std::string& step, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Warning, loc, context->documentRoot(), "begin %1$s than the end, but step %2$s", begin, step);
+static void NOINLINE
+print_range_err(const std::string& begin,
+                const std::string& step,
+                const Location& loc,
+                const std::shared_ptr<const Context>& context) {
+  LOG(message_group::Warning, loc, context->documentRoot(),
+      "begin %1$s than the end, but step %2$s", begin, step);
 }
 
-Value Range::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Range::evaluate(const std::shared_ptr<const Context>& context) const {
   double begin_val;
   double end_val;
-  if (!this->begin->evaluate(context).getDouble(begin_val)
-      || !this->end->evaluate(context).getDouble(end_val)) {
+  if (!this->begin->evaluate(context).getDouble(begin_val) ||
+      !this->end->evaluate(context).getDouble(end_val)) {
     return Value::undefined.clone();
   }
 
@@ -270,23 +327,21 @@ Value Range::evaluate(const std::shared_ptr<const Context>& context) const
   return RangeType(begin_val, step_val, end_val);
 }
 
-void Range::print(std::ostream& stream, const std::string&) const
-{
+void Range::print(std::ostream& stream, const std::string&) const {
   stream << "[" << *this->begin;
-  if (this->step) stream << " : " << *this->step;
+  if (this->step)
+    stream << " : " << *this->step;
   stream << " : " << *this->end;
   stream << "]";
 }
 
 bool Range::isLiteral() const {
-  return this->step ?
-         begin->isLiteral() && end->isLiteral() && step->isLiteral() :
-         begin->isLiteral() && end->isLiteral();
+  return this->step
+             ? begin->isLiteral() && end->isLiteral() && step->isLiteral()
+             : begin->isLiteral() && end->isLiteral();
 }
 
-Vector::Vector(const Location& loc) : Expression(loc), literal_flag(unknown)
-{
-}
+Vector::Vector(const Location& loc) : Expression(loc), literal_flag(unknown) {}
 
 bool Vector::isLiteral() const {
   if (unknown(literal_flag)) {
@@ -303,13 +358,11 @@ bool Vector::isLiteral() const {
   }
 }
 
-void Vector::emplace_back(Expression *expr)
-{
+void Vector::emplace_back(Expression* expr) {
   this->children.emplace_back(expr);
 }
 
-Value Vector::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Vector::evaluate(const std::shared_ptr<const Context>& context) const {
   if (children.size() == 1) {
     Value val = children.front()->evaluate(context);
     // If only 1 EmbeddedVectorType, convert to plain VectorType
@@ -323,98 +376,124 @@ Value Vector::evaluate(const std::shared_ptr<const Context>& context) const
   } else {
     VectorType vec(context->session());
     vec.reserve(this->children.size());
-    for (const auto& e : this->children) vec.emplace_back(e->evaluate(context));
+    for (const auto& e : this->children)
+      vec.emplace_back(e->evaluate(context));
     return std::move(vec);
   }
 }
 
-void Vector::print(std::ostream& stream, const std::string&) const
-{
+void Vector::print(std::ostream& stream, const std::string&) const {
   stream << "[";
   for (size_t i = 0; i < this->children.size(); ++i) {
-    if (i > 0) stream << ", ";
+    if (i > 0)
+      stream << ", ";
     stream << *this->children[i];
   }
   stream << "]";
 }
 
-Lookup::Lookup(std::string name, const Location& loc) : Expression(loc), name(std::move(name))
-{
-}
+Lookup::Lookup(std::string name, const Location& loc)
+    : Expression(loc), name(std::move(name)) {}
 
-Value Lookup::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Lookup::evaluate(const std::shared_ptr<const Context>& context) const {
   return context->lookup_variable(this->name, loc).clone();
 }
 
-void Lookup::print(std::ostream& stream, const std::string&) const
-{
+void Lookup::print(std::ostream& stream, const std::string&) const {
   stream << this->name;
 }
 
-MemberLookup::MemberLookup(Expression *expr, std::string member, const Location& loc)
-  : Expression(loc), expr(expr), member(std::move(member))
-{
-}
+MemberLookup::MemberLookup(Expression* expr,
+                           std::string member,
+                           const Location& loc)
+    : Expression(loc), expr(expr), member(std::move(member)) {}
 
-Value MemberLookup::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value MemberLookup::evaluate(
+    const std::shared_ptr<const Context>& context) const {
   const Value& v = this->expr->evaluate(context);
-  static const boost::regex re_swizzle_validation("^([xyzw]{1,4}|[rgba]{1,4})$");
+  static const boost::regex re_swizzle_validation(
+      "^([xyzw]{1,4}|[rgba]{1,4})$");
 
   switch (v.type()) {
-  case Value::Type::VECTOR:
-    if (this->member.length() > 1 && boost::regex_match(this->member, re_swizzle_validation)) {
-      VectorType ret(context->session());
-      ret.reserve(this->member.length());
-      for (const char& ch : this->member)
-        switch (ch) {
-        case 'r': case 'x': ret.emplace_back(v[0]); break;
-        case 'g': case 'y': ret.emplace_back(v[1]); break;
-        case 'b': case 'z': ret.emplace_back(v[2]); break;
-        case 'a': case 'w': ret.emplace_back(v[3]); break;
-        }
-      return {std::move(ret)};
-    }
-    if (this->member == "x") return v[0];
-    if (this->member == "y") return v[1];
-    if (this->member == "z") return v[2];
-    if (this->member == "w") return v[3];
-    if (this->member == "r") return v[0];
-    if (this->member == "g") return v[1];
-    if (this->member == "b") return v[2];
-    if (this->member == "a") return v[3];
-    break;
-  case Value::Type::RANGE:
-    if (this->member == "begin") return v[0];
-    if (this->member == "step") return v[1];
-    if (this->member == "end") return v[2];
-    break;
-  case Value::Type::OBJECT:
-    return v[this->member];
-  default:
-    break;
+    case Value::Type::VECTOR:
+      if (this->member.length() > 1 &&
+          boost::regex_match(this->member, re_swizzle_validation)) {
+        VectorType ret(context->session());
+        ret.reserve(this->member.length());
+        for (const char& ch : this->member)
+          switch (ch) {
+            case 'r':
+            case 'x':
+              ret.emplace_back(v[0]);
+              break;
+            case 'g':
+            case 'y':
+              ret.emplace_back(v[1]);
+              break;
+            case 'b':
+            case 'z':
+              ret.emplace_back(v[2]);
+              break;
+            case 'a':
+            case 'w':
+              ret.emplace_back(v[3]);
+              break;
+          }
+        return {std::move(ret)};
+      }
+      if (this->member == "x")
+        return v[0];
+      if (this->member == "y")
+        return v[1];
+      if (this->member == "z")
+        return v[2];
+      if (this->member == "w")
+        return v[3];
+      if (this->member == "r")
+        return v[0];
+      if (this->member == "g")
+        return v[1];
+      if (this->member == "b")
+        return v[2];
+      if (this->member == "a")
+        return v[3];
+      break;
+    case Value::Type::RANGE:
+      if (this->member == "begin")
+        return v[0];
+      if (this->member == "step")
+        return v[1];
+      if (this->member == "end")
+        return v[2];
+      break;
+    case Value::Type::OBJECT:
+      return v[this->member];
+    default:
+      break;
   }
   return Value::undefined.clone();
 }
 
-void MemberLookup::print(std::ostream& stream, const std::string&) const
-{
+void MemberLookup::print(std::ostream& stream, const std::string&) const {
   stream << *this->expr << "." << this->member;
 }
 
-FunctionDefinition::FunctionDefinition(Expression *expr, AssignmentList parameters, const Location& loc)
-  : Expression(loc), context(nullptr), parameters(std::move(parameters)), expr(expr)
-{
-}
+FunctionDefinition::FunctionDefinition(Expression* expr,
+                                       AssignmentList parameters,
+                                       const Location& loc)
+    : Expression(loc),
+      context(nullptr),
+      parameters(std::move(parameters)),
+      expr(expr) {}
 
-Value FunctionDefinition::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return FunctionPtr{FunctionType{context, expr, std::make_unique<AssignmentList>(parameters)}};
+Value FunctionDefinition::evaluate(
+    const std::shared_ptr<const Context>& context) const {
+  return FunctionPtr{FunctionType{
+      context, expr, std::make_unique<AssignmentList>(parameters)}};
 }
 
-void FunctionDefinition::print(std::ostream& stream, const std::string& indent) const
-{
+void FunctionDefinition::print(std::ostream& stream,
+                               const std::string& indent) const {
   stream << indent << "function(";
   bool first = true;
   for (const auto& parameter : parameters) {
@@ -434,8 +513,11 @@ void FunctionDefinition::print(std::ostream& stream, const std::string& indent)
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_err(const char *name, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Error, loc, context->documentRoot(), "Recursion detected calling function '%1$s'", name);
+static void NOINLINE print_err(const char* name,
+                               const Location& loc,
+                               const std::shared_ptr<const Context>& context) {
+  LOG(message_group::Error, loc, context->documentRoot(),
+      "Recursion detected calling function '%1$s'", name);
 }
 
 /**
@@ -445,16 +527,20 @@ static void NOINLINE print_err(const char *name, const Location& loc, const std:
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_trace(const FunctionCall *val, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Trace, val->location(), context->documentRoot(), "called by '%1$s'", val->get_name());
+static void NOINLINE
+print_trace(const FunctionCall* val,
+            const std::shared_ptr<const Context>& context) {
+  LOG(message_group::Trace, val->location(), context->documentRoot(),
+      "called by '%1$s'", val->get_name());
 }
 
-FunctionCall::FunctionCall(Expression *expr, AssignmentList args, const Location& loc)
-  : Expression(loc), expr(expr), arguments(std::move(args))
-{
+FunctionCall::FunctionCall(Expression* expr,
+                           AssignmentList args,
+                           const Location& loc)
+    : Expression(loc), expr(expr), arguments(std::move(args)) {
   if (typeid(*expr) == typeid(Lookup)) {
     isLookup = true;
-    const Lookup *lookup = static_cast<Lookup *>(expr);
+    const Lookup* lookup = static_cast<Lookup*>(expr);
     name = lookup->get_name();
   } else {
     isLookup = false;
@@ -466,8 +552,8 @@ FunctionCall::FunctionCall(Expression *expr, AssignmentList args, const Location
   }
 }
 
-boost::optional<CallableFunction> FunctionCall::evaluate_function_expression(const std::shared_ptr<const Context>& context) const
-{
+boost::optional<CallableFunction> FunctionCall::evaluate_function_expression(
+    const std::shared_ptr<const Context>& context) const {
   if (isLookup) {
     return context->lookup_function(name, location());
   } else {
@@ -475,44 +561,47 @@ boost::optional<CallableFunction> FunctionCall::evaluate_function_expression(con
     if (v.type() == Value::Type::FUNCTION) {
       return CallableFunction{std::move(v)};
     } else {
-      LOG(message_group::Warning, loc, context->documentRoot(), "Can't call function on %1$s", v.typeName());
+      LOG(message_group::Warning, loc, context->documentRoot(),
+          "Can't call function on %1$s", v.typeName());
       return boost::none;
     }
   }
 }
 
 struct SimplifiedExpression {
-  const Expression *expression;
+  const Expression* expression;
   boost::optional<ContextHandle<Context>> new_context = boost::none;
-  boost::optional<const FunctionCall *> new_active_function_call = boost::none;
+  boost::optional<const FunctionCall*> new_active_function_call = boost::none;
 };
 using SimplificationResult = std::variant<SimplifiedExpression, Value>;
 
-static SimplificationResult simplify_function_body(const Expression *expression, const std::shared_ptr<const Context>& context)
-{
+static SimplificationResult simplify_function_body(
+    const Expression* expression,
+    const std::shared_ptr<const Context>& context) {
   if (!expression) {
     return Value::undefined.clone();
   } else {
     const auto& type = typeid(*expression);
     if (type == typeid(TernaryOp)) {
-      const auto *ternary = static_cast<const TernaryOp *>(expression);
+      const auto* ternary = static_cast<const TernaryOp*>(expression);
       return SimplifiedExpression{ternary->evaluateStep(context)};
     } else if (type == typeid(Assert)) {
-      const auto *assertion = static_cast<const Assert *>(expression);
+      const auto* assertion = static_cast<const Assert*>(expression);
       return SimplifiedExpression{assertion->evaluateStep(context)};
     } else if (type == typeid(Echo)) {
-      const Echo *echo = static_cast<const Echo *>(expression);
+      const Echo* echo = static_cast<const Echo*>(expression);
       return SimplifiedExpression{echo->evaluateStep(context)};
     } else if (type == typeid(Let)) {
-      const Let *let = static_cast<const Let *>(expression);
+      const Let* let = static_cast<const Let*>(expression);
       ContextHandle<Context> let_context{Context::create<Context>(context)};
       let_context->apply_config_variables(*context);
-      return SimplifiedExpression{let->evaluateStep(let_context), std::move(let_context)};
+      return SimplifiedExpression{let->evaluateStep(let_context),
+                                  std::move(let_context)};
     } else if (type == typeid(FunctionCall)) {
-      const auto *call = static_cast<const FunctionCall *>(expression);
+      const auto* call = static_cast<const FunctionCall*>(expression);
 
-      const Expression *function_body;
-      const AssignmentList *required_parameters;
+      const Expression* function_body;
+      const AssignmentList* required_parameters;
       std::shared_ptr<const Context> defining_context;
 
       auto f = call->evaluate_function_expression(context);
@@ -521,18 +610,18 @@ static SimplificationResult simplify_function_body(const Expression *expression,
       } else {
         auto index = f->index();
         if (index == 0) {
-          return std::get<const BuiltinFunction *>(*f)->evaluate(context, call);
+          return std::get<const BuiltinFunction*>(*f)->evaluate(context, call);
         } else if (index == 1) {
           CallableUserFunction callable = std::get<CallableUserFunction>(*f);
           function_body = callable.function->expr.get();
           required_parameters = &callable.function->parameters;
           defining_context = callable.defining_context;
         } else {
-          const FunctionType *function;
+          const FunctionType* function;
           if (index == 2) {
             function = &std::get<Value>(*f).toFunction();
           } else if (index == 3) {
-            function = &std::get<const Value *>(*f)->toFunction();
+            function = &std::get<const Value*>(*f)->toFunction();
           } else {
             assert(false);
           }
@@ -541,10 +630,13 @@ static SimplificationResult simplify_function_body(const Expression *expression,
           defining_context = function->getContext();
         }
       }
-      ContextHandle<Context> body_context{Context::create<Context>(defining_context)};
+      ContextHandle<Context> body_context{
+          Context::create<Context>(defining_context)};
       body_context->apply_config_variables(*context);
       Arguments arguments{call->arguments, context};
-      Parameters parameters = Parameters::parse(std::move(arguments), call->location(), *required_parameters, defining_context);
+      Parameters parameters =
+          Parameters::parse(std::move(arguments), call->location(),
+                            *required_parameters, defining_context);
       body_context->apply_variables(std::move(parameters).to_context_frame());
 
       return SimplifiedExpression{function_body, std::move(body_context), call};
@@ -554,8 +646,8 @@ static SimplificationResult simplify_function_body(const Expression *expression,
   }
 }
 
-Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value FunctionCall::evaluate(
+    const std::shared_ptr<const Context>& context) const {
   const auto& name = get_name();
   if (StackCheck::inst().check()) {
     print_err(name.c_str(), loc, context);
@@ -567,18 +659,19 @@ Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) cons
   // recurse. If the former, substitute the function body for expr,
   // thereby implementing tail recursion optimization.
   unsigned int recursion_depth = 0;
-  const FunctionCall *current_call = this;
+  const FunctionCall* current_call = this;
 
   ContextHandle<Context> expression_context{Context::create<Context>(context)};
-  const Expression *expression = this;
+  const Expression* expression = this;
   while (true) {
     try {
       auto result = simplify_function_body(expression, *expression_context);
-      if (Value *value = std::get_if<Value>(&result)) {
+      if (Value* value = std::get_if<Value>(&result)) {
         return std::move(*value);
       }
 
-      SimplifiedExpression *simplified_expression = std::get_if<SimplifiedExpression>(&result);
+      SimplifiedExpression* simplified_expression =
+          std::get_if<SimplifiedExpression>(&result);
       assert(simplified_expression);
 
       expression = simplified_expression->expression;
@@ -588,8 +681,11 @@ Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) cons
       if (simplified_expression->new_active_function_call) {
         current_call = *simplified_expression->new_active_function_call;
         if (recursion_depth++ == 1000000) {
-          LOG(message_group::Error, expression->location(), expression_context->documentRoot(), "Recursion detected calling function '%1$s'", current_call->name);
-          throw RecursionException::create("function", current_call->name, current_call->location());
+          LOG(message_group::Error, expression->location(),
+              expression_context->documentRoot(),
+              "Recursion detected calling function '%1$s'", current_call->name);
+          throw RecursionException::create("function", current_call->name,
+                                           current_call->location());
         }
       }
     } catch (EvaluationException& e) {
@@ -602,13 +698,14 @@ Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) cons
   }
 }
 
-void FunctionCall::print(std::ostream& stream, const std::string&) const
-{
+void FunctionCall::print(std::ostream& stream, const std::string&) const {
   stream << this->get_name() << "(" << this->arguments << ")";
 }
 
-Expression *FunctionCall::create(const std::string& funcname, const AssignmentList& arglist, Expression *expr, const Location& loc)
-{
+Expression* FunctionCall::create(const std::string& funcname,
+                                 const AssignmentList& arglist,
+                                 Expression* expr,
+                                 const Location& loc) {
   if (funcname == "assert") {
     return new Assert(arglist, expr, loc);
   } else if (funcname == "echo") {
@@ -618,19 +715,18 @@ Expression *FunctionCall::create(const std::string& funcname, const AssignmentLi
   }
   return nullptr;
   // TODO: Generate error/warning if expr != 0?
-  //return new FunctionCall(funcname, arglist, loc);
+  // return new FunctionCall(funcname, arglist, loc);
 }
 
-Assert::Assert(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
+Assert::Assert(AssignmentList args, Expression* expr, const Location& loc)
+    : Expression(loc), arguments(std::move(args)), expr(expr) {}
 
-}
-
-void Assert::performAssert(const AssignmentList& arguments, const Location& location, const std::shared_ptr<const Context>& context)
-{
-  Parameters parameters = Parameters::parse(Arguments(arguments, context), location, {"condition"}, {"message"});
-  const Expression *conditionExpression = nullptr;
+void Assert::performAssert(const AssignmentList& arguments,
+                           const Location& location,
+                           const std::shared_ptr<const Context>& context) {
+  Parameters parameters = Parameters::parse(
+      Arguments(arguments, context), location, {"condition"}, {"message"});
+  const Expression* conditionExpression = nullptr;
   for (const auto& argument : arguments) {
     if (argument->getName() == "" || argument->getName() == "condition") {
       conditionExpression = argument->getExpr().get();
@@ -639,71 +735,74 @@ void Assert::performAssert(const AssignmentList& arguments, const Location& loca
   }
 
   if (!parameters["condition"].toBool()) {
-    std::string conditionString = conditionExpression ? STR(" '", *conditionExpression, "'") : "";
-    std::string messageString = parameters.contains("message") ? (": " + parameters["message"].toEchoStringNoThrow()) : "";
-    LOG(message_group::Error, location, context->documentRoot(), "Assertion%1$s failed%2$s", conditionString, messageString);
+    std::string conditionString =
+        conditionExpression ? STR(" '", *conditionExpression, "'") : "";
+    std::string messageString =
+        parameters.contains("message")
+            ? (": " + parameters["message"].toEchoStringNoThrow())
+            : "";
+    LOG(message_group::Error, location, context->documentRoot(),
+        "Assertion%1$s failed%2$s", conditionString, messageString);
     throw AssertionFailedException("Assertion Failed", location);
   }
 }
 
-const Expression *Assert::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
+const Expression* Assert::evaluateStep(
+    const std::shared_ptr<const Context>& context) const {
   performAssert(this->arguments, this->loc, context);
   return expr.get();
 }
 
-Value Assert::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const Expression *nextexpr = evaluateStep(context);
+Value Assert::evaluate(const std::shared_ptr<const Context>& context) const {
+  const Expression* nextexpr = evaluateStep(context);
   return nextexpr ? nextexpr->evaluate(context) : Value::undefined.clone();
 }
 
-void Assert::print(std::ostream& stream, const std::string&) const
-{
+void Assert::print(std::ostream& stream, const std::string&) const {
   stream << "assert(" << this->arguments << ")";
-  if (this->expr) stream << " " << *this->expr;
+  if (this->expr)
+    stream << " " << *this->expr;
 }
 
-Echo::Echo(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
-
-}
+Echo::Echo(AssignmentList args, Expression* expr, const Location& loc)
+    : Expression(loc), arguments(std::move(args)), expr(expr) {}
 
-const Expression *Echo::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
+const Expression* Echo::evaluateStep(
+    const std::shared_ptr<const Context>& context) const {
   Arguments arguments{this->arguments, context};
   LOG(message_group::Echo, "%1$s", STR(arguments));
   return expr.get();
 }
 
-Value Echo::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const Expression *nextexpr = evaluateStep(context);
+Value Echo::evaluate(const std::shared_ptr<const Context>& context) const {
+  const Expression* nextexpr = evaluateStep(context);
   return nextexpr ? nextexpr->evaluate(context) : Value::undefined.clone();
 }
 
-void Echo::print(std::ostream& stream, const std::string&) const
-{
+void Echo::print(std::ostream& stream, const std::string&) const {
   stream << "echo(" << this->arguments << ")";
-  if (this->expr) stream << " " << *this->expr;
+  if (this->expr)
+    stream << " " << *this->expr;
 }
 
-Let::Let(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
-}
+Let::Let(AssignmentList args, Expression* expr, const Location& loc)
+    : Expression(loc), arguments(std::move(args)), expr(expr) {}
 
-void Let::doSequentialAssignment(const AssignmentList& assignments, const Location& location, ContextHandle<Context>& targetContext)
-{
+void Let::doSequentialAssignment(const AssignmentList& assignments,
+                                 const Location& location,
+                                 ContextHandle<Context>& targetContext) {
   std::set<std::string> seen;
   for (const auto& assignment : assignments) {
     Value value = assignment->getExpr()->evaluate(*targetContext);
     if (assignment->getName().empty()) {
-      LOG(message_group::Warning, location, targetContext->documentRoot(), "Assignment without variable name %1$s", value.toEchoStringNoThrow());
+      LOG(message_group::Warning, location, targetContext->documentRoot(),
+          "Assignment without variable name %1$s", value.toEchoStringNoThrow());
     } else if (seen.find(assignment->getName()) != seen.end()) {
-      // TODO Should maybe quote the entire assignment with a new quoteExpr() or quoteStmt().
-      LOG(message_group::Warning, location, targetContext->documentRoot(), "Ignoring duplicate variable assignment %1$s = %2$s", quoteVar(assignment->getName()), value.toEchoStringNoThrow());
+      // TODO Should maybe quote the entire assignment with a new quoteExpr() or
+      // quoteStmt().
+      LOG(message_group::Warning, location, targetContext->documentRoot(),
+          "Ignoring duplicate variable assignment %1$s = %2$s",
+          quoteVar(assignment->getName()), value.toEchoStringNoThrow());
     } else {
       targetContext->set_variable(assignment->getName(), std::move(value));
       seen.insert(assignment->getName());
@@ -711,42 +810,41 @@ void Let::doSequentialAssignment(const AssignmentList& assignments, const Locati
   }
 }
 
-ContextHandle<Context> Let::sequentialAssignmentContext(const AssignmentList& assignments, const Location& location, const std::shared_ptr<const Context>& context)
-{
+ContextHandle<Context> Let::sequentialAssignmentContext(
+    const AssignmentList& assignments,
+    const Location& location,
+    const std::shared_ptr<const Context>& context) {
   ContextHandle<Context> letContext{Context::create<Context>(context)};
   doSequentialAssignment(assignments, location, letContext);
   return letContext;
 }
 
-const Expression *Let::evaluateStep(ContextHandle<Context>& targetContext) const
-{
+const Expression* Let::evaluateStep(
+    ContextHandle<Context>& targetContext) const {
   doSequentialAssignment(this->arguments, this->location(), targetContext);
   return this->expr.get();
 }
 
-Value Let::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Let::evaluate(const std::shared_ptr<const Context>& context) const {
   ContextHandle<Context> letContext{Context::create<Context>(context)};
   return evaluateStep(letContext)->evaluate(*letContext);
 }
 
-void Let::print(std::ostream& stream, const std::string&) const
-{
+void Let::print(std::ostream& stream, const std::string&) const {
   stream << "let(" << this->arguments << ") " << *expr;
 }
 
-ListComprehension::ListComprehension(const Location& loc) : Expression(loc)
-{
-}
+ListComprehension::ListComprehension(const Location& loc) : Expression(loc) {}
 
-LcIf::LcIf(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc)
-  : ListComprehension(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr)
-{
-}
+LcIf::LcIf(Expression* cond,
+           Expression* ifexpr,
+           Expression* elseexpr,
+           const Location& loc)
+    : ListComprehension(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr) {}
 
-Value LcIf::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const std::shared_ptr<Expression>& expr = this->cond->evaluate(context).toBool() ? this->ifexpr : this->elseexpr;
+Value LcIf::evaluate(const std::shared_ptr<const Context>& context) const {
+  const std::shared_ptr<Expression>& expr =
+      this->cond->evaluate(context).toBool() ? this->ifexpr : this->elseexpr;
   if (expr) {
     return expr->evaluate(context);
   } else {
@@ -754,49 +852,54 @@ Value LcIf::evaluate(const std::shared_ptr<const Context>& context) const
   }
 }
 
-void LcIf::print(std::ostream& stream, const std::string&) const
-{
+void LcIf::print(std::ostream& stream, const std::string&) const {
   stream << "if(" << *this->cond << ") (" << *this->ifexpr << ")";
   if (this->elseexpr) {
     stream << " else (" << *this->elseexpr << ")";
   }
 }
 
-LcEach::LcEach(Expression *expr, const Location& loc) : ListComprehension(loc), expr(expr)
-{
-}
+LcEach::LcEach(Expression* expr, const Location& loc)
+    : ListComprehension(loc), expr(expr) {}
 
-// Need this for recurring into already embedded vectors, and performing "each" on their elements
+// Need this for recurring into already embedded vectors, and performing "each"
+// on their elements
 //    Context is only passed along for the possible use in Range warning.
-Value LcEach::evalRecur(Value&& v, const std::shared_ptr<const Context>& context) const
-{
+Value LcEach::evalRecur(Value&& v,
+                        const std::shared_ptr<const Context>& context) const {
   if (v.type() == Value::Type::RANGE) {
     const RangeType& range = v.toRange();
     uint32_t steps = range.numValues();
     if (steps >= 1000000) {
-      LOG(message_group::Warning, loc, context->documentRoot(), "Bad range parameter in for statement: too many elements (%1$lu)", steps);
+      LOG(message_group::Warning, loc, context->documentRoot(),
+          "Bad range parameter in for statement: too many elements (%1$lu)",
+          steps);
     } else {
       EmbeddedVectorType vec(context->session());
       vec.reserve(range.numValues());
-      for (double d : range) vec.emplace_back(d);
+      for (double d : range)
+        vec.emplace_back(d);
       return {std::move(vec)};
     }
   } else if (v.type() == Value::Type::VECTOR) {
-    // Safe to move the overall vector ptr since we have a temporary value (could be a copy, or constructed just for us, doesn't matter)
+    // Safe to move the overall vector ptr since we have a temporary value
+    // (could be a copy, or constructed just for us, doesn't matter)
     auto vec = EmbeddedVectorType(std::move(v.toVectorNonConst()));
     return {std::move(vec)};
   } else if (v.type() == Value::Type::EMBEDDED_VECTOR) {
     EmbeddedVectorType vec(context->session());
     vec.reserve(v.toEmbeddedVector().size());
-    // Not safe to move values out of a vector, since it's shared_ptr maye be shared with another Value,
-    // which should remain constant
-    for (const auto& val : v.toEmbeddedVector()) vec.emplace_back(evalRecur(val.clone(), context) );
+    // Not safe to move values out of a vector, since it's shared_ptr maye be
+    // shared with another Value, which should remain constant
+    for (const auto& val : v.toEmbeddedVector())
+      vec.emplace_back(evalRecur(val.clone(), context));
     return {std::move(vec)};
   } else if (v.type() == Value::Type::STRING) {
     EmbeddedVectorType vec(context->session());
     auto& wrapper = v.toStrUtf8Wrapper();
     vec.reserve(wrapper.size());
-    for (auto ch : wrapper) vec.emplace_back(std::move(ch));
+    for (auto ch : wrapper)
+      vec.emplace_back(std::move(ch));
     return {std::move(vec)};
   } else if (v.type() != Value::Type::UNDEFINED) {
     return std::move(v);
@@ -804,58 +907,56 @@ Value LcEach::evalRecur(Value&& v, const std::shared_ptr<const Context>& context
   return EmbeddedVectorType::Empty();
 }
 
-Value LcEach::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value LcEach::evaluate(const std::shared_ptr<const Context>& context) const {
   return evalRecur(this->expr->evaluate(context), context);
 }
 
-void LcEach::print(std::ostream& stream, const std::string&) const
-{
+void LcEach::print(std::ostream& stream, const std::string&) const {
   stream << "each (" << *this->expr << ")";
 }
 
-LcFor::LcFor(AssignmentList args, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), expr(expr)
-{
-}
+LcFor::LcFor(AssignmentList args, Expression* expr, const Location& loc)
+    : ListComprehension(loc), arguments(std::move(args)), expr(expr) {}
 
-static inline ContextHandle<Context> forContext(const std::shared_ptr<const Context>& context, const std::string& name, Value value)
-{
+static inline ContextHandle<Context> forContext(
+    const std::shared_ptr<const Context>& context,
+    const std::string& name,
+    Value value) {
   ContextHandle<Context> innerContext{Context::create<Context>(context)};
   innerContext->set_variable(name, std::move(value));
   return innerContext;
 }
 
 static void doForEach(
-  const AssignmentList& assignments,
-  const Location& location,
-  const std::function<void(const std::shared_ptr<const Context>&)>& operation,
-  size_t assignment_index,
-  const std::shared_ptr<const Context>& context,
-  const std::function<void(size_t)> *pReserve = nullptr
-  ) {
+    const AssignmentList& assignments,
+    const Location& location,
+    const std::function<void(const std::shared_ptr<const Context>&)>& operation,
+    size_t assignment_index,
+    const std::shared_ptr<const Context>& context,
+    const std::function<void(size_t)>* pReserve = nullptr) {
   if (assignment_index >= assignments.size()) {
     operation(context);
     return;
   }
 
   const std::string& variable_name = assignments[assignment_index]->getName();
-  Value variable_values = assignments[assignment_index]->getExpr()->evaluate(context);
+  Value variable_values =
+      assignments[assignment_index]->getExpr()->evaluate(context);
 
   if (variable_values.type() == Value::Type::RANGE) {
     const RangeType& range = variable_values.toRange();
     uint32_t steps = range.numValues();
     if (steps >= 1000000) {
       LOG(message_group::Warning, location, context->documentRoot(),
-          "Bad range parameter in for statement: too many elements (%1$lu)", steps);
+          "Bad range parameter in for statement: too many elements (%1$lu)",
+          steps);
     } else {
       if (pReserve) {
         (*pReserve)(steps);
       }
       for (double value : range) {
         doForEach(assignments, location, operation, assignment_index + 1,
-                  *forContext(context, variable_name, value)
-                  );
+                  *forContext(context, variable_name, value));
       }
     }
   } else if (variable_values.type() == Value::Type::VECTOR) {
@@ -865,8 +966,7 @@ static void doForEach(
     }
     for (const auto& value : vec) {
       doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, value.clone())
-                );
+                *forContext(context, variable_name, value.clone()));
     }
   } else if (variable_values.type() == Value::Type::OBJECT) {
     auto& keys = variable_values.toObject().keys();
@@ -875,8 +975,7 @@ static void doForEach(
     }
     for (auto key : keys) {
       doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, key)
-                );
+                *forContext(context, variable_name, key));
     }
   } else if (variable_values.type() == Value::Type::STRING) {
     auto& wrapper = variable_values.toStrUtf8Wrapper();
@@ -885,57 +984,68 @@ static void doForEach(
     }
     for (auto value : wrapper) {
       doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, Value(std::move(value)))
-                );
+                *forContext(context, variable_name, Value(std::move(value))));
     }
   } else if (variable_values.type() != Value::Type::UNDEFINED) {
     doForEach(assignments, location, operation, assignment_index + 1,
-              *forContext(context, variable_name, std::move(variable_values))
-              );
+              *forContext(context, variable_name, std::move(variable_values)));
   }
 }
 
-void LcFor::forEach(const AssignmentList& assignments, const Location& loc, const std::shared_ptr<const Context>& context, const std::function<void(const std::shared_ptr<const Context>&)>& operation, const std::function<void(size_t)> *pReserve)
-{
+void LcFor::forEach(
+    const AssignmentList& assignments,
+    const Location& loc,
+    const std::shared_ptr<const Context>& context,
+    const std::function<void(const std::shared_ptr<const Context>&)>& operation,
+    const std::function<void(size_t)>* pReserve) {
   doForEach(assignments, loc, operation, 0, context, pReserve);
 }
 
-Value LcFor::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value LcFor::evaluate(const std::shared_ptr<const Context>& context) const {
   EmbeddedVectorType vec(context->session());
   std::function<void(size_t)> reserve = [&vec](size_t capacity) {
-      vec.reserve(capacity);
-    };
-  forEach(this->arguments, this->loc, context,
-          [&vec, expression = expr.get()] (const std::shared_ptr<const Context>& iterationContext) {
-    vec.emplace_back(expression->evaluate(iterationContext));
-  }, &reserve);
+    vec.reserve(capacity);
+  };
+  forEach(
+      this->arguments, this->loc, context,
+      [&vec, expression = expr.get()](
+          const std::shared_ptr<const Context>& iterationContext) {
+        vec.emplace_back(expression->evaluate(iterationContext));
+      },
+      &reserve);
   return {std::move(vec)};
 }
 
-void LcFor::print(std::ostream& stream, const std::string&) const
-{
+void LcFor::print(std::ostream& stream, const std::string&) const {
   stream << "for(" << this->arguments << ") (" << *this->expr << ")";
 }
 
-LcForC::LcForC(AssignmentList args, AssignmentList incrargs, Expression *cond, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), incr_arguments(std::move(incrargs)), cond(cond), expr(expr)
-{
-}
+LcForC::LcForC(AssignmentList args,
+               AssignmentList incrargs,
+               Expression* cond,
+               Expression* expr,
+               const Location& loc)
+    : ListComprehension(loc),
+      arguments(std::move(args)),
+      incr_arguments(std::move(incrargs)),
+      cond(cond),
+      expr(expr) {}
 
-Value LcForC::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value LcForC::evaluate(const std::shared_ptr<const Context>& context) const {
   EmbeddedVectorType output(context->session());
 
-  ContextHandle<Context> initialContext{Let::sequentialAssignmentContext(this->arguments, this->location(), context)};
-  ContextHandle<Context> currentContext{Context::create<Context>(*initialContext)};
+  ContextHandle<Context> initialContext{Let::sequentialAssignmentContext(
+      this->arguments, this->location(), context)};
+  ContextHandle<Context> currentContext{
+      Context::create<Context>(*initialContext)};
 
   unsigned int counter = 0;
   while (this->cond->evaluate(*currentContext).toBool()) {
     output.emplace_back(this->expr->evaluate(*currentContext));
 
     if (counter++ == 1000000) {
-      LOG(message_group::Error, loc, context->documentRoot(), "For loop counter exceeded limit");
+      LOG(message_group::Error, loc, context->documentRoot(),
+          "For loop counter exceeded limit");
       throw LoopCntException::create("for", loc);
     }
 
@@ -950,33 +1060,27 @@ Value LcForC::evaluate(const std::shared_ptr<const Context>& context) const
      * captured context references in lambda functions.
      * So, we reparent the next context to the initial context.
      */
-    ContextHandle<Context> nextContext{Let::sequentialAssignmentContext(this->incr_arguments, this->location(), *currentContext)};
+    ContextHandle<Context> nextContext{Let::sequentialAssignmentContext(
+        this->incr_arguments, this->location(), *currentContext)};
     currentContext = std::move(nextContext);
     currentContext->setParent(*initialContext);
   }
   return {std::move(output)};
 }
 
-void LcForC::print(std::ostream& stream, const std::string&) const
-{
-  stream
-    << "for(" << this->arguments
-    << ";" << *this->cond
-    << ";" << this->incr_arguments
-    << ") " << *this->expr;
+void LcForC::print(std::ostream& stream, const std::string&) const {
+  stream << "for(" << this->arguments << ";" << *this->cond << ";"
+         << this->incr_arguments << ") " << *this->expr;
 }
 
-LcLet::LcLet(AssignmentList args, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), expr(expr)
-{
-}
+LcLet::LcLet(AssignmentList args, Expression* expr, const Location& loc)
+    : ListComprehension(loc), arguments(std::move(args)), expr(expr) {}
 
-Value LcLet::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return this->expr->evaluate(*Let::sequentialAssignmentContext(this->arguments, this->location(), context));
+Value LcLet::evaluate(const std::shared_ptr<const Context>& context) const {
+  return this->expr->evaluate(*Let::sequentialAssignmentContext(
+      this->arguments, this->location(), context));
 }
 
-void LcLet::print(std::ostream& stream, const std::string&) const
-{
+void LcLet::print(std::ostream& stream, const std::string&) const {
   stream << "let(" << this->arguments << ") (" << *this->expr << ")";
 }
diff --git a/src/core/Expression.h b/src/core/Expression.h
index b0800c2a4..df4ff6eb6 100644
--- a/src/core/Expression.h
+++ b/src/core/Expression.h
@@ -1,52 +1,49 @@
 #pragma once
 
-#include <ostream>
-#include <utility>
+#include <boost/logic/tribool.hpp>
 #include <cstddef>
 #include <functional>
+#include <memory>
+#include <ostream>
 #include <string>
+#include <utility>
 #include <vector>
-#include <memory>
-#include <boost/logic/tribool.hpp>
-#include "core/Assignment.h"
 #include "core/AST.h"
-#include "core/function.h"
+#include "core/Assignment.h"
 #include "core/Value.h"
+#include "core/function.h"
 
-template <class T> class ContextHandle;
+template <class T>
+class ContextHandle;
 
-class Expression : public ASTNode
-{
-public:
+class Expression : public ASTNode {
+ public:
   Expression(const Location& loc) : ASTNode(loc) {}
   [[nodiscard]] virtual bool isLiteral() const;
-  [[nodiscard]] virtual Value evaluate(const std::shared_ptr<const Context>& context) const = 0;
-  Value checkUndef(Value&& val, const std::shared_ptr<const Context>& context) const;
+  [[nodiscard]] virtual Value evaluate(
+      const std::shared_ptr<const Context>& context) const = 0;
+  Value checkUndef(Value&& val,
+                   const std::shared_ptr<const Context>& context) const;
 };
 
-class UnaryOp : public Expression
-{
-public:
-  enum class Op {
-    Not,
-    BinaryNot,
-    Negate
-  };
+class UnaryOp : public Expression {
+ public:
+  enum class Op { Not, BinaryNot, Negate };
   [[nodiscard]] bool isLiteral() const override;
-  UnaryOp(Op op, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+  UnaryOp(Op op, Expression* expr, const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
 
-private:
-  [[nodiscard]] const char *opString() const;
+ private:
+  [[nodiscard]] const char* opString() const;
 
   Op op;
   std::shared_ptr<Expression> expr;
 };
 
-class BinaryOp : public Expression
-{
-public:
+class BinaryOp : public Expression {
+ public:
   enum class Op {
     LogicalAnd,
     LogicalOr,
@@ -68,243 +65,309 @@ public:
     NotEqual
   };
 
-  BinaryOp(Expression *left, Op op, Expression *right, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+  BinaryOp(Expression* left, Op op, Expression* right, const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
 
-private:
-  [[nodiscard]] const char *opString() const;
+ private:
+  [[nodiscard]] const char* opString() const;
 
   Op op;
   std::shared_ptr<Expression> left;
   std::shared_ptr<Expression> right;
 };
 
-class TernaryOp : public Expression
-{
-public:
-  TernaryOp(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class TernaryOp : public Expression {
+ public:
+  TernaryOp(Expression* cond,
+            Expression* ifexpr,
+            Expression* elseexpr,
+            const Location& loc);
+  [[nodiscard]] const Expression* evaluateStep(
+      const std::shared_ptr<const Context>& context) const;
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   std::shared_ptr<Expression> cond;
   std::shared_ptr<Expression> ifexpr;
   std::shared_ptr<Expression> elseexpr;
 };
 
-class ArrayLookup : public Expression
-{
-public:
-  ArrayLookup(Expression *array, Expression *index, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class ArrayLookup : public Expression {
+ public:
+  ArrayLookup(Expression* array, Expression* index, const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   std::shared_ptr<Expression> array;
   std::shared_ptr<Expression> index;
 };
 
-class Literal : public Expression
-{
-public:
-  Literal(const Location& loc = Location::NONE) : Expression(loc), value(Value::undefined.clone()) { }
-  Literal(Value val, const Location& loc = Location::NONE) : Expression(loc), value(std::move(val)) { }
-  [[nodiscard]] bool isBool() const { return value.type() == Value::Type::BOOL; }
+class Literal : public Expression {
+ public:
+  Literal(const Location& loc = Location::NONE)
+      : Expression(loc), value(Value::undefined.clone()) {}
+  Literal(Value val, const Location& loc = Location::NONE)
+      : Expression(loc), value(std::move(val)) {}
+  [[nodiscard]] bool isBool() const {
+    return value.type() == Value::Type::BOOL;
+  }
   [[nodiscard]] bool toBool() const { return value.toBool(); }
-  [[nodiscard]] bool isDouble() const { return value.type() == Value::Type::NUMBER; }
+  [[nodiscard]] bool isDouble() const {
+    return value.type() == Value::Type::NUMBER;
+  }
   [[nodiscard]] double toDouble() const { return value.toDouble(); }
-  [[nodiscard]] bool isString() const { return value.type() == Value::Type::STRING; }
-  [[nodiscard]] const std::string& toString() const { return value.toStrUtf8Wrapper().toString(); }
-  [[nodiscard]] bool isUndefined() const { return value.type() == Value::Type::UNDEFINED; }
+  [[nodiscard]] bool isString() const {
+    return value.type() == Value::Type::STRING;
+  }
+  [[nodiscard]] const std::string& toString() const {
+    return value.toStrUtf8Wrapper().toString();
+  }
+  [[nodiscard]] bool isUndefined() const {
+    return value.type() == Value::Type::UNDEFINED;
+  }
 
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
   [[nodiscard]] bool isLiteral() const override { return true; }
-private:
+
+ private:
   const Value value;
 };
 
-class Range : public Expression
-{
-public:
-  Range(Expression *begin, Expression *end, const Location& loc);
-  Range(Expression *begin, Expression *step, Expression *end, const Location& loc);
-  [[nodiscard]] const Expression *getBegin() const { return begin.get(); }
-  [[nodiscard]] const Expression *getStep() const { return step.get(); }
-  [[nodiscard]] const Expression *getEnd() const { return end.get(); }
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class Range : public Expression {
+ public:
+  Range(Expression* begin, Expression* end, const Location& loc);
+  Range(Expression* begin,
+        Expression* step,
+        Expression* end,
+        const Location& loc);
+  [[nodiscard]] const Expression* getBegin() const { return begin.get(); }
+  [[nodiscard]] const Expression* getStep() const { return step.get(); }
+  [[nodiscard]] const Expression* getEnd() const { return end.get(); }
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
   [[nodiscard]] bool isLiteral() const override;
-private:
+
+ private:
   std::shared_ptr<Expression> begin;
   std::shared_ptr<Expression> step;
   std::shared_ptr<Expression> end;
 };
 
-class Vector : public Expression
-{
-public:
+class Vector : public Expression {
+ public:
   Vector(const Location& loc);
-  const std::vector<std::shared_ptr<Expression>>& getChildren() const { return children; }
+  const std::vector<std::shared_ptr<Expression>>& getChildren() const {
+    return children;
+  }
   Value evaluate(const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-  void emplace_back(Expression *expr);
+  void emplace_back(Expression* expr);
   bool isLiteral() const override;
-private:
+
+ private:
   std::vector<std::shared_ptr<Expression>> children;
-  mutable boost::tribool literal_flag; // cache if already computed
+  mutable boost::tribool literal_flag;  // cache if already computed
 };
 
-class Lookup : public Expression
-{
-public:
+class Lookup : public Expression {
+ public:
   Lookup(std::string name, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
   [[nodiscard]] const std::string& get_name() const { return name; }
-private:
+
+ private:
   std::string name;
 };
 
-class MemberLookup : public Expression
-{
-public:
-  MemberLookup(Expression *expr, std::string member, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class MemberLookup : public Expression {
+ public:
+  MemberLookup(Expression* expr, std::string member, const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   std::shared_ptr<Expression> expr;
   std::string member;
 };
 
-class FunctionCall : public Expression
-{
-public:
-  FunctionCall(Expression *expr, AssignmentList arglist, const Location& loc);
-  [[nodiscard]] boost::optional<CallableFunction> evaluate_function_expression(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class FunctionCall : public Expression {
+ public:
+  FunctionCall(Expression* expr, AssignmentList arglist, const Location& loc);
+  [[nodiscard]] boost::optional<CallableFunction> evaluate_function_expression(
+      const std::shared_ptr<const Context>& context) const;
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
   [[nodiscard]] const std::string& get_name() const { return name; }
-  static Expression *create(const std::string& funcname, const AssignmentList& arglist, Expression *expr, const Location& loc);
-public:
+  static Expression* create(const std::string& funcname,
+                            const AssignmentList& arglist,
+                            Expression* expr,
+                            const Location& loc);
+
+ public:
   bool isLookup;
   std::string name;
   std::shared_ptr<Expression> expr;
   AssignmentList arguments;
 };
 
-class FunctionDefinition : public Expression
-{
-public:
-  FunctionDefinition(Expression *expr, AssignmentList parameters, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class FunctionDefinition : public Expression {
+ public:
+  FunctionDefinition(Expression* expr,
+                     AssignmentList parameters,
+                     const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-public:
+
+ public:
   std::shared_ptr<const Context> context;
   AssignmentList parameters;
   std::shared_ptr<Expression> expr;
 };
 
-class Assert : public Expression
-{
-public:
-  Assert(AssignmentList args, Expression *expr, const Location& loc);
-  static void performAssert(const AssignmentList& arguments, const Location& location, const std::shared_ptr<const Context>& context);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class Assert : public Expression {
+ public:
+  Assert(AssignmentList args, Expression* expr, const Location& loc);
+  static void performAssert(const AssignmentList& arguments,
+                            const Location& location,
+                            const std::shared_ptr<const Context>& context);
+  [[nodiscard]] const Expression* evaluateStep(
+      const std::shared_ptr<const Context>& context) const;
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
 
-class Echo : public Expression
-{
-public:
-  Echo(AssignmentList args, Expression *expr, const Location& loc);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class Echo : public Expression {
+ public:
+  Echo(AssignmentList args, Expression* expr, const Location& loc);
+  [[nodiscard]] const Expression* evaluateStep(
+      const std::shared_ptr<const Context>& context) const;
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
 
-class Let : public Expression
-{
-public:
-  Let(AssignmentList args, Expression *expr, const Location& loc);
-  static void doSequentialAssignment(const AssignmentList& assignments, const Location& location, ContextHandle<Context>& targetContext);
-  static ContextHandle<Context> sequentialAssignmentContext(const AssignmentList& assignments, const Location& location, const std::shared_ptr<const Context>& context);
-  const Expression *evaluateStep(ContextHandle<Context>& targetContext) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class Let : public Expression {
+ public:
+  Let(AssignmentList args, Expression* expr, const Location& loc);
+  static void doSequentialAssignment(const AssignmentList& assignments,
+                                     const Location& location,
+                                     ContextHandle<Context>& targetContext);
+  static ContextHandle<Context> sequentialAssignmentContext(
+      const AssignmentList& assignments,
+      const Location& location,
+      const std::shared_ptr<const Context>& context);
+  const Expression* evaluateStep(ContextHandle<Context>& targetContext) const;
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
 
-class ListComprehension : public Expression
-{
-public:
+class ListComprehension : public Expression {
+ public:
   ListComprehension(const Location& loc);
 };
 
-class LcIf : public ListComprehension
-{
-public:
-  LcIf(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class LcIf : public ListComprehension {
+ public:
+  LcIf(Expression* cond,
+       Expression* ifexpr,
+       Expression* elseexpr,
+       const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   std::shared_ptr<Expression> cond;
   std::shared_ptr<Expression> ifexpr;
   std::shared_ptr<Expression> elseexpr;
 };
 
-class LcFor : public ListComprehension
-{
-public:
-  LcFor(AssignmentList args, Expression *expr, const Location& loc);
-  static void forEach(const AssignmentList& assignments, const Location& loc, const std::shared_ptr<const Context>& context, const std::function<void(const std::shared_ptr<const Context>&)>& operation, const std::function<void(size_t)> *pReserve = nullptr);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class LcFor : public ListComprehension {
+ public:
+  LcFor(AssignmentList args, Expression* expr, const Location& loc);
+  static void forEach(
+      const AssignmentList& assignments,
+      const Location& loc,
+      const std::shared_ptr<const Context>& context,
+      const std::function<void(const std::shared_ptr<const Context>&)>&
+          operation,
+      const std::function<void(size_t)>* pReserve = nullptr);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
 
-class LcForC : public ListComprehension
-{
-public:
-  LcForC(AssignmentList args, AssignmentList incrargs, Expression *cond, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class LcForC : public ListComprehension {
+ public:
+  LcForC(AssignmentList args,
+         AssignmentList incrargs,
+         Expression* cond,
+         Expression* expr,
+         const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   AssignmentList arguments;
   AssignmentList incr_arguments;
   std::shared_ptr<Expression> cond;
   std::shared_ptr<Expression> expr;
 };
 
-class LcEach : public ListComprehension
-{
-public:
-  LcEach(Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class LcEach : public ListComprehension {
+ public:
+  LcEach(Expression* expr, const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
-  Value evalRecur(Value&& v, const std::shared_ptr<const Context>& context) const;
+
+ private:
+  Value evalRecur(Value&& v,
+                  const std::shared_ptr<const Context>& context) const;
   std::shared_ptr<Expression> expr;
 };
 
-class LcLet : public ListComprehension
-{
-public:
-  LcLet(AssignmentList args, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
+class LcLet : public ListComprehension {
+ public:
+  LcLet(AssignmentList args, Expression* expr, const Location& loc);
+  [[nodiscard]] Value evaluate(
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-private:
+
+ private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
diff --git a/src/core/FreetypeRenderer.cc b/src/core/FreetypeRenderer.cc
index 892ddb859..28c0bf997 100644
--- a/src/core/FreetypeRenderer.cc
+++ b/src/core/FreetypeRenderer.cc
@@ -26,14 +26,13 @@
 #include "core/FreetypeRenderer.h"
 
 #include <algorithm>
-#include <limits>
-#include <cstdint>
-#include <memory>
 #include <cmath>
+#include <cstdint>
 #include <cstdio>
+#include <limits>
+#include <memory>
 #include <vector>
 
-
 #include <fontconfig/fontconfig.h>
 #include <hb-ft.h>
 
@@ -46,16 +45,18 @@
 
 #include FT_OUTLINE_H
 // NOLINTNEXTLINE(bugprone-macro-parentheses)
-#define SCRIPT_UNTAG(tag)   ((uint8_t)((tag) >> 24)) % ((uint8_t)((tag) >> 16)) % ((uint8_t)((tag) >> 8)) % ((uint8_t)(tag))
+#define SCRIPT_UNTAG(tag)                               \
+  ((uint8_t)((tag) >> 24)) % ((uint8_t)((tag) >> 16)) % \
+      ((uint8_t)((tag) >> 8)) % ((uint8_t)(tag))
 
-static inline Vector2d get_scaled_vector(const FT_Vector *ft_vector, double scale) {
+static inline Vector2d get_scaled_vector(const FT_Vector* ft_vector,
+                                         double scale) {
   return {ft_vector->x / scale, ft_vector->y / scale};
 }
 
 const double FreetypeRenderer::scale = 1e5;
 
-FreetypeRenderer::FreetypeRenderer()
-{
+FreetypeRenderer::FreetypeRenderer() {
   funcs.move_to = outline_move_to_func;
   funcs.line_to = outline_line_to_func;
   funcs.conic_to = outline_conic_to_func;
@@ -64,42 +65,43 @@ FreetypeRenderer::FreetypeRenderer()
   funcs.shift = 0;
 }
 
-int FreetypeRenderer::outline_move_to_func(const FT_Vector *to, void *user)
-{
-  auto *cb = reinterpret_cast<DrawingCallback *>(user);
+int FreetypeRenderer::outline_move_to_func(const FT_Vector* to, void* user) {
+  auto* cb = reinterpret_cast<DrawingCallback*>(user);
 
   cb->move_to(get_scaled_vector(to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_line_to_func(const FT_Vector *to, void *user)
-{
-  auto *cb = reinterpret_cast<DrawingCallback *>(user);
+int FreetypeRenderer::outline_line_to_func(const FT_Vector* to, void* user) {
+  auto* cb = reinterpret_cast<DrawingCallback*>(user);
 
   cb->line_to(get_scaled_vector(to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_conic_to_func(const FT_Vector *c1, const FT_Vector *to, void *user)
-{
-  auto *cb = reinterpret_cast<DrawingCallback *>(user);
+int FreetypeRenderer::outline_conic_to_func(const FT_Vector* c1,
+                                            const FT_Vector* to,
+                                            void* user) {
+  auto* cb = reinterpret_cast<DrawingCallback*>(user);
 
   cb->curve_to(get_scaled_vector(c1, scale), get_scaled_vector(to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_cubic_to_func(const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *to, void *user)
-{
-  auto *cb = reinterpret_cast<DrawingCallback *>(user);
+int FreetypeRenderer::outline_cubic_to_func(const FT_Vector* c1,
+                                            const FT_Vector* c2,
+                                            const FT_Vector* to,
+                                            void* user) {
+  auto* cb = reinterpret_cast<DrawingCallback*>(user);
 
-  cb->curve_to(get_scaled_vector(c1, scale), get_scaled_vector(c2, scale), get_scaled_vector(to, scale));
+  cb->curve_to(get_scaled_vector(c1, scale), get_scaled_vector(c2, scale),
+               get_scaled_vector(to, scale));
   return 0;
 }
 
 // Calculate offsets for horizontal text.
 void FreetypeRenderer::ShapeResults::calc_offsets_horiz(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params& params) {
   if (params.halign == "right") {
     x_offset = -advance_x;
   } else if (params.halign == "center") {
@@ -134,8 +136,7 @@ void FreetypeRenderer::ShapeResults::calc_offsets_horiz(
 
 // Calculate offsets for vertical text.
 void FreetypeRenderer::ShapeResults::calc_offsets_vert(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params& params) {
   if (params.halign == "right") {
     x_offset = -right;
   } else if (params.halign == "left") {
@@ -152,8 +153,7 @@ void FreetypeRenderer::ShapeResults::calc_offsets_vert(
 
   if (params.valign == "baseline") {
     LOG(message_group::Warning, params.loc, params.documentPath,
-        "Don't use valign=\"baseline\" with vertical layouts",
-        params.valign);
+        "Don't use valign=\"baseline\" with vertical layouts", params.valign);
     y_offset = 0;
   } else if (params.valign == "center") {
     y_offset = -advance_y / 2.0;
@@ -172,8 +172,8 @@ void FreetypeRenderer::ShapeResults::calc_offsets_vert(
   }
 }
 
-hb_direction_t FreetypeRenderer::Params::detect_direction(const hb_script_t script) const
-{
+hb_direction_t FreetypeRenderer::Params::detect_direction(
+    const hb_script_t script) const {
   hb_direction_t hbdirection;
 
   hbdirection = hb_direction_from_string(direction.c_str(), -1);
@@ -194,21 +194,21 @@ hb_direction_t FreetypeRenderer::Params::detect_direction(const hb_script_t scri
   return HB_DIRECTION_LTR;
 }
 
-bool FreetypeRenderer::Params::is_ignored_script(const hb_script_t script)
-{
+bool FreetypeRenderer::Params::is_ignored_script(const hb_script_t script) {
   switch (script) {
-  case HB_SCRIPT_COMMON:
-  case HB_SCRIPT_INHERITED:
-  case HB_SCRIPT_UNKNOWN:
-  case HB_SCRIPT_INVALID:
-    return true;
-  default:
-    return false;
+    case HB_SCRIPT_COMMON:
+    case HB_SCRIPT_INHERITED:
+    case HB_SCRIPT_UNKNOWN:
+    case HB_SCRIPT_INVALID:
+      return true;
+    default:
+      return false;
   }
 }
 
-hb_script_t FreetypeRenderer::Params::detect_script(hb_glyph_info_t *glyph_info, unsigned int glyph_count) const
-{
+hb_script_t FreetypeRenderer::Params::detect_script(
+    hb_glyph_info_t* glyph_info,
+    unsigned int glyph_count) const {
   hb_script_t hbscript;
 
   hbscript = hb_script_from_string(script.c_str(), -1);
@@ -228,23 +228,26 @@ hb_script_t FreetypeRenderer::Params::detect_script(hb_glyph_info_t *glyph_info,
       }
     }
   }
-  PRINTDB("Detected script '%c%c%c%c' for %s", SCRIPT_UNTAG(hbscript) % text.c_str());
+  PRINTDB("Detected script '%c%c%c%c' for %s",
+          SCRIPT_UNTAG(hbscript) % text.c_str());
   return hbscript;
 }
 
-void FreetypeRenderer::Params::detect_properties()
-{
-  hb_buffer_t *hb_buf = hb_buffer_create();
-  hb_buffer_add_utf8(hb_buf, text.c_str(), strlen(text.c_str()), 0, strlen(text.c_str()));
+void FreetypeRenderer::Params::detect_properties() {
+  hb_buffer_t* hb_buf = hb_buffer_create();
+  hb_buffer_add_utf8(hb_buf, text.c_str(), strlen(text.c_str()), 0,
+                     strlen(text.c_str()));
 
   unsigned int glyph_count;
-  hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buf, &glyph_count);
+  hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(hb_buf, &glyph_count);
 
   hb_script_t hbscript = detect_script(glyph_info, glyph_count);
   hb_buffer_destroy(hb_buf);
 
   if (!is_ignored_script(hbscript)) {
-    char script_buf[5] = { 0, };
+    char script_buf[5] = {
+        0,
+    };
     hb_tag_to_string(hb_script_to_iso15924_tag(hbscript), script_buf);
     set_script(script_buf);
   }
@@ -261,9 +264,8 @@ void FreetypeRenderer::Params::detect_properties()
   set_segments(text_segments);
 }
 
-const FontFacePtr FreetypeRenderer::Params::get_font_face() const
-{
-  FontCache *cache = FontCache::instance();
+const FontFacePtr FreetypeRenderer::Params::get_font_face() const {
+  FontCache* cache = FontCache::instance();
   if (!cache->is_init_ok()) {
     LOG(message_group::Warning, loc, documentPath,
         "Font cache initialization failed");
@@ -285,23 +287,22 @@ const FontFacePtr FreetypeRenderer::Params::get_font_face() const
   return face;
 }
 
-void FreetypeRenderer::Params::set(Parameters& parameters)
-{
+void FreetypeRenderer::Params::set(Parameters& parameters) {
   // Note:
   // This populates all of the Params entries that text() populates.
   // Probably some of them are not needed by some callers.
   // However, we populate them here rather than "knowing" which
   // ones are and are not needed.
 
-  (void) parameters.valid("size", Value::Type::NUMBER);
-  (void) parameters.valid("text", Value::Type::STRING);
-  (void) parameters.valid("spacing", Value::Type::NUMBER);
-  (void) parameters.valid("font", Value::Type::STRING);
-  (void) parameters.valid("direction", Value::Type::STRING);
-  (void) parameters.valid("language", Value::Type::STRING);
-  (void) parameters.valid("script", Value::Type::STRING);
-  (void) parameters.valid("halign", Value::Type::STRING);
-  (void) parameters.valid("valign", Value::Type::STRING);
+  (void)parameters.valid("size", Value::Type::NUMBER);
+  (void)parameters.valid("text", Value::Type::STRING);
+  (void)parameters.valid("spacing", Value::Type::NUMBER);
+  (void)parameters.valid("font", Value::Type::STRING);
+  (void)parameters.valid("direction", Value::Type::STRING);
+  (void)parameters.valid("language", Value::Type::STRING);
+  (void)parameters.valid("script", Value::Type::STRING);
+  (void)parameters.valid("halign", Value::Type::STRING);
+  (void)parameters.valid("valign", Value::Type::STRING);
 
   set_fn(parameters["$fn"].toDouble());
   set_fa(parameters["$fa"].toDouble());
@@ -318,10 +319,8 @@ void FreetypeRenderer::Params::set(Parameters& parameters)
   set_valign(parameters.get("valign", "default"));
 }
 
-
 FreetypeRenderer::ShapeResults::ShapeResults(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params& params) {
   const FontFacePtr face = params.get_font_face();
   if (!face) {
     return;
@@ -330,9 +329,12 @@ FreetypeRenderer::ShapeResults::ShapeResults(
   hb_ft_font = hb_ft_font_create(face->face_, nullptr);
 
   hb_buf = hb_buffer_create();
-  hb_buffer_set_direction(hb_buf, hb_direction_from_string(params.direction.c_str(), -1));
-  hb_buffer_set_script(hb_buf, hb_script_from_string(params.script.c_str(), -1));
-  hb_buffer_set_language(hb_buf, hb_language_from_string(params.language.c_str(), -1));
+  hb_buffer_set_direction(
+      hb_buf, hb_direction_from_string(params.direction.c_str(), -1));
+  hb_buffer_set_script(hb_buf,
+                       hb_script_from_string(params.script.c_str(), -1));
+  hb_buffer_set_language(hb_buf,
+                         hb_language_from_string(params.language.c_str(), -1));
   if (FontCache::instance()->is_windows_symbol_font(face->face_)) {
     // Special handling for symbol fonts like Webdings.
     // see http://www.microsoft.com/typography/otspec/recom.htm
@@ -355,27 +357,30 @@ FreetypeRenderer::ShapeResults::ShapeResults(
           params.text.c_str());
     }
   } else {
-    hb_buffer_add_utf8(hb_buf, params.text.c_str(), strlen(params.text.c_str()), 0, strlen(params.text.c_str()));
+    hb_buffer_add_utf8(hb_buf, params.text.c_str(), strlen(params.text.c_str()),
+                       0, strlen(params.text.c_str()));
   }
 
   std::vector<hb_feature_t> features;
   features.reserve(face->features_.size());
-  std::transform(begin(face->features_), end(face->features_), std::back_inserter(features), [](const std::string& s) {
-    hb_feature_t f;
-    hb_feature_from_string(s.c_str(), s.size(), &f);
-    return f;
-  });
-  std::vector<hb_feature_t *> features_ptr;
+  std::transform(begin(face->features_), end(face->features_),
+                 std::back_inserter(features), [](const std::string& s) {
+                   hb_feature_t f;
+                   hb_feature_from_string(s.c_str(), s.size(), &f);
+                   return f;
+                 });
+  std::vector<hb_feature_t*> features_ptr;
   features.reserve(features.size());
-  std::transform(begin(features), end(features), std::back_inserter(features_ptr), [](hb_feature_t& f) {
-    return &f;
-  });
+  std::transform(begin(features), end(features),
+                 std::back_inserter(features_ptr),
+                 [](hb_feature_t& f) { return &f; });
 
   hb_shape(hb_ft_font, hb_buf, features_ptr.data()[0], features_ptr.size());
 
   unsigned int glyph_count;
-  hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buf, &glyph_count);
-  hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions(hb_buf, &glyph_count);
+  hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(hb_buf, &glyph_count);
+  hb_glyph_position_t* glyph_pos =
+      hb_buffer_get_glyph_positions(hb_buf, &glyph_count);
 
   glyph_array.reserve(glyph_count);
   for (unsigned int idx = 0; idx < glyph_count; ++idx) {
@@ -432,15 +437,11 @@ FreetypeRenderer::ShapeResults::ShapeResults(
       const double gxoff = glyph.get_x_offset();
       const double gyoff = glyph.get_y_offset();
 
-      left = std::min(left,
-                      advance_x + gxoff + bbox.xMin / scale);
-      right = std::max(right,
-                       advance_x + gxoff + bbox.xMax / scale);
+      left = std::min(left, advance_x + gxoff + bbox.xMin / scale);
+      right = std::max(right, advance_x + gxoff + bbox.xMax / scale);
 
-      top = std::max(top,
-                     advance_y + gyoff + bbox.yMax / scale);
-      bottom = std::min(bottom,
-                        advance_y + gyoff + bbox.yMin / scale);
+      top = std::max(top, advance_y + gyoff + bbox.yMax / scale);
+      bottom = std::min(bottom, advance_y + gyoff + bbox.yMin / scale);
     }
 
     advance_x += glyph.get_x_advance() * params.spacing;
@@ -451,8 +452,7 @@ FreetypeRenderer::ShapeResults::ShapeResults(
   // contributed they will flip.  If they're still reversed,
   // there was no ink.
   if (right >= left) {
-    if (HB_DIRECTION_IS_HORIZONTAL(
-          hb_buffer_get_direction(hb_buf))) {
+    if (HB_DIRECTION_IS_HORIZONTAL(hb_buffer_get_direction(hb_buf))) {
       calc_offsets_horiz(params);
     } else {
       calc_offsets_vert(params);
@@ -471,8 +471,7 @@ FreetypeRenderer::ShapeResults::ShapeResults(
   ok = true;
 }
 
-FreetypeRenderer::ShapeResults::~ShapeResults()
-{
+FreetypeRenderer::ShapeResults::~ShapeResults() {
   if (hb_buf != nullptr) {
     hb_buffer_destroy(hb_buf);
     hb_buf = nullptr;
@@ -484,8 +483,7 @@ FreetypeRenderer::ShapeResults::~ShapeResults()
 }
 
 FreetypeRenderer::FontMetrics::FontMetrics(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params& params) {
   ok = false;
 
   const FontFacePtr face = params.get_font_face();
@@ -495,22 +493,17 @@ FreetypeRenderer::FontMetrics::FontMetrics(
 
   // scale is the width of an em in 26.6 fractional points
   // @ 100dpi = 100/72 pixels per point
-  const FT_Size_Metrics *size_metrics = &face->face_->size->metrics;
-  nominal_ascent =
-    FT_MulFix(face->face_->ascender, size_metrics->y_scale) / scale
-    * params.size;
-  nominal_descent =
-    FT_MulFix(face->face_->descender, size_metrics->y_scale) / scale
-    * params.size;
-  max_ascent =
-    FT_MulFix(face->face_->bbox.yMax, size_metrics->y_scale) / scale
-    * params.size;
-  max_descent =
-    FT_MulFix(face->face_->bbox.yMin, size_metrics->y_scale) / scale
-    * params.size;
-  interline =
-    FT_MulFix(face->face_->height, size_metrics->y_scale) / scale
-    * params.size;
+  const FT_Size_Metrics* size_metrics = &face->face_->size->metrics;
+  nominal_ascent = FT_MulFix(face->face_->ascender, size_metrics->y_scale) /
+                   scale * params.size;
+  nominal_descent = FT_MulFix(face->face_->descender, size_metrics->y_scale) /
+                    scale * params.size;
+  max_ascent = FT_MulFix(face->face_->bbox.yMax, size_metrics->y_scale) /
+               scale * params.size;
+  max_descent = FT_MulFix(face->face_->bbox.yMin, size_metrics->y_scale) /
+                scale * params.size;
+  interline = FT_MulFix(face->face_->height, size_metrics->y_scale) / scale *
+              params.size;
   family_name = face->face_->family_name;
   style_name = face->face_->style_name;
 
@@ -518,8 +511,7 @@ FreetypeRenderer::FontMetrics::FontMetrics(
 }
 
 FreetypeRenderer::TextMetrics::TextMetrics(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params& params) {
   ok = false;
 
   ShapeResults sr(params);
@@ -561,8 +553,8 @@ FreetypeRenderer::TextMetrics::TextMetrics(
   ok = true;
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render(const FreetypeRenderer::Params& params) const
-{
+std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render(
+    const FreetypeRenderer::Params& params) const {
   ShapeResults sr(params);
 
   if (!sr.ok) {
@@ -572,10 +564,10 @@ std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render(const Fre
   DrawingCallback callback(params.segments, params.size);
   for (const auto& glyph : sr.glyph_array) {
     callback.start_glyph();
-    callback.set_glyph_offset(
-      sr.x_offset + glyph.get_x_offset(),
-      sr.y_offset + glyph.get_y_offset());
-    FT_Outline outline = reinterpret_cast<FT_OutlineGlyph>(glyph.get_glyph())->outline;
+    callback.set_glyph_offset(sr.x_offset + glyph.get_x_offset(),
+                              sr.y_offset + glyph.get_y_offset());
+    FT_Outline outline =
+        reinterpret_cast<FT_OutlineGlyph>(glyph.get_glyph())->outline;
     FT_Outline_Decompose(&outline, &funcs, &callback);
 
     double adv_x = glyph.get_x_advance() * params.spacing;
@@ -584,8 +576,10 @@ std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render(const Fre
     callback.finish_glyph();
   }
 
-  // FIXME: The returned Polygon2d currently contains only outlines with the 'positive' flag set to true,
-  // and where the winding order determines if the outlines should be interpreted as polygons or holes.
-  // We have to rely on any downstream processing to be aware of the winding order, and ignore the 'positive' flag.
+  // FIXME: The returned Polygon2d currently contains only outlines with the
+  // 'positive' flag set to true, and where the winding order determines if the
+  // outlines should be interpreted as polygons or holes. We have to rely on any
+  // downstream processing to be aware of the winding order, and ignore the
+  // 'positive' flag.
   return callback.get_result();
 }
diff --git a/src/core/FreetypeRenderer.h b/src/core/FreetypeRenderer.h
index dc6a60af4..90b05acb8 100644
--- a/src/core/FreetypeRenderer.h
+++ b/src/core/FreetypeRenderer.h
@@ -26,105 +26,78 @@
 #pragma once
 
 #include <memory>
+#include <ostream>
 #include <string>
 #include <vector>
-#include <ostream>
 
+#include <ft2build.h>
+#include <hb.h>
+#include "FontCache.h"
 #include "core/AST.h"
 #include "core/Parameters.h"
-#include "FontCache.h"
-#include <hb.h>
-#include <ft2build.h>
 #include FT_FREETYPE_H
 #include FT_GLYPH_H
 
-class FreetypeRenderer
-{
-public:
-  class Params
-  {
-public:
-    void set_size(double size) {
-      this->size = size;
-    }
-    void set_spacing(double spacing) {
-      this->spacing = spacing;
-    }
-    void set_fn(double fn) {
-      this->fn = fn;
-    }
-    void set_fa(double fa) {
-      this->fa = fa;
-    }
-    void set_fs(double fs) {
-      this->fs = fs;
-    }
-    void set_segments(unsigned int segments) {
-      this->segments = segments;
-    }
-    void set_text(const std::string& text) {
-      this->text = text;
-    }
-    void set_font(const std::string& font) {
-      this->font = font;
-    }
+class FreetypeRenderer {
+ public:
+  class Params {
+   public:
+    void set_size(double size) { this->size = size; }
+    void set_spacing(double spacing) { this->spacing = spacing; }
+    void set_fn(double fn) { this->fn = fn; }
+    void set_fa(double fa) { this->fa = fa; }
+    void set_fs(double fs) { this->fs = fs; }
+    void set_segments(unsigned int segments) { this->segments = segments; }
+    void set_text(const std::string& text) { this->text = text; }
+    void set_font(const std::string& font) { this->font = font; }
     void set_direction(const std::string& direction) {
       this->direction = direction;
     }
     void set_language(const std::string& language) {
       this->language = language;
     }
-    void set_script(const std::string& script) {
-      this->script = script;
-    }
-    void set_halign(const std::string& halign) {
-      this->halign = halign;
-    }
-    void set_valign(const std::string& valign) {
-      this->valign = valign;
-    }
-    void set_loc(const Location& loc) {
-      this->loc = loc;
-    }
+    void set_script(const std::string& script) { this->script = script; }
+    void set_halign(const std::string& halign) { this->halign = halign; }
+    void set_valign(const std::string& valign) { this->valign = valign; }
+    void set_loc(const Location& loc) { this->loc = loc; }
     void set_documentPath(const std::string& path) {
       this->documentPath = path;
     }
     void set(Parameters& parameters);
     [[nodiscard]] const FontFacePtr get_font_face() const;
     void detect_properties();
-    friend std::ostream& operator<<(std::ostream& stream, const FreetypeRenderer::Params& params) {
-      return stream
-             << "text = \"" << params.text
-             << "\", size = " << params.size
-             << ", spacing = " << params.spacing
-             << ", font = \"" << params.font
-             << "\", direction = \"" << params.direction
-             << "\", language = \"" << params.language
-             << (params.script.empty() ? "" : "\", script = \"") << params.script
-             << "\", halign = \"" << params.halign
-             << "\", valign = \"" << params.valign
-             << "\", $fn = " << params.fn
-             << ", $fa = " << params.fa
-             << ", $fs = " << params.fs;
+    friend std::ostream& operator<<(std::ostream& stream,
+                                    const FreetypeRenderer::Params& params) {
+      return stream << "text = \"" << params.text
+                    << "\", size = " << params.size
+                    << ", spacing = " << params.spacing << ", font = \""
+                    << params.font << "\", direction = \"" << params.direction
+                    << "\", language = \"" << params.language
+                    << (params.script.empty() ? "" : "\", script = \"")
+                    << params.script << "\", halign = \"" << params.halign
+                    << "\", valign = \"" << params.valign
+                    << "\", $fn = " << params.fn << ", $fa = " << params.fa
+                    << ", $fs = " << params.fs;
     }
-private:
+
+   private:
     double size, spacing, fn, fa, fs;
     unsigned int segments;
     std::string text, font, direction, language, script, halign, valign;
     Location loc = Location::NONE;
     std::string documentPath = "";
     static bool is_ignored_script(const hb_script_t script);
-    hb_script_t detect_script(hb_glyph_info_t *glyph_info,
+    hb_script_t detect_script(hb_glyph_info_t* glyph_info,
                               unsigned int glyph_count) const;
-    [[nodiscard]] hb_direction_t detect_direction(const hb_script_t script) const;
+    [[nodiscard]] hb_direction_t detect_direction(
+        const hb_script_t script) const;
 
     friend class FreetypeRenderer;
   };
 
-  class TextMetrics
-  {
-public:
-    bool ok; // true if object is valid
+  class TextMetrics {
+   public:
+    bool ok;  // true if object is valid
     // The values here are all at their final size; they have been
     // descaled down from the 1e5 size used for Freetype, and rescaled
     // up to the specified size.
@@ -140,10 +113,9 @@ public:
     double y_offset;
     TextMetrics(const FreetypeRenderer::Params& params);
   };
-  class FontMetrics
-  {
-public:
-    bool ok; // true if object is valid
+  class FontMetrics {
+   public:
+    bool ok;  // true if object is valid
     // The values here are all at their final size; they have been
     // descaled down from the 1e5 size used for Freetype, and rescaled
     // up to the specified size.
@@ -159,8 +131,10 @@ public:
   FreetypeRenderer();
   virtual ~FreetypeRenderer() = default;
 
-  [[nodiscard]] std::vector<std::shared_ptr<const class Polygon2d>> render(const FreetypeRenderer::Params& params) const;
-private:
+  [[nodiscard]] std::vector<std::shared_ptr<const class Polygon2d>> render(
+      const FreetypeRenderer::Params& params) const;
+
+ private:
   const static double scale;
   FT_Outline_Funcs funcs;
 
@@ -168,27 +142,35 @@ private:
   // that it is freed when the GlyphData is destroyed.
   // However, glyph_pos points to data that the caller must ensure
   // remains valid until the GlyphData is destroyed.
-  class GlyphData
-  {
-public:
-    GlyphData(FT_Glyph glyph, unsigned int idx, hb_glyph_position_t *glyph_pos) : glyph(glyph), idx(idx), glyph_pos(glyph_pos) {}
+  class GlyphData {
+   public:
+    GlyphData(FT_Glyph glyph, unsigned int idx, hb_glyph_position_t* glyph_pos)
+        : glyph(glyph), idx(idx), glyph_pos(glyph_pos) {}
     [[nodiscard]] unsigned int get_idx() const { return idx; }
     [[nodiscard]] FT_Glyph get_glyph() const { return glyph; }
-    [[nodiscard]] double get_x_offset() const { return glyph_pos->x_offset / scale; }
-    [[nodiscard]] double get_y_offset() const { return glyph_pos->y_offset / scale; }
-    [[nodiscard]] double get_x_advance() const { return glyph_pos->x_advance / scale; }
-    [[nodiscard]] double get_y_advance() const { return glyph_pos->y_advance / scale; }
+    [[nodiscard]] double get_x_offset() const {
+      return glyph_pos->x_offset / scale;
+    }
+    [[nodiscard]] double get_y_offset() const {
+      return glyph_pos->y_offset / scale;
+    }
+    [[nodiscard]] double get_x_advance() const {
+      return glyph_pos->x_advance / scale;
+    }
+    [[nodiscard]] double get_y_advance() const {
+      return glyph_pos->y_advance / scale;
+    }
     ~GlyphData() { FT_Done_Glyph(glyph); }
-private:
+
+   private:
     FT_Glyph glyph;
     unsigned int idx;
-    hb_glyph_position_t *glyph_pos;
+    hb_glyph_position_t* glyph_pos;
   };
 
-  class ShapeResults
-  {
-public:
-    bool ok{false}; // true if object is valid
+  class ShapeResults {
+   public:
+    bool ok{false};  // true if object is valid
     // The values here are all in fractions of the specified size.
     // They have been downscaled from the 1e+5 unit size used for
     // when rendering from Freetype, and have not yet been scaled
@@ -206,15 +188,21 @@ public:
     double descent{0.0};
     ShapeResults(const FreetypeRenderer::Params& params);
     virtual ~ShapeResults();
-private:
+
+   private:
     void calc_offsets_horiz(const FreetypeRenderer::Params& params);
     void calc_offsets_vert(const FreetypeRenderer::Params& params);
-    hb_font_t *hb_ft_font{nullptr};
-    hb_buffer_t *hb_buf{nullptr};
+    hb_font_t* hb_ft_font{nullptr};
+    hb_buffer_t* hb_buf{nullptr};
   };
 
-  static int outline_move_to_func(const FT_Vector *to, void *user);
-  static int outline_line_to_func(const FT_Vector *to, void *user);
-  static int outline_conic_to_func(const FT_Vector *c1, const FT_Vector *to, void *user);
-  static int outline_cubic_to_func(const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *to, void *user);
+  static int outline_move_to_func(const FT_Vector* to, void* user);
+  static int outline_line_to_func(const FT_Vector* to, void* user);
+  static int outline_conic_to_func(const FT_Vector* c1,
+                                   const FT_Vector* to,
+                                   void* user);
+  static int outline_cubic_to_func(const FT_Vector* c1,
+                                   const FT_Vector* c2,
+                                   const FT_Vector* to,
+                                   void* user);
 };
diff --git a/src/core/FunctionType.cc b/src/core/FunctionType.cc
index 71724e652..61acbd81a 100644
--- a/src/core/FunctionType.cc
+++ b/src/core/FunctionType.cc
@@ -1,8 +1,8 @@
 #include "core/FunctionType.h"
 
 #include <ostream>
-#include "core/Value.h"
 #include "core/Expression.h"
+#include "core/Value.h"
 
 Value FunctionType::operator==(const FunctionType& other) const {
   return this == &other;
@@ -23,8 +23,7 @@ Value FunctionType::operator>=(const FunctionType& /*other*/) const {
   return Value::undef("operation undefined (function >= function)");
 }
 
-std::ostream& operator<<(std::ostream& stream, const FunctionType& f)
-{
+std::ostream& operator<<(std::ostream& stream, const FunctionType& f) {
   stream << "function(";
   bool first = true;
   for (const auto& parameter : *(f.getParameters())) {
diff --git a/src/core/FunctionType.h b/src/core/FunctionType.h
index bed08fa94..1215dd772 100644
--- a/src/core/FunctionType.h
+++ b/src/core/FunctionType.h
@@ -1,8 +1,8 @@
 #pragma once
 
-#include <utility>
 #include <memory>
 #include <ostream>
+#include <utility>
 
 #include "core/Assignment.h"
 
@@ -10,11 +10,14 @@ class Context;
 class Expression;
 class Value;
 
-class FunctionType
-{
-public:
-  FunctionType(std::shared_ptr<const Context> context, std::shared_ptr<Expression> expr, std::shared_ptr<AssignmentList> parameters)
-    : context(std::move(context)), expr(std::move(expr)), parameters(std::move(parameters)) { }
+class FunctionType {
+ public:
+  FunctionType(std::shared_ptr<const Context> context,
+               std::shared_ptr<Expression> expr,
+               std::shared_ptr<AssignmentList> parameters)
+      : context(std::move(context)),
+        expr(std::move(expr)),
+        parameters(std::move(parameters)) {}
   Value operator==(const FunctionType& other) const;
   Value operator!=(const FunctionType& other) const;
   Value operator<(const FunctionType& other) const;
@@ -22,10 +25,17 @@ public:
   Value operator<=(const FunctionType& other) const;
   Value operator>=(const FunctionType& other) const;
 
-  [[nodiscard]] const std::shared_ptr<const Context>& getContext() const { return context; }
-  [[nodiscard]] const std::shared_ptr<Expression>& getExpr() const { return expr; }
-  [[nodiscard]] const std::shared_ptr<AssignmentList>& getParameters() const { return parameters; }
-private:
+  [[nodiscard]] const std::shared_ptr<const Context>& getContext() const {
+    return context;
+  }
+  [[nodiscard]] const std::shared_ptr<Expression>& getExpr() const {
+    return expr;
+  }
+  [[nodiscard]] const std::shared_ptr<AssignmentList>& getParameters() const {
+    return parameters;
+  }
+
+ private:
   std::shared_ptr<const Context> context;
   std::shared_ptr<Expression> expr;
   std::shared_ptr<AssignmentList> parameters;
diff --git a/src/core/GroupModule.cc b/src/core/GroupModule.cc
index 91f261abe..0173636f5 100644
--- a/src/core/GroupModule.cc
+++ b/src/core/GroupModule.cc
@@ -24,24 +24,25 @@
  *
  */
 
-#include <utility>
 #include <memory>
-#include "core/ModuleInstantiation.h"
-#include "core/node.h"
+#include <utility>
 #include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/node.h"
 
-std::shared_ptr<AbstractNode> builtin_group(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
+std::shared_ptr<AbstractNode> builtin_group(const ModuleInstantiation* inst,
+                                            Arguments arguments,
+                                            const Children& children) {
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
   return children.instantiate(std::make_shared<GroupNode>(inst));
 }
 
-void register_builtin_group()
-{
+void register_builtin_group() {
   Builtins::init("group", new BuiltinModule(builtin_group),
-  {
-    "group",
-  });
+                 {
+                     "group",
+                 });
 }
diff --git a/src/core/ImportNode.cc b/src/core/ImportNode.cc
index 7ea933038..23cabb69d 100644
--- a/src/core/ImportNode.cc
+++ b/src/core/ImportNode.cc
@@ -29,65 +29,80 @@
 #include "geometry/Geometry.h"
 #include "io/import.h"
 
-#include "core/module.h"
 #include "core/ModuleInstantiation.h"
+#include "core/module.h"
 #include "geometry/PolySet.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALNefGeometry.h"
 #endif
-#include "geometry/Polygon2d.h"
-#include "core/Builtins.h"
-#include "core/Children.h"
-#include "io/DxfData.h"
-#include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "io/fileutils.h"
-#include "Feature.h"
-#include "handle_dep.h"
+#include <sys/types.h>
+#include <boost/algorithm/string.hpp>
 #include <cmath>
+#include <filesystem>
 #include <ios>
-#include <utility>
 #include <memory>
-#include <sys/types.h>
 #include <sstream>
-#include <boost/algorithm/string.hpp>
-#include <filesystem>
+#include <utility>
+#include "Feature.h"
+#include "core/Builtins.h"
+#include "core/Children.h"
+#include "core/Parameters.h"
+#include "geometry/Polygon2d.h"
+#include "handle_dep.h"
+#include "io/DxfData.h"
+#include "io/fileutils.h"
+#include "utils/printutils.h"
 namespace fs = std::filesystem;
 #include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
-
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst, Arguments arguments, ImportType type)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"file", "layer", "convexity", "origin", "scale"},
-                                            {"width", "height", "filename", "layername", "center", "dpi", "id"}
-                                            );
+static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation* inst,
+                                               Arguments arguments,
+                                               ImportType type) {
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(),
+      {"file", "layer", "convexity", "origin", "scale"},
+      {"width", "height", "filename", "layername", "center", "dpi", "id"});
 
   const auto& v = parameters["file"];
   std::string filename;
   if (v.isDefined()) {
-    filename = lookup_file(v.isUndefined() ? "" : v.toString(), inst->location().filePath().parent_path().string(), parameters.documentRoot());
+    filename = lookup_file(v.isUndefined() ? "" : v.toString(),
+                           inst->location().filePath().parent_path().string(),
+                           parameters.documentRoot());
   } else {
     const auto& filename_val = parameters["filename"];
     if (!filename_val.isUndefined()) {
-      LOG(message_group::Deprecated, "filename= is deprecated. Please use file=");
+      LOG(message_group::Deprecated,
+          "filename= is deprecated. Please use file=");
     }
-    filename = lookup_file(filename_val.isUndefined() ? "" : filename_val.toString(), inst->location().filePath().parent_path().string(), parameters.documentRoot());
+    filename =
+        lookup_file(filename_val.isUndefined() ? "" : filename_val.toString(),
+                    inst->location().filePath().parent_path().string(),
+                    parameters.documentRoot());
   }
-  if (!filename.empty()) handle_dep(filename);
+  if (!filename.empty())
+    handle_dep(filename);
   ImportType actualtype = type;
   if (actualtype == ImportType::UNKNOWN) {
     std::string extraw = fs::path(filename).extension().generic_string();
     std::string ext = boost::algorithm::to_lower_copy(extraw);
-    if (ext == ".stl") actualtype = ImportType::STL;
-    else if (ext == ".off") actualtype = ImportType::OFF;
-    else if (ext == ".dxf") actualtype = ImportType::DXF;
-    else if (ext == ".nef3") actualtype = ImportType::NEF3;
-    else if (ext == ".3mf") actualtype = ImportType::_3MF;
-    else if (ext == ".amf") actualtype = ImportType::AMF;
-    else if (ext == ".svg") actualtype = ImportType::SVG;
-    else if (ext == ".obj") actualtype = ImportType::OBJ;
+    if (ext == ".stl")
+      actualtype = ImportType::STL;
+    else if (ext == ".off")
+      actualtype = ImportType::OFF;
+    else if (ext == ".dxf")
+      actualtype = ImportType::DXF;
+    else if (ext == ".nef3")
+      actualtype = ImportType::NEF3;
+    else if (ext == ".3mf")
+      actualtype = ImportType::_3MF;
+    else if (ext == ".amf")
+      actualtype = ImportType::AMF;
+    else if (ext == ".svg")
+      actualtype = ImportType::SVG;
+    else if (ext == ".obj")
+      actualtype = ImportType::OBJ;
   }
 
   auto node = std::make_shared<ImportNode>(inst, actualtype);
@@ -103,7 +118,8 @@ static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst,
   } else {
     const auto& layername = parameters["layername"];
     if (layername.isDefined()) {
-      LOG(message_group::Deprecated, "layername= is deprecated. Please use layer=");
+      LOG(message_group::Deprecated,
+          "layername= is deprecated. Please use layer=");
       node->layer = layername.toString();
     }
   }
@@ -113,32 +129,39 @@ static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst,
   }
   node->convexity = (int)parameters["convexity"].toDouble();
 
-  if (node->convexity <= 0) node->convexity = 1;
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
   const auto& origin = parameters["origin"];
   node->origin_x = node->origin_y = 0;
   bool originOk = origin.getVec2(node->origin_x, node->origin_y);
   originOk &= std::isfinite(node->origin_x) && std::isfinite(node->origin_y);
   if (origin.isDefined() && !originOk) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert import(..., origin=%1$s) parameter to vec2", origin.toEchoStringNoThrow());
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Unable to convert import(..., origin=%1$s) parameter to vec2",
+        origin.toEchoStringNoThrow());
   }
 
   const auto& center = parameters["center"];
   node->center = center.type() == Value::Type::BOOL ? center.toBool() : false;
 
   node->scale = parameters["scale"].toDouble();
-  if (node->scale <= 0) node->scale = 1;
+  if (node->scale <= 0)
+    node->scale = 1;
 
   node->dpi = ImportNode::SVG_DEFAULT_DPI;
   const auto& dpi = parameters["dpi"];
   if (dpi.type() == Value::Type::NUMBER) {
     double val = dpi.toDouble();
     if (val < 0.001) {
-      std::string filePath = fs_uncomplete(inst->location().filePath(), parameters.documentRoot()).generic_string();
+      std::string filePath =
+          fs_uncomplete(inst->location().filePath(), parameters.documentRoot())
+              .generic_string();
       LOG(message_group::Warning,
-          "Invalid dpi value giving, using default of %1$f dpi. Value must be positive and >= 0.001, file %2$s, import() at line %3$d",
-          origin.toEchoStringNoThrow(), filePath, filePath, inst->location().firstLine()
-          );
+          "Invalid dpi value giving, using default of %1$f dpi. Value must be "
+          "positive and >= 0.001, file %2$s, import() at line %3$d",
+          origin.toEchoStringNoThrow(), filePath, filePath,
+          inst->location().firstLine());
     } else {
       node->dpi = val;
     }
@@ -150,8 +173,11 @@ static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst,
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_import(const ModuleInstantiation *inst, Arguments arguments)
-{ return do_import(inst, std::move(arguments), ImportType::UNKNOWN); }
+static std::shared_ptr<AbstractNode> builtin_import(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
+  return do_import(inst, std::move(arguments), ImportType::UNKNOWN);
+}
 
 template <typename T>
 static std::unique_ptr<T> optionally_center(std::unique_ptr<T> g, bool center) {
@@ -159,7 +185,7 @@ static std::unique_ptr<T> optionally_center(std::unique_ptr<T> g, bool center) {
     auto bbox = g->getBoundingBox();
     auto center = bbox.center();
 
-    if constexpr (std::is_same_v<T, Polygon2d> ) {
+    if constexpr (std::is_same_v<T, Polygon2d>) {
       auto mat = Transform2d::Identity();
       auto translate = mat.translation();
 
@@ -185,58 +211,62 @@ static std::unique_ptr<T> optionally_center(std::unique_ptr<T> g, bool center) {
 /*!
    Will return an empty geometry if the import failed, but not nullptr
  */
-std::unique_ptr<const Geometry> ImportNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> ImportNode::createGeometry() const {
   std::unique_ptr<Geometry> g;
   auto loc = this->modinst->location();
 
   switch (this->type) {
-  case ImportType::STL: {
-    g = optionally_center(import_stl(this->filename, loc), this->center);
-    break;
-  }
-  case ImportType::AMF: {
-    g = optionally_center(import_amf(this->filename, loc), this->center);
-    break;
-  }
-  case ImportType::_3MF: {
-    g = optionally_center(import_3mf(this->filename, loc), this->center);
-    break;
-  }
-  case ImportType::OFF: {
-    g = optionally_center(import_off(this->filename, loc), this->center);
-    break;
-  }
-  case ImportType::OBJ: {
-    g = optionally_center(import_obj(this->filename, loc), this->center);
-    break;
-  }
-  case ImportType::SVG: {
-    g = import_svg(this->fn, this->fs, this->fa, this->filename, this->id, this->layer, this->dpi, this->center, loc);
-    break;
-  }
-  case ImportType::DXF: {
-    DxfData dd(this->fn, this->fs, this->fa, this->filename, this->layer.value_or(""), this->origin_x, this->origin_y, this->scale);
-    g = optionally_center(dd.toPolygon2d(), this->center);
-    break;
-  }
+    case ImportType::STL: {
+      g = optionally_center(import_stl(this->filename, loc), this->center);
+      break;
+    }
+    case ImportType::AMF: {
+      g = optionally_center(import_amf(this->filename, loc), this->center);
+      break;
+    }
+    case ImportType::_3MF: {
+      g = optionally_center(import_3mf(this->filename, loc), this->center);
+      break;
+    }
+    case ImportType::OFF: {
+      g = optionally_center(import_off(this->filename, loc), this->center);
+      break;
+    }
+    case ImportType::OBJ: {
+      g = optionally_center(import_obj(this->filename, loc), this->center);
+      break;
+    }
+    case ImportType::SVG: {
+      g = import_svg(this->fn, this->fs, this->fa, this->filename, this->id,
+                     this->layer, this->dpi, this->center, loc);
+      break;
+    }
+    case ImportType::DXF: {
+      DxfData dd(this->fn, this->fs, this->fa, this->filename,
+                 this->layer.value_or(""), this->origin_x, this->origin_y,
+                 this->scale);
+      g = optionally_center(dd.toPolygon2d(), this->center);
+      break;
+    }
 #ifdef ENABLE_CGAL
-  case ImportType::NEF3: {
-    g = import_nef3(this->filename, loc);
-    break;
-  }
+    case ImportType::NEF3: {
+      g = import_nef3(this->filename, loc);
+      break;
+    }
 #endif
-  default:
-    LOG(message_group::Error, "Unsupported file format while trying to import file '%1$s', import() at line %2$d", this->filename, loc.firstLine());
-    g = PolySet::createEmpty();
+    default:
+      LOG(message_group::Error,
+          "Unsupported file format while trying to import file '%1$s', "
+          "import() at line %2$d",
+          this->filename, loc.firstLine());
+      g = PolySet::createEmpty();
   }
 
   g->setConvexity(this->convexity);
   return g;
 }
 
-std::string ImportNode::toString() const
-{
+std::string ImportNode::toString() const {
   std::ostringstream stream;
   fs::path path((std::string)this->filename);
 
@@ -248,29 +278,27 @@ std::string ImportNode::toString() const
   if (this->layer) {
     stream << ", layer = " << QuotedString(this->layer.get());
   }
-  stream << ", origin = [" << std::dec << this->origin_x << ", " << this->origin_y << "]";
+  stream << ", origin = [" << std::dec << this->origin_x << ", "
+         << this->origin_y << "]";
   if (this->type == ImportType::SVG) {
     stream << ", dpi = " << this->dpi;
   }
   stream << ", scale = " << this->scale
          << ", center = " << (this->center ? "true" : "false")
-         << ", convexity = " << this->convexity
-         << ", $fn = " << this->fn << ", $fa = " << this->fa << ", $fs = " << this->fs
-         << ", timestamp = " << fs_timestamp(path)
-         << ")";
+         << ", convexity = " << this->convexity << ", $fn = " << this->fn
+         << ", $fa = " << this->fa << ", $fs = " << this->fs
+         << ", timestamp = " << fs_timestamp(path) << ")";
 
   return stream.str();
 }
 
-std::string ImportNode::name() const
-{
+std::string ImportNode::name() const {
   return "import";
 }
 
-void register_builtin_import()
-{
+void register_builtin_import() {
   Builtins::init("import", new BuiltinModule(builtin_import),
-  {
-    "import(string, [number, [number]])",
-  });
+                 {
+                     "import(string, [number, [number]])",
+                 });
 }
diff --git a/src/core/ImportNode.h b/src/core/ImportNode.h
index 1e2caf0f3..ca69080cc 100644
--- a/src/core/ImportNode.h
+++ b/src/core/ImportNode.h
@@ -1,12 +1,12 @@
 #pragma once
 
+#include <boost/optional.hpp>
 #include <memory>
 #include <string>
-#include <boost/optional.hpp>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
+#include "core/node.h"
 
 enum class ImportType {
   UNKNOWN,
@@ -20,13 +20,13 @@ enum class ImportType {
   OBJ,
 };
 
-class ImportNode : public LeafNode
-{
-public:
+class ImportNode : public LeafNode {
+ public:
   constexpr static double SVG_DEFAULT_DPI = 72.0;
 
   VISITABLE();
-  ImportNode(const ModuleInstantiation *mi, ImportType type) : LeafNode(mi), type(type) { }
+  ImportNode(const ModuleInstantiation* mi, ImportType type)
+      : LeafNode(mi), type(type) {}
   std::string toString() const override;
   std::string name() const override;
 
diff --git a/src/core/IndicatorData.h b/src/core/IndicatorData.h
index d8926892a..fd0a79744 100644
--- a/src/core/IndicatorData.h
+++ b/src/core/IndicatorData.h
@@ -2,15 +2,18 @@
 
 #include <string>
 #include <utility>
-#include <utility>
 
-struct IndicatorData
-{
-  IndicatorData(int firstLine, int firstCol, int lastLine, int lastCol,
+struct IndicatorData {
+  IndicatorData(int firstLine,
+                int firstCol,
+                int lastLine,
+                int lastCol,
                 std::string path)
-    : first_line(firstLine), first_col(firstCol), last_line(lastLine),
-    last_col(lastCol), path(std::move(path)) {
-  }
+      : first_line(firstLine),
+        first_col(firstCol),
+        last_line(lastLine),
+        last_col(lastCol),
+        path(std::move(path)) {}
 
   int first_line;
   int first_col;
diff --git a/src/core/LinearExtrudeNode.cc b/src/core/LinearExtrudeNode.cc
index 2a58b7710..694b75bb0 100644
--- a/src/core/LinearExtrudeNode.cc
+++ b/src/core/LinearExtrudeNode.cc
@@ -26,32 +26,35 @@
 
 #include "core/LinearExtrudeNode.h"
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "io/fileutils.h"
-#include "core/Builtins.h"
+#include "core/module.h"
 #include "handle_dep.h"
+#include "io/fileutils.h"
+#include "utils/printutils.h"
 
-#include <utility>
-#include <memory>
+#include <boost/assign/std/vector.hpp>
 #include <cmath>
+#include <memory>
 #include <sstream>
-#include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
+#include <utility>
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
 #include <filesystem>
 
 namespace {
-std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_linear_extrude(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<LinearExtrudeNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"height", "v", "scale", "center", "twist", "slices", "segments"},
-                                            {"convexity", "h"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(),
+      {"height", "v", "scale", "center", "twist", "slices", "segments"},
+      {"convexity", "h"});
   parameters.set_caller("linear_extrude");
 
   node->fn = parameters["$fn"].toDouble();
@@ -61,7 +64,8 @@ std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *
   double height = 100.0;
 
   if (parameters["v"].isDefined()) {
-    if (!parameters["v"].getVec3(node->height[0], node->height[1], node->height[2])) {
+    if (!parameters["v"].getVec3(node->height[0], node->height[1],
+                                 node->height[2])) {
       LOG(message_group::Error, "v when specified should be a 3d vector.");
     }
     height = 1.0;
@@ -82,19 +86,28 @@ std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *
   bool scaleOK = parameters["scale"].getFiniteDouble(node->scale_x);
   scaleOK &= parameters["scale"].getFiniteDouble(node->scale_y);
   scaleOK |= parameters["scale"].getVec2(node->scale_x, node->scale_y, true);
-  if ((parameters["scale"].isDefined()) && (!scaleOK || !std::isfinite(node->scale_x) || !std::isfinite(node->scale_y))) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "linear_extrude(..., scale=%1$s) could not be converted", parameters["scale"].toEchoStringNoThrow());
+  if ((parameters["scale"].isDefined()) &&
+      (!scaleOK || !std::isfinite(node->scale_x) ||
+       !std::isfinite(node->scale_y))) {
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "linear_extrude(..., scale=%1$s) could not be converted",
+        parameters["scale"].toEchoStringNoThrow());
   }
 
-  if (parameters["center"].type() == Value::Type::BOOL) node->center = parameters["center"].toBool();
+  if (parameters["center"].type() == Value::Type::BOOL)
+    node->center = parameters["center"].toBool();
 
-  if (node->height[2] <= 0) node->height[2] = 0;
+  if (node->height[2] <= 0)
+    node->height[2] = 0;
 
-  if (node->scale_x < 0) node->scale_x = 0;
-  if (node->scale_y < 0) node->scale_y = 0;
+  if (node->scale_x < 0)
+    node->scale_x = 0;
+  if (node->scale_y < 0)
+    node->scale_y = 0;
 
   node->has_slices = parameters.validate_integral("slices", node->slices, 1u);
-  node->has_segments = parameters.validate_integral("segments", node->segments, 0u);
+  node->has_segments =
+      parameters.validate_integral("segments", node->segments, 0u);
 
   node->twist = 0.0;
   parameters["twist"].getFiniteDouble(node->twist);
@@ -107,10 +120,9 @@ std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *
   return node;
 }
 
-} // namespace
+}  // namespace
 
-std::string LinearExtrudeNode::toString() const
-{
+std::string LinearExtrudeNode::toString() const {
   std::ostringstream stream;
 
   stream << this->name() << "(";
@@ -142,7 +154,8 @@ std::string LinearExtrudeNode::toString() const
   }
 
   if (!(this->has_slices && this->has_segments)) {
-    stream << ", $fn = " << this->fn << ", $fa = " << this->fa << ", $fs = " << this->fs;
+    stream << ", $fn = " << this->fn << ", $fa = " << this->fa
+           << ", $fs = " << this->fs;
   }
   if (this->convexity > 1) {
     stream << ", convexity = " << this->convexity;
@@ -151,10 +164,11 @@ std::string LinearExtrudeNode::toString() const
   return stream.str();
 }
 
-void register_builtin_linear_extrude()
-{
-  Builtins::init("linear_extrude", new BuiltinModule(builtin_linear_extrude),
-  {
-    "linear_extrude(height = 100, center = false, convexity = 1, twist = 0, scale = 1.0, [slices, segments, v, $fn, $fs, $fa])",
-  });
+void register_builtin_linear_extrude() {
+  Builtins::init(
+      "linear_extrude", new BuiltinModule(builtin_linear_extrude),
+      {
+          "linear_extrude(height = 100, center = false, convexity = 1, twist = "
+          "0, scale = 1.0, [slices, segments, v, $fn, $fs, $fa])",
+      });
 }
diff --git a/src/core/LinearExtrudeNode.h b/src/core/LinearExtrudeNode.h
index 1caf2a9a7..e54d3238a 100644
--- a/src/core/LinearExtrudeNode.h
+++ b/src/core/LinearExtrudeNode.h
@@ -2,17 +2,15 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
+#include "core/node.h"
 #include "geometry/linalg.h"
 
-class LinearExtrudeNode : public AbstractPolyNode
-{
-public:
+class LinearExtrudeNode : public AbstractPolyNode {
+ public:
   VISITABLE();
-  LinearExtrudeNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {
-  }
+  LinearExtrudeNode(const ModuleInstantiation* mi) : AbstractPolyNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "linear_extrude"; }
 
diff --git a/src/core/LocalScope.cc b/src/core/LocalScope.cc
index bf5cdf8d3..19800d6f1 100644
--- a/src/core/LocalScope.cc
+++ b/src/core/LocalScope.cc
@@ -1,9 +1,9 @@
 #include "core/LocalScope.h"
 
 #include <cassert>
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <ostream>
 #include <string>
 #include <vector>
 
@@ -13,37 +13,39 @@
 #include "core/function.h"
 #include "core/node.h"
 
-void LocalScope::addModuleInst(const std::shared_ptr<ModuleInstantiation>& modinst)
-{
+void LocalScope::addModuleInst(
+    const std::shared_ptr<ModuleInstantiation>& modinst) {
   assert(modinst);
   this->moduleInstantiations.push_back(modinst);
 }
 
-void LocalScope::addModule(const std::shared_ptr<class UserModule>& module)
-{
+void LocalScope::addModule(const std::shared_ptr<class UserModule>& module) {
   assert(module);
   auto it = this->modules.find(module->name);
-  if (it != this->modules.end()) it->second = module;
-  else this->modules.emplace(module->name, module);
+  if (it != this->modules.end())
+    it->second = module;
+  else
+    this->modules.emplace(module->name, module);
   this->astModules.emplace_back(module->name, module);
 }
 
-void LocalScope::addFunction(const std::shared_ptr<class UserFunction>& func)
-{
+void LocalScope::addFunction(const std::shared_ptr<class UserFunction>& func) {
   assert(func);
   auto it = this->functions.find(func->name);
-  if (it != this->functions.end()) it->second = func;
-  else this->functions.emplace(func->name, func);
+  if (it != this->functions.end())
+    it->second = func;
+  else
+    this->functions.emplace(func->name, func);
   this->astFunctions.emplace_back(func->name, func);
 }
 
-void LocalScope::addAssignment(const std::shared_ptr<Assignment>& assignment)
-{
+void LocalScope::addAssignment(const std::shared_ptr<Assignment>& assignment) {
   this->assignments.push_back(assignment);
 }
 
-void LocalScope::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
+void LocalScope::print(std::ostream& stream,
+                       const std::string& indent,
+                       const bool inlined) const {
   for (const auto& f : this->astFunctions) {
     f.second->print(stream, indent);
   }
@@ -58,8 +60,9 @@ void LocalScope::print(std::ostream& stream, const std::string& indent, const bo
   }
 }
 
-std::shared_ptr<AbstractNode> LocalScope::instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target) const
-{
+std::shared_ptr<AbstractNode> LocalScope::instantiateModules(
+    const std::shared_ptr<const Context>& context,
+    const std::shared_ptr<AbstractNode>& target) const {
   for (const auto& modinst : this->moduleInstantiations) {
     auto node = modinst->evaluate(context);
     if (node) {
@@ -69,8 +72,10 @@ std::shared_ptr<AbstractNode> LocalScope::instantiateModules(const std::shared_p
   return target;
 }
 
-std::shared_ptr<AbstractNode> LocalScope::instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const
-{
+std::shared_ptr<AbstractNode> LocalScope::instantiateModules(
+    const std::shared_ptr<const Context>& context,
+    const std::shared_ptr<AbstractNode>& target,
+    const std::vector<size_t>& indices) const {
   for (size_t index : indices) {
     assert(index < this->moduleInstantiations.size());
     auto node = moduleInstantiations[index]->evaluate(context);
diff --git a/src/core/LocalScope.h b/src/core/LocalScope.h
index bd7c66aae..69ca796a6 100644
--- a/src/core/LocalScope.h
+++ b/src/core/LocalScope.h
@@ -1,37 +1,48 @@
 #pragma once
 
-#include "core/Assignment.h"
-#include <utility>
-#include <ostream>
 #include <cstddef>
-#include <unordered_map>
 #include <memory>
+#include <ostream>
 #include <string>
+#include <unordered_map>
+#include <utility>
 #include <vector>
+#include "core/Assignment.h"
 
 class AbstractNode;
 class Context;
 
-class LocalScope
-{
-public:
-  size_t numElements() const { return assignments.size() + moduleInstantiations.size(); }
-  void print(std::ostream& stream, const std::string& indent, const bool inlined = false) const;
-  std::shared_ptr<AbstractNode> instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target) const;
-  std::shared_ptr<AbstractNode> instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const;
+class LocalScope {
+ public:
+  size_t numElements() const {
+    return assignments.size() + moduleInstantiations.size();
+  }
+  void print(std::ostream& stream,
+             const std::string& indent,
+             const bool inlined = false) const;
+  std::shared_ptr<AbstractNode> instantiateModules(
+      const std::shared_ptr<const Context>& context,
+      const std::shared_ptr<AbstractNode>& target) const;
+  std::shared_ptr<AbstractNode> instantiateModules(
+      const std::shared_ptr<const Context>& context,
+      const std::shared_ptr<AbstractNode>& target,
+      const std::vector<size_t>& indices) const;
   void addModuleInst(const std::shared_ptr<class ModuleInstantiation>& modinst);
   void addModule(const std::shared_ptr<class UserModule>& module);
   void addFunction(const std::shared_ptr<class UserFunction>& function);
   void addAssignment(const std::shared_ptr<class Assignment>& assignment);
-  bool hasChildren() const {return !(moduleInstantiations.empty());}
+  bool hasChildren() const { return !(moduleInstantiations.empty()); }
 
   AssignmentList assignments;
   std::vector<std::shared_ptr<ModuleInstantiation>> moduleInstantiations;
 
-  // Modules and functions are stored twice; once for lookup and once for AST serialization
-  // FIXME: Should we split this class into an ASTNode and a run-time support class?
+  // Modules and functions are stored twice; once for lookup and once for AST
+  // serialization
+  // FIXME: Should we split this class into an ASTNode and a run-time support
+  // class?
   std::unordered_map<std::string, std::shared_ptr<UserFunction>> functions;
-  std::vector<std::pair<std::string, std::shared_ptr<UserFunction>>> astFunctions;
+  std::vector<std::pair<std::string, std::shared_ptr<UserFunction>>>
+      astFunctions;
 
   std::unordered_map<std::string, std::shared_ptr<UserModule>> modules;
   std::vector<std::pair<std::string, std::shared_ptr<UserModule>>> astModules;
diff --git a/src/core/ModuleInstantiation.cc b/src/core/ModuleInstantiation.cc
index 3715cef0a..7b5bac68f 100644
--- a/src/core/ModuleInstantiation.cc
+++ b/src/core/ModuleInstantiation.cc
@@ -1,24 +1,28 @@
 #include "core/ModuleInstantiation.h"
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <ostream>
 #include <string>
 
-#include "utils/compiler_specific.h"
 #include "core/Context.h"
 #include "core/Expression.h"
+#include "utils/compiler_specific.h"
 #include "utils/exceptions.h"
 #include "utils/printutils.h"
 
-void ModuleInstantiation::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
-  if (!inlined) stream << indent;
+void ModuleInstantiation::print(std::ostream& stream,
+                                const std::string& indent,
+                                const bool inlined) const {
+  if (!inlined)
+    stream << indent;
   stream << modname + "(";
   for (size_t i = 0; i < this->arguments.size(); ++i) {
     const auto& arg = this->arguments[i];
-    if (i > 0) stream << ", ";
-    if (!arg->getName().empty()) stream << arg->getName() << " = ";
+    if (i > 0)
+      stream << ", ";
+    if (!arg->getName().empty())
+      stream << arg->getName() << " = ";
     stream << *arg->getExpr();
   }
   if (scope.numElements() == 0) {
@@ -33,8 +37,9 @@ void ModuleInstantiation::print(std::ostream& stream, const std::string& indent,
   }
 }
 
-void IfElseModuleInstantiation::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
+void IfElseModuleInstantiation::print(std::ostream& stream,
+                                      const std::string& indent,
+                                      const bool inlined) const {
   ModuleInstantiation::print(stream, indent, inlined);
   if (else_scope) {
     auto num_elements = else_scope->numElements();
@@ -60,19 +65,24 @@ void IfElseModuleInstantiation::print(std::ostream& stream, const std::string& i
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_trace(const ModuleInstantiation *mod, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Trace, mod->location(), context->documentRoot(), "called by '%1$s'", mod->name());
+static void NOINLINE
+print_trace(const ModuleInstantiation* mod,
+            const std::shared_ptr<const Context>& context) {
+  LOG(message_group::Trace, mod->location(), context->documentRoot(),
+      "called by '%1$s'", mod->name());
 }
 
-std::shared_ptr<AbstractNode> ModuleInstantiation::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  boost::optional<InstantiableModule> module = context->lookup_module(this->name(), this->loc);
+std::shared_ptr<AbstractNode> ModuleInstantiation::evaluate(
+    const std::shared_ptr<const Context>& context) const {
+  boost::optional<InstantiableModule> module =
+      context->lookup_module(this->name(), this->loc);
   if (!module) {
     return nullptr;
   }
 
-  try{
-    auto node = module->module->instantiate(module->defining_context, this, context);
+  try {
+    auto node =
+        module->module->instantiate(module->defining_context, this, context);
     return node;
   } catch (EvaluationException& e) {
     if (e.traceDepth > 0) {
@@ -83,8 +93,7 @@ std::shared_ptr<AbstractNode> ModuleInstantiation::evaluate(const std::shared_pt
   }
 }
 
-LocalScope *IfElseModuleInstantiation::makeElseScope()
-{
+LocalScope* IfElseModuleInstantiation::makeElseScope() {
   this->else_scope = std::make_unique<LocalScope>();
   return this->else_scope.get();
 }
diff --git a/src/core/ModuleInstantiation.h b/src/core/ModuleInstantiation.h
index 509672b40..698e9315c 100644
--- a/src/core/ModuleInstantiation.h
+++ b/src/core/ModuleInstantiation.h
@@ -1,24 +1,30 @@
 #pragma once
 
-#include "core/AST.h"
-#include "core/LocalScope.h"
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
+#include "core/AST.h"
+#include "core/LocalScope.h"
 
-using ModuleInstantiationList = std::vector<class ModuleInstantiation *>;
+using ModuleInstantiationList = std::vector<class ModuleInstantiation*>;
 
-class ModuleInstantiation : public ASTNode
-{
-public:
-  ModuleInstantiation(std::string name, AssignmentList args = AssignmentList(), const Location& loc = Location::NONE)
-    : ASTNode(loc), arguments(std::move(args)), modname(std::move(name)) { }
+class ModuleInstantiation : public ASTNode {
+ public:
+  ModuleInstantiation(std::string name,
+                      AssignmentList args = AssignmentList(),
+                      const Location& loc = Location::NONE)
+      : ASTNode(loc), arguments(std::move(args)), modname(std::move(name)) {}
 
-  virtual void print(std::ostream& stream, const std::string& indent, const bool inlined) const;
-  void print(std::ostream& stream, const std::string& indent) const override { print(stream, indent, false); }
-  std::shared_ptr<AbstractNode> evaluate(const std::shared_ptr<const Context>& context) const;
+  virtual void print(std::ostream& stream,
+                     const std::string& indent,
+                     const bool inlined) const;
+  void print(std::ostream& stream, const std::string& indent) const override {
+    print(stream, indent, false);
+  }
+  std::shared_ptr<AbstractNode> evaluate(
+      const std::shared_ptr<const Context>& context) const;
 
   const std::string& name() const { return this->modname; }
   bool isBackground() const { return this->tag_background; }
@@ -31,19 +37,25 @@ public:
   bool tag_root{false};
   bool tag_highlight{false};
   bool tag_background{false};
-protected:
+
+ protected:
   std::string modname;
 };
 
-class IfElseModuleInstantiation : public ModuleInstantiation
-{
-public:
-  IfElseModuleInstantiation(std::shared_ptr<class Expression> expr, const Location& loc) :
-    ModuleInstantiation("if", AssignmentList{assignment("", std::move(expr))}, loc) { }
-
-  LocalScope *makeElseScope();
-  LocalScope *getElseScope() const { return this->else_scope.get(); }
-  void print(std::ostream& stream, const std::string& indent, const bool inlined) const final;
-private:
+class IfElseModuleInstantiation : public ModuleInstantiation {
+ public:
+  IfElseModuleInstantiation(std::shared_ptr<class Expression> expr,
+                            const Location& loc)
+      : ModuleInstantiation("if",
+                            AssignmentList{assignment("", std::move(expr))},
+                            loc) {}
+
+  LocalScope* makeElseScope();
+  LocalScope* getElseScope() const { return this->else_scope.get(); }
+  void print(std::ostream& stream,
+             const std::string& indent,
+             const bool inlined) const final;
+
+ private:
   std::unique_ptr<LocalScope> else_scope;
 };
diff --git a/src/core/NodeCache.h b/src/core/NodeCache.h
index 0550160fd..ac49ba5a2 100644
--- a/src/core/NodeCache.h
+++ b/src/core/NodeCache.h
@@ -1,10 +1,10 @@
 #pragma once
 
-#include <utility>
-#include <string>
-#include <unordered_map>
 #include <cassert>
 #include <cstddef>
+#include <string>
+#include <unordered_map>
+#include <utility>
 
 #include "core/node.h"
 #include "utils/printutils.h"
@@ -15,22 +15,21 @@
    every time a new tree is generated.
  */
 
-class NodeCache
-{
-public:
+class NodeCache {
+ public:
   NodeCache() = default;
 
   bool contains(const AbstractNode& node) const {
     auto result = this->cache.find(node.index());
-    return result != this->cache.end() &&
-           result->second.second >= 0L &&
+    return result != this->cache.end() && result->second.second >= 0L &&
            (long)this->rootString.size() >= result->second.second;
   }
 
   std::string operator[](const AbstractNode& node) const {
     // throws std::out_of_range on miss
     auto indexpair = this->cache.at(node.index());
-    return rootString.substr(indexpair.first, indexpair.second - indexpair.first);
+    return rootString.substr(indexpair.first,
+                             indexpair.second - indexpair.first);
   }
 
   void insertStart(const size_t nodeidx, const long startindex) {
@@ -44,7 +43,8 @@ public:
     assert(indexpair.second == -1L && "end index inserted twice");
     this->cache[nodeidx] = std::make_pair(indexpair.first, endindex);
 #ifdef DEBUG
-    PRINTDB("NodeCache insert {%i,[%d:%d]}", nodeidx % indexpair.first % endindex);
+    PRINTDB("NodeCache insert {%i,[%d:%d]}",
+            nodeidx % indexpair.first % endindex);
 #endif
   }
 
@@ -57,7 +57,7 @@ public:
     this->rootString = "";
   }
 
-private:
+ private:
   std::unordered_map<size_t, std::pair<long, long>> cache;
   std::string rootString;
 };
diff --git a/src/core/NodeDumper.cc b/src/core/NodeDumper.cc
index 3724a87df..5dceeb385 100644
--- a/src/core/NodeDumper.cc
+++ b/src/core/NodeDumper.cc
@@ -1,13 +1,12 @@
 #include "core/NodeDumper.h"
-#include "core/State.h"
-#include "core/ModuleInstantiation.h"
 #include <algorithm>
+#include <boost/regex.hpp>
 #include <iterator>
 #include <ostream>
-#include <string>
 #include <sstream>
-#include <boost/regex.hpp>
-
+#include <string>
+#include "core/ModuleInstantiation.h"
+#include "core/State.h"
 
 void GroupNodeChecker::incChildCount(int groupNodeIndex) {
   auto search = this->groupChildCounts.find(groupNodeIndex);
@@ -26,8 +25,7 @@ int GroupNodeChecker::getChildCount(int groupNodeIndex) const {
   }
 }
 
-Response GroupNodeChecker::visit(State& state, const GroupNode& node)
-{
+Response GroupNodeChecker::visit(State& state, const GroupNode& node) {
   if (state.isPrefix()) {
     // create entry for group node, which children may increment
     this->groupChildCounts.emplace(node.index(), 0);
@@ -39,15 +37,13 @@ Response GroupNodeChecker::visit(State& state, const GroupNode& node)
   return Response::ContinueTraversal;
 }
 
-Response GroupNodeChecker::visit(State& state, const AbstractNode&)
-{
+Response GroupNodeChecker::visit(State& state, const AbstractNode&) {
   if (state.isPostfix() && state.parent()) {
     this->incChildCount(state.parent()->index());
   }
   return Response::ContinueTraversal;
 }
 
-
 /*!
    \class NodeDumper
 
@@ -56,25 +52,21 @@ Response GroupNodeChecker::visit(State& state, const AbstractNode&)
    any node or subtree.
  */
 
-void NodeDumper::initCache()
-{
+void NodeDumper::initCache() {
   this->dumpstream.str("");
   this->dumpstream.clear();
   this->cache.clear();
 }
 
-void NodeDumper::finalizeCache()
-{
+void NodeDumper::finalizeCache() {
   this->cache.setRootString(this->dumpstream.str());
 }
 
-bool NodeDumper::isCached(const AbstractNode& node) const
-{
+bool NodeDumper::isCached(const AbstractNode& node) const {
   return this->cache.contains(node);
 }
 
-Response NodeDumper::visit(State& state, const GroupNode& node)
-{
+Response NodeDumper::visit(State& state, const GroupNode& node) {
   if (!this->idString) {
     return NodeDumper::visit(state, (const AbstractNode&)node);
   }
@@ -85,14 +77,18 @@ Response NodeDumper::visit(State& state, const GroupNode& node)
       this->initCache();
     }
 
-    // ListNodes can pass down modifiers to children via state, so check both modinst and state
-    if (node.modinst->isBackground() || state.isBackground()) this->dumpstream << "%";
-    if (node.modinst->isHighlight() || state.isHighlight()) this->dumpstream << "#";
+    // ListNodes can pass down modifiers to children via state, so check both
+    // modinst and state
+    if (node.modinst->isBackground() || state.isBackground())
+      this->dumpstream << "%";
+    if (node.modinst->isHighlight() || state.isHighlight())
+      this->dumpstream << "#";
 
 // If IDPREFIX is set, we will output "/*id*/" in front of each node
 // which is useful for debugging.
 #ifdef IDPREFIX
-    if (this->idString) this->dumpstream << "\n";
+    if (this->idString)
+      this->dumpstream << "\n";
     this->dumpstream << "/*" << node.index() << "*/";
 #endif
 
@@ -112,7 +108,8 @@ Response NodeDumper::visit(State& state, const GroupNode& node)
     this->cache.insertEnd(node.index(), this->dumpstream.tellp());
 
     // For handling root modifier '!'
-    // Check if we are processing the root of the current Tree and finalize cache
+    // Check if we are processing the root of the current Tree and finalize
+    // cache
     if (this->root.get() == &node) {
       this->finalizeCache();
     }
@@ -121,28 +118,29 @@ Response NodeDumper::visit(State& state, const GroupNode& node)
   return Response::ContinueTraversal;
 }
 
-
 /*!
    Called for each node in the tree.
  */
-Response NodeDumper::visit(State& state, const AbstractNode& node)
-{
+Response NodeDumper::visit(State& state, const AbstractNode& node) {
   if (state.isPrefix()) {
-
     // For handling root modifier '!'
     // Check if we are processing the root of the current Tree and init cache
     if (this->root.get() == &node) {
       this->initCache();
     }
 
-    // ListNodes can pass down modifiers to children via state, so check both modinst and state
-    if (node.modinst->isBackground() || state.isBackground()) this->dumpstream << "%";
-    if (node.modinst->isHighlight() || state.isHighlight()) this->dumpstream << "#";
+    // ListNodes can pass down modifiers to children via state, so check both
+    // modinst and state
+    if (node.modinst->isBackground() || state.isBackground())
+      this->dumpstream << "%";
+    if (node.modinst->isHighlight() || state.isHighlight())
+      this->dumpstream << "#";
 
 // If IDPREFIX is set, we will output "/*id*/" in front of each node
 // which is useful for debugging.
 #ifdef IDPREFIX
-    if (this->idString) this->dumpstream << "\n";
+    if (this->idString)
+      this->dumpstream << "\n";
     this->dumpstream << "/*" << node.index() << "*/";
 #endif
 
@@ -150,18 +148,17 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
     this->cache.insertStart(node.index(), this->dumpstream.tellp());
 
     if (this->idString) {
-
       static const boost::regex re(R"([^\s\"]+|\"(?:[^\"\\]|\\.)*\")");
       const auto name = STR(node);
       boost::sregex_token_iterator it(name.begin(), name.end(), re, 0);
-      std::copy(it, boost::sregex_token_iterator(), std::ostream_iterator<std::string>(this->dumpstream));
+      std::copy(it, boost::sregex_token_iterator(),
+                std::ostream_iterator<std::string>(this->dumpstream));
 
       if (node.getChildren().size() > 0) {
         this->dumpstream << "{";
       }
 
     } else {
-
       for (int i = 0; i < this->currindent; ++i) {
         this->dumpstream << this->indent;
       }
@@ -174,7 +171,6 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
     this->currindent++;
 
   } else if (state.isPostfix()) {
-
     this->currindent--;
 
     if (this->idString) {
@@ -198,7 +194,8 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
     this->cache.insertEnd(node.index(), this->dumpstream.tellp());
 
     // For handling root modifier '!'
-    // Check if we are processing the root of the current Tree and finalize cache
+    // Check if we are processing the root of the current Tree and finalize
+    // cache
     if (this->root.get() == &node) {
       this->finalizeCache();
     }
@@ -210,16 +207,17 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
 /*!
    Handle list nodes specially: Only list children
  */
-Response NodeDumper::visit(State& state, const ListNode& node)
-{
+Response NodeDumper::visit(State& state, const ListNode& node) {
   if (state.isPrefix()) {
     // For handling root modifier '!'
     if (this->root.get() == &node) {
       this->initCache();
     }
     // pass modifiers down to children via state
-    if (node.modinst->isHighlight()) state.setHighlight(true);
-    if (node.modinst->isBackground()) state.setBackground(true);
+    if (node.modinst->isHighlight())
+      state.setHighlight(true);
+    if (node.modinst->isBackground())
+      state.setBackground(true);
     this->cache.insertStart(node.index(), this->dumpstream.tellp());
   } else if (state.isPostfix()) {
     this->cache.insertEnd(node.index(), this->dumpstream.tellp());
@@ -235,9 +233,9 @@ Response NodeDumper::visit(State& state, const ListNode& node)
 /*!
    Handle root nodes specially: Only list children
  */
-Response NodeDumper::visit(State& state, const RootNode& node)
-{
-  if (isCached(node)) return Response::PruneTraversal;
+Response NodeDumper::visit(State& state, const RootNode& node) {
+  if (isCached(node))
+    return Response::PruneTraversal;
 
   if (state.isPrefix()) {
     this->initCache();
diff --git a/src/core/NodeDumper.h b/src/core/NodeDumper.h
index b1f4d0248..c50a6680c 100644
--- a/src/core/NodeDumper.h
+++ b/src/core/NodeDumper.h
@@ -1,22 +1,21 @@
 #pragma once
 
-#include <sstream>
 #include <memory>
+#include <sstream>
 #include <string>
 #include <unordered_map>
 #include <utility>
+#include "core/NodeCache.h"
 #include "core/NodeVisitor.h"
 #include "core/node.h"
-#include "core/NodeCache.h"
 
 // GroupNodeChecker does a quick first pass to count children of group nodes
 // If a GroupNode has 0 children, don't include in node id strings
 // If a GroupNode has 1 child, we replace it with its child
-// This makes id strings much more compact for deeply nested trees, recursive scad scripts,
-// and increases likelihood of node cache hits.
-class GroupNodeChecker : public NodeVisitor
-{
-public:
+// This makes id strings much more compact for deeply nested trees, recursive
+// scad scripts, and increases likelihood of node cache hits.
+class GroupNodeChecker : public NodeVisitor {
+ public:
   GroupNodeChecker() = default;
 
   Response visit(State& state, const AbstractNode& node) override;
@@ -25,16 +24,21 @@ public:
   int getChildCount(int groupNodeIndex) const;
   void reset() { groupChildCounts.clear(); }
 
-private:
+ private:
   // stores <node_idx,nonEmptyChildCount> for each group node
   std::unordered_map<int, int> groupChildCounts;
 };
 
-class NodeDumper : public NodeVisitor
-{
-public:
-  NodeDumper(NodeCache& cache, std::shared_ptr<const AbstractNode> root_node, std::string indent, bool idString) :
-    cache(cache), indent(std::move(indent)), idString(idString), root(std::move(root_node)) {
+class NodeDumper : public NodeVisitor {
+ public:
+  NodeDumper(NodeCache& cache,
+             std::shared_ptr<const AbstractNode> root_node,
+             std::string indent,
+             bool idString)
+      : cache(cache),
+        indent(std::move(indent)),
+        idString(idString),
+        root(std::move(root_node)) {
     if (idString) {
       groupChecker.traverse(*root);
     }
@@ -45,7 +49,7 @@ public:
   Response visit(State& state, const ListNode& node) override;
   Response visit(State& state, const RootNode& node) override;
 
-private:
+ private:
   void initCache();
   void finalizeCache();
   bool isCached(const AbstractNode& node) const;
@@ -59,7 +63,4 @@ private:
   std::shared_ptr<const AbstractNode> root;
   GroupNodeChecker groupChecker;
   std::ostringstream dumpstream;
-
 };
-
-
diff --git a/src/core/NodeVisitor.cc b/src/core/NodeVisitor.cc
index 1cce775b2..837201c85 100644
--- a/src/core/NodeVisitor.cc
+++ b/src/core/NodeVisitor.cc
@@ -3,8 +3,7 @@
 
 State NodeVisitor::nullstate(nullptr);
 
-Response NodeVisitor::traverse(const AbstractNode& node, const State& state)
-{
+Response NodeVisitor::traverse(const AbstractNode& node, const State& state) {
   State newstate = state;
   newstate.setNumChildren(node.getChildren().size());
 
@@ -18,7 +17,8 @@ Response NodeVisitor::traverse(const AbstractNode& node, const State& state)
     newstate.setParent(node.shared_from_this());
     for (const auto& chnode : node.getChildren()) {
       response = this->traverse(*chnode, newstate);
-      if (response == Response::AbortTraversal) return response; // Abort immediately
+      if (response == Response::AbortTraversal)
+        return response;  // Abort immediately
     }
   }
 
@@ -30,6 +30,7 @@ Response NodeVisitor::traverse(const AbstractNode& node, const State& state)
     response = node.accept(newstate, *this);
   }
 
-  if (response != Response::AbortTraversal) response = Response::ContinueTraversal;
+  if (response != Response::AbortTraversal)
+    response = Response::ContinueTraversal;
   return response;
 }
diff --git a/src/core/NodeVisitor.h b/src/core/NodeVisitor.h
index 3252fc108..d4e000127 100644
--- a/src/core/NodeVisitor.h
+++ b/src/core/NodeVisitor.h
@@ -1,100 +1,99 @@
 #pragma once
 
 #include "core/BaseVisitable.h"
-#include "core/node.h"
 #include "core/State.h"
+#include "core/node.h"
 
 class State;
 
-class NodeVisitor :
-  public BaseVisitor,
-  public Visitor<class AbstractNode>,
-  public Visitor<class AbstractIntersectionNode>,
-  public Visitor<class AbstractPolyNode>,
-  public Visitor<class ListNode>,
-  public Visitor<class GroupNode>,
-  public Visitor<class RootNode>,
-  public Visitor<class LeafNode>,
-  public Visitor<class CgalAdvNode>,
-  public Visitor<class CsgOpNode>,
-  public Visitor<class LinearExtrudeNode>,
-  public Visitor<class RotateExtrudeNode>,
-  public Visitor<class RoofNode>,
-  public Visitor<class ImportNode>,
-  public Visitor<class TextNode>,
-  public Visitor<class ProjectionNode>,
-  public Visitor<class RenderNode>,
-  public Visitor<class SurfaceNode>,
-  public Visitor<class TransformNode>,
-  public Visitor<class ColorNode>,
-  public Visitor<class OffsetNode>
-{
-public:
+class NodeVisitor : public BaseVisitor,
+                    public Visitor<class AbstractNode>,
+                    public Visitor<class AbstractIntersectionNode>,
+                    public Visitor<class AbstractPolyNode>,
+                    public Visitor<class ListNode>,
+                    public Visitor<class GroupNode>,
+                    public Visitor<class RootNode>,
+                    public Visitor<class LeafNode>,
+                    public Visitor<class CgalAdvNode>,
+                    public Visitor<class CsgOpNode>,
+                    public Visitor<class LinearExtrudeNode>,
+                    public Visitor<class RotateExtrudeNode>,
+                    public Visitor<class RoofNode>,
+                    public Visitor<class ImportNode>,
+                    public Visitor<class TextNode>,
+                    public Visitor<class ProjectionNode>,
+                    public Visitor<class RenderNode>,
+                    public Visitor<class SurfaceNode>,
+                    public Visitor<class TransformNode>,
+                    public Visitor<class ColorNode>,
+                    public Visitor<class OffsetNode> {
+ public:
   NodeVisitor() = default;
 
-  Response traverse(const AbstractNode& node, const State& state = NodeVisitor::nullstate);
+  Response traverse(const AbstractNode& node,
+                    const State& state = NodeVisitor::nullstate);
 
   Response visit(State& state, const AbstractNode& node) override = 0;
   Response visit(State& state, const AbstractIntersectionNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
   Response visit(State& state, const AbstractPolyNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
   Response visit(State& state, const ListNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
 
   Response visit(State& state, const GroupNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
   Response visit(State& state, const RootNode& node) override {
-    return visit(state, (const GroupNode&) node);
+    return visit(state, (const GroupNode&)node);
   }
   Response visit(State& state, const LeafNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+    return visit(state, (const AbstractPolyNode&)node);
   }
   Response visit(State& state, const CgalAdvNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
   Response visit(State& state, const CsgOpNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
   Response visit(State& state, const LinearExtrudeNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+    return visit(state, (const AbstractPolyNode&)node);
   }
   Response visit(State& state, const RotateExtrudeNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+    return visit(state, (const AbstractPolyNode&)node);
   }
   Response visit(State& state, const RoofNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+    return visit(state, (const AbstractPolyNode&)node);
   }
   Response visit(State& state, const ImportNode& node) override {
-    return visit(state, (const LeafNode&) node);
+    return visit(state, (const LeafNode&)node);
   }
   Response visit(State& state, const TextNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+    return visit(state, (const AbstractPolyNode&)node);
   }
   Response visit(State& state, const ProjectionNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+    return visit(state, (const AbstractPolyNode&)node);
   }
   Response visit(State& state, const RenderNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
   Response visit(State& state, const SurfaceNode& node) override {
-    return visit(state, (const LeafNode&) node);
+    return visit(state, (const LeafNode&)node);
   }
   Response visit(State& state, const TransformNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
   Response visit(State& state, const ColorNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+    return visit(state, (const AbstractNode&)node);
   }
   Response visit(State& state, const OffsetNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+    return visit(state, (const AbstractPolyNode&)node);
   }
   // Add visit() methods for new visitable subtypes of AbstractNode here
 
-private:
+ private:
   static State nullstate;
 };
diff --git a/src/core/OffsetNode.cc b/src/core/OffsetNode.cc
index ba4b485e5..009d0845c 100644
--- a/src/core/OffsetNode.cc
+++ b/src/core/OffsetNode.cc
@@ -26,25 +26,28 @@
 
 #include "core/OffsetNode.h"
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include "core/Builtins.h"
+#include "core/module.h"
 
 #include <clipper2/clipper.offset.h>
+#include <boost/assign/std/vector.hpp>
 #include <ios>
-#include <utility>
 #include <memory>
 #include <sstream>
-#include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
+#include <utility>
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_offset(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_offset(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<OffsetNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"delta", "chamfer"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"r"}, {"delta", "chamfer"});
 
   node->fn = parameters["$fn"].toDouble();
   node->fs = parameters["$fs"].toDouble();
@@ -60,7 +63,8 @@ static std::shared_ptr<AbstractNode> builtin_offset(const ModuleInstantiation *i
   } else if (parameters["delta"].isDefinedAs(Value::Type::NUMBER)) {
     node->delta = parameters["delta"].toDouble();
     node->join_type = Clipper2Lib::JoinType::Miter;
-    if (parameters["chamfer"].isDefinedAs(Value::Type::BOOL) && parameters["chamfer"].toBool()) {
+    if (parameters["chamfer"].isDefinedAs(Value::Type::BOOL) &&
+        parameters["chamfer"].toBool()) {
       node->chamfer = true;
       node->join_type = Clipper2Lib::JoinType::Square;
     }
@@ -69,8 +73,7 @@ static std::shared_ptr<AbstractNode> builtin_offset(const ModuleInstantiation *i
   return children.instantiate(node);
 }
 
-std::string OffsetNode::toString() const
-{
+std::string OffsetNode::toString() const {
   std::ostringstream stream;
 
   bool isRadius = this->join_type == Clipper2Lib::JoinType::Round;
@@ -80,19 +83,17 @@ std::string OffsetNode::toString() const
   if (!isRadius) {
     stream << ", chamfer = " << (this->chamfer ? "true" : "false");
   }
-  stream << ", $fn = " << this->fn
-         << ", $fa = " << this->fa
+  stream << ", $fn = " << this->fn << ", $fa = " << this->fa
          << ", $fs = " << this->fs << ")";
 
   return stream.str();
 }
 
-void register_builtin_offset()
-{
+void register_builtin_offset() {
   Builtins::init("offset", new BuiltinModule(builtin_offset),
-  {
-    "offset(r = number)",
-    "offset(delta = number)",
-    "offset(delta = number, chamfer = false)",
-  });
+                 {
+                     "offset(r = number)",
+                     "offset(delta = number)",
+                     "offset(delta = number, chamfer = false)",
+                 });
 }
diff --git a/src/core/OffsetNode.h b/src/core/OffsetNode.h
index c68805cd4..bd085fd51 100644
--- a/src/core/OffsetNode.h
+++ b/src/core/OffsetNode.h
@@ -1,21 +1,21 @@
 #pragma once
 
-#include "core/node.h"
-#include "core/ModuleInstantiation.h"
 #include "clipper2/clipper.h"
+#include "core/ModuleInstantiation.h"
+#include "core/node.h"
 
 #include <string>
 
-class OffsetNode : public AbstractPolyNode
-{
-public:
+class OffsetNode : public AbstractPolyNode {
+ public:
   VISITABLE();
-  OffsetNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
+  OffsetNode(const ModuleInstantiation* mi) : AbstractPolyNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "offset"; }
 
   bool chamfer{false};
   double fn{0}, fs{0}, fa{0}, delta{1};
-  double miter_limit{1000000.0}; // currently fixed high value to disable chamfers with jtMiter
+  double miter_limit{1000000.0};  // currently fixed high value to disable
+                                  // chamfers with jtMiter
   Clipper2Lib::JoinType join_type{Clipper2Lib::JoinType::Round};
 };
diff --git a/src/core/Parameters.cc b/src/core/Parameters.cc
index 10e616ecd..3f7875fa6 100644
--- a/src/core/Parameters.cc
+++ b/src/core/Parameters.cc
@@ -26,12 +26,12 @@
 
 #include "core/Parameters.h"
 
-#include <initializer_list>
 #include <cassert>
-#include <sstream>
-#include <memory>
 #include <cstddef>
+#include <initializer_list>
+#include <memory>
 #include <set>
+#include <sstream>
 #include <string>
 #include <utility>
 #include <vector>
@@ -39,20 +39,16 @@
 #include "core/AST.h"
 #include "core/Expression.h"
 
-Parameters::Parameters(ContextFrame&& frame, Location loc) :
-  loc(std::move(loc)),
-  frame(std::move(frame)),
-  handle(&this->frame)
-{}
+Parameters::Parameters(ContextFrame&& frame, Location loc)
+    : loc(std::move(loc)), frame(std::move(frame)), handle(&this->frame) {}
 
-Parameters::Parameters(Parameters&& other) noexcept :
-  loc(std::move(other.loc)),
-  frame(std::move(other).to_context_frame()),
-  handle(&this->frame)
-{}
+Parameters::Parameters(Parameters&& other) noexcept
+    : loc(std::move(other.loc)),
+      frame(std::move(other).to_context_frame()),
+      handle(&this->frame) {}
 
-boost::optional<const Value&> Parameters::lookup(const std::string& name) const
-{
+boost::optional<const Value&> Parameters::lookup(
+    const std::string& name) const {
   if (ContextFrame::is_config_variable(name)) {
     return frame.session()->try_lookup_special_variable(name);
   } else {
@@ -60,8 +56,7 @@ boost::optional<const Value&> Parameters::lookup(const std::string& name) const
   }
 }
 
-const Value& Parameters::get(const std::string& name) const
-{
+const Value& Parameters::get(const std::string& name) const {
   boost::optional<const Value&> value = lookup(name);
   if (!value) {
     return Value::undefined;
@@ -69,12 +64,12 @@ const Value& Parameters::get(const std::string& name) const
   return *value;
 }
 
-const Value& Parameters::get(const std::initializer_list<std::string> names) const
-{
+const Value& Parameters::get(
+    const std::initializer_list<std::string> names) const {
   std::string matchName;
   boost::optional<const Value&> matchValue;
 
-  for (const std::string& name: names) {
+  for (const std::string& name : names) {
     boost::optional<const Value&> value = lookup(name);
     if (value && value->isDefined()) {
       if (!matchValue) {
@@ -82,7 +77,8 @@ const Value& Parameters::get(const std::initializer_list<std::string> names) con
         matchValue = value;
       } else {
         LOG(message_group::Warning, loc, documentRoot(),
-            "Specified both %1$s and %2$s", quoteVar(matchName), quoteVar(name));
+            "Specified both %1$s and %2$s", quoteVar(matchName),
+            quoteVar(name));
       }
     }
   }
@@ -90,33 +86,34 @@ const Value& Parameters::get(const std::initializer_list<std::string> names) con
   return matchValue ? *matchValue : Value::undefined;
 }
 
-double Parameters::get(const std::string& name, double default_value) const
-{
+double Parameters::get(const std::string& name, double default_value) const {
   boost::optional<const Value&> value = lookup(name);
-  return (value && value->type() == Value::Type::NUMBER) ? value->toDouble() : default_value;
+  return (value && value->type() == Value::Type::NUMBER) ? value->toDouble()
+                                                         : default_value;
 }
 
-const std::string& Parameters::get(const std::string& name, const std::string& default_value) const
-{
+const std::string& Parameters::get(const std::string& name,
+                                   const std::string& default_value) const {
   boost::optional<const Value&> value = lookup(name);
-  return (value && value->type() == Value::Type::STRING) ? value->toStrUtf8Wrapper().toString() : default_value;
+  return (value && value->type() == Value::Type::STRING)
+             ? value->toStrUtf8Wrapper().toString()
+             : default_value;
 }
 
-bool Parameters::valid(const std::string& name, const Value& value,
-                       Value::Type type)
-{
+bool Parameters::valid(const std::string& name,
+                       const Value& value,
+                       Value::Type type) {
   if (value.type() == type) {
     return true;
   }
-  print_argConvert_warning(caller, name, value, {type}, loc,
-                           documentRoot());
+  print_argConvert_warning(caller, name, value, {type}, loc, documentRoot());
   return false;
 }
 
-// Note:  unused, doesn't really work right because in some cases where the parameter
-// is not supplied, lookup() returns an existing Value with a value of undef.
-bool Parameters::valid_required(const std::string& name, Value::Type type)
-{
+// Note:  unused, doesn't really work right because in some cases where the
+// parameter is not supplied, lookup() returns an existing Value with a value of
+// undef.
+bool Parameters::valid_required(const std::string& name, Value::Type type) {
   boost::optional<const Value&> value = lookup(name);
   if (!value) {
     LOG(message_group::Warning, loc, documentRoot(),
@@ -126,8 +123,7 @@ bool Parameters::valid_required(const std::string& name, Value::Type type)
   return valid(name, *value, type);
 }
 
-bool Parameters::valid(const std::string& name, Value::Type type)
-{
+bool Parameters::valid(const std::string& name, Value::Type type) {
   boost::optional<const Value&> value = lookup(name);
   if (!value || value->isUndefined()) {
     return true;
@@ -136,8 +132,7 @@ bool Parameters::valid(const std::string& name, Value::Type type)
 }
 
 // Handle all general warnings and return true if a valid number is found.
-bool Parameters::validate_number(const std::string& name, double& out)
-{
+bool Parameters::validate_number(const std::string& name, double& out) {
   boost::optional<const Value&> value = lookup(name);
   if (!value || value->isUndefined()) {
     return false;
@@ -145,28 +140,28 @@ bool Parameters::validate_number(const std::string& name, double& out)
     if (value->getFiniteDouble(out)) {
       return true;
     } else {
-      LOG(message_group::Warning, loc, documentRoot(), "%1$s(..., %2$s=%3$s) argument cannot be infinite or nan", caller, name, value->toString());
+      LOG(message_group::Warning, loc, documentRoot(),
+          "%1$s(..., %2$s=%3$s) argument cannot be infinite or nan", caller,
+          name, value->toString());
       return false;
     }
   }
   return false;
 }
 
-ContextFrame Parameters::to_context_frame() &&
-{
+ContextFrame Parameters::to_context_frame() && {
   handle.release();
   return std::move(frame);
 }
 
 template <class T, class F>
 static ContextFrame parse_without_defaults(
-  Arguments arguments,
-  const Location& loc,
-  const std::vector<T>& required_parameters,
-  const std::vector<T>& optional_parameters,
-  bool warn_for_unexpected_arguments,
-  F parameter_name
-  ) {
+    Arguments arguments,
+    const Location& loc,
+    const std::vector<T>& required_parameters,
+    const std::vector<T>& optional_parameters,
+    bool warn_for_unexpected_arguments,
+    F parameter_name) {
   ContextFrame output{arguments.session()};
 
   std::set<std::string> named_arguments;
@@ -179,10 +174,13 @@ static ContextFrame parse_without_defaults(
     if (argument.name) {
       name = *argument.name;
       if (named_arguments.count(name)) {
-        LOG(message_group::Warning, loc, arguments.documentRoot(), "argument %1$s supplied more than once", quoteVar(name));
+        LOG(message_group::Warning, loc, arguments.documentRoot(),
+            "argument %1$s supplied more than once", quoteVar(name));
       } else if (output.lookup_local_variable(name)) {
-        LOG(message_group::Warning, loc, arguments.documentRoot(), "argument %1$s overrides positional argument", quoteVar(name));
-      } else if (warn_for_unexpected_arguments && !ContextFrame::is_config_variable(name)) {
+        LOG(message_group::Warning, loc, arguments.documentRoot(),
+            "argument %1$s overrides positional argument", quoteVar(name));
+      } else if (warn_for_unexpected_arguments &&
+                 !ContextFrame::is_config_variable(name)) {
         bool found = false;
         for (const auto& parameter : required_parameters) {
           if (parameter_name(parameter) == name) {
@@ -197,16 +195,20 @@ static ContextFrame parse_without_defaults(
           }
         }
         if (!found) {
-          LOG(message_group::Warning, loc, arguments.documentRoot(), "variable %1$s not specified as parameter", quoteVar(name));
+          LOG(message_group::Warning, loc, arguments.documentRoot(),
+              "variable %1$s not specified as parameter", quoteVar(name));
         }
       }
       named_arguments.insert(name);
     } else {
-      while (parameter_position < required_parameters.size() + optional_parameters.size()) {
-        std::string candidate_name = (parameter_position < required_parameters.size())
-    ? parameter_name(required_parameters[parameter_position])
-    : parameter_name(optional_parameters[parameter_position - required_parameters.size()])
-        ;
+      while (parameter_position <
+             required_parameters.size() + optional_parameters.size()) {
+        std::string candidate_name =
+            (parameter_position < required_parameters.size())
+                ? parameter_name(required_parameters[parameter_position])
+                : parameter_name(
+                      optional_parameters[parameter_position -
+                                          required_parameters.size()]);
         parameter_position++;
         if (!named_arguments.count(candidate_name)) {
           name = candidate_name;
@@ -215,7 +217,8 @@ static ContextFrame parse_without_defaults(
       }
       if (name.empty()) {
         if (warn_for_unexpected_arguments && !warned_for_extra_arguments) {
-          LOG(message_group::Warning, loc, arguments.documentRoot(), "Too many unnamed arguments supplied");
+          LOG(message_group::Warning, loc, arguments.documentRoot(),
+              "Too many unnamed arguments supplied");
           warned_for_extra_arguments = true;
         }
         continue;
@@ -228,16 +231,13 @@ static ContextFrame parse_without_defaults(
 }
 
 Parameters Parameters::parse(
-  Arguments arguments,
-  const Location& loc,
-  const std::vector<std::string>& required_parameters,
-  const std::vector<std::string>& optional_parameters
-  ) {
-  ContextFrame frame{parse_without_defaults(std::move(arguments), loc, required_parameters, optional_parameters, true,
-                                            [](const std::string& s) -> std::string {
-      return s;
-    }
-                                            )};
+    Arguments arguments,
+    const Location& loc,
+    const std::vector<std::string>& required_parameters,
+    const std::vector<std::string>& optional_parameters) {
+  ContextFrame frame{parse_without_defaults(
+      std::move(arguments), loc, required_parameters, optional_parameters, true,
+      [](const std::string& s) -> std::string { return s; })};
 
   for (const auto& parameter : required_parameters) {
     if (!frame.lookup_local_variable(parameter)) {
@@ -249,21 +249,22 @@ Parameters Parameters::parse(
 }
 
 Parameters Parameters::parse(
-  Arguments arguments,
-  const Location& loc,
-  const AssignmentList& required_parameters,
-  const std::shared_ptr<const Context>& defining_context
-  ) {
-  ContextFrame frame{parse_without_defaults(std::move(arguments), loc, required_parameters, {}, OpenSCAD::parameterCheck,
-                                            [](const std::shared_ptr<Assignment>& assignment) {
-      return assignment->getName();
-    }
-                                            )};
+    Arguments arguments,
+    const Location& loc,
+    const AssignmentList& required_parameters,
+    const std::shared_ptr<const Context>& defining_context) {
+  ContextFrame frame{
+      parse_without_defaults(std::move(arguments), loc, required_parameters, {},
+                             OpenSCAD::parameterCheck,
+                             [](const std::shared_ptr<Assignment>& assignment) {
+                               return assignment->getName();
+                             })};
 
   for (const auto& parameter : required_parameters) {
     if (!frame.lookup_local_variable(parameter->getName())) {
       if (parameter->getExpr()) {
-        frame.set_variable(parameter->getName(), parameter->getExpr()->evaluate(defining_context));
+        frame.set_variable(parameter->getName(),
+                           parameter->getExpr()->evaluate(defining_context));
       } else {
         frame.set_variable(parameter->getName(), Value::undefined.clone());
       }
@@ -273,31 +274,29 @@ Parameters Parameters::parse(
   return Parameters{std::move(frame), loc};
 }
 
-void Parameters::set_caller(const std::string& caller)
-{
+void Parameters::set_caller(const std::string& caller) {
   this->caller = caller;
 }
 
-void print_argCnt_warning(
-  const std::string& name,
-  int found,
-  const std::string& expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ) {
-  LOG(message_group::Warning, loc, documentRoot, "%1$s() number of parameters does not match: expected %2$s, found %3$i", name, expected, found);
+void print_argCnt_warning(const std::string& name,
+                          int found,
+                          const std::string& expected,
+                          const Location& loc,
+                          const std::string& documentRoot) {
+  LOG(message_group::Warning, loc, documentRoot,
+      "%1$s() number of parameters does not match: expected %2$s, found %3$i",
+      name, expected, found);
 }
 
-void print_argConvert_positioned_warning(
-  const std::string& calledName,
-  const std::string& where,
-  const Value& found,
-  std::vector<Value::Type> expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ){
+void print_argConvert_positioned_warning(const std::string& calledName,
+                                         const std::string& where,
+                                         const Value& found,
+                                         std::vector<Value::Type> expected,
+                                         const Location& loc,
+                                         const std::string& documentRoot) {
   std::stringstream message;
-  message << calledName << "() parameter could not be converted: " << where << ": expected ";
+  message << calledName << "() parameter could not be converted: " << where
+          << ": expected ";
   if (expected.size() == 1) {
     message << Value::typeName(expected[0]);
   } else {
@@ -308,20 +307,20 @@ void print_argConvert_positioned_warning(
     }
     message << ")";
   }
-  message << ", found " << found.typeName() << " " << "(" << found.toEchoStringNoThrow() << ")";
+  message << ", found " << found.typeName() << " " << "("
+          << found.toEchoStringNoThrow() << ")";
   LOG(message_group::Warning, loc, documentRoot, "%1$s", message.str());
 }
 
-void print_argConvert_warning(
-  const std::string& calledName,
-  const std::string& argName,
-  const Value& found,
-  std::vector<Value::Type> expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ) {
+void print_argConvert_warning(const std::string& calledName,
+                              const std::string& argName,
+                              const Value& found,
+                              std::vector<Value::Type> expected,
+                              const Location& loc,
+                              const std::string& documentRoot) {
   std::stringstream message;
-  message << calledName << "(..., " << argName << "=" << found.toEchoStringNoThrow() << ") Invalid type: expected ";
+  message << calledName << "(..., " << argName << "="
+          << found.toEchoStringNoThrow() << ") Invalid type: expected ";
   if (expected.size() == 1) {
     message << Value::typeName(expected[0]);
   } else {
diff --git a/src/core/Parameters.h b/src/core/Parameters.h
index 749bfee8d..e2d68a049 100644
--- a/src/core/Parameters.h
+++ b/src/core/Parameters.h
@@ -6,8 +6,8 @@
 #include <string>
 #include <vector>
 
-#include "core/Arguments.h"
 #include "core/AST.h"
+#include "core/Arguments.h"
 #include "core/ContextFrame.h"
 
 /*
@@ -17,12 +17,11 @@
  * But special variables passed as parameters ARE accessible on the execution
  * stack. Thus, a Parameters is a ContextFrame, held by a ContextFrameHandle.
  */
-class Parameters
-{
-private:
+class Parameters {
+ private:
   Parameters(ContextFrame&& frame, Location loc);
 
-public:
+ public:
   Parameters(Parameters&& other) noexcept;
 
   /*
@@ -32,22 +31,20 @@ public:
    * Optional parameters are not set at all.
    */
   static Parameters parse(
-    Arguments arguments,
-    const Location& loc,
-    const std::vector<std::string>& required_parameters,
-    const std::vector<std::string>& optional_parameters = {}
-    );
+      Arguments arguments,
+      const Location& loc,
+      const std::vector<std::string>& required_parameters,
+      const std::vector<std::string>& optional_parameters = {});
   /*
    * Matches arguments with parameters.
-   * Supports default arguments, and requires a context in which to interpret them.
-   * Absent parameters without defaults are set to undefined.
+   * Supports default arguments, and requires a context in which to interpret
+   * them. Absent parameters without defaults are set to undefined.
    */
   static Parameters parse(
-    Arguments arguments,
-    const Location& loc,
-    const AssignmentList& required_parameters,
-    const std::shared_ptr<const Context>& defining_context
-    );
+      Arguments arguments,
+      const Location& loc,
+      const AssignmentList& required_parameters,
+      const std::shared_ptr<const Context>& defining_context);
 
   boost::optional<const Value&> lookup(const std::string& name) const;
 
@@ -55,24 +52,30 @@ public:
   const Value& get(const std::string& name) const;
   const Value& get(const std::initializer_list<std::string> names) const;
   double get(const std::string& name, double default_value) const;
-  const std::string& get(const std::string& name, const std::string& default_value) const;
+  const std::string& get(const std::string& name,
+                         const std::string& default_value) const;
 
   bool contains(const std::string& name) const { return bool(lookup(name)); }
   const Value& operator[](const std::string& name) const { return get(name); }
-  const Value& operator[](const std::initializer_list<std::string> names) const { return get(names); }
+  const Value& operator[](
+      const std::initializer_list<std::string> names) const {
+    return get(names);
+  }
   bool valid(const std::string& name, Value::Type type);
   bool valid_required(const std::string& name, Value::Type type);
   bool validate_number(const std::string& name, double& out);
-  template <typename T> bool validate_integral(const std::string& name, T& out,
-                                               T lo = std::numeric_limits<T>::min(),
-                                               T hi = std::numeric_limits<T>::max());
+  template <typename T>
+  bool validate_integral(const std::string& name,
+                         T& out,
+                         T lo = std::numeric_limits<T>::min(),
+                         T hi = std::numeric_limits<T>::max());
 
   ContextFrame to_context_frame() &&;
 
   const std::string& documentRoot() const { return frame.documentRoot(); }
   const Location& location() const { return loc; }
 
-private:
+ private:
   Location loc;
   ContextFrame frame;
   ContextFrameHandle handle;
@@ -83,8 +86,10 @@ private:
 // Silently clamp to the given range(defaults to numeric_limits)
 // as long as param is a finite number.
 template <typename T>
-bool Parameters::validate_integral(const std::string& name, T& out, T lo, T hi)
-{
+bool Parameters::validate_integral(const std::string& name,
+                                   T& out,
+                                   T lo,
+                                   T hi) {
   double temp;
   if (validate_number(name, temp)) {
     if (temp < lo) {
@@ -99,12 +104,20 @@ bool Parameters::validate_integral(const std::string& name, T& out, T lo, T hi)
   return false;
 }
 
-void print_argCnt_warning(const std::string& name, int found,
-                          const std::string& expected, const Location& loc,
+void print_argCnt_warning(const std::string& name,
+                          int found,
+                          const std::string& expected,
+                          const Location& loc,
                           const std::string& documentRoot);
-void print_argConvert_positioned_warning(const std::string& calledName, const std::string& where,
-                                         const Value& found, std::vector<Value::Type> expected,
-                                         const Location& loc, const std::string& documentRoot);
-void print_argConvert_warning(const std::string& calledName, const std::string& argName,
-                              const Value& found, std::vector<Value::Type> expected,
-                              const Location& loc, const std::string& documentRoot);
+void print_argConvert_positioned_warning(const std::string& calledName,
+                                         const std::string& where,
+                                         const Value& found,
+                                         std::vector<Value::Type> expected,
+                                         const Location& loc,
+                                         const std::string& documentRoot);
+void print_argConvert_warning(const std::string& calledName,
+                              const std::string& argName,
+                              const Value& found,
+                              std::vector<Value::Type> expected,
+                              const Location& loc,
+                              const std::string& documentRoot);
diff --git a/src/core/ProjectionNode.cc b/src/core/ProjectionNode.cc
index 07ea7c033..9bc8b91d3 100644
--- a/src/core/ProjectionNode.cc
+++ b/src/core/ProjectionNode.cc
@@ -25,23 +25,26 @@
  */
 
 #include "core/ProjectionNode.h"
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include "core/Builtins.h"
+#include "core/module.h"
 
-#include <utility>
-#include <memory>
-#include <cassert>
 #include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
+#include <cassert>
+#include <memory>
+#include <utility>
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_projection(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_projection(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<ProjectionNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"cut"}, {"convexity"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"cut"}, {"convexity"});
   node->convexity = static_cast<int>(parameters["convexity"].toDouble());
   if (parameters["cut"].type() == Value::Type::BOOL) {
     node->cut_mode = parameters["cut"].toBool();
@@ -50,16 +53,14 @@ static std::shared_ptr<AbstractNode> builtin_projection(const ModuleInstantiatio
   return children.instantiate(node);
 }
 
-std::string ProjectionNode::toString() const
-{
+std::string ProjectionNode::toString() const {
   return STR("projection(cut = ", (this->cut_mode ? "true" : "false"),
              ", convexity = ", this->convexity, ")");
 }
 
-void register_builtin_projection()
-{
+void register_builtin_projection() {
   Builtins::init("projection", new BuiltinModule(builtin_projection),
-  {
-    "projection(cut = false)",
-  });
+                 {
+                     "projection(cut = false)",
+                 });
 }
diff --git a/src/core/ProjectionNode.h b/src/core/ProjectionNode.h
index c9b6da64e..3309ce7fd 100644
--- a/src/core/ProjectionNode.h
+++ b/src/core/ProjectionNode.h
@@ -1,14 +1,13 @@
 #pragma once
 
+#include <string>
 #include "core/ModuleInstantiation.h"
 #include "core/node.h"
-#include <string>
 
-class ProjectionNode : public AbstractPolyNode
-{
-public:
+class ProjectionNode : public AbstractPolyNode {
+ public:
   VISITABLE();
-  ProjectionNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
+  ProjectionNode(const ModuleInstantiation* mi) : AbstractPolyNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "projection"; }
 
diff --git a/src/core/RangeType.h b/src/core/RangeType.h
index 2bbbeaa4b..2c5202bcb 100644
--- a/src/core/RangeType.h
+++ b/src/core/RangeType.h
@@ -1,36 +1,38 @@
 #pragma once
 
+#include <cmath>
+#include <cstdint>
 #include <iterator>
 #include <limits>
-#include <cstdint>
 #include <ostream>
-#include <cmath>
 
-class RangeType
-{
-private:
+class RangeType {
+ private:
   double begin_val;
   double step_val;
   double end_val;
   enum class iter_state { RANGE_BEGIN, RANGE_RUNNING, RANGE_END };
 
-public:
+ public:
   static constexpr uint32_t MAX_RANGE_STEPS = 10000;
   static const RangeType EMPTY;
 
-  class iterator
-  {
-public:
+  class iterator {
+   public:
     // iterator_traits required types:
     using iterator_category = std::forward_iterator_tag;
     using value_type = double;
-    using difference_type = void; // type used by operator-(iterator), not implemented for forward iterator
-    using reference = value_type; // type used by operator*(), not actually a reference
-    using pointer = void;     // type used by operator->(), not implemented
-    iterator(const RangeType& range, iter_state state) :
-      range(range), val(range.begin_val), state(state),
-      num_values(range.numValues()), i_step(state == iter_state::RANGE_END ? num_values : 0)
-    {
+    using difference_type = void;  // type used by operator-(iterator), not
+                                   // implemented for forward iterator
+    using reference =
+        value_type;        // type used by operator*(), not actually a reference
+    using pointer = void;  // type used by operator->(), not implemented
+    iterator(const RangeType& range, iter_state state)
+        : range(range),
+          val(range.begin_val),
+          state(state),
+          num_values(range.numValues()),
+          i_step(state == iter_state::RANGE_END ? num_values : 0) {
       if (std::isnan(range.begin_val) || std::isnan(range.end_val) ||
           std::isnan(range.step_val) || range.step_val == 0) {
         i_step = num_values;
@@ -51,7 +53,8 @@ public:
              state == other.state && range == other.range;
     }
     bool operator!=(const iterator& other) const { return !(*this == other); }
-private:
+
+   private:
     const RangeType& range;
     double val;
     iter_state state;
@@ -62,93 +65,103 @@ private:
         state = iter_state::RANGE_END;
       }
     }
-
   };
 
-  RangeType(const RangeType&) = delete;       // never copy, move instead
-  RangeType& operator=(const RangeType&) = delete; // never copy, move instead
+  RangeType(const RangeType&) = delete;             // never copy, move instead
+  RangeType& operator=(const RangeType&) = delete;  // never copy, move instead
   RangeType(RangeType&&) = default;
   RangeType& operator=(RangeType&&) = default;
   ~RangeType() = default;
 
   explicit RangeType(double begin, double step, double end)
-    : begin_val(begin), step_val(step), end_val(end) {}
+      : begin_val(begin), step_val(step), end_val(end) {}
 
   bool operator==(const RangeType& other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n1 == 0) return n2 == 0;
-    if (n2 == 0) return false;
-    return this == &other ||
-           (this->begin_val == other.begin_val &&
-            this->step_val == other.step_val &&
-            n1 == n2);
+    if (n1 == 0)
+      return n2 == 0;
+    if (n2 == 0)
+      return false;
+    return this == &other || (this->begin_val == other.begin_val &&
+                              this->step_val == other.step_val && n1 == n2);
   }
 
-  bool operator!=(const RangeType& other) const {
-    return !(*this == other);
-  }
+  bool operator!=(const RangeType& other) const { return !(*this == other); }
 
   bool operator<(const RangeType& other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n1 == 0) return 0 < n2;
-    if (n2 == 0) return false;
+    if (n1 == 0)
+      return 0 < n2;
+    if (n2 == 0)
+      return false;
     return this->begin_val < other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val < other.step_val || (this->step_val == other.step_val && n1 < n2))
-           );
+            (this->step_val < other.step_val ||
+             (this->step_val == other.step_val && n1 < n2)));
   }
 
   bool operator<=(const RangeType& other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n1 == 0) return true; // (0 <= n2) is always true
-    if (n2 == 0) return false;
+    if (n1 == 0)
+      return true;  // (0 <= n2) is always true
+    if (n2 == 0)
+      return false;
     return this->begin_val < other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val < other.step_val || (this->step_val == other.step_val && n1 <= n2))
-           );
+            (this->step_val < other.step_val ||
+             (this->step_val == other.step_val && n1 <= n2)));
   }
 
   bool operator>(const RangeType& other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n2 == 0) return n1 > 0;
-    if (n1 == 0) return false;
+    if (n2 == 0)
+      return n1 > 0;
+    if (n1 == 0)
+      return false;
     return this->begin_val > other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val > other.step_val || (this->step_val == other.step_val && n1 > n2))
-           );
+            (this->step_val > other.step_val ||
+             (this->step_val == other.step_val && n1 > n2)));
   }
 
   bool operator>=(const RangeType& other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n2 == 0) return true; // (n1 >= 0) is always true
-    if (n1 == 0) return false;
+    if (n2 == 0)
+      return true;  // (n1 >= 0) is always true
+    if (n1 == 0)
+      return false;
     return this->begin_val > other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val > other.step_val || (this->step_val == other.step_val && n1 >= n2))
-           );
+            (this->step_val > other.step_val ||
+             (this->step_val == other.step_val && n1 >= n2)));
   }
 
   [[nodiscard]] double begin_value() const { return begin_val; }
   [[nodiscard]] double step_value() const { return step_val; }
   [[nodiscard]] double end_value() const { return end_val; }
 
-  [[nodiscard]] iterator begin() const { return {*this, iter_state::RANGE_BEGIN}; }
+  [[nodiscard]] iterator begin() const {
+    return {*this, iter_state::RANGE_BEGIN};
+  }
   [[nodiscard]] iterator end() const { return {*this, iter_state::RANGE_END}; }
 
-  /// return number of values, max uint32_t value if step is 0 or range is infinite
+  /// return number of values, max uint32_t value if step is 0 or range is
+  /// infinite
   [[nodiscard]] uint32_t numValues() const {
     if (std::isnan(begin_val) || std::isnan(end_val) || std::isnan(step_val)) {
       return 0;
     }
     if (step_val < 0) {
-      if (begin_val < end_val) return 0;
+      if (begin_val < end_val)
+        return 0;
     } else {
-      if (begin_val > end_val) return 0;
+      if (begin_val > end_val)
+        return 0;
     }
     if ((begin_val == end_val) || std::isinf(step_val)) {
       return 1;
@@ -156,12 +169,12 @@ private:
     if (std::isinf(begin_val) || std::isinf(end_val) || step_val == 0) {
       return std::numeric_limits<uint32_t>::max();
     }
-    // Use nextafter to compensate for possible floating point inaccurary where result is just below a whole number.
+    // Use nextafter to compensate for possible floating point inaccurary where
+    // result is just below a whole number.
     const uint32_t max = std::numeric_limits<uint32_t>::max();
     uint32_t num_steps = std::nextafter((end_val - begin_val) / step_val, max);
     return (num_steps == max) ? max : num_steps + 1;
   }
-
 };
 
 std::ostream& operator<<(std::ostream& stream, const RangeType& r);
diff --git a/src/core/RenderNode.cc b/src/core/RenderNode.cc
index 320e67f27..c27442741 100644
--- a/src/core/RenderNode.cc
+++ b/src/core/RenderNode.cc
@@ -25,22 +25,25 @@
  */
 
 #include "core/RenderNode.h"
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
 
-#include <utility>
-#include <memory>
 #include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
+#include <memory>
+#include <utility>
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_render(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_render(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<RenderNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
   if (parameters["convexity"].type() == Value::Type::NUMBER) {
     node->convexity = static_cast<int>(parameters["convexity"].toDouble());
   }
@@ -48,15 +51,13 @@ static std::shared_ptr<AbstractNode> builtin_render(const ModuleInstantiation *i
   return children.instantiate(node);
 }
 
-std::string RenderNode::toString() const
-{
+std::string RenderNode::toString() const {
   return STR(this->name(), "(convexity = ", convexity, ")");
 }
 
-void register_builtin_render()
-{
+void register_builtin_render() {
   Builtins::init("render", new BuiltinModule(builtin_render),
-  {
-    "render(convexity = 1)",
-  });
+                 {
+                     "render(convexity = 1)",
+                 });
 }
diff --git a/src/core/RenderNode.h b/src/core/RenderNode.h
index 02f1e94b6..f96d34da4 100644
--- a/src/core/RenderNode.h
+++ b/src/core/RenderNode.h
@@ -1,14 +1,13 @@
 #pragma once
 
+#include <string>
 #include "core/ModuleInstantiation.h"
 #include "core/node.h"
-#include <string>
 
-class RenderNode : public AbstractNode
-{
-public:
+class RenderNode : public AbstractNode {
+ public:
   VISITABLE();
-  RenderNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  RenderNode(const ModuleInstantiation* mi) : AbstractNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "render"; }
 
diff --git a/src/core/RenderVariables.cc b/src/core/RenderVariables.cc
index 719e6649c..aa55a3d65 100644
--- a/src/core/RenderVariables.cc
+++ b/src/core/RenderVariables.cc
@@ -1,19 +1,18 @@
 #include "core/RenderVariables.h"
-#include "core/Context.h"
 #include "core/BuiltinContext.h"
+#include "core/Context.h"
 
-void
-RenderVariables::applyToContext(ContextHandle<BuiltinContext>& context) const
-{
+void RenderVariables::applyToContext(
+    ContextHandle<BuiltinContext>& context) const {
   context->set_variable("$preview", preview);
   context->set_variable("$t", time);
 
   const auto vpr = camera.getVpr();
-  context->set_variable("$vpr",
-                        VectorType(context->session(), vpr.x(), vpr.y(), vpr.z()));
+  context->set_variable(
+      "$vpr", VectorType(context->session(), vpr.x(), vpr.y(), vpr.z()));
   const auto vpt = camera.getVpt();
-  context->set_variable("$vpt",
-                        VectorType(context->session(), vpt.x(), vpt.y(), vpt.z()));
+  context->set_variable(
+      "$vpt", VectorType(context->session(), vpt.x(), vpt.y(), vpt.z()));
   const auto vpd = camera.zoomValue();
   context->set_variable("$vpd", vpd);
   const auto vpf = camera.fovValue();
diff --git a/src/core/RenderVariables.h b/src/core/RenderVariables.h
index 7e3b117ec..0e65c5fde 100644
--- a/src/core/RenderVariables.h
+++ b/src/core/RenderVariables.h
@@ -1,10 +1,9 @@
-#include "glview/Camera.h"
-#include "core/Context.h"
 #include "core/BuiltinContext.h"
+#include "core/Context.h"
+#include "glview/Camera.h"
 
-class RenderVariables
-{
-public:
+class RenderVariables {
+ public:
   bool preview;
   double time;
   Camera camera;
diff --git a/src/core/RoofNode.cc b/src/core/RoofNode.cc
index 979be260e..0995d9c16 100644
--- a/src/core/RoofNode.cc
+++ b/src/core/RoofNode.cc
@@ -4,24 +4,24 @@
 #include "core/RoofNode.h"
 
 #include <algorithm>
-#include <utility>
 #include <memory>
 #include <sstream>
+#include <utility>
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
-#include "core/Parameters.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/module.h"
 
-static std::shared_ptr<AbstractNode> builtin_roof(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_roof(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<RoofNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"method"},
-                                            {"convexity"}
-                                            );
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"method"}, {"convexity"});
 
   node->fn = parameters["$fn"].toDouble();
   node->fs = parameters["$fs"].toDouble();
@@ -49,30 +49,27 @@ static std::shared_ptr<AbstractNode> builtin_roof(const ModuleInstantiation *ins
   double tmp_convexity = 0.0;
   parameters["convexity"].getFiniteDouble(tmp_convexity);
   node->convexity = static_cast<int>(tmp_convexity);
-  if (node->convexity <= 0) node->convexity = 1;
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
   children.instantiate(node);
 
   return node;
 }
 
-std::string RoofNode::toString() const
-{
+std::string RoofNode::toString() const {
   std::stringstream stream;
 
   stream << "roof(method = \"" << this->method << "\""
-         << ", $fa = " << this->fa
-         << ", $fs = " << this->fs
-         << ", $fn = " << this->fn
-         << ", convexity = " << this->convexity
+         << ", $fa = " << this->fa << ", $fs = " << this->fs
+         << ", $fn = " << this->fn << ", convexity = " << this->convexity
          << ")";
 
   return stream.str();
 }
 
-void register_builtin_roof()
-{
-  Builtins::init("roof", new BuiltinModule(builtin_roof, &Feature::ExperimentalRoof), {
-    "roof(method = \"voronoi\")"
-  });
+void register_builtin_roof() {
+  Builtins::init("roof",
+                 new BuiltinModule(builtin_roof, &Feature::ExperimentalRoof),
+                 {"roof(method = \"voronoi\")"});
 }
diff --git a/src/core/RoofNode.h b/src/core/RoofNode.h
index 127ea855f..c80b6f72c 100644
--- a/src/core/RoofNode.h
+++ b/src/core/RoofNode.h
@@ -10,11 +10,10 @@
 #include "core/ModuleInstantiation.h"
 #include "core/node.h"
 
-class RoofNode : public AbstractPolyNode
-{
-public:
+class RoofNode : public AbstractPolyNode {
+ public:
   VISITABLE();
-  RoofNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
+  RoofNode(const ModuleInstantiation* mi) : AbstractPolyNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "roof"; }
 
@@ -22,12 +21,12 @@ public:
   int convexity = 1;
   std::string method;
 
-  class roof_exception : public std::exception
-  {
-public:
+  class roof_exception : public std::exception {
+   public:
     roof_exception(std::string message) : m(std::move(message)) {}
-    std::string message() {return m;}
-private:
+    std::string message() { return m; }
+
+   private:
     std::string m;
   };
 };
diff --git a/src/core/RotateExtrudeNode.cc b/src/core/RotateExtrudeNode.cc
index 38ab24ef9..a2b0934fd 100644
--- a/src/core/RotateExtrudeNode.cc
+++ b/src/core/RotateExtrudeNode.cc
@@ -25,30 +25,33 @@
  */
 
 #include "core/RotateExtrudeNode.h"
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
-#include "core/Children.h"
-#include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "io/fileutils.h"
-#include "core/Builtins.h"
-#include "handle_dep.h"
+#include <boost/assign/std/vector.hpp>
+#include <cmath>
 #include <ios>
-#include <utility>
 #include <memory>
-#include <cmath>
 #include <sstream>
-#include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
+#include <utility>
+#include "core/Builtins.h"
+#include "core/Children.h"
+#include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/module.h"
+#include "handle_dep.h"
+#include "io/fileutils.h"
+#include "utils/printutils.h"
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
 namespace {
 
-std::shared_ptr<AbstractNode> builtin_rotate_extrude(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_rotate_extrude(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<RotateExtrudeNode>(inst);
 
-  const Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                                  {"angle", "start"}, {"convexity", "a"});
+  const Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(),
+                        {"angle", "start"}, {"convexity", "a"});
 
   node->fn = parameters["$fn"].toDouble();
   node->fs = parameters["$fs"].toDouble();
@@ -61,17 +64,22 @@ std::shared_ptr<AbstractNode> builtin_rotate_extrude(const ModuleInstantiation *
   bool hasAngle = parameters[{"angle", "a"}].getFiniteDouble(node->angle);
   if (hasAngle) {
     node->start = 0;
-    if ((node->angle <= -360) || (node->angle > 360)) node->angle = 360;
+    if ((node->angle <= -360) || (node->angle > 360))
+      node->angle = 360;
   } else {
     node->angle = 360;
     node->start = 180;
   }
   bool hasStart = parameters["start"].getFiniteDouble(node->start);
   if (!hasAngle && !hasStart && (int)node->fn % 2 != 0) {
-    LOG(message_group::Deprecated, "In future releases, rotational extrusion without \"angle\" will start at zero, the +X axis.  Set start=180 to explicitly start on the -X axis.");
+    LOG(message_group::Deprecated,
+        "In future releases, rotational extrusion without \"angle\" will start "
+        "at zero, the +X axis.  Set start=180 to explicitly start on the -X "
+        "axis.");
   }
 
-  if (node->convexity <= 0) node->convexity = 2;
+  if (node->convexity <= 0)
+    node->convexity = 2;
 
   children.instantiate(node);
 
@@ -80,25 +88,35 @@ std::shared_ptr<AbstractNode> builtin_rotate_extrude(const ModuleInstantiation *
 
 }  // namespace
 
-std::string RotateExtrudeNode::toString() const
-{
+std::string RotateExtrudeNode::toString() const {
   std::ostringstream stream;
 
-  stream << this->name() << "("
-    "angle = " << this->angle << ", "
-    "start = " << this->start << ", "
-    "convexity = " << this->convexity << ", "
-    "$fn = " << this->fn << ", "
-    "$fa = " << this->fa << ", "
-    "$fs = " << this->fs << ")";
+  stream << this->name()
+         << "("
+            "angle = "
+         << this->angle
+         << ", "
+            "start = "
+         << this->start
+         << ", "
+            "convexity = "
+         << this->convexity
+         << ", "
+            "$fn = "
+         << this->fn
+         << ", "
+            "$fa = "
+         << this->fa
+         << ", "
+            "$fs = "
+         << this->fs << ")";
 
   return stream.str();
 }
 
-void register_builtin_rotate_extrude()
-{
+void register_builtin_rotate_extrude() {
   Builtins::init("rotate_extrude", new BuiltinModule(builtin_rotate_extrude),
-  {
-    "rotate_extrude(angle = 360, convexity = 2)",
-  });
+                 {
+                     "rotate_extrude(angle = 360, convexity = 2)",
+                 });
 }
diff --git a/src/core/RotateExtrudeNode.h b/src/core/RotateExtrudeNode.h
index 0827326c7..ca5dea9a5 100644
--- a/src/core/RotateExtrudeNode.h
+++ b/src/core/RotateExtrudeNode.h
@@ -2,15 +2,14 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
+#include "core/node.h"
 
-class RotateExtrudeNode : public AbstractPolyNode
-{
-public:
+class RotateExtrudeNode : public AbstractPolyNode {
+ public:
   VISITABLE();
-  RotateExtrudeNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {
+  RotateExtrudeNode(const ModuleInstantiation* mi) : AbstractPolyNode(mi) {
     convexity = 0;
     fn = fs = fa = 0;
     angle = 360;
diff --git a/src/core/ScopeContext.cc b/src/core/ScopeContext.cc
index 9ce02825c..13c5b0157 100644
--- a/src/core/ScopeContext.cc
+++ b/src/core/ScopeContext.cc
@@ -1,13 +1,13 @@
 #include "core/ScopeContext.h"
 #include "core/Expression.h"
 #include "core/Parameters.h"
-#include "utils/printutils.h"
 #include "core/SourceFileCache.h"
 #include "core/UserModule.h"
+#include "utils/printutils.h"
 
-#include <utility>
-#include <memory>
 #include <cmath>
+#include <memory>
+#include <utility>
 #include <vector>
 
 // Experimental code. See issue #399
@@ -53,23 +53,34 @@ void ScopeContext::evaluateAssignments(const AssignmentList& assignments)
     }
   }
 }
-#endif // if 0
+#endif  // if 0
 
-void ScopeContext::init()
-{
+void ScopeContext::init() {
   for (const auto& assignment : scope->assignments) {
-    if (assignment->getExpr()->isLiteral() && lookup_local_variable(assignment->getName())) {
-      LOG(message_group::Warning, assignment->location(), this->documentRoot(), "Parameter %1$s is overwritten with a literal", quoteVar(assignment->getName()));
+    if (assignment->getExpr()->isLiteral() &&
+        lookup_local_variable(assignment->getName())) {
+      LOG(message_group::Warning, assignment->location(), this->documentRoot(),
+          "Parameter %1$s is overwritten with a literal",
+          quoteVar(assignment->getName()));
     }
-    try{
-      set_variable(assignment->getName(), assignment->getExpr()->evaluate(get_shared_ptr()));
+    try {
+      set_variable(assignment->getName(),
+                   assignment->getExpr()->evaluate(get_shared_ptr()));
     } catch (EvaluationException& e) {
       if (e.traceDepth > 0) {
-        if (assignment->locationOfOverwrite().isNone()){
-          LOG(message_group::Trace, assignment->location(), this->documentRoot(), "assignment to %1$s", quoteVar(assignment->getName()));
+        if (assignment->locationOfOverwrite().isNone()) {
+          LOG(message_group::Trace, assignment->location(),
+              this->documentRoot(), "assignment to %1$s",
+              quoteVar(assignment->getName()));
         } else {
-          LOG(message_group::Trace, assignment->location(), this->documentRoot(), "overwritten assignment to %1$s (this is where the assignment is evaluated)", quoteVar(assignment->getName()));
-          LOG(message_group::Trace, assignment->locationOfOverwrite(), this->documentRoot(), "overwriting assignment to %1$s", quoteVar(assignment->getName()));
+          LOG(message_group::Trace, assignment->location(),
+              this->documentRoot(),
+              "overwritten assignment to %1$s (this is where the assignment is "
+              "evaluated)",
+              quoteVar(assignment->getName()));
+          LOG(message_group::Trace, assignment->locationOfOverwrite(),
+              this->documentRoot(), "overwriting assignment to %1$s",
+              quoteVar(assignment->getName()));
         }
         e.traceDepth--;
       }
@@ -77,21 +88,24 @@ void ScopeContext::init()
     }
   }
 
-// Experimental code. See issue #399
-//	evaluateAssignments(module.scope.assignments);
+  // Experimental code. See issue #399
+  //	evaluateAssignments(module.scope.assignments);
 }
 
-boost::optional<CallableFunction> ScopeContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
+boost::optional<CallableFunction> ScopeContext::lookup_local_function(
+    const std::string& name,
+    const Location& loc) const {
   const auto& search = scope->functions.find(name);
   if (search != scope->functions.end()) {
-    return CallableFunction{CallableUserFunction{get_shared_ptr(), search->second.get()}};
+    return CallableFunction{
+        CallableUserFunction{get_shared_ptr(), search->second.get()}};
   }
   return Context::lookup_local_function(name, loc);
 }
 
-boost::optional<InstantiableModule> ScopeContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
+boost::optional<InstantiableModule> ScopeContext::lookup_local_module(
+    const std::string& name,
+    const Location& loc) const {
   const auto& search = scope->modules.find(name);
   if (search != scope->modules.end()) {
     return InstantiableModule{get_shared_ptr(), search->second.get()};
@@ -99,56 +113,71 @@ boost::optional<InstantiableModule> ScopeContext::lookup_local_module(const std:
   return Context::lookup_local_module(name, loc);
 }
 
-UserModuleContext::UserModuleContext(const std::shared_ptr<const Context>& parent, const UserModule *module, const Location& loc, Arguments arguments, Children children) :
-  ScopeContext(parent, &module->body),
-  children(std::move(children))
-{
+UserModuleContext::UserModuleContext(
+    const std::shared_ptr<const Context>& parent,
+    const UserModule* module,
+    const Location& loc,
+    Arguments arguments,
+    Children children)
+    : ScopeContext(parent, &module->body), children(std::move(children)) {
   set_variable("$children", Value(double(this->children.size())));
   set_variable("$parent_modules", Value(double(StaticModuleNameStack::size())));
-  apply_variables(Parameters::parse(std::move(arguments), loc, module->parameters, parent).to_context_frame());
+  apply_variables(
+      Parameters::parse(std::move(arguments), loc, module->parameters, parent)
+          .to_context_frame());
 }
 
-std::vector<const std::shared_ptr<const Context> *> UserModuleContext::list_referenced_contexts() const
-{
-  std::vector<const std::shared_ptr<const Context> *> output = Context::list_referenced_contexts();
+std::vector<const std::shared_ptr<const Context>*>
+UserModuleContext::list_referenced_contexts() const {
+  std::vector<const std::shared_ptr<const Context>*> output =
+      Context::list_referenced_contexts();
   output.push_back(&children.getContext());
   return output;
 }
 
-boost::optional<CallableFunction> FileContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
+boost::optional<CallableFunction> FileContext::lookup_local_function(
+    const std::string& name,
+    const Location& loc) const {
   auto result = ScopeContext::lookup_local_function(name, loc);
   if (result) {
     return result;
   }
 
   for (const auto& m : source_file->usedlibs) {
-    // usedmod is nullptr if the library wasn't be compiled (error or file-not-found)
+    // usedmod is nullptr if the library wasn't be compiled (error or
+    // file-not-found)
     auto usedmod = SourceFileCache::instance()->lookup(m);
-    if (usedmod && usedmod->scope.functions.find(name) != usedmod->scope.functions.end()) {
-      ContextHandle<FileContext> context{Context::create<FileContext>(this->parent, usedmod)};
+    if (usedmod &&
+        usedmod->scope.functions.find(name) != usedmod->scope.functions.end()) {
+      ContextHandle<FileContext> context{
+          Context::create<FileContext>(this->parent, usedmod)};
 #ifdef DEBUG
       PRINTDB("FileContext for function %s::%s:", m % name);
       PRINTDB("%s", context->dump());
 #endif
-      return CallableFunction{CallableUserFunction{*context, usedmod->scope.functions[name].get()}};
+      return CallableFunction{
+          CallableUserFunction{*context, usedmod->scope.functions[name].get()}};
     }
   }
   return boost::none;
 }
 
-boost::optional<InstantiableModule> FileContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
+boost::optional<InstantiableModule> FileContext::lookup_local_module(
+    const std::string& name,
+    const Location& loc) const {
   auto result = ScopeContext::lookup_local_module(name, loc);
   if (result) {
     return result;
   }
 
   for (const auto& m : source_file->usedlibs) {
-    // usedmod is nullptr if the library wasn't be compiled (error or file-not-found)
+    // usedmod is nullptr if the library wasn't be compiled (error or
+    // file-not-found)
     auto usedmod = SourceFileCache::instance()->lookup(m);
-    if (usedmod && usedmod->scope.modules.find(name) != usedmod->scope.modules.end()) {
-      ContextHandle<FileContext> context{Context::create<FileContext>(this->parent, usedmod)};
+    if (usedmod &&
+        usedmod->scope.modules.find(name) != usedmod->scope.modules.end()) {
+      ContextHandle<FileContext> context{
+          Context::create<FileContext>(this->parent, usedmod)};
 #ifdef DEBUG
       PRINTDB("FileContext for module %s::%s:", m % name);
       PRINTDB("%s", context->dump());
diff --git a/src/core/ScopeContext.h b/src/core/ScopeContext.h
index a52281741..99586d69e 100644
--- a/src/core/ScopeContext.h
+++ b/src/core/ScopeContext.h
@@ -4,65 +4,73 @@
 #include <string>
 #include <vector>
 
-#include "core/Arguments.h"
 #include "core/AST.h"
+#include "core/Arguments.h"
 #include "core/Children.h"
 #include "core/Context.h"
 #include "core/SourceFile.h"
 
 class UserModule;
 
-class ScopeContext : public Context
-{
-public:
+class ScopeContext : public Context {
+ public:
   void init() override;
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
+  boost::optional<CallableFunction> lookup_local_function(
+      const std::string& name,
+      const Location& loc) const override;
+  boost::optional<InstantiableModule> lookup_local_module(
+      const std::string& name,
+      const Location& loc) const override;
 
-protected:
-  ScopeContext(const std::shared_ptr<const Context>& parent, const LocalScope *scope) :
-    Context(parent),
-    scope(scope)
-  {}
+ protected:
+  ScopeContext(const std::shared_ptr<const Context>& parent,
+               const LocalScope* scope)
+      : Context(parent), scope(scope) {}
 
-private:
-// Experimental code. See issue #399
-//	void evaluateAssignments(const AssignmentList &assignments);
+ private:
+  // Experimental code. See issue #399
+  //	void evaluateAssignments(const AssignmentList &assignments);
 
-  const LocalScope *scope;
+  const LocalScope* scope;
 
   friend class Context;
 };
 
-class UserModuleContext : public ScopeContext
-{
-public:
-  const Children *user_module_children() const override { return &children; }
-  std::vector<const std::shared_ptr<const Context> *> list_referenced_contexts() const override;
+class UserModuleContext : public ScopeContext {
+ public:
+  const Children* user_module_children() const override { return &children; }
+  std::vector<const std::shared_ptr<const Context>*> list_referenced_contexts()
+      const override;
 
-protected:
-  UserModuleContext(const std::shared_ptr<const Context>& parent, const UserModule *module, const Location& loc, Arguments arguments, Children children);
+ protected:
+  UserModuleContext(const std::shared_ptr<const Context>& parent,
+                    const UserModule* module,
+                    const Location& loc,
+                    Arguments arguments,
+                    Children children);
 
-private:
+ private:
   Children children;
 
   friend class Context;
 };
 
-class FileContext : public ScopeContext
-{
-public:
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
-
-protected:
-  FileContext(const std::shared_ptr<const Context>& parent, const SourceFile *source_file) :
-    ScopeContext(parent, &source_file->scope),
-    source_file(source_file)
-  {}
-
-private:
-  const SourceFile *source_file;
+class FileContext : public ScopeContext {
+ public:
+  boost::optional<CallableFunction> lookup_local_function(
+      const std::string& name,
+      const Location& loc) const override;
+  boost::optional<InstantiableModule> lookup_local_module(
+      const std::string& name,
+      const Location& loc) const override;
+
+ protected:
+  FileContext(const std::shared_ptr<const Context>& parent,
+              const SourceFile* source_file)
+      : ScopeContext(parent, &source_file->scope), source_file(source_file) {}
+
+ private:
+  const SourceFile* source_file;
 
   friend class Context;
 };
diff --git a/src/core/Selection.h b/src/core/Selection.h
index 543cdf0e3..7cb08cce2 100644
--- a/src/core/Selection.h
+++ b/src/core/Selection.h
@@ -27,14 +27,10 @@
 #pragma once
 #include "geometry/linalg.h"
 
-enum class SelectionType {
-  SELECTION_POINT,
-  SELECTION_LINE
-};
+enum class SelectionType { SELECTION_POINT, SELECTION_LINE };
 
 struct SelectedObject {
   SelectionType type;
   Vector3d p1;
   Vector3d p2;
 };
-
diff --git a/src/core/Settings.cc b/src/core/Settings.cc
index 3fb113863..f2c48ea24 100644
--- a/src/core/Settings.cc
+++ b/src/core/Settings.cc
@@ -1,19 +1,19 @@
 #include "core/Settings.h"
 
-#include <ostream>
+#include <boost/algorithm/string.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/range/adaptors.hpp>
 #include <cassert>
 #include <cstddef>
 #include <istream>
 #include <iterator>
+#include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
-#include <boost/algorithm/string.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/range/adaptors.hpp>
 
-#include "io/export_enums.h"
 #include "io/export.h"
+#include "io/export_enums.h"
 #include "utils/printutils.h"
 
 #include "json/json.hpp"
@@ -24,15 +24,17 @@ namespace Settings {
 
 namespace {
 
-std::vector<SettingsEntryBase *> entries;
+std::vector<SettingsEntryBase*> entries;
 
-std::vector<SettingsEntryEnum<std::string>::Item> createFileFormatItems(std::vector<FileFormat> formats) {
+std::vector<SettingsEntryEnum<std::string>::Item> createFileFormatItems(
+    std::vector<FileFormat> formats) {
   std::vector<SettingsEntryEnum<std::string>::Item> items;
   std::transform(formats.begin(), formats.end(), std::back_inserter(items),
-                 [](const FileFormat& format){
-        const FileFormatInfo& info = fileformat::info(format);
-        return SettingsEntryEnum<std::string>::Item{info.identifier, info.identifier, info.description};
-      });
+                 [](const FileFormat& format) {
+                   const FileFormatInfo& info = fileformat::info(format);
+                   return SettingsEntryEnum<std::string>::Item{
+                       info.identifier, info.identifier, info.description};
+                 });
   return items;
 }
 
@@ -52,28 +54,24 @@ std::vector<SettingsEntryEnum<std::string>::Item> axisValues() {
   return output;
 }
 
-} // namespace
+}  // namespace
 
-void Settings::visit(const SettingsVisitor& visitor)
-{
-  for (SettingsEntryBase *entry : entries) {
+void Settings::visit(const SettingsVisitor& visitor) {
+  for (SettingsEntryBase* entry : entries) {
     visitor.handle(*entry);
   }
 }
 
-SettingsEntryBase::SettingsEntryBase(std::string category, std::string name) :
-  _category(std::move(category)), _name(std::move(name))
-{
+SettingsEntryBase::SettingsEntryBase(std::string category, std::string name)
+    : _category(std::move(category)), _name(std::move(name)) {
   entries.push_back(this);
 }
 
-std::string SettingsEntryBool::encode() const
-{
+std::string SettingsEntryBool::encode() const {
   return _value ? "true" : "false";
 }
 
-const bool SettingsEntryBool::decode(const std::string& encoded) const
-{
+const bool SettingsEntryBool::decode(const std::string& encoded) const {
   std::string trimmed = boost::algorithm::trim_copy(encoded);
   if (trimmed == "true") {
     return true;
@@ -88,13 +86,11 @@ const bool SettingsEntryBool::decode(const std::string& encoded) const
   }
 }
 
-std::string SettingsEntryInt::encode() const
-{
+std::string SettingsEntryInt::encode() const {
   return STR(_value);
 }
 
-const int SettingsEntryInt::decode(const std::string& encoded) const
-{
+const int SettingsEntryInt::decode(const std::string& encoded) const {
   try {
     return boost::lexical_cast<int>(boost::algorithm::trim_copy(encoded));
   } catch (const boost::bad_lexical_cast&) {
@@ -102,13 +98,11 @@ const int SettingsEntryInt::decode(const std::string& encoded) const
   }
 }
 
-std::string SettingsEntryDouble::encode() const
-{
+std::string SettingsEntryDouble::encode() const {
   return STR(_value);
 }
 
-const double SettingsEntryDouble::decode(const std::string& encoded) const
-{
+const double SettingsEntryDouble::decode(const std::string& encoded) const {
   try {
     return boost::lexical_cast<double>(boost::algorithm::trim_copy(encoded));
   } catch (const boost::bad_lexical_cast&) {
@@ -116,8 +110,7 @@ const double SettingsEntryDouble::decode(const std::string& encoded) const
   }
 }
 
-std::ostream& operator<<(std::ostream& stream, const LocalAppParameter& param)
-{
+std::ostream& operator<<(std::ostream& stream, const LocalAppParameter& param) {
   json data;
   data["type"] = static_cast<int>(param.type);
   if (!param.value.empty()) {
@@ -127,8 +120,7 @@ std::ostream& operator<<(std::ostream& stream, const LocalAppParameter& param)
   return stream;
 }
 
-std::istream& operator>>(std::istream& stream, LocalAppParameter& param)
-{
+std::istream& operator>>(std::istream& stream, LocalAppParameter& param) {
   try {
     json data;
     stream >> data;
@@ -143,130 +135,299 @@ std::istream& operator>>(std::istream& stream, LocalAppParameter& param)
   return stream;
 }
 
-SettingsEntryBool Settings::showWarningsIn3dView("3dview", "showWarningsIn3dView", true);
-SettingsEntryBool Settings::mouseCentricZoom("3dview", "mouseCentricZoom", true);
-SettingsEntryBool Settings::mouseSwapButtons("3dview", "mouseSwapButtons", false);
-SettingsEntryInt Settings::indentationWidth("editor", "indentationWidth", 1, 16, 4);
+SettingsEntryBool Settings::showWarningsIn3dView("3dview",
+                                                 "showWarningsIn3dView",
+                                                 true);
+SettingsEntryBool Settings::mouseCentricZoom("3dview",
+                                             "mouseCentricZoom",
+                                             true);
+SettingsEntryBool Settings::mouseSwapButtons("3dview",
+                                             "mouseSwapButtons",
+                                             false);
+SettingsEntryInt Settings::indentationWidth("editor",
+                                            "indentationWidth",
+                                            1,
+                                            16,
+                                            4);
 SettingsEntryInt Settings::tabWidth("editor", "tabWidth", 1, 16, 4);
-SettingsEntryEnum<std::string> Settings::lineWrap("editor", "lineWrap", {
-    {"None", "none", _("None")},
-    {"Char", "char", _("Wrap at character boundaries")},
-    {"Word", "word", _("Wrap at word boundaries")}
-  }, "Word");
-SettingsEntryEnum<std::string> Settings::lineWrapIndentationStyle("editor", "lineWrapIndentationStyle", {
-    {"Fixed",    "fixed",    _("Fixed")},
-    {"Same",     "same",     _("Same")},
-    {"Indented", "indented", _("Indented")}
-  }, "Fixed");
-SettingsEntryInt Settings::lineWrapIndentation("editor", "lineWrapIndentation", 0, 999, 4);
-SettingsEntryEnum<std::string> Settings::lineWrapVisualizationBegin("editor", "lineWrapVisualizationBegin", {
-    {"None",   "none",   _("None")},
-    {"Text",   "text", _("Text")},
-    {"Border", "border", _("Border")},
-    {"Margin", "margin", _("Margin")}
-  }, "None");
-SettingsEntryEnum<std::string> Settings::lineWrapVisualizationEnd("editor", "lineWrapVisualizationEnd", {
-    {"None",   "none",   _("None")},
-    {"Text",   "text",   _("Text")},
-    {"Border", "border", _("Border")},
-    {"Margin", "margin", _("Margin")}
-  }, "Border");
-SettingsEntryEnum<std::string> Settings::showWhitespace("editor", "showWhitespaces", {
-    {"Never",            "never",        _("Never")},
-    {"Always",           "always",       _("Always")},
-    {"AfterIndentation", "after-indent", _("After indentation")}
-  }, "Never");
-SettingsEntryInt Settings::showWhitespaceSize("editor", "showWhitespacesSize", 1, 16, 2);
+SettingsEntryEnum<std::string> Settings::lineWrap(
+    "editor",
+    "lineWrap",
+    {{"None", "none", _("None")},
+     {"Char", "char", _("Wrap at character boundaries")},
+     {"Word", "word", _("Wrap at word boundaries")}},
+    "Word");
+SettingsEntryEnum<std::string> Settings::lineWrapIndentationStyle(
+    "editor",
+    "lineWrapIndentationStyle",
+    {{"Fixed", "fixed", _("Fixed")},
+     {"Same", "same", _("Same")},
+     {"Indented", "indented", _("Indented")}},
+    "Fixed");
+SettingsEntryInt Settings::lineWrapIndentation("editor",
+                                               "lineWrapIndentation",
+                                               0,
+                                               999,
+                                               4);
+SettingsEntryEnum<std::string> Settings::lineWrapVisualizationBegin(
+    "editor",
+    "lineWrapVisualizationBegin",
+    {{"None", "none", _("None")},
+     {"Text", "text", _("Text")},
+     {"Border", "border", _("Border")},
+     {"Margin", "margin", _("Margin")}},
+    "None");
+SettingsEntryEnum<std::string> Settings::lineWrapVisualizationEnd(
+    "editor",
+    "lineWrapVisualizationEnd",
+    {{"None", "none", _("None")},
+     {"Text", "text", _("Text")},
+     {"Border", "border", _("Border")},
+     {"Margin", "margin", _("Margin")}},
+    "Border");
+SettingsEntryEnum<std::string> Settings::showWhitespace(
+    "editor",
+    "showWhitespaces",
+    {{"Never", "never", _("Never")},
+     {"Always", "always", _("Always")},
+     {"AfterIndentation", "after-indent", _("After indentation")}},
+    "Never");
+SettingsEntryInt Settings::showWhitespaceSize("editor",
+                                              "showWhitespacesSize",
+                                              1,
+                                              16,
+                                              2);
 SettingsEntryBool Settings::autoIndent("editor", "autoIndent", true);
-SettingsEntryBool Settings::backspaceUnindents("editor", "backspaceUnindents", false);
-SettingsEntryEnum<std::string> Settings::indentStyle("editor", "indentStyle", {
-    {"Spaces", "spaces", _("Spaces")},
-    {"Tabs",   "tabs",   _("Tabs")}
-  }, "spaces");
-SettingsEntryEnum<std::string> Settings::tabKeyFunction("editor", "tabKeyFunction", {
-    {"Indent",    "indent", _("Indent")},
-    {"InsertTab", "tab",    _("Insert Tab")}
-  }, "Indent");
-SettingsEntryBool Settings::highlightCurrentLine("editor", "highlightCurrentLine", true);
-SettingsEntryBool Settings::enableBraceMatching("editor", "enableBraceMatching", true);
-SettingsEntryBool Settings::enableLineNumbers("editor", "enableLineNumbers", true);
-SettingsEntryBool Settings::enableNumberScrollWheel("editor", "enableNumberScrollWheel", true);
-SettingsEntryEnum<std::string> Settings::modifierNumberScrollWheel("editor", "modifierNumberScrollWheel", {
-    {"Alt",               "alt",               _("Alt")},
-    {"Left Mouse Button", "left-mouse-button", _("Left Mouse Button")},
-    {"Either",            "either",            _("Either")}
-  }, "Alt");
-
-SettingsEntryString Settings::defaultPrintService("printing", "printService", "NONE");
-SettingsEntryBool Settings::enableRemotePrintServices("printing", "enableRemotePrintServices", false);
-SettingsEntryBool Settings::printServiceAlwaysShowDialog("printing", "always-show-dialog", false);
-SettingsEntryString Settings::printServiceName("printing", "printServiceName", "");
+SettingsEntryBool Settings::backspaceUnindents("editor",
+                                               "backspaceUnindents",
+                                               false);
+SettingsEntryEnum<std::string> Settings::indentStyle(
+    "editor",
+    "indentStyle",
+    {{"Spaces", "spaces", _("Spaces")}, {"Tabs", "tabs", _("Tabs")}},
+    "spaces");
+SettingsEntryEnum<std::string> Settings::tabKeyFunction(
+    "editor",
+    "tabKeyFunction",
+    {{"Indent", "indent", _("Indent")}, {"InsertTab", "tab", _("Insert Tab")}},
+    "Indent");
+SettingsEntryBool Settings::highlightCurrentLine("editor",
+                                                 "highlightCurrentLine",
+                                                 true);
+SettingsEntryBool Settings::enableBraceMatching("editor",
+                                                "enableBraceMatching",
+                                                true);
+SettingsEntryBool Settings::enableLineNumbers("editor",
+                                              "enableLineNumbers",
+                                              true);
+SettingsEntryBool Settings::enableNumberScrollWheel("editor",
+                                                    "enableNumberScrollWheel",
+                                                    true);
+SettingsEntryEnum<std::string> Settings::modifierNumberScrollWheel(
+    "editor",
+    "modifierNumberScrollWheel",
+    {{"Alt", "alt", _("Alt")},
+     {"Left Mouse Button", "left-mouse-button", _("Left Mouse Button")},
+     {"Either", "either", _("Either")}},
+    "Alt");
+
+SettingsEntryString Settings::defaultPrintService("printing",
+                                                  "printService",
+                                                  "NONE");
+SettingsEntryBool Settings::enableRemotePrintServices(
+    "printing",
+    "enableRemotePrintServices",
+    false);
+SettingsEntryBool Settings::printServiceAlwaysShowDialog("printing",
+                                                         "always-show-dialog",
+                                                         false);
+SettingsEntryString Settings::printServiceName("printing",
+                                               "printServiceName",
+                                               "");
 SettingsEntryEnum<std::string> Settings::printServiceFileFormat(
-  "printing", "printServiceFileFormat", createFileFormatItems(fileformat::all3D()),
-  fileformat::info(FileFormat::ASCII_STL).description);
+    "printing",
+    "printServiceFileFormat",
+    createFileFormatItems(fileformat::all3D()),
+    fileformat::info(FileFormat::ASCII_STL).description);
 
 SettingsEntryString Settings::octoPrintUrl("printing", "octoPrintUrl", "");
-SettingsEntryString Settings::octoPrintApiKey("printing", "octoPrintApiKey", "");
-SettingsEntryEnum<std::string> Settings::octoPrintAction("printing", "octoPrintAction", {
-    {"upload", "upload", _("Upload only")},
-    {"slice",  "slice",  _("Upload & Slice")},
-    {"select", "select", _("Upload, Slice & Select for printing")},
-    {"print",  "print",  _("Upload, Slice & Start printing")}
-  }, "upload");
-SettingsEntryString Settings::octoPrintSlicerEngine("printing", "octoPrintSlicerEngine", "");
-SettingsEntryString Settings::octoPrintSlicerEngineDesc("printing", "octoPrintSlicerEngineDesc", "");
-SettingsEntryString Settings::octoPrintSlicerProfile("printing", "octoPrintSlicerProfile", "");
-SettingsEntryString Settings::octoPrintSlicerProfileDesc("printing", "octoPrintSlicerProfileDesc", "");
+SettingsEntryString Settings::octoPrintApiKey("printing",
+                                              "octoPrintApiKey",
+                                              "");
+SettingsEntryEnum<std::string> Settings::octoPrintAction(
+    "printing",
+    "octoPrintAction",
+    {{"upload", "upload", _("Upload only")},
+     {"slice", "slice", _("Upload & Slice")},
+     {"select", "select", _("Upload, Slice & Select for printing")},
+     {"print", "print", _("Upload, Slice & Start printing")}},
+    "upload");
+SettingsEntryString Settings::octoPrintSlicerEngine("printing",
+                                                    "octoPrintSlicerEngine",
+                                                    "");
+SettingsEntryString Settings::octoPrintSlicerEngineDesc(
+    "printing",
+    "octoPrintSlicerEngineDesc",
+    "");
+SettingsEntryString Settings::octoPrintSlicerProfile("printing",
+                                                     "octoPrintSlicerProfile",
+                                                     "");
+SettingsEntryString Settings::octoPrintSlicerProfileDesc(
+    "printing",
+    "octoPrintSlicerProfileDesc",
+    "");
 SettingsEntryEnum<std::string> Settings::octoPrintFileFormat(
-  "printing", "octoPrintFileFormat",
-  createFileFormatItems({FileFormat::ASCII_STL, FileFormat::BINARY_STL, FileFormat::_3MF, FileFormat::OFF}),
-  fileformat::info(FileFormat::ASCII_STL).description);
-
-SettingsEntryString Settings::localAppExecutable("printing", "localAppExecutable", "");
-SettingsEntryString Settings::localAppTempDir("printing", "localAppTempDir", "");
+    "printing",
+    "octoPrintFileFormat",
+    createFileFormatItems({FileFormat::ASCII_STL, FileFormat::BINARY_STL,
+                           FileFormat::_3MF, FileFormat::OFF}),
+    fileformat::info(FileFormat::ASCII_STL).description);
+
+SettingsEntryString Settings::localAppExecutable("printing",
+                                                 "localAppExecutable",
+                                                 "");
+SettingsEntryString Settings::localAppTempDir("printing",
+                                              "localAppTempDir",
+                                              "");
 SettingsEntryEnum<std::string> Settings::localAppFileFormat(
-  "printing", "localAppFileFormat", createFileFormatItems(fileformat::all3D()),
-  fileformat::info(FileFormat::ASCII_STL).description);
-SettingsEntryList<LocalAppParameter> Settings::localAppParameterList("printing", "localAppParameterList");
-
-SettingsEntryEnum<std::string> Settings::renderBackend3D("advanced", "renderBackend3D", {
-    {"CGAL",     "cgal",     "CGAL (old/slow)"},
-    {"Manifold", "manifold", "Manifold (new/fast)"}
-  }, "CGAL");
-SettingsEntryEnum<std::string> Settings::toolbarExport3D("advanced", "toolbarExport3D", createFileFormatItems(fileformat::all3D()), fileformat::info(FileFormat::ASCII_STL).description);
-SettingsEntryEnum<std::string> Settings::toolbarExport2D("advanced", "toolbarExport2D", createFileFormatItems(fileformat::all2D()), fileformat::info(FileFormat::DXF).description);
+    "printing",
+    "localAppFileFormat",
+    createFileFormatItems(fileformat::all3D()),
+    fileformat::info(FileFormat::ASCII_STL).description);
+SettingsEntryList<LocalAppParameter> Settings::localAppParameterList(
+    "printing",
+    "localAppParameterList");
+
+SettingsEntryEnum<std::string> Settings::renderBackend3D(
+    "advanced",
+    "renderBackend3D",
+    {{"CGAL", "cgal", "CGAL (old/slow)"},
+     {"Manifold", "manifold", "Manifold (new/fast)"}},
+    "CGAL");
+SettingsEntryEnum<std::string> Settings::toolbarExport3D(
+    "advanced",
+    "toolbarExport3D",
+    createFileFormatItems(fileformat::all3D()),
+    fileformat::info(FileFormat::ASCII_STL).description);
+SettingsEntryEnum<std::string> Settings::toolbarExport2D(
+    "advanced",
+    "toolbarExport2D",
+    createFileFormatItems(fileformat::all2D()),
+    fileformat::info(FileFormat::DXF).description);
 
 SettingsEntryBool Settings::summaryCamera("summary", "camera", false);
 SettingsEntryBool Settings::summaryArea("summary", "measurementArea", false);
 SettingsEntryBool Settings::summaryBoundingBox("summary", "boundingBox", false);
 
-SettingsEntryBool Settings::inputEnableDriverHIDAPI("input", "enableDriverHIDAPI", false);
-SettingsEntryBool Settings::inputEnableDriverHIDAPILog("input", "enableDriverHIDAPILog", false);
-SettingsEntryBool Settings::inputEnableDriverSPNAV("input", "enableDriverSPNAV", false);
-SettingsEntryBool Settings::inputEnableDriverJOYSTICK("input", "enableDriverJOYSTICK", false);
-SettingsEntryBool Settings::inputEnableDriverQGAMEPAD("input", "enableDriverQGAMEPAD", false);
-SettingsEntryBool Settings::inputEnableDriverDBUS("input", "enableDriverDBUS", false);
-
-SettingsEntryEnum<std::string> Settings::inputTranslationX("input", "translationX", axisValues(), "+1");
-SettingsEntryEnum<std::string> Settings::inputTranslationY("input", "translationY", axisValues(), "-2");
-SettingsEntryEnum<std::string> Settings::inputTranslationZ("input", "translationZ", axisValues(), "-3");
-SettingsEntryEnum<std::string> Settings::inputTranslationXVPRel("input", "translationXVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputTranslationYVPRel("input", "translationYVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputTranslationZVPRel("input", "translationZVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateX("input", "rotateX", axisValues(), "+4");
-SettingsEntryEnum<std::string> Settings::inputRotateY("input", "rotateY", axisValues(), "-5");
-SettingsEntryEnum<std::string> Settings::inputRotateZ("input", "rotateZ", axisValues(), "-6");
-SettingsEntryEnum<std::string> Settings::inputRotateXVPRel("input", "rotateXVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateYVPRel("input", "rotateYVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateZVPRel("input", "rotateZVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputZoom("input", "zoom", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputZoom2("input", "zoom2", axisValues(), "None");
-
-SettingsEntryDouble Settings::inputTranslationGain("input", "translationGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputTranslationVPRelGain("input", "translationVPRelGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputRotateGain("input", "rotateGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputRotateVPRelGain("input", "rotateVPRelGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputZoomGain("input", "zoomGain", 0.1, 0.1, 99.9, 1.0);
+SettingsEntryBool Settings::inputEnableDriverHIDAPI("input",
+                                                    "enableDriverHIDAPI",
+                                                    false);
+SettingsEntryBool Settings::inputEnableDriverHIDAPILog("input",
+                                                       "enableDriverHIDAPILog",
+                                                       false);
+SettingsEntryBool Settings::inputEnableDriverSPNAV("input",
+                                                   "enableDriverSPNAV",
+                                                   false);
+SettingsEntryBool Settings::inputEnableDriverJOYSTICK("input",
+                                                      "enableDriverJOYSTICK",
+                                                      false);
+SettingsEntryBool Settings::inputEnableDriverQGAMEPAD("input",
+                                                      "enableDriverQGAMEPAD",
+                                                      false);
+SettingsEntryBool Settings::inputEnableDriverDBUS("input",
+                                                  "enableDriverDBUS",
+                                                  false);
+
+SettingsEntryEnum<std::string> Settings::inputTranslationX("input",
+                                                           "translationX",
+                                                           axisValues(),
+                                                           "+1");
+SettingsEntryEnum<std::string> Settings::inputTranslationY("input",
+                                                           "translationY",
+                                                           axisValues(),
+                                                           "-2");
+SettingsEntryEnum<std::string> Settings::inputTranslationZ("input",
+                                                           "translationZ",
+                                                           axisValues(),
+                                                           "-3");
+SettingsEntryEnum<std::string> Settings::inputTranslationXVPRel(
+    "input",
+    "translationXVPRel",
+    axisValues(),
+    "None");
+SettingsEntryEnum<std::string> Settings::inputTranslationYVPRel(
+    "input",
+    "translationYVPRel",
+    axisValues(),
+    "None");
+SettingsEntryEnum<std::string> Settings::inputTranslationZVPRel(
+    "input",
+    "translationZVPRel",
+    axisValues(),
+    "None");
+SettingsEntryEnum<std::string> Settings::inputRotateX("input",
+                                                      "rotateX",
+                                                      axisValues(),
+                                                      "+4");
+SettingsEntryEnum<std::string> Settings::inputRotateY("input",
+                                                      "rotateY",
+                                                      axisValues(),
+                                                      "-5");
+SettingsEntryEnum<std::string> Settings::inputRotateZ("input",
+                                                      "rotateZ",
+                                                      axisValues(),
+                                                      "-6");
+SettingsEntryEnum<std::string> Settings::inputRotateXVPRel("input",
+                                                           "rotateXVPRel",
+                                                           axisValues(),
+                                                           "None");
+SettingsEntryEnum<std::string> Settings::inputRotateYVPRel("input",
+                                                           "rotateYVPRel",
+                                                           axisValues(),
+                                                           "None");
+SettingsEntryEnum<std::string> Settings::inputRotateZVPRel("input",
+                                                           "rotateZVPRel",
+                                                           axisValues(),
+                                                           "None");
+SettingsEntryEnum<std::string> Settings::inputZoom("input",
+                                                   "zoom",
+                                                   axisValues(),
+                                                   "None");
+SettingsEntryEnum<std::string> Settings::inputZoom2("input",
+                                                    "zoom2",
+                                                    axisValues(),
+                                                    "None");
+
+SettingsEntryDouble Settings::inputTranslationGain("input",
+                                                   "translationGain",
+                                                   0.01,
+                                                   0.01,
+                                                   9.99,
+                                                   1.00);
+SettingsEntryDouble Settings::inputTranslationVPRelGain("input",
+                                                        "translationVPRelGain",
+                                                        0.01,
+                                                        0.01,
+                                                        9.99,
+                                                        1.00);
+SettingsEntryDouble Settings::inputRotateGain("input",
+                                              "rotateGain",
+                                              0.01,
+                                              0.01,
+                                              9.99,
+                                              1.00);
+SettingsEntryDouble Settings::inputRotateVPRelGain("input",
+                                                   "rotateVPRelGain",
+                                                   0.01,
+                                                   0.01,
+                                                   9.99,
+                                                   1.00);
+SettingsEntryDouble Settings::inputZoomGain("input",
+                                            "zoomGain",
+                                            0.1,
+                                            0.1,
+                                            99.9,
+                                            1.0);
 
 SettingsEntryString Settings::inputButton0("input", "button0", "");
 SettingsEntryString Settings::inputButton1("input", "button1", "");
@@ -292,95 +453,310 @@ SettingsEntryString Settings::inputButton20("input", "button20", "");
 SettingsEntryString Settings::inputButton21("input", "button21", "");
 SettingsEntryString Settings::inputButton22("input", "button22", "");
 SettingsEntryString Settings::inputButton23("input", "button23", "");
-SettingsEntryDouble Settings::axisTrim0("input", "axisTrim0", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim1("input", "axisTrim1", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim2("input", "axisTrim2", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim3("input", "axisTrim3", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim4("input", "axisTrim4", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim5("input", "axisTrim5", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim6("input", "axisTrim6", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim7("input", "axisTrim7", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim8("input", "axisTrim8", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisDeadzone0("input", "axisDeadzone0", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone1("input", "axisDeadzone1", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone2("input", "axisDeadzone2", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone3("input", "axisDeadzone3", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone4("input", "axisDeadzone4", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone5("input", "axisDeadzone5", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone6("input", "axisDeadzone6", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone7("input", "axisDeadzone7", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone8("input", "axisDeadzone8", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisTrim0("input",
+                                        "axisTrim0",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim1("input",
+                                        "axisTrim1",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim2("input",
+                                        "axisTrim2",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim3("input",
+                                        "axisTrim3",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim4("input",
+                                        "axisTrim4",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim5("input",
+                                        "axisTrim5",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim6("input",
+                                        "axisTrim6",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim7("input",
+                                        "axisTrim7",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim8("input",
+                                        "axisTrim8",
+                                        -1.0,
+                                        0.01,
+                                        1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisDeadzone0("input",
+                                            "axisDeadzone0",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
+SettingsEntryDouble Settings::axisDeadzone1("input",
+                                            "axisDeadzone1",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
+SettingsEntryDouble Settings::axisDeadzone2("input",
+                                            "axisDeadzone2",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
+SettingsEntryDouble Settings::axisDeadzone3("input",
+                                            "axisDeadzone3",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
+SettingsEntryDouble Settings::axisDeadzone4("input",
+                                            "axisDeadzone4",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
+SettingsEntryDouble Settings::axisDeadzone5("input",
+                                            "axisDeadzone5",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
+SettingsEntryDouble Settings::axisDeadzone6("input",
+                                            "axisDeadzone6",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
+SettingsEntryDouble Settings::axisDeadzone7("input",
+                                            "axisDeadzone7",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
+SettingsEntryDouble Settings::axisDeadzone8("input",
+                                            "axisDeadzone8",
+                                            0.0,
+                                            0.01,
+                                            1.0,
+                                            0.10);
 
 SettingsEntryInt Settings::joystickNr("input", "joystickNr", 0, 9, 0);
 
-SettingsEntryString SettingsPython::pythonTrustedFiles(SECTION_PYTHON, "trusted-files", "");
-SettingsEntryString SettingsPython::pythonVirtualEnv(SECTION_PYTHON, "virtual-env", "");
-
-SettingsEntryBool SettingsExportPdf::exportPdfAlwaysShowDialog(SECTION_EXPORT_PDF, "always-show-dialog", true);
-SettingsEntryEnum<ExportPdfPaperSize> SettingsExportPdf::exportPdfPaperSize(SECTION_EXPORT_PDF, "paper-size", {
-    {ExportPdfPaperSize::A6,      "a6",      _("A6 (105 x 148 mm)")},
-    {ExportPdfPaperSize::A5,      "a5",      _("A5 (148 x 210 mm)")},
-    {ExportPdfPaperSize::A4,      "a4",      _("A4 (210x297 mm)")},
-    {ExportPdfPaperSize::A3,      "a3",      _("A3 (297x420 mm)")},
-    {ExportPdfPaperSize::LETTER,  "letter",  _("Letter (8.5x11 in)")},
-    {ExportPdfPaperSize::LEGAL,   "legal",   _("Legal (8.5x14 in)")},
-    {ExportPdfPaperSize::TABLOID, "tabloid", _("Tabloid (11x17 in)")}
-  }, ExportPdfPaperSize::A4);
-SettingsEntryEnum<ExportPdfPaperOrientation> SettingsExportPdf::exportPdfOrientation(SECTION_EXPORT_PDF, "orientation", {
-    {ExportPdfPaperOrientation::PORTRAIT,  "portrait",  _("Portrait (Vertical)")},
-    {ExportPdfPaperOrientation::LANDSCAPE, "landscape", _("Landscape (Horizontal)")},
-    {ExportPdfPaperOrientation::AUTO,      "auto",      _("Auto")}
-  }, ExportPdfPaperOrientation::PORTRAIT);
-SettingsEntryBool SettingsExportPdf::exportPdfShowFilename(SECTION_EXPORT_PDF, "show-filename", false);
-SettingsEntryBool SettingsExportPdf::exportPdfShowScale(SECTION_EXPORT_PDF, "show-scale", true);
-SettingsEntryBool SettingsExportPdf::exportPdfShowScaleMessage(SECTION_EXPORT_PDF, "show-scale-message", true);
-SettingsEntryBool SettingsExportPdf::exportPdfShowGrid(SECTION_EXPORT_PDF, "show-grid", false);
-SettingsEntryDouble SettingsExportPdf::exportPdfGridSize(SECTION_EXPORT_PDF, "grid-size", 1.0, 1.0, 100.0, 10.0);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaData(SECTION_EXPORT_PDF, "add-meta-data", true);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataAuthor(SECTION_EXPORT_PDF, "add-meta-data-author", false);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataSubject(SECTION_EXPORT_PDF, "add-meta-data-subject", false);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataKeywords(SECTION_EXPORT_PDF, "add-meta-data-keywords", false);
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataTitle(SECTION_EXPORT_PDF, "meta-data-title", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataAuthor(SECTION_EXPORT_PDF, "meta-data-author", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataSubject(SECTION_EXPORT_PDF, "meta-data-subject", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataKeywords(SECTION_EXPORT_PDF, "meta-data-keywords", "");
-SettingsEntryBool SettingsExportPdf::exportPdfFill(SECTION_EXPORT_PDF, "fill", false);
-SettingsEntryString SettingsExportPdf::exportPdfFillColor(SECTION_EXPORT_PDF, "fill-color", "black");
-SettingsEntryBool SettingsExportPdf::exportPdfStroke(SECTION_EXPORT_PDF, "stroke", true);
-SettingsEntryString SettingsExportPdf::exportPdfStrokeColor(SECTION_EXPORT_PDF, "stroke-color", "black");
-SettingsEntryDouble SettingsExportPdf::exportPdfStrokeWidth(SECTION_EXPORT_PDF, "stroke-width", 0, 0.01, 999, 0.35);
-
-SettingsEntryBool SettingsExport3mf::export3mfAlwaysShowDialog(SECTION_EXPORT_3MF, "always-show-dialog", true);
-SettingsEntryEnum<Export3mfColorMode> SettingsExport3mf::export3mfColorMode(SECTION_EXPORT_3MF, "color-mode", {
-    {Export3mfColorMode::model,               "model",               _("Use colors from model")},
-    {Export3mfColorMode::none,                "none",                _("No colors")},
-    {Export3mfColorMode::selected_only,       "selected-only",       _("Use selected color only")},
-  }, Export3mfColorMode::model);
-SettingsEntryEnum<Export3mfUnit> SettingsExport3mf::export3mfUnit(SECTION_EXPORT_3MF, "unit", {
-    {Export3mfUnit::micron,     "micron",     _("Micron")},
-    {Export3mfUnit::millimeter, "millimeter", _("Millimeter")},
-    {Export3mfUnit::centimeter, "centimeter", _("Centimeter")},
-    {Export3mfUnit::meter,      "meter",      _("Meter")},
-    {Export3mfUnit::inch,       "inch",       _("Inch")},
-    {Export3mfUnit::foot,       "foot",       _("Feet")},
-  }, Export3mfUnit::millimeter);
-SettingsEntryString SettingsExport3mf::export3mfColor(SECTION_EXPORT_3MF, "color", "#f9d72c"); // Cornfield: CGAL_FACE_FRONT_COLOR
-SettingsEntryEnum<Export3mfMaterialType> SettingsExport3mf::export3mfMaterialType(SECTION_EXPORT_3MF, "material-type", {
-    {Export3mfMaterialType::color,        "color",        _("Color")},
-    {Export3mfMaterialType::basematerial, "basematerial", _("Base Material")},
-  }, Export3mfMaterialType::basematerial);
-SettingsEntryInt SettingsExport3mf::export3mfDecimalPrecision(SECTION_EXPORT_3MF, "decimal-precision", 1, 16, 6);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaData(SECTION_EXPORT_3MF, "add-meta-data", true);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDesigner(SECTION_EXPORT_3MF, "add-meta-data-designer", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDescription(SECTION_EXPORT_3MF, "add-meta-data-description", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataCopyright(SECTION_EXPORT_3MF, "add-meta-data-copyright", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataLicenseTerms(SECTION_EXPORT_3MF, "add-meta-data-license-terms", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataRating(SECTION_EXPORT_3MF, "add-meta-data-rating", false);
-SettingsEntryString SettingsExport3mf::export3mfMetaDataTitle(SECTION_EXPORT_3MF, "meta-data-title", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataDesigner(SECTION_EXPORT_3MF, "meta-data-designer", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataDescription(SECTION_EXPORT_3MF, "meta-data-description", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataCopyright(SECTION_EXPORT_3MF, "meta-data-copyright", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataLicenseTerms(SECTION_EXPORT_3MF, "meta-data-license-terms", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataRating(SECTION_EXPORT_3MF, "meta-data-rating", "");
-
-} // namespace Settings
+SettingsEntryString SettingsPython::pythonTrustedFiles(SECTION_PYTHON,
+                                                       "trusted-files",
+                                                       "");
+SettingsEntryString SettingsPython::pythonVirtualEnv(SECTION_PYTHON,
+                                                     "virtual-env",
+                                                     "");
+
+SettingsEntryBool SettingsExportPdf::exportPdfAlwaysShowDialog(
+    SECTION_EXPORT_PDF,
+    "always-show-dialog",
+    true);
+SettingsEntryEnum<ExportPdfPaperSize> SettingsExportPdf::exportPdfPaperSize(
+    SECTION_EXPORT_PDF,
+    "paper-size",
+    {{ExportPdfPaperSize::A6, "a6", _("A6 (105 x 148 mm)")},
+     {ExportPdfPaperSize::A5, "a5", _("A5 (148 x 210 mm)")},
+     {ExportPdfPaperSize::A4, "a4", _("A4 (210x297 mm)")},
+     {ExportPdfPaperSize::A3, "a3", _("A3 (297x420 mm)")},
+     {ExportPdfPaperSize::LETTER, "letter", _("Letter (8.5x11 in)")},
+     {ExportPdfPaperSize::LEGAL, "legal", _("Legal (8.5x14 in)")},
+     {ExportPdfPaperSize::TABLOID, "tabloid", _("Tabloid (11x17 in)")}},
+    ExportPdfPaperSize::A4);
+SettingsEntryEnum<ExportPdfPaperOrientation>
+    SettingsExportPdf::exportPdfOrientation(
+        SECTION_EXPORT_PDF,
+        "orientation",
+        {{ExportPdfPaperOrientation::PORTRAIT, "portrait",
+          _("Portrait (Vertical)")},
+         {ExportPdfPaperOrientation::LANDSCAPE, "landscape",
+          _("Landscape (Horizontal)")},
+         {ExportPdfPaperOrientation::AUTO, "auto", _("Auto")}},
+        ExportPdfPaperOrientation::PORTRAIT);
+SettingsEntryBool SettingsExportPdf::exportPdfShowFilename(SECTION_EXPORT_PDF,
+                                                           "show-filename",
+                                                           false);
+SettingsEntryBool SettingsExportPdf::exportPdfShowScale(SECTION_EXPORT_PDF,
+                                                        "show-scale",
+                                                        true);
+SettingsEntryBool SettingsExportPdf::exportPdfShowScaleMessage(
+    SECTION_EXPORT_PDF,
+    "show-scale-message",
+    true);
+SettingsEntryBool SettingsExportPdf::exportPdfShowGrid(SECTION_EXPORT_PDF,
+                                                       "show-grid",
+                                                       false);
+SettingsEntryDouble SettingsExportPdf::exportPdfGridSize(SECTION_EXPORT_PDF,
+                                                         "grid-size",
+                                                         1.0,
+                                                         1.0,
+                                                         100.0,
+                                                         10.0);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaData(SECTION_EXPORT_PDF,
+                                                          "add-meta-data",
+                                                          true);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataAuthor(
+    SECTION_EXPORT_PDF,
+    "add-meta-data-author",
+    false);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataSubject(
+    SECTION_EXPORT_PDF,
+    "add-meta-data-subject",
+    false);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataKeywords(
+    SECTION_EXPORT_PDF,
+    "add-meta-data-keywords",
+    false);
+SettingsEntryString SettingsExportPdf::exportPdfMetaDataTitle(
+    SECTION_EXPORT_PDF,
+    "meta-data-title",
+    "");
+SettingsEntryString SettingsExportPdf::exportPdfMetaDataAuthor(
+    SECTION_EXPORT_PDF,
+    "meta-data-author",
+    "");
+SettingsEntryString SettingsExportPdf::exportPdfMetaDataSubject(
+    SECTION_EXPORT_PDF,
+    "meta-data-subject",
+    "");
+SettingsEntryString SettingsExportPdf::exportPdfMetaDataKeywords(
+    SECTION_EXPORT_PDF,
+    "meta-data-keywords",
+    "");
+SettingsEntryBool SettingsExportPdf::exportPdfFill(SECTION_EXPORT_PDF,
+                                                   "fill",
+                                                   false);
+SettingsEntryString SettingsExportPdf::exportPdfFillColor(SECTION_EXPORT_PDF,
+                                                          "fill-color",
+                                                          "black");
+SettingsEntryBool SettingsExportPdf::exportPdfStroke(SECTION_EXPORT_PDF,
+                                                     "stroke",
+                                                     true);
+SettingsEntryString SettingsExportPdf::exportPdfStrokeColor(SECTION_EXPORT_PDF,
+                                                            "stroke-color",
+                                                            "black");
+SettingsEntryDouble SettingsExportPdf::exportPdfStrokeWidth(SECTION_EXPORT_PDF,
+                                                            "stroke-width",
+                                                            0,
+                                                            0.01,
+                                                            999,
+                                                            0.35);
+
+SettingsEntryBool SettingsExport3mf::export3mfAlwaysShowDialog(
+    SECTION_EXPORT_3MF,
+    "always-show-dialog",
+    true);
+SettingsEntryEnum<Export3mfColorMode> SettingsExport3mf::export3mfColorMode(
+    SECTION_EXPORT_3MF,
+    "color-mode",
+    {
+        {Export3mfColorMode::model, "model", _("Use colors from model")},
+        {Export3mfColorMode::none, "none", _("No colors")},
+        {Export3mfColorMode::selected_only, "selected-only",
+         _("Use selected color only")},
+    },
+    Export3mfColorMode::model);
+SettingsEntryEnum<Export3mfUnit> SettingsExport3mf::export3mfUnit(
+    SECTION_EXPORT_3MF,
+    "unit",
+    {
+        {Export3mfUnit::micron, "micron", _("Micron")},
+        {Export3mfUnit::millimeter, "millimeter", _("Millimeter")},
+        {Export3mfUnit::centimeter, "centimeter", _("Centimeter")},
+        {Export3mfUnit::meter, "meter", _("Meter")},
+        {Export3mfUnit::inch, "inch", _("Inch")},
+        {Export3mfUnit::foot, "foot", _("Feet")},
+    },
+    Export3mfUnit::millimeter);
+SettingsEntryString SettingsExport3mf::export3mfColor(
+    SECTION_EXPORT_3MF,
+    "color",
+    "#f9d72c");  // Cornfield: CGAL_FACE_FRONT_COLOR
+SettingsEntryEnum<Export3mfMaterialType>
+    SettingsExport3mf::export3mfMaterialType(
+        SECTION_EXPORT_3MF,
+        "material-type",
+        {
+            {Export3mfMaterialType::color, "color", _("Color")},
+            {Export3mfMaterialType::basematerial, "basematerial",
+             _("Base Material")},
+        },
+        Export3mfMaterialType::basematerial);
+SettingsEntryInt SettingsExport3mf::export3mfDecimalPrecision(
+    SECTION_EXPORT_3MF,
+    "decimal-precision",
+    1,
+    16,
+    6);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaData(SECTION_EXPORT_3MF,
+                                                          "add-meta-data",
+                                                          true);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDesigner(
+    SECTION_EXPORT_3MF,
+    "add-meta-data-designer",
+    false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDescription(
+    SECTION_EXPORT_3MF,
+    "add-meta-data-description",
+    false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataCopyright(
+    SECTION_EXPORT_3MF,
+    "add-meta-data-copyright",
+    false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataLicenseTerms(
+    SECTION_EXPORT_3MF,
+    "add-meta-data-license-terms",
+    false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataRating(
+    SECTION_EXPORT_3MF,
+    "add-meta-data-rating",
+    false);
+SettingsEntryString SettingsExport3mf::export3mfMetaDataTitle(
+    SECTION_EXPORT_3MF,
+    "meta-data-title",
+    "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataDesigner(
+    SECTION_EXPORT_3MF,
+    "meta-data-designer",
+    "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataDescription(
+    SECTION_EXPORT_3MF,
+    "meta-data-description",
+    "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataCopyright(
+    SECTION_EXPORT_3MF,
+    "meta-data-copyright",
+    "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataLicenseTerms(
+    SECTION_EXPORT_3MF,
+    "meta-data-license-terms",
+    "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataRating(
+    SECTION_EXPORT_3MF,
+    "meta-data-rating",
+    "");
+
+}  // namespace Settings
diff --git a/src/core/Settings.h b/src/core/Settings.h
index 6755bcf33..7ab4c1144 100644
--- a/src/core/Settings.h
+++ b/src/core/Settings.h
@@ -1,13 +1,13 @@
 #pragma once
 
+#include <array>
 #include <cstddef>
 #include <cstdint>
+#include <sstream>
 #include <string>
+#include <tuple>
 #include <utility>
 #include <vector>
-#include <array>
-#include <sstream>
-#include <tuple>
 
 #include "io/export_enums.h"
 
@@ -21,16 +21,16 @@ constexpr inline size_t max_buttons = 24;
 
 // Property name in GUI designer for matching enum values
 constexpr inline auto PROPERTY_NAME = "_settings_value";
-// Additional value for enums that can map to an additional value (e.g. GridSize in PDF Export)
+// Additional value for enums that can map to an additional value (e.g. GridSize
+// in PDF Export)
 constexpr inline auto PROPERTY_SELECTED_VALUE = "_selected_value";
 
 constexpr inline auto SECTION_PYTHON = "python";
 constexpr inline auto SECTION_EXPORT_PDF = "export-pdf";
 constexpr inline auto SECTION_EXPORT_3MF = "export-3mf";
 
-class SettingsEntryBase
-{
-public:
+class SettingsEntryBase {
+ public:
   const std::string& category() const { return _category; }
   const std::string& name() const { return _name; }
   const std::string key() const { return category() + "/" + name(); }
@@ -40,36 +40,36 @@ public:
   virtual void set(const std::string& encoded) = 0;
   virtual const std::tuple<std::string, std::string> help() const = 0;
 
-protected:
+ protected:
   SettingsEntryBase(std::string category, std::string name);
   virtual ~SettingsEntryBase() = default;
 
-private:
+ private:
   std::string _category;
   std::string _name;
 };
 
 template <typename entry_type>
-class SettingsEntry : public SettingsEntryBase
-{
-public:
+class SettingsEntry : public SettingsEntryBase {
+ public:
   using entry_type_t = entry_type;
 
   virtual const entry_type decode(const std::string& encoded) const = 0;
 
-protected:
-  SettingsEntry(const std::string& category, const std::string& name) : SettingsEntryBase(category, name) {}
+ protected:
+  SettingsEntry(const std::string& category, const std::string& name)
+      : SettingsEntryBase(category, name) {}
   virtual ~SettingsEntry() = default;
 };
 
-class SettingsEntryBool : public SettingsEntry<bool>
-{
-public:
-  SettingsEntryBool(const std::string& category, const std::string& name, bool defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue)
-  {}
+class SettingsEntryBool : public SettingsEntry<bool> {
+ public:
+  SettingsEntryBool(const std::string& category,
+                    const std::string& name,
+                    bool defaultValue)
+      : SettingsEntry(category, name),
+        _value(defaultValue),
+        _defaultValue(defaultValue) {}
 
   bool value() const { return _value; }
   void setValue(bool value) { _value = value; }
@@ -82,21 +82,23 @@ public:
     return {"bool", defaultValue() ? "<true>/false" : "true/<false>"};
   }
 
-private:
+ private:
   bool _value;
   bool _defaultValue;
 };
 
-class SettingsEntryInt : public SettingsEntry<int>
-{
-public:
-  SettingsEntryInt(const std::string& category, const std::string& name, int minimum, int maximum, int defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue),
-    _minimum(minimum),
-    _maximum(maximum)
-  {}
+class SettingsEntryInt : public SettingsEntry<int> {
+ public:
+  SettingsEntryInt(const std::string& category,
+                   const std::string& name,
+                   int minimum,
+                   int maximum,
+                   int defaultValue)
+      : SettingsEntry(category, name),
+        _value(defaultValue),
+        _defaultValue(defaultValue),
+        _minimum(minimum),
+        _maximum(maximum) {}
 
   int value() const { return _value; }
   void setValue(int value) { _value = value; }
@@ -108,27 +110,32 @@ public:
   const int decode(const std::string& encoded) const override;
   void set(const std::string& encoded) override { setValue(decode(encoded)); }
   const std::tuple<std::string, std::string> help() const override {
-    return {"int", std::to_string(_minimum) + " : <" + std::to_string(defaultValue()) + "> : " + std::to_string(maximum())};
+    return {"int", std::to_string(_minimum) + " : <" +
+                       std::to_string(defaultValue()) +
+                       "> : " + std::to_string(maximum())};
   }
 
-private:
+ private:
   int _value;
   int _defaultValue;
   int _minimum;
   int _maximum;
 };
 
-class SettingsEntryDouble : public SettingsEntry<double>
-{
-public:
-  SettingsEntryDouble(const std::string& category, const std::string& name, double minimum, double step, double maximum, double defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue),
-    _minimum(minimum),
-    _step(step),
-    _maximum(maximum)
-  {}
+class SettingsEntryDouble : public SettingsEntry<double> {
+ public:
+  SettingsEntryDouble(const std::string& category,
+                      const std::string& name,
+                      double minimum,
+                      double step,
+                      double maximum,
+                      double defaultValue)
+      : SettingsEntry(category, name),
+        _value(defaultValue),
+        _defaultValue(defaultValue),
+        _minimum(minimum),
+        _step(step),
+        _maximum(maximum) {}
 
   double value() const { return _value; }
   void setValue(double value) { _value = value; }
@@ -141,10 +148,12 @@ public:
   const double decode(const std::string& encoded) const override;
   void set(const std::string& encoded) override { setValue(decode(encoded)); }
   const std::tuple<std::string, std::string> help() const override {
-    return {"double", std::to_string(_minimum) + " : <" + std::to_string(defaultValue()) + "> : " + std::to_string(maximum())};
+    return {"double", std::to_string(_minimum) + " : <" +
+                          std::to_string(defaultValue()) +
+                          "> : " + std::to_string(maximum())};
   }
 
-private:
+ private:
   double _value;
   double _defaultValue;
   double _minimum;
@@ -152,45 +161,52 @@ private:
   double _maximum;
 };
 
-class SettingsEntryString : public SettingsEntry<std::string>
-{
-public:
-  SettingsEntryString(const std::string& category, const std::string& name, const std::string& defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue)
-  {}
+class SettingsEntryString : public SettingsEntry<std::string> {
+ public:
+  SettingsEntryString(const std::string& category,
+                      const std::string& name,
+                      const std::string& defaultValue)
+      : SettingsEntry(category, name),
+        _value(defaultValue),
+        _defaultValue(defaultValue) {}
 
   const std::string& value() const { return _value; }
   void setValue(const std::string& value) { _value = value; }
   const std::string& defaultValue() const { return _defaultValue; }
   bool isDefault() const override { return _value == _defaultValue; }
   std::string encode() const override { return value(); }
-  const std::string decode(const std::string& encoded) const override { return encoded; }
+  const std::string decode(const std::string& encoded) const override {
+    return encoded;
+  }
   void set(const std::string& encoded) override { setValue(decode(encoded)); }
-  const std::tuple<std::string, std::string> help() const override { return {"string", "\"" + encode() + "\""}; }
+  const std::tuple<std::string, std::string> help() const override {
+    return {"string", "\"" + encode() + "\""};
+  }
 
-private:
+ private:
   std::string _value;
   std::string _defaultValue;
 };
 
 template <typename enum_type>
-class SettingsEntryEnum : public SettingsEntry<enum_type>
-{
-public:
+class SettingsEntryEnum : public SettingsEntry<enum_type> {
+ public:
   struct Item {
-    Item(enum_type value, std::string name, std::string description) : value(value), name(std::move(name)), description(std::move(description)) {
-    }
+    Item(enum_type value, std::string name, std::string description)
+        : value(value),
+          name(std::move(name)),
+          description(std::move(description)) {}
     enum_type value;
     std::string name;
     std::string description;
   };
-  SettingsEntryEnum(const std::string& category, const std::string& name, std::vector<Item> items, enum_type defaultValue) :
-    SettingsEntry<enum_type>(category, name),
-    _items(std::move(items)),
-    _defaultValue(std::move(defaultValue))
-  {
+  SettingsEntryEnum(const std::string& category,
+                    const std::string& name,
+                    std::vector<Item> items,
+                    enum_type defaultValue)
+      : SettingsEntry<enum_type>(category, name),
+        _items(std::move(items)),
+        _defaultValue(std::move(defaultValue)) {
     setValue(_defaultValue);
   }
 
@@ -198,7 +214,10 @@ public:
   const enum_type& value() const { return item().value; }
   size_t index() const { return _index; }
   void setValue(const enum_type& value);
-  void setIndex(size_t index) { if (index < _items.size()) _index = index; }
+  void setIndex(size_t index) {
+    if (index < _items.size())
+      _index = index;
+  }
   const std::vector<Item>& items() const { return _items; }
   const enum_type& defaultValue() const { return _defaultValue; }
   bool isDefault() const override { return value() == _defaultValue; }
@@ -219,15 +238,14 @@ public:
     return {"enum", list};
   }
 
-private:
+ private:
   std::vector<Item> _items;
   size_t _index{0};
   enum_type _defaultValue;
 };
 
 template <typename enum_type>
-void SettingsEntryEnum<enum_type>::setValue(const enum_type& value)
-{
+void SettingsEntryEnum<enum_type>::setValue(const enum_type& value) {
   for (size_t i = 0; i < _items.size(); ++i) {
     if (_items[i].value == value) {
       _index = i;
@@ -237,10 +255,13 @@ void SettingsEntryEnum<enum_type>::setValue(const enum_type& value)
 }
 
 template <typename enum_type>
-std::string SettingsEntryEnum<enum_type>::encode() const { return item().name; }
+std::string SettingsEntryEnum<enum_type>::encode() const {
+  return item().name;
+}
 
 template <typename enum_type>
-const enum_type SettingsEntryEnum<enum_type>::decode(const std::string& encoded) const {
+const enum_type SettingsEntryEnum<enum_type>::decode(
+    const std::string& encoded) const {
   for (const Item& item : items()) {
     if (item.name == encoded) {
       return item.value;
@@ -250,16 +271,19 @@ const enum_type SettingsEntryEnum<enum_type>::decode(const std::string& encoded)
 }
 
 template <>
-inline std::string SettingsEntryEnum<std::string>::encode() const { return value(); }
+inline std::string SettingsEntryEnum<std::string>::encode() const {
+  return value();
+}
 
 template <>
-inline const std::string SettingsEntryEnum<std::string>::decode(const std::string& encoded) const { return encoded; }
+inline const std::string SettingsEntryEnum<std::string>::decode(
+    const std::string& encoded) const {
+  return encoded;
+}
 
-class LocalAppParameterType
-{
-public:
-  enum Value : uint8_t
-  {
+class LocalAppParameterType {
+ public:
+  enum Value : uint8_t {
     invalid,
     string,
     file,
@@ -270,37 +294,49 @@ public:
   };
 
   LocalAppParameterType() = default;
-  constexpr LocalAppParameterType(Value v) : value(v) { }
-  constexpr operator Value() const {
-    return value;
-  }
+  constexpr LocalAppParameterType(Value v) : value(v) {}
+  constexpr operator Value() const { return value; }
   explicit operator bool() const = delete;
 
   std::string icon() const {
     switch (value) {
-    case string: return "chokusen-parameter";
-    case file: return "chokusen-orthogonal";
-    case dir: return "chokusen-folder";
-    case extension: return "chokusen-parameter";
-    case source: return "chokusen-file";
-    case sourcedir: return "chokusen-folder";
-    default: return "*invalid*";
+      case string:
+        return "chokusen-parameter";
+      case file:
+        return "chokusen-orthogonal";
+      case dir:
+        return "chokusen-folder";
+      case extension:
+        return "chokusen-parameter";
+      case source:
+        return "chokusen-file";
+      case sourcedir:
+        return "chokusen-folder";
+      default:
+        return "*invalid*";
     }
   }
 
   std::string description() const {
     switch (value) {
-    case string: return "";
-    case file: return "<full path to the output file>";
-    case dir: return "<directory of the output file>";
-    case extension: return "<extension of the output file without leading dot>";
-    case source: return "<full path to the main source file>";
-    case sourcedir: return "<directory of the main source file>";
-    default: return "*invalid*";
+      case string:
+        return "";
+      case file:
+        return "<full path to the output file>";
+      case dir:
+        return "<directory of the output file>";
+      case extension:
+        return "<extension of the output file without leading dot>";
+      case source:
+        return "<full path to the main source file>";
+      case sourcedir:
+        return "<directory of the main source file>";
+      default:
+        return "*invalid*";
     }
   }
 
-private:
+ private:
   Value value;
 };
 
@@ -308,24 +344,18 @@ struct LocalAppParameter {
   LocalAppParameterType type;
   std::string value;
 
-  LocalAppParameter() : type(LocalAppParameterType::string), value("") {
-  }
-  LocalAppParameter(const LocalAppParameterType t, std::string v) : type(t), value(std::move(v)) {
-  }
-  operator bool() const {
-    return type != LocalAppParameterType::invalid;
-  }
+  LocalAppParameter() : type(LocalAppParameterType::string), value("") {}
+  LocalAppParameter(const LocalAppParameterType t, std::string v)
+      : type(t), value(std::move(v)) {}
+  operator bool() const { return type != LocalAppParameterType::invalid; }
 };
 
 template <typename item_type>
-class SettingsEntryList : public SettingsEntry<std::vector<item_type>>
-{
-public:
+class SettingsEntryList : public SettingsEntry<std::vector<item_type>> {
+ public:
   using list_type_t = std::vector<item_type>;
-  SettingsEntryList(const std::string& category, const std::string& name) :
-    SettingsEntry<std::vector<item_type>>(category, name)
-  {
-  }
+  SettingsEntryList(const std::string& category, const std::string& name)
+      : SettingsEntry<std::vector<item_type>>(category, name) {}
   const list_type_t& value() const { return _items; }
   void setValue(const list_type_t& items) { _items = items; }
   bool isDefault() const override { return _items.empty(); }
@@ -336,7 +366,8 @@ public:
     }
     return oss.str();
   }
-  const std::vector<item_type> decode(const std::string& encoded) const override {
+  const std::vector<item_type> decode(
+      const std::string& encoded) const override {
     std::vector<item_type> items;
     std::stringstream ss;
     ss << encoded;
@@ -354,15 +385,14 @@ public:
     return {"list", ""};
   }
 
-private:
+ private:
   list_type_t _items;
 };
 
 class SettingsVisitor;
 
-class Settings
-{
-public:
+class Settings {
+ public:
   static SettingsEntryBool showWarningsIn3dView;
   static SettingsEntryBool mouseCentricZoom;
   static SettingsEntryBool mouseSwapButtons;
@@ -487,16 +517,14 @@ public:
   static void visit(const SettingsVisitor& visitor);
 };
 
-class SettingsPython
-{
-public:
+class SettingsPython {
+ public:
   static SettingsEntryString pythonTrustedFiles;
   static SettingsEntryString pythonVirtualEnv;
 };
 
-class SettingsExportPdf
-{
-public:
+class SettingsExportPdf {
+ public:
   static SettingsEntryBool exportPdfAlwaysShowDialog;
   static SettingsEntryEnum<ExportPdfPaperSize> exportPdfPaperSize;
   static SettingsEntryEnum<ExportPdfPaperOrientation> exportPdfOrientation;
@@ -519,30 +547,29 @@ public:
   static SettingsEntryString exportPdfStrokeColor;
   static SettingsEntryDouble exportPdfStrokeWidth;
 
-  static constexpr std::array<const SettingsEntryBase *, 17> cmdline{
-    &exportPdfPaperSize,
-    &exportPdfOrientation,
-    &exportPdfShowFilename,
-    &exportPdfShowScale,
-    &exportPdfShowScaleMessage,
-    &exportPdfShowGrid,
-    &exportPdfGridSize,
-    &exportPdfAddMetaData,
-    &exportPdfMetaDataTitle,
-    &exportPdfMetaDataAuthor,
-    &exportPdfMetaDataSubject,
-    &exportPdfMetaDataKeywords,
-    &exportPdfFill,
-    &exportPdfFillColor,
-    &exportPdfStroke,
-    &exportPdfStrokeColor,
-    &exportPdfStrokeWidth,
+  static constexpr std::array<const SettingsEntryBase*, 17> cmdline{
+      &exportPdfPaperSize,
+      &exportPdfOrientation,
+      &exportPdfShowFilename,
+      &exportPdfShowScale,
+      &exportPdfShowScaleMessage,
+      &exportPdfShowGrid,
+      &exportPdfGridSize,
+      &exportPdfAddMetaData,
+      &exportPdfMetaDataTitle,
+      &exportPdfMetaDataAuthor,
+      &exportPdfMetaDataSubject,
+      &exportPdfMetaDataKeywords,
+      &exportPdfFill,
+      &exportPdfFillColor,
+      &exportPdfStroke,
+      &exportPdfStrokeColor,
+      &exportPdfStrokeWidth,
   };
 };
 
-class SettingsExport3mf
-{
-public:
+class SettingsExport3mf {
+ public:
   static SettingsEntryBool export3mfAlwaysShowDialog;
   static SettingsEntryEnum<Export3mfColorMode> export3mfColorMode;
   static SettingsEntryEnum<Export3mfUnit> export3mfUnit;
@@ -562,29 +589,28 @@ public:
   static SettingsEntryString export3mfMetaDataLicenseTerms;
   static SettingsEntryString export3mfMetaDataRating;
 
-  static constexpr std::array<const SettingsEntryBase *, 12> cmdline{
-    &export3mfColorMode,
-    &export3mfUnit,
-    &export3mfColor,
-    &export3mfMaterialType,
-    &export3mfDecimalPrecision,
-    &export3mfAddMetaData,
-    &export3mfMetaDataTitle,
-    &export3mfMetaDataDesigner,
-    &export3mfMetaDataDescription,
-    &export3mfMetaDataCopyright,
-    &export3mfMetaDataLicenseTerms,
-    &export3mfMetaDataRating,
+  static constexpr std::array<const SettingsEntryBase*, 12> cmdline{
+      &export3mfColorMode,
+      &export3mfUnit,
+      &export3mfColor,
+      &export3mfMaterialType,
+      &export3mfDecimalPrecision,
+      &export3mfAddMetaData,
+      &export3mfMetaDataTitle,
+      &export3mfMetaDataDesigner,
+      &export3mfMetaDataDescription,
+      &export3mfMetaDataCopyright,
+      &export3mfMetaDataLicenseTerms,
+      &export3mfMetaDataRating,
   };
 };
 
-class SettingsVisitor
-{
-public:
+class SettingsVisitor {
+ public:
   SettingsVisitor() = default;
   virtual ~SettingsVisitor() = default;
 
   virtual void handle(SettingsEntryBase& entry) const = 0;
 };
 
-} // namespace Settings
+}  // namespace Settings
diff --git a/src/core/SourceFile.cc b/src/core/SourceFile.cc
index 3b87eb69a..07f391584 100644
--- a/src/core/SourceFile.cc
+++ b/src/core/SourceFile.cc
@@ -25,44 +25,40 @@
  */
 
 #include "core/SourceFile.h"
-#include "core/SourceFileCache.h"
-#include "core/node.h"
-#include "utils/printutils.h"
-#include "utils/exceptions.h"
-#include "core/ScopeContext.h"
-#include "core/parsersettings.h"
-#include "core/StatCache.h"
 #include <algorithm>
-#include <ctime>
-#include <ostream>
-#include <memory>
 #include <boost/algorithm/string.hpp>
+#include <ctime>
 #include <filesystem>
+#include <memory>
+#include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
+#include "core/ScopeContext.h"
+#include "core/SourceFileCache.h"
+#include "core/StatCache.h"
+#include "core/node.h"
+#include "core/parsersettings.h"
+#include "utils/exceptions.h"
+#include "utils/printutils.h"
 
 namespace fs = std::filesystem;
-#include "FontCache.h"
 #include <sys/stat.h>
+#include "FontCache.h"
 
 SourceFile::SourceFile(std::string path, std::string filename)
-  : ASTNode(Location::NONE), path(std::move(path)), filename(std::move(filename))
-{
-}
+    : ASTNode(Location::NONE),
+      path(std::move(path)),
+      filename(std::move(filename)) {}
 
-void SourceFile::print(std::ostream& stream, const std::string& indent) const
-{
+void SourceFile::print(std::ostream& stream, const std::string& indent) const {
   scope.print(stream, indent);
 }
 
-void SourceFile::registerUse(const std::string& path, const Location& loc)
-{
-  PRINTDB("registerUse(): (%p) %d, %d - %d, %d (%s) -> %s", this %
-          loc.firstLine() % loc.firstColumn() %
-          loc.lastLine() % loc.lastColumn() %
-          loc.fileName() %
-          path);
+void SourceFile::registerUse(const std::string& path, const Location& loc) {
+  PRINTDB("registerUse(): (%p) %d, %d - %d, %d (%s) -> %s",
+          this % loc.firstLine() % loc.firstColumn() % loc.lastLine() %
+              loc.lastColumn() % loc.fileName() % path);
 
   auto ext = fs::path(path).extension().generic_string();
 
@@ -74,40 +70,41 @@ void SourceFile::registerUse(const std::string& path, const Location& loc)
     }
   } else {
     auto pos = std::find(usedlibs.begin(), usedlibs.end(), path);
-    if (pos != usedlibs.end()) usedlibs.erase(pos);
+    if (pos != usedlibs.end())
+      usedlibs.erase(pos);
     usedlibs.insert(usedlibs.begin(), path);
     if (!loc.isNone()) {
-      indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(), loc.lastLine(), loc.lastColumn(), path);
+      indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(),
+                                 loc.lastLine(), loc.lastColumn(), path);
     }
   }
 }
 
-void SourceFile::registerInclude(const std::string& localpath, const std::string& fullpath, const Location& loc)
-{
-  PRINTDB("registerInclude(): (%p) %d, %d - %d, %d (%s) -> %s", this %
-          loc.firstLine() % loc.firstColumn() %
-          loc.lastLine() % loc.lastColumn() %
-          localpath %
-          fullpath);
+void SourceFile::registerInclude(const std::string& localpath,
+                                 const std::string& fullpath,
+                                 const Location& loc) {
+  PRINTDB("registerInclude(): (%p) %d, %d - %d, %d (%s) -> %s",
+          this % loc.firstLine() % loc.firstColumn() % loc.lastLine() %
+              loc.lastColumn() % localpath % fullpath);
 
   this->includes[localpath] = fullpath;
   if (!loc.isNone()) {
-    indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(), loc.lastLine(), loc.lastColumn(), fullpath);
+    indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(),
+                               loc.lastLine(), loc.lastColumn(), fullpath);
   }
 }
 
-time_t SourceFile::includesChanged() const
-{
+time_t SourceFile::includesChanged() const {
   time_t latest = 0;
   for (const auto& item : this->includes) {
     auto mtime = include_modified(item.second);
-    if (mtime > latest) latest = mtime;
+    if (mtime > latest)
+      latest = mtime;
   }
   return latest;
 }
 
-time_t SourceFile::include_modified(const std::string& filename) const
-{
+time_t SourceFile::include_modified(const std::string& filename) const {
   struct stat st;
 
   if (StatCache::stat(filename, st) == 0) {
@@ -121,20 +118,20 @@ time_t SourceFile::include_modified(const std::string& filename) const
    Check if any dependencies have been modified and recompile them.
    Returns true if anything was recompiled.
  */
-time_t SourceFile::handleDependencies(bool is_root)
-{
-  if (is_root) SourceFileCache::clear_markers();
-  else if (this->is_handling_dependencies) return 0;
+time_t SourceFile::handleDependencies(bool is_root) {
+  if (is_root)
+    SourceFileCache::clear_markers();
+  else if (this->is_handling_dependencies)
+    return 0;
   this->is_handling_dependencies = true;
 
   std::vector<std::pair<std::string, std::string>> updates;
 
   // If a lib in usedlibs was previously missing, we need to relocate it
-  // by searching the applicable paths. We can identify a previously missing module
-  // as it will have a relative path.
+  // by searching the applicable paths. We can identify a previously missing
+  // module as it will have a relative path.
   time_t latest = 0;
   for (auto filename : this->usedlibs) {
-
     auto found = true;
 
     // Get an absolute filename for the module
@@ -151,9 +148,11 @@ time_t SourceFile::handleDependencies(bool is_root)
 
     if (found) {
       auto oldmodule = SourceFileCache::instance()->lookup(filename);
-      SourceFile *newmodule;
-      auto mtime = SourceFileCache::instance()->evaluate(this->getFullpath(), filename, newmodule);
-      if (mtime > latest) latest = mtime;
+      SourceFile* newmodule;
+      auto mtime = SourceFileCache::instance()->evaluate(this->getFullpath(),
+                                                         filename, newmodule);
+      if (mtime > latest)
+        latest = mtime;
       auto changed = newmodule && newmodule != oldmodule;
       // Detect appearance but not removal of files, and keep old module
       // on compile errors (FIXME: Is this correct behavior?)
@@ -168,30 +167,34 @@ time_t SourceFile::handleDependencies(bool is_root)
   // Relative filenames which were located are reinserted as absolute filenames
   for (const auto& files : updates) {
     auto pos = std::find(usedlibs.begin(), usedlibs.end(), files.first);
-    if (pos != usedlibs.end()) *pos = files.second;
+    if (pos != usedlibs.end())
+      *pos = files.second;
   }
   return latest;
 }
 
-std::shared_ptr<AbstractNode> SourceFile::instantiate(const std::shared_ptr<const Context>& context, std::shared_ptr<const FileContext> *resulting_file_context) const
-{
+std::shared_ptr<AbstractNode> SourceFile::instantiate(
+    const std::shared_ptr<const Context>& context,
+    std::shared_ptr<const FileContext>* resulting_file_context) const {
   auto node = std::make_shared<RootNode>();
   try {
-    ContextHandle<FileContext> file_context{Context::create<FileContext>(context, this)};
+    ContextHandle<FileContext> file_context{
+        Context::create<FileContext>(context, this)};
     *resulting_file_context = *file_context;
     this->scope.instantiateModules(*file_context, node);
   } catch (HardWarningException& e) {
     throw;
   } catch (EvaluationException& e) {
-    // LOG(message_group::NONE,,e.what()); //please output the message before throwing the exception
+    // LOG(message_group::NONE,,e.what()); //please output the message before
+    // throwing the exception
     *resulting_file_context = nullptr;
   }
   return node;
 }
 
-//please preferably use getFilename
-//if you compare filenames (which is the origin of this method),
-//please call getFilename first and use this method only as a fallback
+// please preferably use getFilename
+// if you compare filenames (which is the origin of this method),
+// please call getFilename first and use this method only as a fallback
 const std::string SourceFile::getFullpath() const {
   if (fs::path(this->filename).is_absolute()) {
     return this->filename;
diff --git a/src/core/SourceFile.h b/src/core/SourceFile.h
index 903b69c43..2280b83f7 100644
--- a/src/core/SourceFile.h
+++ b/src/core/SourceFile.h
@@ -1,29 +1,32 @@
 #pragma once
 
-#include <ostream>
+#include <ctime>
 #include <memory>
+#include <ostream>
 #include <string>
 #include <unordered_map>
-#include <ctime>
 #include <vector>
 
-#include "core/module.h"
 #include "core/AST.h"
-#include "core/LocalScope.h"
 #include "core/IndicatorData.h"
+#include "core/LocalScope.h"
+#include "core/module.h"
 
-class SourceFile : public ASTNode
-{
-public:
+class SourceFile : public ASTNode {
+ public:
   SourceFile(std::string path, std::string filename);
 
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& context, std::shared_ptr<const class FileContext> *resulting_file_context) const;
+  std::shared_ptr<AbstractNode> instantiate(
+      const std::shared_ptr<const Context>& context,
+      std::shared_ptr<const class FileContext>* resulting_file_context) const;
   void print(std::ostream& stream, const std::string& indent) const override;
 
   void setModulePath(const std::string& path) { this->path = path; }
   const std::string& modulePath() const { return this->path; }
   void registerUse(const std::string& path, const Location& loc);
-  void registerInclude(const std::string& localpath, const std::string& fullpath, const Location& loc);
+  void registerInclude(const std::string& localpath,
+                       const std::string& fullpath,
+                       const Location& loc);
   std::time_t includesChanged() const;
   std::time_t handleDependencies(bool is_root = true);
   bool hasIncludes() const { return !this->includes.empty(); }
@@ -39,7 +42,7 @@ public:
 
   std::vector<IndicatorData> indicatorData;
 
-private:
+ private:
   std::time_t include_modified(const std::string& filename) const;
 
   std::unordered_map<std::string, std::string> includes;
diff --git a/src/core/SourceFileCache.cc b/src/core/SourceFileCache.cc
index 72523479c..14ee7ccb0 100644
--- a/src/core/SourceFileCache.cc
+++ b/src/core/SourceFileCache.cc
@@ -1,50 +1,55 @@
 #include "core/SourceFileCache.h"
-#include "core/StatCache.h"
+#include <boost/format.hpp>
+#include <ctime>
 #include "core/SourceFile.h"
-#include "utils/printutils.h"
+#include "core/StatCache.h"
 #include "openscad.h"
-#include <ctime>
-#include <boost/format.hpp>
+#include "utils/printutils.h"
 
+#include <sys/stat.h>
+#include <algorithm>
 #include <cstdio>
 #include <fstream>
 #include <string>
-#include <sys/stat.h>
-#include <algorithm>
 
 /*!
-   FIXME: Implement an LRU scheme to avoid having an ever-growing source file cache
+   FIXME: Implement an LRU scheme to avoid having an ever-growing source file
+   cache
  */
 
-SourceFileCache *SourceFileCache::inst = nullptr;
+SourceFileCache* SourceFileCache::inst = nullptr;
 
 /*!
    Reevaluate the given file and all its dependencies and recompile anything
    needing reevaluation. Updates the cache if necessary.
    The given filename must be absolute.
 
-   Sets the given source file reference to the new file, or nullptr on any error (e.g. compile
-   error or file not found).
+   Sets the given source file reference to the new file, or nullptr on any error
+   (e.g. compile error or file not found).
 
-   Returns the latest modification time of the file, its dependencies or includes.
+   Returns the latest modification time of the file, its dependencies or
+   includes.
  */
-std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::string& filename, SourceFile *& sourceFile)
-{
+std::time_t SourceFileCache::evaluate(const std::string& mainFile,
+                                      const std::string& filename,
+                                      SourceFile*& sourceFile) {
   sourceFile = nullptr;
   auto entry = this->entries.find(filename);
   bool found{entry != this->entries.end()};
-  SourceFile *file{found ? entry->second.file : nullptr};
+  SourceFile* file{found ? entry->second.file : nullptr};
 
   // Don't try to recursively evaluate - if the file changes
   // during evaluation, that would be really bad.
-  if (file && file->isHandlingDependencies()) return 0;
+  if (file && file->isHandlingDependencies())
+    return 0;
 
   // Create cache ID
   struct stat st;
   bool valid = (StatCache::stat(filename, st) == 0);
 
   // If file isn't there, just return and let the cache retain the old file
-  if (!valid) return 0;
+  if (!valid)
+    return 0;
 
   // If the file is present, we'll always cache some result
   std::string cache_id = str(boost::format("%x.%x") % st.st_mtime % st.st_size);
@@ -77,7 +82,8 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
 
 #ifdef DEBUG
   // Causes too much debug output
-  //if (!shouldCompile) LOG(message_group::NONE,,"Using cached library: %1$s (%2$p)",filename,file);
+  // if (!shouldCompile) LOG(message_group::NONE,,"Using cached library: %1$s
+  // (%2$p)",filename,file);
 #endif
 
   // If cache lookup failed (non-existing or old timestamp), compile file
@@ -94,7 +100,8 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
     {
       std::ifstream ifs(filename.c_str());
       if (!ifs.is_open()) {
-        LOG(message_group::Warning, "Can't open library file '%1$s'\n", filename);
+        LOG(message_group::Warning, "Can't open library file '%1$s'\n",
+            filename);
         return 0;
       }
       text = STR(ifs.rdbuf(), "\n\x03\n", commandline_commands);
@@ -103,12 +110,15 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
     print_messages_push();
 
     delete cacheEntry.parsed_file;
-    file = parse(cacheEntry.parsed_file, text, filename, mainFile, false) ? cacheEntry.parsed_file : nullptr;
+    file = parse(cacheEntry.parsed_file, text, filename, mainFile, false)
+               ? cacheEntry.parsed_file
+               : nullptr;
     PRINTDB("compiled file: %s", filename);
     cacheEntry.file = file;
     cacheEntry.cache_id = cache_id;
     auto mod = file ? file : cacheEntry.parsed_file;
-    if (!found && mod) cacheEntry.includes_mtime = mod->includesChanged();
+    if (!found && mod)
+      cacheEntry.includes_mtime = mod->includesChanged();
     print_messages_pop();
   }
 
@@ -119,18 +129,17 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
   return std::max({deps_mtime, cacheEntry.mtime, cacheEntry.includes_mtime});
 }
 
-void SourceFileCache::clear()
-{
+void SourceFileCache::clear() {
   this->entries.clear();
 }
 
-SourceFile *SourceFileCache::lookup(const std::string& filename)
-{
+SourceFile* SourceFileCache::lookup(const std::string& filename) {
   auto it = this->entries.find(filename);
   return it != this->entries.end() ? it->second.file : nullptr;
 }
 
 void SourceFileCache::clear_markers() {
   for (const auto& entry : instance()->entries)
-    if (auto lib = entry.second.file) lib->clearHandlingDependencies();
+    if (auto lib = entry.second.file)
+      lib->clearHandlingDependencies();
 }
diff --git a/src/core/SourceFileCache.h b/src/core/SourceFileCache.h
index eb736a530..9e6c13d93 100644
--- a/src/core/SourceFileCache.h
+++ b/src/core/SourceFileCache.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <string>
 #include <ctime>
+#include <string>
 #include <unordered_map>
 
 class SourceFile;
@@ -9,28 +9,33 @@ class SourceFile;
 /*!
    Caches SourceFiles based on their filenames
  */
-class SourceFileCache
-{
-public:
-  static SourceFileCache *instance() { if (!inst) inst = new SourceFileCache; return inst; }
+class SourceFileCache {
+ public:
+  static SourceFileCache* instance() {
+    if (!inst)
+      inst = new SourceFileCache;
+    return inst;
+  }
 
-  std::time_t evaluate(const std::string& mainFile, const std::string& filename, SourceFile *& sourceFile);
-  SourceFile *lookup(const std::string& filename);
+  std::time_t evaluate(const std::string& mainFile,
+                       const std::string& filename,
+                       SourceFile*& sourceFile);
+  SourceFile* lookup(const std::string& filename);
   size_t size() const { return this->entries.size(); }
   void clear();
   static void clear_markers();
 
-private:
+ private:
   SourceFileCache() = default;
 
-  static SourceFileCache *inst;
+  static SourceFileCache* inst;
 
   struct cache_entry {
-    SourceFile *file{};
-    SourceFile *parsed_file{};                   // the last version parsed for the include list
+    SourceFile* file{};
+    SourceFile* parsed_file{};  // the last version parsed for the include list
     std::string cache_id;
-    std::time_t mtime{}; // time file last modified
-    std::time_t includes_mtime{}; // time the includes last changed
+    std::time_t mtime{};           // time file last modified
+    std::time_t includes_mtime{};  // time the includes last changed
   };
   std::unordered_map<std::string, cache_entry> entries;
 };
diff --git a/src/core/StatCache.cc b/src/core/StatCache.cc
index cf7cf0737..84a946483 100644
--- a/src/core/StatCache.cc
+++ b/src/core/StatCache.cc
@@ -26,44 +26,45 @@
 
 #include "core/StatCache.h"
 
+#include <chrono>
 #include <string>
 #include <unordered_map>
-#include <chrono>
 
 namespace {
 
-const float stale = 190;  // 190ms, maximum lifetime of a cache entry chosen to be shorter than the automatic reload poll time
+const float stale = 190;  // 190ms, maximum lifetime of a cache entry chosen to
+                          // be shorter than the automatic reload poll time
 
-double millis_clock()
-{
-  return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
+double millis_clock() {
+  return std::chrono::duration_cast<std::chrono::milliseconds>(
+             std::chrono::system_clock::now().time_since_epoch())
+      .count();
 }
 
-struct CacheEntry
-{
-  struct stat st;  // result from stat
-  double timestamp; // the time stat was called
+struct CacheEntry {
+  struct stat st;    // result from stat
+  double timestamp;  // the time stat was called
 };
 
 std::unordered_map<std::string, CacheEntry> statMap;
 
-} // namespace
+}  // namespace
 
 namespace StatCache {
 
-int stat(const std::string& path, struct ::stat &st)
-{
+int stat(const std::string& path, struct ::stat& st) {
   auto iter = statMap.find(path);
-  if (iter != statMap.end()) {                // Have we got an entry for this file?
+  if (iter != statMap.end()) {  // Have we got an entry for this file?
     if (millis_clock() - iter->second.timestamp < stale) {
-      st = iter->second.st;      // Not stale yet so return it
+      st = iter->second.st;  // Not stale yet so return it
       return 0;
     }
-    statMap.erase(iter);                // Remove stale entry
+    statMap.erase(iter);  // Remove stale entry
   }
-  if (auto rv = ::stat(path.c_str(), &st)) return rv; // stat failed
+  if (auto rv = ::stat(path.c_str(), &st))
+    return rv;  // stat failed
   statMap[path] = {st, millis_clock()};
   return 0;
 }
 
-} // namespace StatCache
+}  // namespace StatCache
diff --git a/src/core/StatCache.h b/src/core/StatCache.h
index bc46f5f2b..f9565fd27 100644
--- a/src/core/StatCache.h
+++ b/src/core/StatCache.h
@@ -26,11 +26,11 @@
 
 #pragma once
 
-#include <string>
 #include <sys/stat.h>
+#include <string>
 
 namespace StatCache {
 
-int stat(const std::string& path, struct ::stat &st);
+int stat(const std::string& path, struct ::stat& st);
 
 }
diff --git a/src/core/State.h b/src/core/State.h
index c327fe66e..26be40285 100644
--- a/src/core/State.h
+++ b/src/core/State.h
@@ -3,15 +3,13 @@
 #include <cstring>
 #include <memory>
 #include <utility>
-#include "geometry/linalg.h"
 #include "core/node.h"
+#include "geometry/linalg.h"
 
-class State
-{
-
-public:
+class State {
+ public:
   State(std::shared_ptr<const AbstractNode> parent)
-    : parentnode(std::move(parent)) {
+      : parentnode(std::move(parent)) {
     this->matrix_ = Transform3d::Identity();
   }
 
@@ -20,7 +18,9 @@ public:
   void setHighlight(bool on) { FLAG(this->flags, HIGHLIGHT, on); }
   void setBackground(bool on) { FLAG(this->flags, BACKGROUND, on); }
   void setNumChildren(unsigned int numc) { this->numchildren = numc; }
-  void setParent(const std::shared_ptr<const AbstractNode>& parent) { this->parentnode = parent; }
+  void setParent(const std::shared_ptr<const AbstractNode>& parent) {
+    this->parentnode = parent;
+  }
   void setMatrix(const Transform3d& m) { this->matrix_ = m; }
   void setColor(const Color4f& c) { this->color_ = c; }
   void setPreferNef(bool on) { FLAG(this->flags, PREFERNEF, on); }
@@ -31,17 +31,19 @@ public:
   [[nodiscard]] bool isHighlight() const { return this->flags & HIGHLIGHT; }
   [[nodiscard]] bool isBackground() const { return this->flags & BACKGROUND; }
   [[nodiscard]] unsigned int numChildren() const { return this->numchildren; }
-  [[nodiscard]] std::shared_ptr<const AbstractNode> parent() const { return this->parentnode; }
+  [[nodiscard]] std::shared_ptr<const AbstractNode> parent() const {
+    return this->parentnode;
+  }
   [[nodiscard]] const Transform3d& matrix() const { return this->matrix_; }
   [[nodiscard]] const Color4f& color() const { return this->color_; }
 
-private:
+ private:
   enum StateFlags : unsigned int {
-    NONE       = 0x00u,
-    PREFIX     = 0x01u,
-    POSTFIX    = 0x02u,
-    PREFERNEF  = 0x04u,
-    HIGHLIGHT  = 0x08u,
+    NONE = 0x00u,
+    PREFIX = 0x01u,
+    POSTFIX = 0x02u,
+    PREFERNEF = 0x04u,
+    HIGHLIGHT = 0x08u,
     BACKGROUND = 0x10u
   };
 
diff --git a/src/core/SurfaceNode.cc b/src/core/SurfaceNode.cc
index 2e5134bbe..b3df41fb5 100644
--- a/src/core/SurfaceNode.cc
+++ b/src/core/SurfaceNode.cc
@@ -26,51 +26,56 @@
 
 #include "core/SurfaceNode.h"
 
-#include "core/module.h"
+#include "core/Builtins.h"
+#include "core/Children.h"
 #include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/module.h"
 #include "core/node.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
-#include "core/Builtins.h"
-#include "core/Children.h"
-#include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "io/fileutils.h"
 #include "handle_dep.h"
+#include "io/fileutils.h"
 #include "lodepng/lodepng.h"
+#include "utils/printutils.h"
 
 #include <algorithm>
+#include <cstddef>
+#include <cstdint>
 #include <cstring>
+#include <fstream>
+#include <memory>
 #include <new>
+#include <sstream>
 #include <string>
+#include <unordered_map>
 #include <utility>
-#include <memory>
-#include <cstdint>
-#include <cstddef>
-#include <sstream>
-#include <fstream>
 #include <vector>
-#include <unordered_map>
 
-#include <boost/functional/hash.hpp>
-#include <boost/tokenizer.hpp>
-#include <boost/lexical_cast.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
+#include <boost/functional/hash.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/tokenizer.hpp>
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
 #include <filesystem>
 namespace fs = std::filesystem;
 
-
-static std::shared_ptr<AbstractNode> builtin_surface(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_surface(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<SurfaceNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"file", "center", "convexity"}, {"invert"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(),
+                        {"file", "center", "convexity"}, {"invert"});
 
-  std::string fileval = parameters["file"].isUndefined() ? "" : parameters["file"].toString();
-  auto filename = lookup_file(fileval, inst->location().filePath().parent_path().string(), parameters.documentRoot());
+  std::string fileval =
+      parameters["file"].isUndefined() ? "" : parameters["file"].toString();
+  auto filename =
+      lookup_file(fileval, inst->location().filePath().parent_path().string(),
+                  parameters.documentRoot());
   node->filename = filename;
   handle_dep(fs::path(filename).generic_string());
 
@@ -89,38 +94,40 @@ static std::shared_ptr<AbstractNode> builtin_surface(const ModuleInstantiation *
   return node;
 }
 
-void SurfaceNode::convert_image(img_data_t& data, std::vector<uint8_t>& img, unsigned int width, unsigned int height) const
-{
+void SurfaceNode::convert_image(img_data_t& data,
+                                std::vector<uint8_t>& img,
+                                unsigned int width,
+                                unsigned int height) const {
   data.width = width;
   data.height = height;
-  data.resize( (size_t)width * height);
+  data.resize((size_t)width * height);
   double min_val = 200;
   for (unsigned int y = 0; y < height; ++y) {
     for (unsigned int x = 0; x < width; ++x) {
       long idx = 4l * (y * width + x);
-      double pixel = 0.2126 * img[idx] + 0.7152 * img[idx + 1] + 0.0722 * img[idx + 2];
+      double pixel =
+          0.2126 * img[idx] + 0.7152 * img[idx + 1] + 0.0722 * img[idx + 2];
       double z = 100.0 / 255 * (invert ? 1 - pixel : pixel);
-      data[ x + (width * (height - 1 - y)) ] = z;
+      data[x + (width * (height - 1 - y))] = z;
       min_val = std::min(z, min_val);
     }
   }
   data.min_val = min_val;
 }
 
-bool SurfaceNode::is_png(std::vector<uint8_t>& png) const
-{
+bool SurfaceNode::is_png(std::vector<uint8_t>& png) const {
   const size_t pngHeaderLength = 8;
-  const uint8_t pngHeader[pngHeaderLength] = {0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a};
+  const uint8_t pngHeader[pngHeaderLength] = {0x89, 0x50, 0x4e, 0x47,
+                                              0x0d, 0x0a, 0x1a, 0x0a};
   return (png.size() >= pngHeaderLength &&
           std::memcmp(png.data(), pngHeader, pngHeaderLength) == 0);
 }
 
-img_data_t SurfaceNode::read_png_or_dat(std::string filename) const
-{
+img_data_t SurfaceNode::read_png_or_dat(std::string filename) const {
   img_data_t data;
   std::vector<uint8_t> png;
   int ret_val = 0;
-  try{
+  try {
     ret_val = lodepng::load_file(png, filename);
   } catch (std::bad_alloc& ba) {
     LOG(message_group::Warning, "bad_alloc caught for '%1$s'.", ba.what());
@@ -128,7 +135,8 @@ img_data_t SurfaceNode::read_png_or_dat(std::string filename) const
   }
 
   if (ret_val == 78) {
-    LOG(message_group::Warning, "The file '%1$s' couldn't be opened.", filename);
+    LOG(message_group::Warning, "The file '%1$s' couldn't be opened.",
+        filename);
     return data;
   }
 
@@ -151,8 +159,7 @@ img_data_t SurfaceNode::read_png_or_dat(std::string filename) const
   return data;
 }
 
-img_data_t SurfaceNode::read_dat(std::string filename) const
-{
+img_data_t SurfaceNode::read_dat(std::string filename) const {
   img_data_t data;
   std::ifstream stream(filename.c_str());
 
@@ -162,14 +169,17 @@ img_data_t SurfaceNode::read_dat(std::string filename) const
   }
 
   int lines = 0, columns = 0;
-  double min_val = 1; // this balances out with the (min_val-1) inside createGeometry, to match old behavior
+  double min_val = 1;  // this balances out with the (min_val-1) inside
+                       // createGeometry, to match old behavior
 
   using tokenizer = boost::tokenizer<boost::char_separator<char>>;
   boost::char_separator<char> sep(" \t");
 
   // We use an unordered map because the data file may not be rectangular,
   // and we may need to fill in some bits.
-  using unordered_image_data_t = std::unordered_map<std::pair<int, int>, double, boost::hash<std::pair<int, int>>>;
+  using unordered_image_data_t =
+      std::unordered_map<std::pair<int, int>, double,
+                         boost::hash<std::pair<int, int>>>;
   unordered_image_data_t unordered_data;
 
   while (!stream.eof()) {
@@ -178,20 +188,23 @@ img_data_t SurfaceNode::read_dat(std::string filename) const
       std::getline(stream, line);
       boost::trim(line);
     }
-    if (line.size() == 0 && stream.eof()) break;
+    if (line.size() == 0 && stream.eof())
+      break;
 
     int col = 0;
     tokenizer tokens(line, sep);
     try {
       for (const auto& token : tokens) {
         auto v = boost::lexical_cast<double>(token);
-        unordered_data[ std::make_pair(lines, col++) ] = v;
-        if (col > columns) columns = col;
+        unordered_data[std::make_pair(lines, col++)] = v;
+        if (col > columns)
+          columns = col;
         min_val = std::min(v, min_val);
       }
     } catch (const boost::bad_lexical_cast& blc) {
       if (!stream.eof()) {
-        LOG(message_group::Warning, "Illegal value in '%1$s': %2$s", filename, blc.what());
+        LOG(message_group::Warning, "Illegal value in '%1$s': %2$s", filename,
+            blc.what());
       }
       return data;
     }
@@ -203,116 +216,101 @@ img_data_t SurfaceNode::read_dat(std::string filename) const
   data.height = lines;
   data.min_val = min_val;
 
-  // Now convert the unordered, possibly non-rectangular data into a well ordered vector
-  // for faster access and reduced memory usage.
-  data.resize( (size_t)lines * columns);
+  // Now convert the unordered, possibly non-rectangular data into a well
+  // ordered vector for faster access and reduced memory usage.
+  data.resize((size_t)lines * columns);
   for (int i = 0; i < lines; ++i)
     for (int j = 0; j < columns; ++j)
-      data[ i * columns + j ] = unordered_data[std::make_pair(i, j)];
+      data[i * columns + j] = unordered_data[std::make_pair(i, j)];
 
   return data;
 }
 
 // FIXME: Look for faster way to generate PolySet directly
-std::unique_ptr<const Geometry> SurfaceNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> SurfaceNode::createGeometry() const {
   auto data = read_png_or_dat(filename);
 
   int lines = data.height;
   int columns = data.width;
-  double min_val = data.min_value() - 1; // make the bottom solid, and match old code
+  double min_val =
+      data.min_value() - 1;  // make the bottom solid, and match old code
 
   // reserve the polygon vector size so we don't have to reallocate as often
 
   double ox = center ? -(columns - 1) / 2.0 : 0;
   double oy = center ? -(lines - 1) / 2.0 : 0;
 
-  int num_indices = (lines - 1) * (columns - 1) * 4 + (lines - 1) * 2 + (columns - 1) * 2 + 1;
+  int num_indices =
+      (lines - 1) * (columns - 1) * 4 + (lines - 1) * 2 + (columns - 1) * 2 + 1;
   PolySetBuilder builder(0, num_indices);
   builder.setConvexity(convexity);
   // the bulk of the heightmap
   for (int i = 1; i < lines; ++i)
     for (int j = 1; j < columns; ++j) {
-      double v1 = data[ (j - 1) + (i - 1) * columns ];
-      double v2 = data[ (j) + (i - 1) * columns ];
-      double v3 = data[ (j - 1) + (i) * columns ];
-      double v4 = data[ (j) + (i) * columns ];
+      double v1 = data[(j - 1) + (i - 1) * columns];
+      double v2 = data[(j) + (i - 1) * columns];
+      double v3 = data[(j - 1) + (i)*columns];
+      double v4 = data[(j) + (i)*columns];
 
       double vx = (v1 + v2 + v3 + v4) / 4;
 
-      builder.appendPolygon({
-        Vector3d(ox + j - 1, oy + i - 1, v1),
-        Vector3d(ox + j, oy + i - 1, v2),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j, oy + i - 1, v2),
-        Vector3d(ox + j, oy + i, v4),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j, oy + i, v4),
-        Vector3d(ox + j - 1, oy + i, v3),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j - 1, oy + i, v3),
-        Vector3d(ox + j - 1, oy + i - 1, v1),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
+      builder.appendPolygon({Vector3d(ox + j - 1, oy + i - 1, v1),
+                             Vector3d(ox + j, oy + i - 1, v2),
+                             Vector3d(ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon({Vector3d(ox + j, oy + i - 1, v2),
+                             Vector3d(ox + j, oy + i, v4),
+                             Vector3d(ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon({Vector3d(ox + j, oy + i, v4),
+                             Vector3d(ox + j - 1, oy + i, v3),
+                             Vector3d(ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon({Vector3d(ox + j - 1, oy + i, v3),
+                             Vector3d(ox + j - 1, oy + i - 1, v1),
+                             Vector3d(ox + j - 0.5, oy + i - 0.5, vx)});
     }
 
   // edges along Y
   for (int i = 1; i < lines; ++i) {
-    double v1 = data[ (0) + (i - 1) * columns ];
-    double v2 = data[ (0) + (i) * columns ];
-    double v3 = data[ (columns - 1) + (i - 1) * columns ];
-    double v4 = data[ (columns - 1) + (i) * columns ];
-
-
-    builder.appendPolygon({
-      Vector3d(ox + 0, oy + i - 1, min_val),
-      Vector3d(ox + 0, oy + i - 1, v1),
-      Vector3d(ox + 0, oy + i, v2),
-      Vector3d(ox + 0, oy + i, min_val)
-    });
-
-    builder.appendPolygon({
-      Vector3d(ox + columns - 1, oy + i, min_val),
-      Vector3d(ox + columns - 1, oy + i, v4),
-      Vector3d(ox + columns - 1, oy + i - 1, v3),
-      Vector3d(ox + columns - 1, oy + i - 1, min_val)
-    });
+    double v1 = data[(0) + (i - 1) * columns];
+    double v2 = data[(0) + (i)*columns];
+    double v3 = data[(columns - 1) + (i - 1) * columns];
+    double v4 = data[(columns - 1) + (i)*columns];
+
+    builder.appendPolygon({Vector3d(ox + 0, oy + i - 1, min_val),
+                           Vector3d(ox + 0, oy + i - 1, v1),
+                           Vector3d(ox + 0, oy + i, v2),
+                           Vector3d(ox + 0, oy + i, min_val)});
+
+    builder.appendPolygon({Vector3d(ox + columns - 1, oy + i, min_val),
+                           Vector3d(ox + columns - 1, oy + i, v4),
+                           Vector3d(ox + columns - 1, oy + i - 1, v3),
+                           Vector3d(ox + columns - 1, oy + i - 1, min_val)});
   }
 
   // edges along X
   for (int i = 1; i < columns; ++i) {
-    double v1 = data[ (i - 1) + (0) * columns ];
-    double v2 = data[ (i) + (0) * columns ];
-    double v3 = data[ (i - 1) + (lines - 1) * columns ];
-    double v4 = data[ (i) + (lines - 1) * columns ];
-
-    builder.appendPolygon({
-      Vector3d(ox + i, oy + 0, min_val),
-      Vector3d(ox + i, oy + 0, v2),
-      Vector3d(ox + i - 1, oy + 0, v1),
-      Vector3d(ox + i - 1, oy + 0, min_val)
-    });
-
-    builder.appendPolygon({
-      Vector3d(ox + i - 1, oy + lines - 1, min_val),
-      Vector3d(ox + i - 1, oy + lines - 1, v3),
-      Vector3d(ox + i, oy + lines - 1, v4),
-      Vector3d(ox + i, oy + lines - 1, min_val)
-    });
+    double v1 = data[(i - 1) + (0) * columns];
+    double v2 = data[(i) + (0) * columns];
+    double v3 = data[(i - 1) + (lines - 1) * columns];
+    double v4 = data[(i) + (lines - 1) * columns];
+
+    builder.appendPolygon({Vector3d(ox + i, oy + 0, min_val),
+                           Vector3d(ox + i, oy + 0, v2),
+                           Vector3d(ox + i - 1, oy + 0, v1),
+                           Vector3d(ox + i - 1, oy + 0, min_val)});
+
+    builder.appendPolygon({Vector3d(ox + i - 1, oy + lines - 1, min_val),
+                           Vector3d(ox + i - 1, oy + lines - 1, v3),
+                           Vector3d(ox + i, oy + lines - 1, v4),
+                           Vector3d(ox + i, oy + lines - 1, min_val)});
   }
 
-  // the bottom of the shape (one less than the real minimum value), making it a solid volume
+  // the bottom of the shape (one less than the real minimum value), making it a
+  // solid volume
   if (columns > 1 && lines > 1) {
-    builder.beginPolygon(2 * (columns - 1) + 2 * (lines - 1) );
+    builder.beginPolygon(2 * (columns - 1) + 2 * (lines - 1));
     for (int i = 0; i < lines - 1; ++i)
       builder.addVertex(Vector3d(ox + 0, oy + i, min_val));
     for (int i = 0; i < columns - 1; ++i)
@@ -326,24 +324,23 @@ std::unique_ptr<const Geometry> SurfaceNode::createGeometry() const
   return builder.build();
 }
 
-std::string SurfaceNode::toString() const
-{
+std::string SurfaceNode::toString() const {
   std::ostringstream stream;
-  fs::path path{static_cast<std::string>(this->filename)}; // gcc-4.6
+  fs::path path{static_cast<std::string>(this->filename)};  // gcc-4.6
 
   stream << this->name() << "(file = " << this->filename
          << ", center = " << (this->center ? "true" : "false")
          << ", invert = " << (this->invert ? "true" : "false")
-         << ", " "timestamp = " << fs_timestamp(path)
-         << ")";
+         << ", "
+            "timestamp = "
+         << fs_timestamp(path) << ")";
 
   return stream.str();
 }
 
-void register_builtin_surface()
-{
+void register_builtin_surface() {
   Builtins::init("surface", new BuiltinModule(builtin_surface),
-  {
-    "surface(string, center = false, invert = false, number)",
-  });
+                 {
+                     "surface(string, center = false, invert = false, number)",
+                 });
 }
diff --git a/src/core/SurfaceNode.h b/src/core/SurfaceNode.h
index df58f84a9..9af8f1151 100644
--- a/src/core/SurfaceNode.h
+++ b/src/core/SurfaceNode.h
@@ -24,26 +24,30 @@
  *
  */
 
+#include <cstddef>
 #include <cstdint>
 #include <memory>
-#include <cstddef>
 #include <string>
 #include <vector>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
+#include "core/node.h"
 
-struct img_data_t
-{
-public:
-  using storage_type = double; // float could be enough here
+struct img_data_t {
+ public:
+  using storage_type = double;  // float could be enough here
 
   img_data_t() {
-    min_val = 0; height = width = 0;
+    min_val = 0;
+    height = width = 0;
   }
 
-  void clear() { min_val = 0; height = width = 0; storage.clear(); }
+  void clear() {
+    min_val = 0;
+    height = width = 0;
+    storage.clear();
+  }
 
   void reserve(size_t x) { storage.reserve(x); }
 
@@ -51,22 +55,21 @@ public:
 
   storage_type& operator[](int x) { return storage[x]; }
 
-  storage_type min_value() { return min_val; } // *std::min_element(storage.begin(), storage.end());
+  storage_type min_value() {
+    return min_val;
+  }  // *std::min_element(storage.begin(), storage.end());
 
-public:
-  unsigned int height; // rows
-  unsigned int width; // columns
+ public:
+  unsigned int height;  // rows
+  unsigned int width;   // columns
   storage_type min_val;
   std::vector<storage_type> storage;
-
 };
 
-
-class SurfaceNode : public LeafNode
-{
-public:
+class SurfaceNode : public LeafNode {
+ public:
   VISITABLE();
-  SurfaceNode(const ModuleInstantiation *mi) : LeafNode(mi) { }
+  SurfaceNode(const ModuleInstantiation* mi) : LeafNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "surface"; }
 
@@ -76,8 +79,12 @@ public:
   int convexity{1};
 
   std::unique_ptr<const Geometry> createGeometry() const override;
-private:
-  void convert_image(img_data_t& data, std::vector<uint8_t>& img, unsigned int width, unsigned int height) const;
+
+ private:
+  void convert_image(img_data_t& data,
+                     std::vector<uint8_t>& img,
+                     unsigned int width,
+                     unsigned int height) const;
   bool is_png(std::vector<uint8_t>& img) const;
   img_data_t read_dat(std::string filename) const;
   img_data_t read_png_or_dat(std::string filename) const;
diff --git a/src/core/TextNode.cc b/src/core/TextNode.cc
index 274971622..48708b374 100644
--- a/src/core/TextNode.cc
+++ b/src/core/TextNode.cc
@@ -26,31 +26,31 @@
 
 #include "core/TextNode.h"
 
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 
+#include "core/Builtins.h"
 #include "core/Children.h"
-#include "core/module.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
 #include "utils/printutils.h"
-#include "core/Builtins.h"
 
 #include "core/FreetypeRenderer.h"
 
 #include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_text(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_text(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<TextNode>(inst);
 
-  auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"text", "size", "font"},
-                                            {"direction", "language", "script", "halign", "valign", "spacing"}
-                                            );
+  auto* session = arguments.session();
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"text", "size", "font"},
+      {"direction", "language", "script", "halign", "valign", "spacing"});
   parameters.set_caller("text");
 
   node->params.set_loc(inst->location());
@@ -61,26 +61,24 @@ static std::shared_ptr<AbstractNode> builtin_text(const ModuleInstantiation *ins
   return node;
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> TextNode::createPolygonList() const
-{
+std::vector<std::shared_ptr<const Polygon2d>> TextNode::createPolygonList()
+    const {
   FreetypeRenderer renderer;
   return renderer.render(this->get_params());
 }
 
-FreetypeRenderer::Params TextNode::get_params() const
-{
+FreetypeRenderer::Params TextNode::get_params() const {
   return params;
 }
 
-std::string TextNode::toString() const
-{
+std::string TextNode::toString() const {
   return STR(name(), "(", this->params, ")");
 }
 
-void register_builtin_text()
-{
-  Builtins::init("text", new BuiltinModule(builtin_text),
-  {
-    R"(text(text = "", size = 10, font = "", halign = "left", valign = "baseline", spacing = 1, direction = "ltr", language = "en", script = "latin"[, $fn]))",
-  });
+void register_builtin_text() {
+  Builtins::init(
+      "text", new BuiltinModule(builtin_text),
+      {
+          R"(text(text = "", size = 10, font = "", halign = "left", valign = "baseline", spacing = 1, direction = "ltr", language = "en", script = "latin"[, $fn]))",
+      });
 }
diff --git a/src/core/TextNode.h b/src/core/TextNode.h
index 0bf4e4783..399791236 100644
--- a/src/core/TextNode.h
+++ b/src/core/TextNode.h
@@ -4,18 +4,17 @@
 #include <string>
 #include <vector>
 
-#include "core/node.h"
-#include "core/ModuleInstantiation.h"
 #include "core/FreetypeRenderer.h"
+#include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/Polygon2d.h"
 
 class TextModule;
 
-class TextNode : public AbstractPolyNode
-{
-public:
+class TextNode : public AbstractPolyNode {
+ public:
   VISITABLE();
-  TextNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
+  TextNode(const ModuleInstantiation* mi) : AbstractPolyNode(mi) {}
 
   std::string toString() const override;
   std::string name() const override { return "text"; }
diff --git a/src/core/TransformNode.cc b/src/core/TransformNode.cc
index e767b741d..4acd088ac 100644
--- a/src/core/TransformNode.cc
+++ b/src/core/TransformNode.cc
@@ -25,38 +25,34 @@
  */
 
 #include "core/TransformNode.h"
-#include "geometry/linalg.h"
-#include "core/ModuleInstantiation.h"
-#include "core/Children.h"
-#include "core/Builtins.h"
-#include "core/Value.h"
-#include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "utils/degree_trig.h"
 #include <algorithm>
+#include <boost/assign/std/vector.hpp>
+#include <cassert>
 #include <cmath>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <sstream>
 #include <utility>
 #include <vector>
-#include <cassert>
-#include <boost/assign/std/vector.hpp>
-using namespace boost::assign; // bring 'operator+=()' into scope
-
-enum class transform_type_e {
-  SCALE,
-  ROTATE,
-  MIRROR,
-  TRANSLATE,
-  MULTMATRIX
-};
-
-std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+#include "core/Builtins.h"
+#include "core/Children.h"
+#include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/Value.h"
+#include "geometry/linalg.h"
+#include "utils/degree_trig.h"
+#include "utils/printutils.h"
+using namespace boost::assign;  // bring 'operator+=()' into scope
+
+enum class transform_type_e { SCALE, ROTATE, MIRROR, TRANSLATE, MULTMATRIX };
+
+std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation* inst,
+                                            Arguments arguments,
+                                            const Children& children) {
   auto node = std::make_shared<TransformNode>(inst, "scale");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"v"});
 
   Vector3d scalevec(1, 1, 1);
   if (!parameters["v"].getVec3(scalevec[0], scalevec[1], scalevec[2], 1.0)) {
@@ -64,12 +60,18 @@ std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation *inst, Arg
     if (parameters["v"].getDouble(num)) {
       scalevec.setConstant(num);
     } else {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert scale(%1$s) parameter to a number, a vec3 or vec2 of numbers or a number", parameters["v"].toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Unable to convert scale(%1$s) parameter to a number, a vec3 or vec2 "
+          "of numbers or a number",
+          parameters["v"].toEchoStringNoThrow());
     }
   }
   if (OpenSCAD::rangeCheck) {
-    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 || !std::isfinite(scalevec[0])|| !std::isfinite(scalevec[1])|| !std::isfinite(scalevec[2])) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
+    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 ||
+        !std::isfinite(scalevec[0]) || !std::isfinite(scalevec[1]) ||
+        !std::isfinite(scalevec[2])) {
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
     }
   }
   node->matrix.scale(scalevec);
@@ -77,11 +79,13 @@ std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation *inst, Arg
   return children.instantiate(node);
 }
 
-std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation* inst,
+                                             Arguments arguments,
+                                             const Children& children) {
   auto node = std::make_shared<TransformNode>(inst, "rotate");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"a", "v"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"a", "v"});
 
   const auto& val_a = parameters["a"];
   const auto& val_v = parameters["v"];
@@ -92,47 +96,53 @@ std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation *inst, Ar
     bool ok = true;
     const auto& vec_a = val_a.toVector();
     switch (vec_a.size()) {
-    default:
-      ok &= false;
-      [[fallthrough]];
-    case 3:
-      ok &= vec_a[2].getDouble(a);
-      ok &= !std::isinf(a) && !std::isnan(a);
-      sz = sin_degrees(a);
-      cz = cos_degrees(a);
-      [[fallthrough]];
-    case 2:
-      ok &= vec_a[1].getDouble(a);
-      ok &= !std::isinf(a) && !std::isnan(a);
-      sy = sin_degrees(a);
-      cy = cos_degrees(a);
-      [[fallthrough]];
-    case 1:
-      ok &= vec_a[0].getDouble(a);
-      ok &= !std::isinf(a) && !std::isnan(a);
-      sx = sin_degrees(a);
-      cx = cos_degrees(a);
-      break;
-    case 0:
-      break;
+      default:
+        ok &= false;
+        [[fallthrough]];
+      case 3:
+        ok &= vec_a[2].getDouble(a);
+        ok &= !std::isinf(a) && !std::isnan(a);
+        sz = sin_degrees(a);
+        cz = cos_degrees(a);
+        [[fallthrough]];
+      case 2:
+        ok &= vec_a[1].getDouble(a);
+        ok &= !std::isinf(a) && !std::isnan(a);
+        sy = sin_degrees(a);
+        cy = cos_degrees(a);
+        [[fallthrough]];
+      case 1:
+        ok &= vec_a[0].getDouble(a);
+        ok &= !std::isinf(a) && !std::isnan(a);
+        sx = sin_degrees(a);
+        cx = cos_degrees(a);
+        break;
+      case 0:
+        break;
     }
 
     bool v_supplied = val_v.isDefined();
     if (ok) {
       if (v_supplied) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "When parameter a is supplied as vector, v is ignored rotate(a=%1$s, v=%2$s)", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "When parameter a is supplied as vector, v is ignored "
+            "rotate(a=%1$s, v=%2$s)",
+            val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
       }
     } else {
       if (v_supplied) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s, v=%2$s) parameter", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "Problem converting rotate(a=%1$s, v=%2$s) parameter",
+            val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
       } else {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s) parameter", val_a.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "Problem converting rotate(a=%1$s) parameter",
+            val_a.toEchoStringNoThrow());
       }
     }
     Matrix3d M;
-    M << cy * cz,  cz * sx * sy - cx * sz,   cx * cz * sy + sx * sz,
-      cy *sz,  cx *cz + sx * sy * sz,  -cz * sx + cx * sy * sz,
-      -sy,       cy *sx,                  cx *cy;
+    M << cy * cz, cz * sx * sy - cx * sz, cx * cz * sy + sx * sz, cy * sz,
+        cx * cz + sx * sy * sz, -cz * sx + cx * sy * sz, -sy, cy * sx, cx * cy;
     node->matrix.rotate(M);
   } else {
     double a = 0.0;
@@ -144,72 +154,92 @@ std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation *inst, Ar
     node->matrix.rotate(angle_axis_degrees(aConverted ? a : 0, v));
     if (val_v.isDefined() && !vConverted) {
       if (aConverted) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(..., v=%1$s) parameter", val_v.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "Problem converting rotate(..., v=%1$s) parameter",
+            val_v.toEchoStringNoThrow());
       } else {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s, v=%2$s) parameter", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "Problem converting rotate(a=%1$s, v=%2$s) parameter",
+            val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
       }
     } else if (!aConverted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s) parameter", val_a.toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Problem converting rotate(a=%1$s) parameter",
+          val_a.toEchoStringNoThrow());
     }
   }
 
   return children.instantiate(node);
 }
 
-std::shared_ptr<AbstractNode> builtin_mirror(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_mirror(const ModuleInstantiation* inst,
+                                             Arguments arguments,
+                                             const Children& children) {
   auto node = std::make_shared<TransformNode>(inst, "mirror");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"v"});
 
   double x = 1.0, y = 0.0, z = 0.0;
   if (!parameters["v"].getVec3(x, y, z, 0.0)) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert mirror(%1$s) parameter to a vec3 or vec2 of numbers", parameters["v"].toEchoStringNoThrow());
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Unable to convert mirror(%1$s) parameter to a vec3 or vec2 of numbers",
+        parameters["v"].toEchoStringNoThrow());
   }
 
   // x /= sqrt(x*x + y*y + z*z)
   // y /= sqrt(x*x + y*y + z*z)
   // z /= sqrt(x*x + y*y + z*z)
   if (x != 0.0 || y != 0.0 || z != 0.0) {
-    // skip using sqrt to normalize the vector since each element of matrix contributes it with two multiplied terms
-    // instead just divide directly within each matrix element
-    // simplified calculation leads to less float errors
+    // skip using sqrt to normalize the vector since each element of matrix
+    // contributes it with two multiplied terms instead just divide directly
+    // within each matrix element simplified calculation leads to less float
+    // errors
     double a = x * x + y * y + z * z;
 
     Matrix4d m;
-    m << 1 - 2 * x * x / a, -2 * y * x / a, -2 * z * x / a, 0,
-      -2 * x * y / a, 1 - 2 * y * y / a, -2 * z * y / a, 0,
-      -2 * x * z / a, -2 * y * z / a, 1 - 2 * z * z / a, 0,
-      0, 0, 0, 1;
+    m << 1 - 2 * x * x / a, -2 * y * x / a, -2 * z * x / a, 0, -2 * x * y / a,
+        1 - 2 * y * y / a, -2 * z * y / a, 0, -2 * x * z / a, -2 * y * z / a,
+        1 - 2 * z * z / a, 0, 0, 0, 0, 1;
     node->matrix = m;
   }
 
   return children.instantiate(node);
 }
 
-std::shared_ptr<AbstractNode> builtin_translate(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_translate(const ModuleInstantiation* inst,
+                                                Arguments arguments,
+                                                const Children& children) {
   auto node = std::make_shared<TransformNode>(inst, "translate");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"v"});
 
   Vector3d translatevec(0, 0, 0);
-  bool ok = parameters["v"].getVec3(translatevec[0], translatevec[1], translatevec[2], 0.0);
-  ok &= std::isfinite(translatevec[0]) && std::isfinite(translatevec[1]) && std::isfinite(translatevec[2]);
+  bool ok = parameters["v"].getVec3(translatevec[0], translatevec[1],
+                                    translatevec[2], 0.0);
+  ok &= std::isfinite(translatevec[0]) && std::isfinite(translatevec[1]) &&
+        std::isfinite(translatevec[2]);
   if (ok) {
     node->matrix.translate(translatevec);
   } else {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert translate(%1$s) parameter to a vec3 or vec2 of numbers", parameters["v"].toEchoStringNoThrow());
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Unable to convert translate(%1$s) parameter to a vec3 or vec2 of "
+        "numbers",
+        parameters["v"].toEchoStringNoThrow());
   }
 
   return children.instantiate(node);
 }
 
-std::shared_ptr<AbstractNode> builtin_multmatrix(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_multmatrix(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   auto node = std::make_shared<TransformNode>(inst, "multmatrix");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"m"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"m"});
 
   if (parameters["m"].type() == Value::Type::VECTOR) {
     Matrix4d rawmatrix{Matrix4d::Identity()};
@@ -221,15 +251,16 @@ std::shared_ptr<AbstractNode> builtin_multmatrix(const ModuleInstantiation *inst
       }
     }
     double w = rawmatrix(3, 3);
-    if (w != 1.0) node->matrix = rawmatrix / w;
-    else node->matrix = rawmatrix;
+    if (w != 1.0)
+      node->matrix = rawmatrix / w;
+    else
+      node->matrix = rawmatrix;
   }
 
   return children.instantiate(node);
 }
 
-std::string TransformNode::toString() const
-{
+std::string TransformNode::toString() const {
   std::ostringstream stream;
 
   stream << "multmatrix([";
@@ -237,57 +268,55 @@ std::string TransformNode::toString() const
     stream << "[";
     for (int i = 0; i < 4; ++i) {
       stream << this->matrix(j, i);
-      if (i != 3) stream << ", ";
+      if (i != 3)
+        stream << ", ";
     }
     stream << "]";
-    if (j != 3) stream << ", ";
+    if (j != 3)
+      stream << ", ";
   }
   stream << "])";
 
   return stream.str();
 }
 
-TransformNode::TransformNode(const ModuleInstantiation *mi, std::string verbose_name) :
-  AbstractNode(mi),
-  matrix(Transform3d::Identity()),
-  _name(std::move(verbose_name))
-{
-}
+TransformNode::TransformNode(const ModuleInstantiation* mi,
+                             std::string verbose_name)
+    : AbstractNode(mi),
+      matrix(Transform3d::Identity()),
+      _name(std::move(verbose_name)) {}
 
-std::string TransformNode::name() const
-{
+std::string TransformNode::name() const {
   return "transform";
 }
 
-std::string TransformNode::verbose_name() const
-{
+std::string TransformNode::verbose_name() const {
   return _name;
 }
 
-void register_builtin_transform()
-{
+void register_builtin_transform() {
   Builtins::init("scale", new BuiltinModule(builtin_scale),
-  {
-    "scale([x, y, z])",
-  });
+                 {
+                     "scale([x, y, z])",
+                 });
 
   Builtins::init("rotate", new BuiltinModule(builtin_rotate),
-  {
-    "rotate([x, y, z])",
-  });
+                 {
+                     "rotate([x, y, z])",
+                 });
 
   Builtins::init("mirror", new BuiltinModule(builtin_mirror),
-  {
-    "mirror([x, y, z])",
-  });
+                 {
+                     "mirror([x, y, z])",
+                 });
 
   Builtins::init("translate", new BuiltinModule(builtin_translate),
-  {
-    "translate([x, y, z])",
-  });
+                 {
+                     "translate([x, y, z])",
+                 });
 
   Builtins::init("multmatrix", new BuiltinModule(builtin_multmatrix),
-  {
-    "multmatrix(matrix_4_by_4)",
-  });
+                 {
+                     "multmatrix(matrix_4_by_4)",
+                 });
 }
diff --git a/src/core/TransformNode.h b/src/core/TransformNode.h
index 3aaadb9a0..07b315ea1 100644
--- a/src/core/TransformNode.h
+++ b/src/core/TransformNode.h
@@ -2,21 +2,20 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/linalg.h"
 
-class TransformNode : public AbstractNode
-{
-public:
+class TransformNode : public AbstractNode {
+ public:
   VISITABLE();
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  TransformNode(const ModuleInstantiation *mi, std::string verbose_name);
+  TransformNode(const ModuleInstantiation* mi, std::string verbose_name);
   std::string toString() const override;
   std::string name() const override;
   std::string verbose_name() const override;
   Transform3d matrix;
 
-private:
+ private:
   const std::string _name;
 };
diff --git a/src/core/Tree.cc b/src/core/Tree.cc
index 9c54d3e37..ad4032961 100644
--- a/src/core/Tree.cc
+++ b/src/core/Tree.cc
@@ -1,13 +1,12 @@
 #include "core/Tree.h"
 #include "core/NodeDumper.h"
 
-#include <memory>
 #include <cassert>
+#include <memory>
 #include <string>
 #include <tuple>
 
-Tree::~Tree()
-{
+Tree::~Tree() {
   this->nodecachemap.clear();
 }
 
@@ -15,8 +14,8 @@ Tree::~Tree()
    Returns the cached string representation of the subtree rooted by \a node.
    If node is not cached, the cache will be rebuilt.
  */
-const std::string Tree::getString(const AbstractNode& node, const std::string& indent) const
-{
+const std::string Tree::getString(const AbstractNode& node,
+                                  const std::string& indent) const {
   assert(this->root_node);
   bool idString = false;
 
@@ -40,8 +39,7 @@ const std::string Tree::getString(const AbstractNode& node, const std::string& i
    is stripped for whitespace. Especially indentation whitespace is important to
    strip to enable cache hits for equivalent nodes from different scopes.
  */
-const std::string Tree::getIdString(const AbstractNode& node) const
-{
+const std::string Tree::getIdString(const AbstractNode& node) const {
   assert(this->root_node);
   const std::string indent = "";
   const bool idString = true;
@@ -62,17 +60,15 @@ const std::string Tree::getIdString(const AbstractNode& node) const
 /*!
    Sets a new root. Will clear the existing cache.
  */
-void Tree::setRoot(const std::shared_ptr<const AbstractNode>& root)
-{
+void Tree::setRoot(const std::shared_ptr<const AbstractNode>& root) {
   this->root_node = root;
   this->nodecachemap.clear();
 }
 
-void Tree::setDocumentPath(const std::string& path){
+void Tree::setDocumentPath(const std::string& path) {
   this->document_path = path;
 }
 
-const std::string Tree::getDocumentPath() const
-{
+const std::string Tree::getDocumentPath() const {
   return this->document_path;
 }
diff --git a/src/core/Tree.h b/src/core/Tree.h
index efe74daab..1de2c2b9f 100644
--- a/src/core/Tree.h
+++ b/src/core/Tree.h
@@ -1,33 +1,38 @@
 #pragma once
 
-#include "core/NodeCache.h"
-#include <tuple>
-#include <memory>
 #include <map>
+#include <memory>
 #include <string>
+#include <tuple>
 #include <utility>
+#include "core/NodeCache.h"
 
 /*!
    For now, just an abstraction of the node tree which keeps a dump
    cache based on node indices around.
 
-   Note that since node trees don't survive a recompilation, the tree cannot either.
+   Note that since node trees don't survive a recompilation, the tree cannot
+   either.
  */
-class Tree
-{
-public:
-  Tree(std::shared_ptr<const AbstractNode> root = nullptr, std::string path = {}) : root_node(std::move(root)), document_path(std::move(path)) {}
+class Tree {
+ public:
+  Tree(std::shared_ptr<const AbstractNode> root = nullptr,
+       std::string path = {})
+      : root_node(std::move(root)), document_path(std::move(path)) {}
   ~Tree();
 
   void setRoot(const std::shared_ptr<const AbstractNode>& root);
   void setDocumentPath(const std::string& path);
-  const std::shared_ptr<const AbstractNode>& root() const { return this->root_node; }
+  const std::shared_ptr<const AbstractNode>& root() const {
+    return this->root_node;
+  }
 
-  const std::string getString(const AbstractNode& node, const std::string& indent) const;
+  const std::string getString(const AbstractNode& node,
+                              const std::string& indent) const;
   const std::string getIdString(const AbstractNode& node) const;
   const std::string getDocumentPath() const;
 
-private:
+ private:
   std::shared_ptr<const AbstractNode> root_node;
   // keep a separate nodecache per tuple of NodeDumper constructor parameters
   mutable std::map<std::tuple<std::string, bool>, NodeCache> nodecachemap;
diff --git a/src/core/UndefType.h b/src/core/UndefType.h
index 1bee3c348..9ba4f3ece 100644
--- a/src/core/UndefType.h
+++ b/src/core/UndefType.h
@@ -10,20 +10,26 @@
 class Value;
 
 /*
-   Require a reason why (string), any time an undefined value is created/returned.
-   This allows for passing of "exception" information from low level functions (i.e. from value.cc)
-   up to Expression::evaluate() or other functions where a proper "WARNING: ..."
-   with ASTNode Location info (source file, line number) can be included.
+   Require a reason why (string), any time an undefined value is
+   created/returned. This allows for passing of "exception" information from low
+   level functions (i.e. from value.cc) up to Expression::evaluate() or other
+   functions where a proper "WARNING: ..." with ASTNode Location info (source
+   file, line number) can be included.
  */
-class UndefType
-{
-public:
+class UndefType {
+ public:
   // TODO: eventually deprecate undef creation without a reason.
-  UndefType() : reasons{std::make_unique<std::vector<std::string>>()} { }
-  explicit UndefType(const std::string& why) : reasons{std::make_unique<std::vector<std::string>>(std::initializer_list<std::string>({why}))} { }
+  UndefType() : reasons{std::make_unique<std::vector<std::string>>()} {}
+  explicit UndefType(const std::string& why)
+      : reasons{std::make_unique<std::vector<std::string>>(
+            std::initializer_list<std::string>({why}))} {}
 
-  // Append another reason in case a chain of undefined operations are made before handling
-  const UndefType& append(const std::string& why) const { reasons->push_back(why); return *this; }
+  // Append another reason in case a chain of undefined operations are made
+  // before handling
+  const UndefType& append(const std::string& why) const {
+    reasons->push_back(why);
+    return *this;
+  }
 
   Value operator<(const UndefType& other) const;
   Value operator>(const UndefType& other) const;
@@ -44,16 +50,16 @@ public:
     return stream.str();
   }
   bool empty() const { return reasons->empty(); }
-private:
+
+ private:
   // using unique_ptr to keep the size small enough that the variant of
   // all value types does not exceed the 24 bytes.
-  // mutable to allow clearing reasons, which should avoid duplication of warnings that have already been displayed.
+  // mutable to allow clearing reasons, which should avoid duplication of
+  // warnings that have already been displayed.
   mutable std::unique_ptr<std::vector<std::string>> reasons;
 };
 
-
-inline std::ostream& operator<<(std::ostream& stream, const UndefType& /*u*/)
-{
+inline std::ostream& operator<<(std::ostream& stream, const UndefType& /*u*/) {
   stream << "undef";
   return stream;
 }
diff --git a/src/core/UserModule.cc b/src/core/UserModule.cc
index d36dc29cb..add99b1bc 100644
--- a/src/core/UserModule.cc
+++ b/src/core/UserModule.cc
@@ -26,33 +26,39 @@
 
 #include "core/UserModule.h"
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <vector>
 
+#include <cstddef>
+#include <sstream>
+#include <string>
 #include "core/AST.h"
+#include "core/Expression.h"
 #include "core/ModuleInstantiation.h"
+#include "core/ScopeContext.h"
 #include "core/node.h"
-#include "utils/exceptions.h"
 #include "utils/StackCheck.h"
-#include "core/ScopeContext.h"
-#include "core/Expression.h"
-#include "utils/printutils.h"
 #include "utils/compiler_specific.h"
-#include <cstddef>
-#include <sstream>
-#include <string>
+#include "utils/exceptions.h"
+#include "utils/printutils.h"
 
 std::vector<std::string> StaticModuleNameStack::stack;
 
-static void NOINLINE print_err(std::string name, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Error, loc, context->documentRoot(), "Recursion detected calling module '%1$s'", name);
+static void NOINLINE print_err(std::string name,
+                               const Location& loc,
+                               const std::shared_ptr<const Context>& context) {
+  LOG(message_group::Error, loc, context->documentRoot(),
+      "Recursion detected calling module '%1$s'", name);
 }
 
-static void NOINLINE print_trace(const UserModule *mod, const std::shared_ptr<const UserModuleContext>& context, const AssignmentList& parameters){
+static void NOINLINE
+print_trace(const UserModule* mod,
+            const std::shared_ptr<const UserModuleContext>& context,
+            const AssignmentList& parameters) {
   std::stringstream stream;
   if (parameters.size() == 0) {
-    //nothing to do
+    // nothing to do
   } else if (StackCheck::inst().check()) {
     stream << "...";
   } else {
@@ -68,41 +74,44 @@ static void NOINLINE print_trace(const UserModule *mod, const std::shared_ptr<co
         stream << " = ";
       }
       try {
-        stream << context->lookup_variable(assignment->getName(), Location::NONE);
+        stream << context->lookup_variable(assignment->getName(),
+                                           Location::NONE);
       } catch (EvaluationException& e) {
         stream << "...";
       }
     }
   }
-  LOG(message_group::Trace, mod->location(), context->documentRoot(), "call of '%1$s(%2$s)'",
-      mod->name, stream.str()
-      );
+  LOG(message_group::Trace, mod->location(), context->documentRoot(),
+      "call of '%1$s(%2$s)'", mod->name, stream.str());
 }
 
-std::shared_ptr<AbstractNode> UserModule::instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const
-{
+std::shared_ptr<AbstractNode> UserModule::instantiate(
+    const std::shared_ptr<const Context>& defining_context,
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) const {
   if (StackCheck::inst().check()) {
     print_err(inst->name(), loc, context);
     throw RecursionException::create("module", inst->name(), loc);
     return nullptr;
   }
 
-  StaticModuleNameStack name{inst->name()}; // push on static stack, pop at end of method!
-  ContextHandle<UserModuleContext> module_context{Context::create<UserModuleContext>(
-                                                    defining_context,
-                                                    this,
-                                                    inst->location(),
-                                                    Arguments(inst->arguments, context),
-                                                    Children(&inst->scope, context)
-                                                    )};
+  StaticModuleNameStack name{
+      inst->name()};  // push on static stack, pop at end of method!
+  ContextHandle<UserModuleContext> module_context{
+      Context::create<UserModuleContext>(defining_context, this,
+                                         inst->location(),
+                                         Arguments(inst->arguments, context),
+                                         Children(&inst->scope, context))};
 #if 0 && DEBUG
   PRINTDB("UserModuleContext for module %s(%s):\n", this->name % STR(this->parameters));
   PRINTDB("%s", module_context->dump());
 #endif
 
   std::shared_ptr<AbstractNode> ret;
-  try{
-    ret = this->body.instantiateModules(*module_context, std::make_shared<GroupNode>(inst, std::string("module ") + this->name));
+  try {
+    ret = this->body.instantiateModules(
+        *module_context,
+        std::make_shared<GroupNode>(inst, std::string("module ") + this->name));
   } catch (EvaluationException& e) {
     if (OpenSCAD::traceUsermoduleParameters && e.traceDepth > 0) {
       print_trace(this, *module_context, this->parameters);
@@ -113,16 +122,17 @@ std::shared_ptr<AbstractNode> UserModule::instantiate(const std::shared_ptr<cons
   return ret;
 }
 
-void UserModule::print(std::ostream& stream, const std::string& indent) const
-{
+void UserModule::print(std::ostream& stream, const std::string& indent) const {
   std::string tab;
   if (!this->name.empty()) {
     stream << indent << "module " << this->name << "(";
     for (size_t i = 0; i < this->parameters.size(); ++i) {
       const auto& parameter = this->parameters[i];
-      if (i > 0) stream << ", ";
+      if (i > 0)
+        stream << ", ";
       stream << parameter->getName();
-      if (parameter->getExpr()) stream << " = " << *parameter->getExpr();
+      if (parameter->getExpr())
+        stream << " = " << *parameter->getExpr();
     }
     stream << ") {\n";
     tab = "\t";
diff --git a/src/core/UserModule.h b/src/core/UserModule.h
index 39cc4df34..30c020f75 100644
--- a/src/core/UserModule.h
+++ b/src/core/UserModule.h
@@ -1,42 +1,43 @@
 #pragma once
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <string>
 #include <vector>
 
-#include "core/module.h"
 #include "core/AST.h"
 #include "core/LocalScope.h"
+#include "core/module.h"
 
 class Feature;
 
-class StaticModuleNameStack
-{
-public:
-  StaticModuleNameStack(const std::string& name) {
-    stack.push_back(name);
-  }
-  ~StaticModuleNameStack() {
-    stack.pop_back();
-  }
+class StaticModuleNameStack {
+ public:
+  StaticModuleNameStack(const std::string& name) { stack.push_back(name); }
+  ~StaticModuleNameStack() { stack.pop_back(); }
 
   static int size() { return stack.size(); }
   static const std::string& at(int idx) { return stack[idx]; }
 
-private:
+ private:
   static std::vector<std::string> stack;
 };
 
-class UserModule : public AbstractModule, public ASTNode
-{
-public:
-  UserModule(const char *name, const Location& loc) : ASTNode(loc), name(name) { }
-  UserModule(const char *name, const Feature& feature, const Location& loc) : AbstractModule(feature), ASTNode(loc), name(name) { }
-
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const override;
+class UserModule : public AbstractModule, public ASTNode {
+ public:
+  UserModule(const char* name, const Location& loc)
+      : ASTNode(loc), name(name) {}
+  UserModule(const char* name, const Feature& feature, const Location& loc)
+      : AbstractModule(feature), ASTNode(loc), name(name) {}
+
+  std::shared_ptr<AbstractNode> instantiate(
+      const std::shared_ptr<const Context>& defining_context,
+      const ModuleInstantiation* inst,
+      const std::shared_ptr<const Context>& context) const override;
   void print(std::ostream& stream, const std::string& indent) const override;
-  static const std::string& stack_element(int n) { return StaticModuleNameStack::at(n); }
+  static const std::string& stack_element(int n) {
+    return StaticModuleNameStack::at(n);
+  }
   static int stack_size() { return StaticModuleNameStack::size(); }
 
   std::string name;
diff --git a/src/core/Value.cc b/src/core/Value.cc
index 976204a98..9a8800b48 100644
--- a/src/core/Value.cc
+++ b/src/core/Value.cc
@@ -26,29 +26,29 @@
 
 #include "core/Value.h"
 
-#include <filesystem>
-#include <cmath>
-#include <variant>
-#include <limits>
-#include <ostream>
-#include <utility>
-#include <cstdint>
+#include <boost/lexical_cast.hpp>
 #include <cassert>
+#include <cmath>
 #include <cstddef>
+#include <cstdint>
+#include <filesystem>
+#include <limits>
 #include <memory>
+#include <ostream>
 #include <sstream>
 #include <string>
+#include <utility>
+#include <variant>
 #include <vector>
-#include <boost/lexical_cast.hpp>
 
+#include <double-conversion/double-conversion.h>
+#include <double-conversion/ieee.h>
+#include <double-conversion/utils.h>
 #include "core/EvaluationSession.h"
 #include "io/fileutils.h"
-#include "utils/printutils.h"
 #include "utils/StackCheck.h"
 #include "utils/boost-utils.h"
-#include <double-conversion/double-conversion.h>
-#include <double-conversion/utils.h>
-#include <double-conversion/ieee.h>
+#include "utils/printutils.h"
 
 namespace fs = std::filesystem;
 
@@ -56,10 +56,11 @@ const Value Value::undefined;
 const VectorType VectorType::EMPTY(nullptr);
 const RangeType RangeType::EMPTY{0, 0, 0};
 
-
 /* Define values for double-conversion library. */
 #define DC_BUFFER_SIZE (128)
-#define DC_FLAGS (double_conversion::DoubleToStringConverter::UNIQUE_ZERO | double_conversion::DoubleToStringConverter::EMIT_POSITIVE_EXPONENT_SIGN)
+#define DC_FLAGS                                             \
+  (double_conversion::DoubleToStringConverter::UNIQUE_ZERO | \
+   double_conversion::DoubleToStringConverter::EMIT_POSITIVE_EXPONENT_SIGN)
 #define DC_INF "inf"
 #define DC_NAN "nan"
 #define DC_EXP 'e'
@@ -72,70 +73,86 @@ const RangeType RangeType::EMPTY{0, 0, 0};
  * conversion, defeating the purpose of using double-conversion library */
 #define DC_PRECISION_REQUESTED (6)
 
-//private definitions used by trimTrailingZeroesHelper
+// private definitions used by trimTrailingZeroesHelper
 #define TRIM_TRAILINGZEROES_DONE (0)
 #define TRIM_TRAILINGZEROES_CONTINUE (1)
 
-//process parameter buffer from the end to start to find out where the zeroes are located (if any).
-//parameter pos shall be the pos in buffer where '\0' is located.
-//parameter currentpos shall be set to end of buffer (where '\0' is located).
-//set parameters exppos and decimalpos when needed.
-//leave parameter zeropos as is.
-inline int trimTrailingZeroesHelper(char *buffer, const int pos, char *currentpos = nullptr, char *exppos = nullptr, char *decimalpos = nullptr, char *zeropos = nullptr) {
-
+// process parameter buffer from the end to start to find out where the zeroes
+// are located (if any). parameter pos shall be the pos in buffer where '\0' is
+// located. parameter currentpos shall be set to end of buffer (where '\0' is
+// located). set parameters exppos and decimalpos when needed. leave parameter
+// zeropos as is.
+inline int trimTrailingZeroesHelper(char* buffer,
+                                    const int pos,
+                                    char* currentpos = nullptr,
+                                    char* exppos = nullptr,
+                                    char* decimalpos = nullptr,
+                                    char* zeropos = nullptr) {
   int cont = TRIM_TRAILINGZEROES_CONTINUE;
 
-  //we have exhausted all positions from end to start
-  if (currentpos <= buffer) return TRIM_TRAILINGZEROES_DONE;
+  // we have exhausted all positions from end to start
+  if (currentpos <= buffer)
+    return TRIM_TRAILINGZEROES_DONE;
 
-  //we do no need to process the terminator of string
+  // we do no need to process the terminator of string
   if (*currentpos == '\0') {
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos,
+                                    zeropos);
   }
 
-  //we have an exponent and jumps to the position before the exponent - no need to process the characters belonging to the exponent
+  // we have an exponent and jumps to the position before the exponent - no need
+  // to process the characters belonging to the exponent
   if (cont && exppos && currentpos >= exppos) {
     currentpos = exppos;
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos,
+                                    zeropos);
   }
 
-  //we are still on the right side of the decimal and still counting zeroes (keep track of) from the back to start
+  // we are still on the right side of the decimal and still counting zeroes
+  // (keep track of) from the back to start
   if (cont && currentpos && decimalpos < currentpos && *currentpos == '0') {
     zeropos = currentpos;
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos,
+                                    zeropos);
   }
 
-  //we have found the first occurrence of not a zero and have zeroes and exponent to take care of (move exponent to either the position of the zero or the decimal)
+  // we have found the first occurrence of not a zero and have zeroes and
+  // exponent to take care of (move exponent to either the position of the zero
+  // or the decimal)
   if (cont && zeropos && exppos) {
     int count = &buffer[pos] - exppos + 1;
     memmove(zeropos - 1 == decimalpos ? decimalpos : zeropos, exppos, count);
     return TRIM_TRAILINGZEROES_DONE;
   }
 
-  //we have found a zero and need to take care of (truncate the string to the position of either the zero or the decimal)
+  // we have found a zero and need to take care of (truncate the string to the
+  // position of either the zero or the decimal)
   if (cont && zeropos) {
-    zeropos - 1 == decimalpos ? *decimalpos = '\0' : *zeropos = '\0';
+    zeropos - 1 == decimalpos ? * decimalpos = '\0' : * zeropos = '\0';
     return TRIM_TRAILINGZEROES_DONE;
   }
 
-  //we have just another character (other than a zero) and are done
-  if (cont && !zeropos) return TRIM_TRAILINGZEROES_DONE;
+  // we have just another character (other than a zero) and are done
+  if (cont && !zeropos)
+    return TRIM_TRAILINGZEROES_DONE;
 
   return TRIM_TRAILINGZEROES_DONE;
 }
 
-inline void trimTrailingZeroes(char *buffer, const int pos) {
-  char *decimal = strchr(buffer, '.');
+inline void trimTrailingZeroes(char* buffer, const int pos) {
+  char* decimal = strchr(buffer, '.');
   if (decimal) {
-    char *exppos = strchr(buffer, DC_EXP);
-    trimTrailingZeroesHelper(buffer, pos, &buffer[pos], exppos, decimal, nullptr);
+    char* exppos = strchr(buffer, DC_EXP);
+    trimTrailingZeroesHelper(buffer, pos, &buffer[pos], exppos, decimal,
+                             nullptr);
   }
 }
 
-inline bool HandleSpecialValues(const double& value, double_conversion::StringBuilder& builder) {
+inline bool HandleSpecialValues(const double& value,
+                                double_conversion::StringBuilder& builder) {
   double_conversion::Double double_inspect(value);
   if (double_inspect.IsInfinite()) {
     if (value < 0) {
@@ -151,8 +168,11 @@ inline bool HandleSpecialValues(const double& value, double_conversion::StringBu
   return false;
 }
 
-inline std::string DoubleConvert(const double& value, char *buffer,
-                                 double_conversion::StringBuilder& builder, const double_conversion::DoubleToStringConverter& dc) {
+inline std::string DoubleConvert(
+    const double& value,
+    char* buffer,
+    double_conversion::StringBuilder& builder,
+    const double_conversion::DoubleToStringConverter& dc) {
   builder.Reset();
   if (double_conversion::Double(value).IsSpecial()) {
     HandleSpecialValues(value, builder);
@@ -160,14 +180,13 @@ inline std::string DoubleConvert(const double& value, char *buffer,
     return buffer;
   }
   dc.ToPrecision(value, DC_PRECISION_REQUESTED, &builder);
-  int pos = builder.position(); // get position before Finalize destroys it
+  int pos = builder.position();  // get position before Finalize destroys it
   builder.Finalize();
   trimTrailingZeroes(buffer, pos);
   return buffer;
 }
 
-static uint32_t convert_to_uint32(const double d)
-{
+static uint32_t convert_to_uint32(const double d) {
   auto ret = std::numeric_limits<uint32_t>::max();
   if (std::isfinite(d)) {
     try {
@@ -179,26 +198,35 @@ static uint32_t convert_to_uint32(const double d)
   return ret;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Filename& filename)
-{
-  fs::path fnpath{static_cast<std::string>(filename)}; // gcc-4.6
+std::ostream& operator<<(std::ostream& stream, const Filename& filename) {
+  fs::path fnpath{static_cast<std::string>(filename)};  // gcc-4.6
   auto fpath = fs_uncomplete(fnpath, fs::current_path());
   stream << QuotedString(fpath.generic_string());
   return stream;
 }
 
 // FIXME: This could probably be done more elegantly using boost::regex
-std::ostream& operator<<(std::ostream& stream, const QuotedString& s)
-{
+std::ostream& operator<<(std::ostream& stream, const QuotedString& s) {
   stream << '"';
   for (char c : s) {
     switch (c) {
-    case '\t': stream << "\\t"; break;
-    case '\n': stream << "\\n"; break;
-    case '\r': stream << "\\r"; break;
-    case '"':  stream << "\\\""; break;
-    case '\\': stream << "\\\\"; break;
-    default:   stream << c;
+      case '\t':
+        stream << "\\t";
+        break;
+      case '\n':
+        stream << "\\n";
+        break;
+      case '\r':
+        stream << "\\r";
+        break;
+      case '"':
+        stream << "\\\"";
+        break;
+      case '\\':
+        stream << "\\\\";
+        break;
+      default:
+        stream << c;
     }
   }
   return stream << '"';
@@ -206,92 +234,131 @@ std::ostream& operator<<(std::ostream& stream, const QuotedString& s)
 
 Value Value::clone() const {
   switch (this->type()) {
-  case Type::UNDEFINED: return {};
-  case Type::BOOL:      return std::get<bool>(this->value);
-  case Type::NUMBER:    return std::get<double>(this->value);
-  case Type::STRING:    return std::get<str_utf8_wrapper>(this->value).clone();
-  case Type::RANGE:     return std::get<RangePtr>(this->value).clone();
-  case Type::VECTOR:    return std::get<VectorType>(this->value).clone();
-  case Type::OBJECT:    return std::get<ObjectType>(this->value).clone();
-  case Type::FUNCTION:  return std::get<FunctionPtr>(this->value).clone();
-  default: assert(false && "unknown Value variant type"); return {};
-  }
-}
-
-Value Value::undef(const std::string& why)
-{
+    case Type::UNDEFINED:
+      return {};
+    case Type::BOOL:
+      return std::get<bool>(this->value);
+    case Type::NUMBER:
+      return std::get<double>(this->value);
+    case Type::STRING:
+      return std::get<str_utf8_wrapper>(this->value).clone();
+    case Type::RANGE:
+      return std::get<RangePtr>(this->value).clone();
+    case Type::VECTOR:
+      return std::get<VectorType>(this->value).clone();
+    case Type::OBJECT:
+      return std::get<ObjectType>(this->value).clone();
+    case Type::FUNCTION:
+      return std::get<FunctionPtr>(this->value).clone();
+    default:
+      assert(false && "unknown Value variant type");
+      return {};
+  }
+}
+
+Value Value::undef(const std::string& why) {
   return Value{UndefType{why}};
 }
 
-std::string Value::typeName(Type type)
-{
+std::string Value::typeName(Type type) {
   switch (type) {
-  case Type::UNDEFINED: return "undefined";
-  case Type::BOOL:      return "bool";
-  case Type::NUMBER:    return "number";
-  case Type::STRING:    return "string";
-  case Type::VECTOR:    return "vector";
-  case Type::RANGE:     return "range";
-  case Type::OBJECT:    return "object";
-  case Type::FUNCTION:  return "function";
-  default: assert(false && "unknown Value variant type"); return "<unknown>";
-  }
-}
-
-const std::string Value::typeName() const
-{
+    case Type::UNDEFINED:
+      return "undefined";
+    case Type::BOOL:
+      return "bool";
+    case Type::NUMBER:
+      return "number";
+    case Type::STRING:
+      return "string";
+    case Type::VECTOR:
+      return "vector";
+    case Type::RANGE:
+      return "range";
+    case Type::OBJECT:
+      return "object";
+    case Type::FUNCTION:
+      return "function";
+    default:
+      assert(false && "unknown Value variant type");
+      return "<unknown>";
+  }
+}
+
+const std::string Value::typeName() const {
   return typeName(this->type());
 }
 
-// free functions for use by static_visitor templated functions in creating undef messages.
-std::string getTypeName(const UndefType&) { return "undefined"; }
-std::string getTypeName(bool) { return "bool"; }
-std::string getTypeName(double) { return "number"; }
-std::string getTypeName(const str_utf8_wrapper&) { return "string"; }
-std::string getTypeName(const VectorType&) { return "vector"; }
-std::string getTypeName(const ObjectType&) { return "object"; }
-std::string getTypeName(const RangePtr&) { return "range"; }
-std::string getTypeName(const FunctionPtr&) { return "function"; }
+// free functions for use by static_visitor templated functions in creating
+// undef messages.
+std::string getTypeName(const UndefType&) {
+  return "undefined";
+}
+std::string getTypeName(bool) {
+  return "bool";
+}
+std::string getTypeName(double) {
+  return "number";
+}
+std::string getTypeName(const str_utf8_wrapper&) {
+  return "string";
+}
+std::string getTypeName(const VectorType&) {
+  return "vector";
+}
+std::string getTypeName(const ObjectType&) {
+  return "object";
+}
+std::string getTypeName(const RangePtr&) {
+  return "range";
+}
+std::string getTypeName(const FunctionPtr&) {
+  return "function";
+}
 
-bool Value::toBool() const
-{
+bool Value::toBool() const {
   // NOLINTBEGIN(bugprone-branch-clone)
   switch (this->type()) {
-  case Type::UNDEFINED: return false;
-  case Type::BOOL:      return std::get<bool>(this->value);
-  case Type::NUMBER:    return std::get<double>(this->value) != 0;
-  case Type::STRING:    return !std::get<str_utf8_wrapper>(this->value).empty();
-  case Type::VECTOR:    return !std::get<VectorType>(this->value).empty();
-  case Type::RANGE:     return true;
-  case Type::OBJECT:    return !std::get<ObjectType>(this->value).empty();
-  case Type::FUNCTION:  return true;
-  default: assert(false && "unknown Value variant type"); return false;
+    case Type::UNDEFINED:
+      return false;
+    case Type::BOOL:
+      return std::get<bool>(this->value);
+    case Type::NUMBER:
+      return std::get<double>(this->value) != 0;
+    case Type::STRING:
+      return !std::get<str_utf8_wrapper>(this->value).empty();
+    case Type::VECTOR:
+      return !std::get<VectorType>(this->value).empty();
+    case Type::RANGE:
+      return true;
+    case Type::OBJECT:
+      return !std::get<ObjectType>(this->value).empty();
+    case Type::FUNCTION:
+      return true;
+    default:
+      assert(false && "unknown Value variant type");
+      return false;
   }
   // NOLINTEND(bugprone-branch-clone)
 }
 
-// Convert the value to a double with an integer value, for use in bitwise operations.
-// Since there are several possible ways to do this (floor, ceil, round, trunc) this function
-// centralizes the choice for consistency.
-double Value::toInteger() const
-{
+// Convert the value to a double with an integer value, for use in bitwise
+// operations. Since there are several possible ways to do this (floor, ceil,
+// round, trunc) this function centralizes the choice for consistency.
+double Value::toInteger() const {
   return trunc(this->toDouble());
 }
 
-int64_t Value::toInt64() const
-{
+int64_t Value::toInt64() const {
   return this->toInteger();
 }
 
-double Value::toDouble() const
-{
-  const double *d = std::get_if<double>(&this->value);
+double Value::toDouble() const {
+  const double* d = std::get_if<double>(&this->value);
   return d ? *d : 0.0;
 }
 
-bool Value::getDouble(double& v) const
-{
-  const double *d = std::get_if<double>(&this->value);
+bool Value::getDouble(double& v) const {
+  const double* d = std::get_if<double>(&this->value);
   if (d) {
     v = *d;
     return true;
@@ -299,8 +366,7 @@ bool Value::getDouble(double& v) const
   return false;
 }
 
-bool Value::getFiniteDouble(double& v) const
-{
+bool Value::getFiniteDouble(double& v) const {
   double result;
   if (getDouble(result) && std::isfinite(result)) {
     v = result;
@@ -309,22 +375,20 @@ bool Value::getFiniteDouble(double& v) const
   return false;
 }
 
-bool Value::getUnsignedInt(unsigned int& v) const
-{
+bool Value::getUnsignedInt(unsigned int& v) const {
   double result;
-  if (getFiniteDouble(result) &&
-      result >= 0.0 && result <= std::numeric_limits<unsigned int>::max()) {
+  if (getFiniteDouble(result) && result >= 0.0 &&
+      result <= std::numeric_limits<unsigned int>::max()) {
     v = result;
     return true;
   }
   return false;
 }
 
-bool Value::getPositiveInt(unsigned int& v) const
-{
+bool Value::getPositiveInt(unsigned int& v) const {
   double result;
-  if (getFiniteDouble(result) &&
-      result >= 1 && result <= std::numeric_limits<unsigned int>::max()) {
+  if (getFiniteDouble(result) && result >= 1 &&
+      result <= std::numeric_limits<unsigned int>::max()) {
     v = result;
     return true;
   }
@@ -335,23 +399,31 @@ const str_utf8_wrapper& Value::toStrUtf8Wrapper() const {
   return std::get<str_utf8_wrapper>(this->value);
 }
 
-// Optimization to avoid multiple stream instantiations and copies to str for long vectors.
-// Functions identically to "class tostring_visitor", except outputting to stream and not returning strings
-class tostream_visitor
-{
-public:
+// Optimization to avoid multiple stream instantiations and copies to str for
+// long vectors. Functions identically to "class tostring_visitor", except
+// outputting to stream and not returning strings
+class tostream_visitor {
+ public:
   std::ostringstream& stream;
   mutable char buffer[DC_BUFFER_SIZE];
   mutable double_conversion::StringBuilder builder;
   double_conversion::DoubleToStringConverter dc;
 
   tostream_visitor(std::ostringstream& stream)
-    : stream(stream), builder(buffer, DC_BUFFER_SIZE),
-    dc(DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES)
-  {}
-
-  template <typename T> void operator()(const T& op1) const {
-    //std::cout << "[generic tostream_visitor]\n";
+      : stream(stream),
+        builder(buffer, DC_BUFFER_SIZE),
+        dc(DC_FLAGS,
+           DC_INF,
+           DC_NAN,
+           DC_EXP,
+           DC_DECIMAL_LOW_EXP,
+           DC_DECIMAL_HIGH_EXP,
+           DC_MAX_LEADING_ZEROES,
+           DC_MAX_TRAILING_ZEROES) {}
+
+  template <typename T>
+  void operator()(const T& op1) const {
+    // std::cout << "[generic tostream_visitor]\n";
     stream << boost::lexical_cast<std::string>(op1);
   }
 
@@ -359,13 +431,9 @@ public:
     stream << DoubleConvert(op1, buffer, builder, dc);
   }
 
-  void operator()(const UndefType&) const {
-    stream << "undef";
-  }
+  void operator()(const UndefType&) const { stream << "undef"; }
 
-  void operator()(const bool& v) const {
-    stream << (v ? "true" : "false");
-  }
+  void operator()(const bool& v) const { stream << (v ? "true" : "false"); }
 
   void operator()(const EmbeddedVectorType&) const {
     assert(false && "Error: unexpected visit to EmbeddedVectorType!");
@@ -391,19 +459,15 @@ public:
     stream << '"' << v.toString() << '"';
   }
 
-  void operator()(const RangePtr& v) const {
-    stream << *v;
-  }
+  void operator()(const RangePtr& v) const { stream << *v; }
 
-  void operator()(const FunctionPtr& v) const {
-    stream << *v;
-  }
+  void operator()(const FunctionPtr& v) const { stream << *v; }
 };
 
-class tostring_visitor
-{
-public:
-  template <typename T> std::string operator()(const T& op1) const {
+class tostring_visitor {
+ public:
+  template <typename T>
+  std::string operator()(const T& op1) const {
     assert(false && "unhandled tostring_visitor type");
     return STR(op1);
   }
@@ -415,18 +479,15 @@ public:
   std::string operator()(const double& op1) const {
     char buffer[DC_BUFFER_SIZE];
     double_conversion::StringBuilder builder(buffer, DC_BUFFER_SIZE);
-    double_conversion::DoubleToStringConverter dc(DC_FLAGS, DC_INF, DC_NAN, DC_EXP,
-                                                  DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
+    double_conversion::DoubleToStringConverter dc(
+        DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP,
+        DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
     return DoubleConvert(op1, buffer, builder, dc);
   }
 
-  std::string operator()(const UndefType&) const {
-    return "undef";
-  }
+  std::string operator()(const UndefType&) const { return "undef"; }
 
-  std::string operator()(const bool& v) const {
-    return v ? "true" : "false";
-  }
+  std::string operator()(const bool& v) const { return v ? "true" : "false"; }
 
   std::string operator()(const EmbeddedVectorType&) const {
     assert(false && "Error: unexpected visit to EmbeddedVectorType!");
@@ -434,7 +495,8 @@ public:
   }
 
   std::string operator()(const VectorType& v) const {
-    // Create a single stream and pass reference to it for list elements for optimization.
+    // Create a single stream and pass reference to it for list elements for
+    // optimization.
     std::ostringstream stream;
     try {
       (tostream_visitor(stream))(v);
@@ -445,26 +507,18 @@ public:
     return stream.str();
   }
 
-  std::string operator()(const ObjectType& v) const {
-    return STR(v);
-  }
+  std::string operator()(const ObjectType& v) const { return STR(v); }
 
-  std::string operator()(const RangePtr& v) const {
-    return STR(*v);
-  }
+  std::string operator()(const RangePtr& v) const { return STR(*v); }
 
-  std::string operator()(const FunctionPtr& v) const {
-    return STR(*v);
-  }
+  std::string operator()(const FunctionPtr& v) const { return STR(*v); }
 };
 
-std::string Value::toString() const
-{
+std::string Value::toString() const {
   return std::visit(tostring_visitor(), this->value);
 }
 
-std::string Value::toEchoString() const
-{
+std::string Value::toEchoString() const {
   if (type() == Value::Type::STRING) {
     return std::string("\"") + toString() + '"';
   } else {
@@ -472,10 +526,9 @@ std::string Value::toEchoString() const
   }
 }
 
-std::string Value::toEchoStringNoThrow() const
-{
+std::string Value::toEchoStringNoThrow() const {
   std::string ret;
-  try{
+  try {
     ret = toEchoString();
   } catch (EvaluationException& e) {
     ret = "...";
@@ -483,26 +536,22 @@ std::string Value::toEchoStringNoThrow() const
   return ret;
 }
 
-const UndefType& Value::toUndef() const
-{
+const UndefType& Value::toUndef() const {
   return std::get<UndefType>(this->value);
 }
 
-std::string Value::toUndefString() const
-{
+std::string Value::toUndefString() const {
   return std::get<UndefType>(this->value).toString();
 }
 
-class chr_visitor
-{
-public:
-  template <typename S> std::string operator()(const S&) const
-  {
+class chr_visitor {
+ public:
+  template <typename S>
+  std::string operator()(const S&) const {
     return "";
   }
 
-  std::string operator()(const double& v) const
-  {
+  std::string operator()(const double& v) const {
     char buf[8];
     memset(buf, 0, 8);
     if (v > 0) {
@@ -514,8 +563,7 @@ public:
     return {buf};
   }
 
-  std::string operator()(const VectorType& v) const
-  {
+  std::string operator()(const VectorType& v) const {
     std::ostringstream stream;
     for (auto& val : v) {
       stream << val.chrString();
@@ -523,42 +571,45 @@ public:
     return stream.str();
   }
 
-  std::string operator()(const RangePtr& v) const
-  {
+  std::string operator()(const RangePtr& v) const {
     const uint32_t steps = v->numValues();
     if (steps >= RangeType::MAX_RANGE_STEPS) {
-      LOG(message_group::Warning, "Bad range parameter in for statement: too many elements (%1$lu).", steps);
+      LOG(message_group::Warning,
+          "Bad range parameter in for statement: too many elements (%1$lu).",
+          steps);
       return "";
     }
 
     std::ostringstream stream;
-    for (double d : *v) stream << Value(d).chrString();
+    for (double d : *v)
+      stream << Value(d).chrString();
     return stream.str();
   }
 };
 
-std::string Value::chrString() const
-{
+std::string Value::chrString() const {
   return std::visit(chr_visitor(), this->value);
 }
 
-VectorType::VectorType(EvaluationSession *session) :
-  ptr(std::shared_ptr<VectorObject>(new VectorObject(), VectorObjectDeleter() ))
-{
+VectorType::VectorType(EvaluationSession* session)
+    : ptr(std::shared_ptr<VectorObject>(new VectorObject(),
+                                        VectorObjectDeleter())) {
   ptr->evaluation_session = session;
 }
 
-VectorType::VectorType(class EvaluationSession *session, double x, double y, double z) :
-  ptr(std::shared_ptr<VectorObject>(new VectorObject(), VectorObjectDeleter() ))
-{
+VectorType::VectorType(class EvaluationSession* session,
+                       double x,
+                       double y,
+                       double z)
+    : ptr(std::shared_ptr<VectorObject>(new VectorObject(),
+                                        VectorObjectDeleter())) {
   ptr->evaluation_session = session;
   emplace_back(x);
   emplace_back(y);
   emplace_back(z);
 }
 
-void VectorType::emplace_back(Value&& val)
-{
+void VectorType::emplace_back(Value&& val) {
   if (val.type() == Value::Type::EMBEDDED_VECTOR) {
     emplace_back(std::move(val.toEmbeddedVectorNonConst()));
   } else {
@@ -570,32 +621,33 @@ void VectorType::emplace_back(Value&& val)
 }
 
 // Specialized handler for EmbeddedVectorTypes
-void VectorType::emplace_back(EmbeddedVectorType&& mbed)
-{
+void VectorType::emplace_back(EmbeddedVectorType&& mbed) {
   if (mbed.size() > 1) {
-    // embed_excess represents how many to add to vec.size() to get the total elements after flattening,
-    // the embedded vector itself already counts towards an element in the parent's size, so subtract 1 from its size.
+    // embed_excess represents how many to add to vec.size() to get the total
+    // elements after flattening, the embedded vector itself already counts
+    // towards an element in the parent's size, so subtract 1 from its size.
     ptr->embed_excess += mbed.size() - 1;
     ptr->vec.emplace_back(std::move(mbed));
     if (ptr->evaluation_session) {
       ptr->evaluation_session->accounting().addVectorElement(1);
     }
   } else if (mbed.size() == 1) {
-    // If embedded vector contains only one value, then insert a copy of that element
-    // Due to the above mentioned "-1" count, putting it in directaly as an EmbeddedVector
-    // would not change embed_excess, which is needed to check if flatten is required.
+    // If embedded vector contains only one value, then insert a copy of that
+    // element Due to the above mentioned "-1" count, putting it in directaly as
+    // an EmbeddedVector would not change embed_excess, which is needed to check
+    // if flatten is required.
     emplace_back(mbed.ptr->vec[0].clone());
   }
   // else mbed.size() == 0, do nothing
 }
 
-void VectorType::flatten() const
-{
+void VectorType::flatten() const {
   vec_t ret;
   ret.reserve(this->size());
-  // VectorType::iterator already handles the tricky recursive navigation of embedded vectors,
-  // so just build up our new vector from that.
-  for (const auto& el : *this) ret.emplace_back(el.clone());
+  // VectorType::iterator already handles the tricky recursive navigation of
+  // embedded vectors, so just build up our new vector from that.
+  for (const auto& el : *this)
+    ret.emplace_back(el.clone());
   assert(ret.size() == this->size());
   ptr->embed_excess = 0;
   if (ptr->evaluation_session) {
@@ -605,13 +657,12 @@ void VectorType::flatten() const
   ptr->vec = std::move(ret);
 }
 
-void VectorType::VectorObjectDeleter::operator()(VectorObject *v)
-{
+void VectorType::VectorObjectDeleter::operator()(VectorObject* v) {
   if (v->evaluation_session) {
     v->evaluation_session->accounting().removeVectorElement(v->vec.size());
   }
 
-  VectorObject *orig = v;
+  VectorObject* orig = v;
   std::shared_ptr<VectorObject> curr;
   std::vector<std::shared_ptr<VectorObject>> purge;
   while (true) {
@@ -619,60 +670,62 @@ void VectorType::VectorObjectDeleter::operator()(VectorObject *v)
       for (Value& val : v->vec) {
         auto type = val.type();
         if (type == Value::Type::EMBEDDED_VECTOR) {
-          std::shared_ptr<VectorObject>& temp = std::get<EmbeddedVectorType>(val.value).ptr;
-          if (temp.use_count() <= 1) purge.emplace_back(std::move(temp));
+          std::shared_ptr<VectorObject>& temp =
+              std::get<EmbeddedVectorType>(val.value).ptr;
+          if (temp.use_count() <= 1)
+            purge.emplace_back(std::move(temp));
         } else if (type == Value::Type::VECTOR) {
-          std::shared_ptr<VectorObject>& temp = std::get<VectorType>(val.value).ptr;
-          if (temp.use_count() <= 1) purge.emplace_back(std::move(temp));
+          std::shared_ptr<VectorObject>& temp =
+              std::get<VectorType>(val.value).ptr;
+          if (temp.use_count() <= 1)
+            purge.emplace_back(std::move(temp));
         }
       }
     }
-    if (purge.empty()) break;
-    curr = std::move(purge.back()); // this should cause destruction of the *previous value* for curr
+    if (purge.empty())
+      break;
+    curr = std::move(purge.back());  // this should cause destruction of the
+                                     // *previous value* for curr
     v = curr.get();
     purge.pop_back();
   }
   delete orig;
 }
 
-const VectorType& Value::toVector() const
-{
+const VectorType& Value::toVector() const {
   static const VectorType empty(nullptr);
-  const VectorType *v = std::get_if<VectorType>(&this->value);
+  const VectorType* v = std::get_if<VectorType>(&this->value);
   return v ? *v : empty;
 }
 
-VectorType& Value::toVectorNonConst()
-{
+VectorType& Value::toVectorNonConst() {
   return std::get<VectorType>(this->value);
 }
 
-const ObjectType& Value::toObject() const
-{
+const ObjectType& Value::toObject() const {
   static const ObjectType empty(nullptr);
-  const ObjectType *v = std::get_if<ObjectType>(&this->value);
+  const ObjectType* v = std::get_if<ObjectType>(&this->value);
   return v ? *v : empty;
 }
 
-EmbeddedVectorType& Value::toEmbeddedVectorNonConst()
-{
+EmbeddedVectorType& Value::toEmbeddedVectorNonConst() {
   return std::get<EmbeddedVectorType>(this->value);
 }
 
-const EmbeddedVectorType& Value::toEmbeddedVector() const
-{
+const EmbeddedVectorType& Value::toEmbeddedVector() const {
   return std::get<EmbeddedVectorType>(this->value);
 }
 
-bool Value::getVec2(double& x, double& y, bool ignoreInfinite) const
-{
-  if (this->type() != Type::VECTOR) return false;
+bool Value::getVec2(double& x, double& y, bool ignoreInfinite) const {
+  if (this->type() != Type::VECTOR)
+    return false;
   const auto& v = this->toVector();
-  if (v.size() != 2) return false;
+  if (v.size() != 2)
+    return false;
   double rx, ry;
   bool valid = ignoreInfinite
-    ? v[0].getFiniteDouble(rx) && v[1].getFiniteDouble(ry)
-    : v[0].getDouble(rx) && v[1].getDouble(ry);
+                   ? v[0].getFiniteDouble(rx) && v[1].getFiniteDouble(ry)
+                   : v[0].getDouble(rx) && v[1].getDouble(ry);
   if (valid) {
     x = rx;
     y = ry;
@@ -680,44 +733,45 @@ bool Value::getVec2(double& x, double& y, bool ignoreInfinite) const
   return valid;
 }
 
-bool Value::getVec3(double& x, double& y, double& z) const
-{
-  if (this->type() != Type::VECTOR) return false;
+bool Value::getVec3(double& x, double& y, double& z) const {
+  if (this->type() != Type::VECTOR)
+    return false;
   const VectorType& v = this->toVector();
-  if (v.size() != 3) return false;
+  if (v.size() != 3)
+    return false;
   return (v[0].getDouble(x) && v[1].getDouble(y) && v[2].getDouble(z));
 }
 
-bool Value::getVec3(double& x, double& y, double& z, double defaultval) const
-{
-  if (this->type() != Type::VECTOR) return false;
+bool Value::getVec3(double& x, double& y, double& z, double defaultval) const {
+  if (this->type() != Type::VECTOR)
+    return false;
   const VectorType& v = toVector();
   if (v.size() == 2) {
     getVec2(x, y);
     z = defaultval;
     return true;
   } else {
-    if (v.size() != 3) return false;
+    if (v.size() != 3)
+      return false;
   }
   return (v[0].getDouble(x) && v[1].getDouble(y) && v[2].getDouble(z));
 }
 
-const RangeType& Value::toRange() const
-{
-  const RangePtr *val = std::get_if<RangePtr>(&this->value);
+const RangeType& Value::toRange() const {
+  const RangePtr* val = std::get_if<RangePtr>(&this->value);
   if (val) {
     return **val;
-  } else return RangeType::EMPTY;
+  } else
+    return RangeType::EMPTY;
 }
 
-const FunctionType& Value::toFunction() const
-{
+const FunctionType& Value::toFunction() const {
   return *std::get<FunctionPtr>(this->value);
 }
 
-bool Value::isUncheckedUndef() const
-{
-  return this->type() == Type::UNDEFINED && !std::get<UndefType>(this->value).empty();
+bool Value::isUncheckedUndef() const {
+  return this->type() == Type::UNDEFINED &&
+         !std::get<UndefType>(this->value).empty();
 }
 
 Value ObjectType::operator==(const ObjectType& other) const {
@@ -728,14 +782,14 @@ Value ObjectType::operator==(const ObjectType& other) const {
     return false;
   }
 
-  for ( size_t i = 0; i < this->ptr->values.size(); i++){
+  for (size_t i = 0; i < this->ptr->values.size(); i++) {
     auto key_the_same = this->ptr->keys[i] != other.ptr->keys[i];
     if (key_the_same) {
       return false;
     }
 
     auto value_the_same = this->ptr->values[i] != other.ptr->values[i];
-    if (value_the_same.toBool() ) {
+    if (value_the_same.toBool()) {
       return false;
     }
   }
@@ -761,36 +815,42 @@ Value ObjectType::operator>=(const ObjectType& /*other*/) const {
 
 Value VectorType::operator==(const VectorType& v) const {
   size_t i = 0;
-  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(), last2 = v.end();
-  for ( ; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
+  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(),
+       last2 = v.end();
+  for (; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
     Value temp = *first1 == *first2;
     if (temp.isUndefined()) {
       temp.toUndef().append(STR("in vector comparison at index ", i));
       return temp;
     }
-    if (!temp.toBool()) return false;
+    if (!temp.toBool())
+      return false;
   }
   return (first1 == last1) && (first2 == last2);
 }
 
 Value VectorType::operator!=(const VectorType& v) const {
   Value temp = this->VectorType::operator==(v);
-  if (temp.isUndefined()) return temp;
+  if (temp.isUndefined())
+    return temp;
   return !temp.toBool();
 }
 
 // lexicographical compare with possible undef result
 Value VectorType::operator<(const VectorType& v) const {
-  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(), last2 = v.end();
+  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(),
+       last2 = v.end();
   size_t i = 0;
-  for ( ; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
+  for (; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
     Value temp = *first1 < *first2;
     if (temp.isUndefined()) {
       temp.toUndef().append(STR("in vector comparison at index ", i));
       return temp;
     }
-    if (temp.toBool()) return true;
-    if ((*first2 < *first1).toBool()) return false;
+    if (temp.toBool())
+      return true;
+    if ((*first2 < *first1).toBool())
+      return false;
   }
   return (first1 == last1) && (first2 != last2);
 }
@@ -801,101 +861,141 @@ Value VectorType::operator>(const VectorType& v) const {
 
 Value VectorType::operator<=(const VectorType& v) const {
   Value temp = this->VectorType::operator>(v);
-  if (temp.isUndefined()) return temp;
+  if (temp.isUndefined())
+    return temp;
   return !temp.toBool();
 }
 
 Value VectorType::operator>=(const VectorType& v) const {
   Value temp = this->VectorType::operator<(v);
-  if (temp.isUndefined()) return temp;
+  if (temp.isUndefined())
+    return temp;
   return !temp.toBool();
 }
 
-class notequal_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& /*op1*/, const U& /*op2*/) const { return true; }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 != op2; }
+class notequal_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& /*op1*/, const U& /*op2*/) const {
+    return true;
+  }
+  template <typename T>
+  Value operator()(const T& op1, const T& op2) const {
+    return op1 != op2;
+  }
   Value operator()(const UndefType&, const UndefType&) const { return false; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 != *op2; }
+  template <typename T>
+  Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const {
+    return *op1 != *op2;
+  }
 };
 
-class equals_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& /*op1*/, const U& /*op2*/) const { return false; }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 == op2; }
+class equals_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& /*op1*/, const U& /*op2*/) const {
+    return false;
+  }
+  template <typename T>
+  Value operator()(const T& op1, const T& op2) const {
+    return op1 == op2;
+  }
   Value operator()(const UndefType&, const UndefType&) const { return true; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 == *op2; }
+  template <typename T>
+  Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const {
+    return *op1 == *op2;
+  }
 };
 
-class less_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " < ", getTypeName(op2), ")"));
+class less_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& op1, const U& op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " < ",
+                            getTypeName(op2), ")"));
+  }
+  template <typename T>
+  Value operator()(const T& op1, const T& op2) const {
+    return op1 < op2;
+  }
+  template <typename T>
+  Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const {
+    return *op1 < *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 < op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 < *op2; }
 };
 
-class greater_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " > ", getTypeName(op2), ")"));
+class greater_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& op1, const U& op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " > ",
+                            getTypeName(op2), ")"));
+  }
+  template <typename T>
+  Value operator()(const T& op1, const T& op2) const {
+    return op1 > op2;
+  }
+  template <typename T>
+  Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const {
+    return *op1 > *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 > op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 > *op2; }
 };
 
-class lessequal_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " <= ", getTypeName(op2), ")"));
+class lessequal_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& op1, const U& op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1),
+                            " <= ", getTypeName(op2), ")"));
+  }
+  template <typename T>
+  Value operator()(const T& op1, const T& op2) const {
+    return op1 <= op2;
+  }
+  template <typename T>
+  Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const {
+    return *op1 <= *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 <= op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 <= *op2; }
 };
 
-class greaterequal_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " >= ", getTypeName(op2), ")"));
+class greaterequal_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& op1, const U& op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1),
+                            " >= ", getTypeName(op2), ")"));
+  }
+  template <typename T>
+  Value operator()(const T& op1, const T& op2) const {
+    return op1 >= op2;
+  }
+  template <typename T>
+  Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const {
+    return *op1 >= *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 >= op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 >= *op2; }
 };
 
-Value Value::operator==(const Value& v) const
-{
+Value Value::operator==(const Value& v) const {
   return std::visit(equals_visitor(), this->value, v.value);
 }
 
-Value Value::operator!=(const Value& v) const
-{
+Value Value::operator!=(const Value& v) const {
   return std::visit(notequal_visitor(), this->value, v.value);
 }
 
-Value Value::operator<(const Value& v) const
-{
+Value Value::operator<(const Value& v) const {
   return std::visit(less_visitor(), this->value, v.value);
 }
 
-Value Value::operator>=(const Value& v) const
-{
+Value Value::operator>=(const Value& v) const {
   return std::visit(greaterequal_visitor(), this->value, v.value);
 }
 
-Value Value::operator>(const Value& v) const
-{
+Value Value::operator>(const Value& v) const {
   return std::visit(greater_visitor(), this->value, v.value);
 }
 
-Value Value::operator<=(const Value& v) const
-{
+Value Value::operator<=(const Value& v) const {
   return std::visit(lessequal_visitor(), this->value, v.value);
 }
 
@@ -903,11 +1003,12 @@ bool Value::cmp_less(const Value& v1, const Value& v2) {
   return v1.operator<(v2).toBool();
 }
 
-class plus_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " + ", getTypeName(op2), ")"));
+class plus_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& op1, const U& op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " + ",
+                            getTypeName(op2), ")"));
   }
 
   Value operator()(const double& op1, const double& op2) const {
@@ -920,25 +1021,25 @@ public:
     // FIXME: should we really truncate to shortest vector here?
     //   Maybe better to either "add zeroes" and return longest
     //   and/or issue an warning/error about length mismatch.
-    for (auto it1 = op1.begin(), end1 = op1.end(), it2 = op2.begin(), end2 = op2.end();
-         it1 != end1 && it2 != end2;
-         ++it1, ++it2) {
+    for (auto it1 = op1.begin(), end1 = op1.end(), it2 = op2.begin(),
+              end2 = op2.end();
+         it1 != end1 && it2 != end2; ++it1, ++it2) {
       sum.emplace_back(*it1 + *it2);
     }
     return std::move(sum);
   }
 };
 
-Value Value::operator+(const Value& v) const
-{
+Value Value::operator+(const Value& v) const {
   return std::visit(plus_visitor(), this->value, v.value);
 }
 
-class minus_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " - ", getTypeName(op2), ")"));
+class minus_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& op1, const U& op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " - ",
+                            getTypeName(op2), ")"));
   }
 
   Value operator()(const double& op1, const double& op2) const {
@@ -955,13 +1056,11 @@ public:
   }
 };
 
-Value Value::operator-(const Value& v) const
-{
+Value Value::operator-(const Value& v) const {
   return std::visit(minus_visitor(), this->value, v.value);
 }
 
-Value multvecnum(const VectorType& vecval, const Value& numval)
-{
+Value multvecnum(const VectorType& vecval, const Value& numval) {
   // Vector * Number
   VectorType dstv(vecval.evaluation_session());
   dstv.reserve(vecval.size());
@@ -971,23 +1070,26 @@ Value multvecnum(const VectorType& vecval, const Value& numval)
   return std::move(dstv);
 }
 
-Value multmatvec(const VectorType& matrixvec, const VectorType& vectorvec)
-{
+Value multmatvec(const VectorType& matrixvec, const VectorType& vectorvec) {
   // Matrix * Vector
   VectorType dstv(matrixvec.evaluation_session());
   dstv.reserve(matrixvec.size());
   for (size_t i = 0; i < matrixvec.size(); ++i) {
     if (matrixvec[i].type() != Value::Type::VECTOR ||
         matrixvec[i].toVector().size() != vectorvec.size()) {
-      return Value::undef(STR("Matrix must be rectangular. Problem at row ", i));
+      return Value::undef(
+          STR("Matrix must be rectangular. Problem at row ", i));
     }
     double r_e = 0.0;
     for (size_t j = 0; j < matrixvec[i].toVector().size(); ++j) {
       if (matrixvec[i].toVector()[j].type() != Value::Type::NUMBER) {
-        return Value::undef(STR("Matrix must contain only numbers. Problem at row ", i, ", col ", j));
+        return Value::undef(
+            STR("Matrix must contain only numbers. Problem at row ", i,
+                ", col ", j));
       }
       if (vectorvec[j].type() != Value::Type::NUMBER) {
-        return Value::undef(STR("Vector must contain only numbers. Problem at index ", j));
+        return Value::undef(
+            STR("Vector must contain only numbers. Problem at index ", j));
       }
       r_e += matrixvec[i].toVector()[j].toDouble() * vectorvec[j].toDouble();
     }
@@ -996,8 +1098,7 @@ Value multmatvec(const VectorType& matrixvec, const VectorType& vectorvec)
   return std::move(dstv);
 }
 
-Value multvecmat(const VectorType& vectorvec, const VectorType& matrixvec)
-{
+Value multvecmat(const VectorType& vectorvec, const VectorType& matrixvec) {
   assert(vectorvec.size() == matrixvec.size());
   // Vector * Matrix
   VectorType dstv(matrixvec[0].toVector().evaluation_session());
@@ -1008,16 +1109,24 @@ Value multvecmat(const VectorType& vectorvec, const VectorType& matrixvec)
     for (size_t j = 0; j < vectorvec.size(); ++j) {
       if (matrixvec[j].type() != Value::Type::VECTOR ||
           matrixvec[j].toVector().size() != firstRowSize) {
-        LOG(message_group::Warning, "Matrix must be rectangular. Problem at row %1$lu", j);
-        return Value::undef(STR("Matrix must be rectangular. Problem at row ", j));
+        LOG(message_group::Warning,
+            "Matrix must be rectangular. Problem at row %1$lu", j);
+        return Value::undef(
+            STR("Matrix must be rectangular. Problem at row ", j));
       }
       if (vectorvec[j].type() != Value::Type::NUMBER) {
-        LOG(message_group::Warning, "Vector must contain only numbers. Problem at index %1$lu", j);
-        return Value::undef(STR("Vector must contain only numbers. Problem at index ", j));
+        LOG(message_group::Warning,
+            "Vector must contain only numbers. Problem at index %1$lu", j);
+        return Value::undef(
+            STR("Vector must contain only numbers. Problem at index ", j));
       }
       if (matrixvec[j].toVector()[i].type() != Value::Type::NUMBER) {
-        LOG(message_group::Warning, "Matrix must contain only numbers. Problem at row %1$lu, col %2$lu", j, i);
-        return Value::undef(STR("Matrix must contain only numbers. Problem at row ", j, ", col ", i));
+        LOG(message_group::Warning,
+            "Matrix must contain only numbers. Problem at row %1$lu, col %2$lu",
+            j, i);
+        return Value::undef(
+            STR("Matrix must contain only numbers. Problem at row ", j,
+                ", col ", i));
       }
       r_e += vectorvec[j].toDouble() * matrixvec[j].toVector()[i].toDouble();
     }
@@ -1030,40 +1139,63 @@ Value multvecvec(const VectorType& vec1, const VectorType& vec2) {
   // Vector dot product.
   auto r = 0.0;
   for (size_t i = 0; i < vec1.size(); i++) {
-    if (vec1[i].type() != Value::Type::NUMBER || vec2[i].type() != Value::Type::NUMBER) {
-      return Value::undef(STR("undefined operation (", vec1[i].typeName(), " * ", vec2[i].typeName(), ")"));
+    if (vec1[i].type() != Value::Type::NUMBER ||
+        vec2[i].type() != Value::Type::NUMBER) {
+      return Value::undef(STR("undefined operation (", vec1[i].typeName(),
+                              " * ", vec2[i].typeName(), ")"));
     }
     r += vec1[i].toDouble() * vec2[i].toDouble();
   }
   return {r};
 }
 
-class multiply_visitor
-{
-public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " * ", getTypeName(op2), ")"));
+class multiply_visitor {
+ public:
+  template <typename T, typename U>
+  Value operator()(const T& op1, const U& op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " * ",
+                            getTypeName(op2), ")"));
+  }
+  Value operator()(const double& op1, const double& op2) const {
+    return op1 * op2;
+  }
+  Value operator()(const double& op1, const VectorType& op2) const {
+    return multvecnum(op2, op1);
+  }
+  Value operator()(const VectorType& op1, const double& op2) const {
+    return multvecnum(op1, op2);
   }
-  Value operator()(const double& op1, const double& op2) const { return op1 * op2; }
-  Value operator()(const double& op1, const VectorType& op2) const { return multvecnum(op2, op1); }
-  Value operator()(const VectorType& op1, const double& op2) const { return multvecnum(op1, op2); }
 
   Value operator()(const VectorType& op1, const VectorType& op2) const {
-    if (op1.empty() || op2.empty()) return Value::undef("Multiplication is undefined on empty vectors");
+    if (op1.empty() || op2.empty())
+      return Value::undef("Multiplication is undefined on empty vectors");
     auto first1 = op1.begin(), first2 = op2.begin();
     auto eltype1 = (*first1).type(), eltype2 = (*first2).type();
     if (eltype1 == Value::Type::NUMBER) {
       if (eltype2 == Value::Type::NUMBER) {
-        if (op1.size() == op2.size()) return multvecvec(op1, op2);
-        else return Value::undef(STR("vector*vector requires matching lengths (", op1.size(), " != ", op2.size(), ')'));
+        if (op1.size() == op2.size())
+          return multvecvec(op1, op2);
+        else
+          return Value::undef(STR("vector*vector requires matching lengths (",
+                                  op1.size(), " != ", op2.size(), ')'));
       } else if (eltype2 == Value::Type::VECTOR) {
-        if (op1.size() == op2.size()) return multvecmat(op1, op2);
-        else return Value::undef(STR("vector*matrix requires vector length to match matrix row count (", op1.size(), " != ", op2.size(), ')'));
+        if (op1.size() == op2.size())
+          return multvecmat(op1, op2);
+        else
+          return Value::undef(
+              STR("vector*matrix requires vector length to match matrix row "
+                  "count (",
+                  op1.size(), " != ", op2.size(), ')'));
       }
     } else if (eltype1 == Value::Type::VECTOR) {
       if (eltype2 == Value::Type::NUMBER) {
-        if ((*first1).toVector().size() == op2.size()) return multmatvec(op1, op2);
-        else return Value::undef(STR("matrix*vector requires matrix column count to match vector length (", (*first1).toVector().size(), " != ", op2.size(), ')'));
+        if ((*first1).toVector().size() == op2.size())
+          return multmatvec(op1, op2);
+        else
+          return Value::undef(
+              STR("matrix*vector requires matrix column count to match vector "
+                  "length (",
+                  (*first1).toVector().size(), " != ", op2.size(), ')'));
       } else if (eltype2 == Value::Type::VECTOR) {
         if ((*first1).toVector().size() == op2.size()) {
           // Matrix * Matrix
@@ -1072,10 +1204,15 @@ public:
           size_t i = 0;
           for (const auto& srcrow : op1) {
             const auto& srcrowvec = srcrow.toVector();
-            if (srcrowvec.size() != op2.size()) return Value::undef(STR("matrix*matrix left operand row length does not match right operand row count (", srcrowvec.size(), " != ", op2.size(), ") at row ", i));
+            if (srcrowvec.size() != op2.size())
+              return Value::undef(
+                  STR("matrix*matrix left operand row length does not match "
+                      "right operand row count (",
+                      srcrowvec.size(), " != ", op2.size(), ") at row ", i));
             auto temp = multvecmat(srcrowvec, op2);
             if (temp.isUndefined()) {
-              temp.toUndef().append(STR("while processing left operand at row ", i));
+              temp.toUndef().append(
+                  STR("while processing left operand at row ", i));
               return temp;
             } else {
               dstv.emplace_back(std::move(temp));
@@ -1084,21 +1221,25 @@ public:
           }
           return {std::move(dstv)};
         } else {
-          return Value::undef(STR("matrix*matrix requires left operand column count to match right operand row count (", (*first1).toVector().size(), " != ", op2.size(), ')'));
+          return Value::undef(
+              STR("matrix*matrix requires left operand column count to match "
+                  "right operand row count (",
+                  (*first1).toVector().size(), " != ", op2.size(), ')'));
         }
       }
     }
-    return Value::undef(STR("undefined vector*vector multiplication where first elements are types ", (*first1).typeName(), " and ", (*first2).typeName() ));
+    return Value::undef(
+        STR("undefined vector*vector multiplication where first elements are "
+            "types ",
+            (*first1).typeName(), " and ", (*first2).typeName()));
   }
 };
 
-Value Value::operator*(const Value& v) const
-{
+Value Value::operator*(const Value& v) const {
   return std::visit(multiply_visitor(), this->value, v.value);
 }
 
-Value Value::operator/(const Value& v) const
-{
+Value Value::operator/(const Value& v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return this->toDouble() / v.toDouble();
   } else if (this->type() == Type::VECTOR && v.type() == Type::NUMBER) {
@@ -1116,19 +1257,19 @@ Value Value::operator/(const Value& v) const
     }
     return std::move(dstv);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " / ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " / ", v.typeName(), ")"));
 }
 
-Value Value::operator%(const Value& v) const
-{
+Value Value::operator%(const Value& v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return fmod(std::get<double>(this->value), std::get<double>(v.value));
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " % ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " % ", v.typeName(), ")"));
 }
 
-Value Value::operator<<(const Value& v) const
-{
+Value Value::operator<<(const Value& v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     int64_t lhs = this->toInt64();
     int64_t rhs = v.toInt64();
@@ -1140,11 +1281,11 @@ Value Value::operator<<(const Value& v) const
     }
     return (double)(lhs << rhs);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " << ", v.typeName(), ")"));
+  return Value::undef(STR("undefined operation (", this->typeName(), " << ",
+                          v.typeName(), ")"));
 }
 
-Value Value::operator>>(const Value& v) const
-{
+Value Value::operator>>(const Value& v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     int64_t lhs = this->toInt64();
     int64_t rhs = v.toInt64();
@@ -1156,28 +1297,27 @@ Value Value::operator>>(const Value& v) const
     }
     return (double)(lhs >> rhs);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " >> ", v.typeName(), ")"));
+  return Value::undef(STR("undefined operation (", this->typeName(), " >> ",
+                          v.typeName(), ")"));
 }
 
-Value Value::operator&(const Value& v) const
-{
+Value Value::operator&(const Value& v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return (double)(this->toInt64() & v.toInt64());
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " & ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " & ", v.typeName(), ")"));
 }
 
-Value Value::operator|(const Value& v) const
-{
+Value Value::operator|(const Value& v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return (double)(this->toInt64() | v.toInt64());
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " | ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " | ", v.typeName(), ")"));
 }
 
-
-Value Value::operator-() const
-{
+Value Value::operator-() const {
   if (this->type() == Type::NUMBER) {
     return {-this->toDouble()};
   } else if (this->type() == Type::VECTOR) {
@@ -1191,30 +1331,29 @@ Value Value::operator-() const
   return Value::undef(STR("undefined operation (-", this->typeName(), ")"));
 }
 
-Value Value::operator~() const
-{
+Value Value::operator~() const {
   if (this->type() == Type::NUMBER) {
     return (double)~this->toInt64();
   }
   return Value::undef(STR("undefined operation (~", this->typeName(), ")"));
 }
 
-Value Value::operator^(const Value& v) const
-{
+Value Value::operator^(const Value& v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return {pow(std::get<double>(this->value), std::get<double>(v.value))};
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " ^ ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " ^ ", v.typeName(), ")"));
 }
 
 /*
  * bracket operation [] detecting multi-byte unicode.
- * If the string is multi-byte unicode then the index will offset to the character (2 or 4 byte) and not to the byte.
- * A 'normal' string with byte chars are a subset of unicode and still work.
+ * If the string is multi-byte unicode then the index will offset to the
+ * character (2 or 4 byte) and not to the byte. A 'normal' string with byte
+ * chars are a subset of unicode and still work.
  */
-class bracket_visitor
-{
-public:
+class bracket_visitor {
+ public:
   Value operator()(const str_utf8_wrapper& str, const double& idx) const {
     const auto i = convert_to_uint32(idx);
     auto unichar = str[i];
@@ -1226,8 +1365,10 @@ public:
 
   Value operator()(const VectorType& vec, const double& idx) const {
     const auto i = convert_to_uint32(idx);
-    if (i < vec.size()) return vec[i].clone();
-    return Value::undef(STR("index ", i, " out of bounds for vector of size ", vec.size()));
+    if (i < vec.size())
+      return vec[i].clone();
+    return Value::undef(
+        STR("index ", i, " out of bounds for vector of size ", vec.size()));
   }
 
   Value operator()(const ObjectType& obj, const str_utf8_wrapper& key) const {
@@ -1237,77 +1378,88 @@ public:
   Value operator()(const RangePtr& range, const double& idx) const {
     const auto i = convert_to_uint32(idx);
     switch (i) {
-    case 0: return range->begin_value();
-    case 1: return range->step_value();
-    case 2: return range->end_value();
+      case 0:
+        return range->begin_value();
+      case 1:
+        return range->step_value();
+      case 2:
+        return range->end_value();
     }
-    return Value::undef("subscript operator only defined for indices 0-2 on range (begin,step,end)");
+    return Value::undef(
+        "subscript operator only defined for indices 0-2 on range "
+        "(begin,step,end)");
   }
 
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    //std::cout << "generic bracket_visitor " << getTypeName(op1) << " " << getTypeName(op2) << "\n";
-    return Value::undef(STR("undefined operation ", getTypeName(op1), "[", getTypeName(op2), "]"));
+  template <typename T, typename U>
+  Value operator()(const T& op1, const U& op2) const {
+    // std::cout << "generic bracket_visitor " << getTypeName(op1) << " " <<
+    // getTypeName(op2) << "\n";
+    return Value::undef(STR("undefined operation ", getTypeName(op1), "[",
+                            getTypeName(op2), "]"));
   }
 };
 
-Value Value::operator[](const Value& v) const
-{
+Value Value::operator[](const Value& v) const {
   return std::visit(bracket_visitor(), this->value, v.value);
 }
 
-Value Value::operator[](size_t idx) const
-{
+Value Value::operator[](size_t idx) const {
   Value v{(double)idx};
   return std::visit(bracket_visitor(), this->value, v.value);
 }
 
-std::ostream& operator<<(std::ostream& stream, const RangeType& r)
-{
+std::ostream& operator<<(std::ostream& stream, const RangeType& r) {
   char buffer[DC_BUFFER_SIZE];
   double_conversion::StringBuilder builder(buffer, DC_BUFFER_SIZE);
-  double_conversion::DoubleToStringConverter dc(DC_FLAGS, DC_INF,
-                                                DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP,
-                                                DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
-  return stream << "["
-                << DoubleConvert(r.begin_value(), buffer, builder, dc) << " : "
-                << DoubleConvert(r.step_value(), buffer, builder, dc) << " : "
-                << DoubleConvert(r.end_value(),   buffer, builder, dc) << "]";
+  double_conversion::DoubleToStringConverter dc(
+      DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP,
+      DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
+  return stream << "[" << DoubleConvert(r.begin_value(), buffer, builder, dc)
+                << " : " << DoubleConvert(r.step_value(), buffer, builder, dc)
+                << " : " << DoubleConvert(r.end_value(), buffer, builder, dc)
+                << "]";
 }
 
 // called by clone()
-ObjectType::ObjectType(const std::shared_ptr<ObjectObject>& copy)
-  : ptr(copy)
-{
-}
+ObjectType::ObjectType(const std::shared_ptr<ObjectObject>& copy) : ptr(copy) {}
 
-ObjectType::ObjectType(EvaluationSession *session) :
-  ptr(std::make_shared<ObjectObject>())
-{
+ObjectType::ObjectType(EvaluationSession* session)
+    : ptr(std::make_shared<ObjectObject>()) {
   ptr->evaluation_session = session;
 }
 
-const Value& ObjectType::get(const std::string& key) const { return ptr->get(key); }
-bool ObjectType::set(const std::string& key, Value value)               { return ptr->set(key, std::move(value)); }
-bool ObjectType::del(const std::string& key)                            { return ptr->del(key) != NOINDEX; }
-bool ObjectType::contains(const std::string& key) const { return ptr->find(key) != NOINDEX; }
-bool ObjectType::empty() const { return ptr->values.empty(); }
-const std::vector<std::string>& ObjectType::keys() const { return ptr->keys; }
-const std::vector<Value>& ObjectType::values() const { return ptr->values; }
+const Value& ObjectType::get(const std::string& key) const {
+  return ptr->get(key);
+}
+bool ObjectType::set(const std::string& key, Value value) {
+  return ptr->set(key, std::move(value));
+}
+bool ObjectType::del(const std::string& key) {
+  return ptr->del(key) != NOINDEX;
+}
+bool ObjectType::contains(const std::string& key) const {
+  return ptr->find(key) != NOINDEX;
+}
+bool ObjectType::empty() const {
+  return ptr->values.empty();
+}
+const std::vector<std::string>& ObjectType::keys() const {
+  return ptr->keys;
+}
+const std::vector<Value>& ObjectType::values() const {
+  return ptr->values;
+}
 
-const Value& ObjectType::operator[](const str_utf8_wrapper& v) const
-{
+const Value& ObjectType::operator[](const str_utf8_wrapper& v) const {
   return this->get(v.toString());
 }
 
-
 // Copy explicitly only when necessary
-ObjectType ObjectType::clone() const
-{
+ObjectType ObjectType::clone() const {
   return ObjectType(this->ptr);
 }
 
-std::ostream& operator<<(std::ostream& stream, const ObjectType& v)
-{
+std::ostream& operator<<(std::ostream& stream, const ObjectType& v) {
   stream << "{ ";
   auto iter = v.ptr->keys.begin();
   if (iter != v.ptr->keys.end()) {
diff --git a/src/core/Value.h b/src/core/Value.h
index 8260ac6fb..162eeadd3 100644
--- a/src/core/Value.h
+++ b/src/core/Value.h
@@ -1,57 +1,55 @@
 #pragma once
 
-#include <iterator>
-#include <unordered_map>
-#include <utility>
-#include <vector>
-#include <string>
 #include <algorithm>
 #include <cstddef>
-#include <ostream>
+#include <iterator>
 #include <memory>
+#include <ostream>
+#include <string>
 #include <type_traits>
+#include <unordered_map>
+#include <utility>
 #include <variant>
+#include <vector>
 
 #include "core/FunctionType.h"
 #include "core/RangeType.h"
-#include "core/str_utf8_wrapper.h"
 #include "core/UndefType.h"
+#include "core/str_utf8_wrapper.h"
 
 class tostring_visitor;
 class tostream_visitor;
 class Expression;
 class Value;
 
-class QuotedString : public std::string
-{
-public:
+class QuotedString : public std::string {
+ public:
   QuotedString() : std::string() {}
   QuotedString(const std::string& s) : std::string(s) {}
 };
 std::ostream& operator<<(std::ostream& stream, const QuotedString& s);
 
-class Filename : public QuotedString
-{
-public:
+class Filename : public QuotedString {
+ public:
   Filename() : QuotedString() {}
   Filename(const std::string& f) : QuotedString(f) {}
 };
 std::ostream& operator<<(std::ostream& stream, const Filename& filename);
 
 template <typename T>
-class ValuePtr
-{
-private:
-  explicit ValuePtr(std::shared_ptr<T> val_in) : value(std::move(val_in)) { }
-public:
-  ValuePtr(T&& value) : value(std::make_shared<T>(std::move(value))) { }
+class ValuePtr {
+ private:
+  explicit ValuePtr(std::shared_ptr<T> val_in) : value(std::move(val_in)) {}
+
+ public:
+  ValuePtr(T&& value) : value(std::make_shared<T>(std::move(value))) {}
   [[nodiscard]] ValuePtr clone() const { return ValuePtr(value); }
 
   const T& operator*() const { return *value; }
-  const T *operator->() const { return value.get(); }
+  const T* operator->() const { return value.get(); }
   [[nodiscard]] const std::shared_ptr<T>& get() const { return value; }
 
-private:
+ private:
   std::shared_ptr<T> value;
 };
 
@@ -61,20 +59,21 @@ using FunctionPtr = ValuePtr<FunctionType>;
 /**
  *  Value class encapsulates a std::variant value which can represent any of the
  *  value types existing in the SCAD language.
- * -- As part of a refactoring effort which began as PR #2881 and continued as PR #3102,
- *    Value and its constituent types have been made (nominally) "move only".
- * -- In some cases a copy of a Value is necessary or unavoidable, in which case Value::clone() can be used.
- * -- Value::clone() is used instead of automatic copy construction/assignment so this action is
- *    made deliberate and explicit (and discouraged).
- * -- Recommended to make use of RVO (Return Value Optimization) wherever possible:
- *       https://en.cppreference.com/w/cpp/language/copy_elision
- * -- Classes which cache Values such as Context or dxf_dim_cache(see dxfdim.cc), when queried
- *    should return either a const reference or a clone of the cached value if returning by-value.
- *    NEVER return a non-const reference!
+ * -- As part of a refactoring effort which began as PR #2881 and continued as
+ * PR #3102, Value and its constituent types have been made (nominally) "move
+ * only".
+ * -- In some cases a copy of a Value is necessary or unavoidable, in which case
+ * Value::clone() can be used.
+ * -- Value::clone() is used instead of automatic copy construction/assignment
+ * so this action is made deliberate and explicit (and discouraged).
+ * -- Recommended to make use of RVO (Return Value Optimization) wherever
+ * possible: https://en.cppreference.com/w/cpp/language/copy_elision
+ * -- Classes which cache Values such as Context or dxf_dim_cache(see
+ * dxfdim.cc), when queried should return either a const reference or a clone of
+ * the cached value if returning by-value. NEVER return a non-const reference!
  */
-class Value
-{
-public:
+class Value {
+ public:
   enum class Type {
     UNDEFINED,
     BOOL,
@@ -86,83 +85,100 @@ public:
     FUNCTION,
     OBJECT
   };
-  // FIXME: eventually remove this in favor of specific messages for each undef usage
+  // FIXME: eventually remove this in favor of specific messages for each undef
+  // usage
   static const Value undefined;
 
   /**
-   * VectorType is the underlying "BoundedType" of std::variant for OpenSCAD vectors.
-   * It holds only a shared_ptr to its VectorObject type, and provides a convenient
-   * interface for various operations needed on the vector.
+   * VectorType is the underlying "BoundedType" of std::variant for OpenSCAD
+   * vectors. It holds only a shared_ptr to its VectorObject type, and provides
+   * a convenient interface for various operations needed on the vector.
    *
-   * EmbeddedVectorType class derives from VectorType and enables O(1) concatenation of vectors
-   * by treating their elements as elements of their parent, traversable via VectorType's custom iterator.
-   * -- An embedded vector should never exist "in the wild", only as a pseudo-element of a parent vector.
-   *    Eg "Lc*" Expressions return Embedded Vectors but they are necessarily child expressions of a Vector expression.
-   * -- Any VectorType containing embedded elements will be forced to "flatten" upon usage of operator[],
-   *    which is the only case of random-access.
-   * -- Any loops through VectorTypes should prefer automatic range-based for loops eg: for(const auto& value : vec) { ... }
-   *    which make use of begin() and end() iterators of VectorType.  https://en.cppreference.com/w/cpp/language/range-for
-   * -- Moving a temporary Value of type VectorType or EmbeddedVectorType is always safe,
-   *    since it just moves the shared_ptr in its possession (which might be a copy but that doesn't matter).
-   *    Additionally any VectorType can be converted to an EmbeddedVectorType by moving it into
+   * EmbeddedVectorType class derives from VectorType and enables O(1)
+   * concatenation of vectors by treating their elements as elements of their
+   * parent, traversable via VectorType's custom iterator.
+   * -- An embedded vector should never exist "in the wild", only as a
+   * pseudo-element of a parent vector. Eg "Lc*" Expressions return Embedded
+   * Vectors but they are necessarily child expressions of a Vector expression.
+   * -- Any VectorType containing embedded elements will be forced to "flatten"
+   * upon usage of operator[], which is the only case of random-access.
+   * -- Any loops through VectorTypes should prefer automatic range-based for
+   * loops eg: for(const auto& value : vec) { ... } which make use of begin()
+   * and end() iterators of VectorType.
+   * https://en.cppreference.com/w/cpp/language/range-for
+   * -- Moving a temporary Value of type VectorType or EmbeddedVectorType is
+   * always safe, since it just moves the shared_ptr in its possession (which
+   * might be a copy but that doesn't matter). Additionally any VectorType can
+   * be converted to an EmbeddedVectorType by moving it into
    *    EmbeddedVectorType's converting constructor (or vice-versa).
-   * -- HOWEVER, moving elements out of a [Embedded]VectorType is potentially DANGEROUS unless it can be
-   *    verified that ( ptr.use_count() == 1 ) for that outermost [Embedded]VectorType
-   *    AND recursively any EmbeddedVectorTypes which led to that element.
-   *    Therefore elements are currently cloned rather than making any attempt to move.
-   *    Performing such use_count checks may be an area for further optimization.
+   * -- HOWEVER, moving elements out of a [Embedded]VectorType is potentially
+   * DANGEROUS unless it can be verified that ( ptr.use_count() == 1 ) for that
+   * outermost [Embedded]VectorType AND recursively any EmbeddedVectorTypes
+   * which led to that element. Therefore elements are currently cloned rather
+   * than making any attempt to move. Performing such use_count checks may be an
+   * area for further optimization.
    */
   class EmbeddedVectorType;
-  class VectorType
-  {
-
-protected:
+  class VectorType {
+   protected:
     // The object type which VectorType's shared_ptr points to.
     struct VectorObject {
       using vec_t = std::vector<Value>;
       using size_type = vec_t::size_type;
       vec_t vec;
-      size_type embed_excess = 0; // Keep count of the number of embedded elements *excess of* vec.size()
-      class EvaluationSession *evaluation_session = nullptr; // Used for heap size bookkeeping. May be null for vectors of known small maximum size.
-      [[nodiscard]] size_type size() const { return vec.size() + embed_excess;  }
-      [[nodiscard]] bool empty() const { return vec.empty() && embed_excess == 0;  }
+      size_type embed_excess = 0;  // Keep count of the number of embedded
+                                   // elements *excess of* vec.size()
+      class EvaluationSession* evaluation_session =
+          nullptr;  // Used for heap size bookkeeping. May be null for vectors
+                    // of known small maximum size.
+      [[nodiscard]] size_type size() const { return vec.size() + embed_excess; }
+      [[nodiscard]] bool empty() const {
+        return vec.empty() && embed_excess == 0;
+      }
     };
     using vec_t = VectorObject::vec_t;
-public:
+
+   public:
     std::shared_ptr<VectorObject> ptr;
-protected:
 
+   protected:
     // A Deleter is used on the shared_ptrs to avoid stack overflow in cases
-    // of destructing a very large list of nested embedded vectors, such as from a
-    // recursive function which concats one element at a time.
-    // (A similar solution can also be seen with CSGNode.h:CSGOperationDeleter).
+    // of destructing a very large list of nested embedded vectors, such as from
+    // a recursive function which concats one element at a time. (A similar
+    // solution can also be seen with CSGNode.h:CSGOperationDeleter).
     struct VectorObjectDeleter {
-      void operator()(VectorObject *vec);
+      void operator()(VectorObject* vec);
     };
-    void flatten() const; // flatten replaces VectorObject::vec with a new vector
-                          // where any embedded elements are copied directly into the top level vec,
-                          // leaving only true elements for straightforward indexing by operator[].
-    explicit VectorType(const std::shared_ptr<VectorObject>& copy) : ptr(copy) { } // called by clone()
-public:
+    void flatten()
+        const;  // flatten replaces VectorObject::vec with a new vector
+                // where any embedded elements are copied directly into the top
+                // level vec, leaving only true elements for straightforward
+                // indexing by operator[].
+    explicit VectorType(const std::shared_ptr<VectorObject>& copy)
+        : ptr(copy) {}  // called by clone()
+   public:
     using size_type = VectorObject::size_type;
     static const VectorType EMPTY;
-    // EmbeddedVectorType-aware iterator, manages its own stack of begin/end vec_t::const_iterators
-    // such that calling code will only receive references to "true" elements (i.e. NOT EmbeddedVectorTypes).
-    // Also tracks the overall element index. In case flattening occurs during iteration, it can continue based on that index. (Issue #3541)
-    class iterator
-    {
-private:
-      const VectorObject *vo;
-      std::vector<std::pair<vec_t::const_iterator, vec_t::const_iterator>> it_stack;
+    // EmbeddedVectorType-aware iterator, manages its own stack of begin/end
+    // vec_t::const_iterators such that calling code will only receive
+    // references to "true" elements (i.e. NOT EmbeddedVectorTypes). Also tracks
+    // the overall element index. In case flattening occurs during iteration, it
+    // can continue based on that index. (Issue #3541)
+    class iterator {
+     private:
+      const VectorObject* vo;
+      std::vector<std::pair<vec_t::const_iterator, vec_t::const_iterator>>
+          it_stack;
       vec_t::const_iterator it, end;
       size_t index;
 
-      // Recursively push stack while current (pseudo)element is an EmbeddedVector
-      //  - Depends on the fact that VectorType::emplace_back(EmbeddedVectorType&& mbed)
-      //    will not embed an empty vector, which ensures iterator will arrive at an actual element,
-      //    unless already at end of parent VectorType.
-      void check_and_push()
-      {
+      // Recursively push stack while current (pseudo)element is an
+      // EmbeddedVector
+      //  - Depends on the fact that
+      //  VectorType::emplace_back(EmbeddedVectorType&& mbed)
+      //    will not embed an empty vector, which ensures iterator will arrive
+      //    at an actual element, unless already at end of parent VectorType.
+      void check_and_push() {
         if (it != end) {
           while (it->type() == Type::EMBEDDED_VECTOR) {
             const vec_t& cur = it->toEmbeddedVector().ptr->vec;
@@ -172,22 +188,31 @@ private:
           }
         }
       }
-public:
+
+     public:
       using iterator_category = std::forward_iterator_tag;
       using value_type = Value;
       using difference_type = void;
       using reference = const value_type&;
-      using pointer = const value_type *;
-
-      iterator() : vo(EMPTY.ptr.get()), it_stack(), it(EMPTY.ptr->vec.begin()), end(EMPTY.ptr->vec.end()), index(0) {}
-      iterator(const VectorObject *v) : vo(v), it(v->vec.begin()), end(v->vec.end()), index(0) {
-        if (vo->embed_excess) check_and_push();
+      using pointer = const value_type*;
+
+      iterator()
+          : vo(EMPTY.ptr.get()),
+            it_stack(),
+            it(EMPTY.ptr->vec.begin()),
+            end(EMPTY.ptr->vec.end()),
+            index(0) {}
+      iterator(const VectorObject* v)
+          : vo(v), it(v->vec.begin()), end(v->vec.end()), index(0) {
+        if (vo->embed_excess)
+          check_and_push();
       }
-      iterator(const VectorObject *v, bool /*end*/) : vo(v), index(v->size()) { }
+      iterator(const VectorObject* v, bool /*end*/) : vo(v), index(v->size()) {}
       iterator& operator++() {
         ++index;
         if (vo->embed_excess) {
-          // recursively increment and pop stack while at the end of EmbeddedVector(s)
+          // recursively increment and pop stack while at the end of
+          // EmbeddedVector(s)
           while (++it == end && !it_stack.empty()) {
             const auto& up = it_stack.back();
             it = up.first;
@@ -195,39 +220,48 @@ public:
             it_stack.pop_back();
           }
           check_and_push();
-        } else { // vo->vec is flat
-          it = vo->vec.begin() + static_cast<vec_t::iterator::difference_type>(index);
+        } else {  // vo->vec is flat
+          it = vo->vec.begin() +
+               static_cast<vec_t::iterator::difference_type>(index);
         }
         return *this;
       }
       reference operator*() const { return *it; }
       pointer operator->() const { return &*it; }
-      bool operator==(const iterator& other) const { return this->vo == other.vo && this->index == other.index; }
-      bool operator!=(const iterator& other) const { return this->vo != other.vo || this->index != other.index; }
+      bool operator==(const iterator& other) const {
+        return this->vo == other.vo && this->index == other.index;
+      }
+      bool operator!=(const iterator& other) const {
+        return this->vo != other.vo || this->index != other.index;
+      }
     };
     using const_iterator = const iterator;
-    VectorType(class EvaluationSession *session);
-    VectorType(class EvaluationSession *session, double x, double y, double z);
-    VectorType(const VectorType&) = delete; // never copy, move instead
-    VectorType& operator=(const VectorType&) = delete; // never copy, move instead
+    VectorType(class EvaluationSession* session);
+    VectorType(class EvaluationSession* session, double x, double y, double z);
+    VectorType(const VectorType&) = delete;  // never copy, move instead
+    VectorType& operator=(const VectorType&) =
+        delete;  // never copy, move instead
     VectorType(VectorType&&) = default;
     VectorType& operator=(VectorType&&) = default;
     ~VectorType() = default;
-    [[nodiscard]] VectorType clone() const { return VectorType(this->ptr); } // Copy explicitly only when necessary
+    [[nodiscard]] VectorType clone() const {
+      return VectorType(this->ptr);
+    }  // Copy explicitly only when necessary
     static Value Empty() { return VectorType(nullptr); }
 
-    void reserve(size_t size) {
-      ptr->vec.reserve(size);
-    }
+    void reserve(size_t size) { ptr->vec.reserve(size); }
 
     [[nodiscard]] const_iterator begin() const { return iterator(ptr.get()); }
-    [[nodiscard]] const_iterator   end() const { return iterator(ptr.get(), true); }
+    [[nodiscard]] const_iterator end() const {
+      return iterator(ptr.get(), true);
+    }
     [[nodiscard]] size_type size() const { return ptr->size(); }
     [[nodiscard]] bool empty() const { return ptr->empty(); }
     // const accesses to VectorObject require .clone to be move-able
     const Value& operator[](size_t idx) const {
       if (idx < this->size()) {
-        if (ptr->embed_excess) flatten();
+        if (ptr->embed_excess)
+          flatten();
         return ptr->vec[idx];
       } else {
         return Value::undefined;
@@ -239,47 +273,55 @@ public:
     Value operator!=(const VectorType& v) const;
     Value operator<=(const VectorType& v) const;
     Value operator>=(const VectorType& v) const;
-    [[nodiscard]] class EvaluationSession *evaluation_session() const { return ptr->evaluation_session; }
+    [[nodiscard]] class EvaluationSession* evaluation_session() const {
+      return ptr->evaluation_session;
+    }
 
     void emplace_back(Value&& val);
     void emplace_back(EmbeddedVectorType&& mbed);
-    template <typename ... Args> void emplace_back(Args&&... args) { emplace_back(Value(std::forward<Args>(args)...)); }
+    template <typename... Args>
+    void emplace_back(Args&&... args) {
+      emplace_back(Value(std::forward<Args>(args)...));
+    }
   };
 
-  class EmbeddedVectorType : public VectorType
-  {
-private:
-    explicit EmbeddedVectorType(const std::shared_ptr<VectorObject>& copy) : VectorType(copy) { } // called by clone()
-public:
-    EmbeddedVectorType(class EvaluationSession *session) : VectorType(session) {}
+  class EmbeddedVectorType : public VectorType {
+   private:
+    explicit EmbeddedVectorType(const std::shared_ptr<VectorObject>& copy)
+        : VectorType(copy) {}  // called by clone()
+   public:
+    EmbeddedVectorType(class EvaluationSession* session)
+        : VectorType(session) {}
     EmbeddedVectorType(const EmbeddedVectorType&) = delete;
     EmbeddedVectorType& operator=(const EmbeddedVectorType&) = delete;
     EmbeddedVectorType(EmbeddedVectorType&&) = default;
     EmbeddedVectorType& operator=(EmbeddedVectorType&&) = default;
     ~EmbeddedVectorType() = default;
-    EmbeddedVectorType(VectorType&& v) : VectorType(std::move(v)) {} // converting constructor
-    [[nodiscard]] EmbeddedVectorType clone() const { return EmbeddedVectorType(this->ptr); }
+    EmbeddedVectorType(VectorType&& v)
+        : VectorType(std::move(v)) {}  // converting constructor
+    [[nodiscard]] EmbeddedVectorType clone() const {
+      return EmbeddedVectorType(this->ptr);
+    }
     static Value Empty() { return EmbeddedVectorType(nullptr); }
   };
 
-  class ObjectType
-  {
-protected:
+  class ObjectType {
+   protected:
     struct ObjectObject;
     struct ObjectObjectDeleter {
-      void operator()(ObjectObject *obj);
+      void operator()(ObjectObject* obj);
     };
 
-private:
+   private:
     explicit ObjectType(const std::shared_ptr<ObjectObject>& copy);
 
-public:
+   public:
     std::shared_ptr<ObjectObject> ptr;
-    ObjectType(class EvaluationSession *session);
+    ObjectType(class EvaluationSession* session);
     [[nodiscard]] ObjectType clone() const;
     [[nodiscard]] const Value& get(const std::string& key) const;
     bool set(const std::string& key, Value value);
-    bool del(const std::string& key); // true if was present
+    bool del(const std::string& key);  // true if was present
     bool contains(const std::string& key) const;
     bool empty() const;
     Value operator==(const ObjectType& v) const;
@@ -293,32 +335,51 @@ public:
     [[nodiscard]] const std::vector<Value>& values() const;
   };
 
-private:
-  Value() : value(UndefType()) { } // Don't default construct empty Values.  If "undefined" needed, use reference to Value::undefined, or call Value::undef() for return by value
-public:
-  Value(const Value&) = delete; // never copy, move instead
-  Value& operator=(const Value& v) = delete; // never copy, move instead
+ private:
+  Value()
+      : value(UndefType()) {
+  }  // Don't default construct empty Values.  If "undefined" needed, use
+     // reference to Value::undefined, or call Value::undef() for return by
+     // value
+ public:
+  Value(const Value&) = delete;               // never copy, move instead
+  Value& operator=(const Value& v) = delete;  // never copy, move instead
   Value(Value&&) = default;
   Value& operator=(Value&&) = default;
-  [[nodiscard]] Value clone() const; // Use sparingly to explicitly copy a Value
+  [[nodiscard]] Value clone()
+      const;  // Use sparingly to explicitly copy a Value
   ~Value() = default;
 
-  Value(int v) : value(double(v)) { }
-  Value(const char *v) : value(str_utf8_wrapper(v)) { } // prevent insane implicit conversion to bool!
-  Value(char *v) : value(str_utf8_wrapper(v)) { } // prevent insane implicit conversion to bool!
-                                                  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html
+  Value(int v) : value(double(v)) {}
+  Value(const char* v)
+      : value(str_utf8_wrapper(v)) {
+  }  // prevent insane implicit conversion to bool!
+  Value(char* v)
+      : value(str_utf8_wrapper(v)) {
+  }  // prevent insane implicit conversion to bool!
+     // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html
   // Don't shadow move constructor
-  template <class T, class = std::enable_if_t<!std::is_same_v<std::decay_t<T>, Value>>>
-  Value(T&& val) : value(std::forward<T>(val)) { }
+  template <class T,
+            class = std::enable_if_t<!std::is_same_v<std::decay_t<T>, Value>>>
+  Value(T&& val) : value(std::forward<T>(val)) {}
 
-  static Value undef(const std::string& why); // creation of undef requires a reason!
+  static Value undef(
+      const std::string& why);  // creation of undef requires a reason!
 
   [[nodiscard]] const std::string typeName() const;
   [[nodiscard]] static std::string typeName(Type type);
-  [[nodiscard]] Type type() const { return static_cast<Type>(this->value.index()); }
-  [[nodiscard]] bool isDefinedAs(const Type type) const { return this->type() == type; }
-  [[nodiscard]] bool isDefined()   const { return this->type() != Type::UNDEFINED; }
-  [[nodiscard]] bool isUndefined() const { return this->type() == Type::UNDEFINED; }
+  [[nodiscard]] Type type() const {
+    return static_cast<Type>(this->value.index());
+  }
+  [[nodiscard]] bool isDefinedAs(const Type type) const {
+    return this->type() == type;
+  }
+  [[nodiscard]] bool isDefined() const {
+    return this->type() != Type::UNDEFINED;
+  }
+  [[nodiscard]] bool isUndefined() const {
+    return this->type() == Type::UNDEFINED;
+  }
   [[nodiscard]] bool isUncheckedUndef() const;
 
   // Conversion to std::variant "BoundedType"s. const ref where appropriate.
@@ -342,7 +403,8 @@ public:
   bool getPositiveInt(unsigned int& v) const;
   [[nodiscard]] std::string toString() const;
   [[nodiscard]] std::string toEchoString() const;
-  [[nodiscard]] std::string toEchoStringNoThrow() const; //use this for warnings
+  [[nodiscard]] std::string toEchoStringNoThrow()
+      const;  // use this for warnings
   [[nodiscard]] const UndefType& toUndef() const;
   [[nodiscard]] std::string toUndefString() const;
   [[nodiscard]] std::string chrString() const;
@@ -376,25 +438,34 @@ public:
   static bool cmp_less(const Value& v1, const Value& v2);
 
   friend std::ostream& operator<<(std::ostream& stream, const Value& value) {
-    if (value.type() == Value::Type::STRING) stream << QuotedString(value.toString());
-    else stream << value.toString();
+    if (value.type() == Value::Type::STRING)
+      stream << QuotedString(value.toString());
+    else
+      stream << value.toString();
     return stream;
   }
 
-  using Variant = std::variant<UndefType, bool, double, str_utf8_wrapper, VectorType, EmbeddedVectorType, RangePtr, FunctionPtr, ObjectType>;
+  using Variant = std::variant<UndefType,
+                               bool,
+                               double,
+                               str_utf8_wrapper,
+                               VectorType,
+                               EmbeddedVectorType,
+                               RangePtr,
+                               FunctionPtr,
+                               ObjectType>;
 
   static_assert(sizeof(Value::Variant) <= 24, "Memory size of Value too big");
   [[nodiscard]] const Variant& getVariant() const { return value; }
 
-private:
+ private:
   Variant value;
 };
 
 static const size_t NOINDEX = std::string::npos;
 // The object type which ObjectType's shared_ptr points to.
 struct Value::ObjectType::ObjectObject {
-
-  class EvaluationSession *evaluation_session = nullptr;
+  class EvaluationSession* evaluation_session = nullptr;
 
   // for consistency, it is important that the
   // order of the keys+values remains the insertion
@@ -410,15 +481,16 @@ struct Value::ObjectType::ObjectObject {
   std::vector<Value> values;
 
   const size_t find(const std::string& key) {
-    if (!keys.empty() && map.empty()){
-      for ( size_t i = 0; i < keys.size(); i++) {
+    if (!keys.empty() && map.empty()) {
+      for (size_t i = 0; i < keys.size(); i++) {
         map.emplace(keys[i], i);
       }
     }
     auto it = map.find(key);
     if (it != map.end()) {
       return it->second;
-    } else return NOINDEX;
+    } else
+      return NOINDEX;
   }
 
   bool set(const std::string& key, Value value) {
@@ -428,7 +500,7 @@ struct Value::ObjectType::ObjectObject {
       values[index] = std::move(value);
     } else {
       if (!map.empty()) {
-        map[key] = keys.size();       // incremental update
+        map[key] = keys.size();  // incremental update
       }
       keys.emplace_back(key);
       values.emplace_back(std::move(value));
@@ -448,8 +520,10 @@ struct Value::ObjectType::ObjectObject {
 
   const Value& get(const std::string& key) {
     size_t index = find(key);
-    if (index != NOINDEX)return values[index];
-    else return Value::undefined;
+    if (index != NOINDEX)
+      return values[index];
+    else
+      return Value::undefined;
   }
 };
 
diff --git a/src/core/ValueMap.h b/src/core/ValueMap.h
index 226658499..b228487d0 100644
--- a/src/core/ValueMap.h
+++ b/src/core/ValueMap.h
@@ -3,39 +3,41 @@
 
 #include <cstddef>
 #include <string>
-#include <utility>
 #include <unordered_map>
+#include <utility>
 
 // Wrapper for provide *futuristic* unordered_map features,
 // plus some functions specialized to our use case.
-class ValueMap
-{
+class ValueMap {
   using map_t = std::unordered_map<std::string, Value>;
   map_t map;
 
-public:
+ public:
   using iterator = map_t::iterator;
   using const_iterator = map_t::const_iterator;
 
-// Gotta have C++20 for this beast
+  // Gotta have C++20 for this beast
   bool contains(const std::string& name) const { return map.count(name); }
 
-// Directly wrapped calls
-  const_iterator find(const std::string& name) const {  return map.find(name); }
-  const_iterator begin() const {  return map.cbegin(); }
-  const_iterator end() const {  return map.cend(); }
-  iterator begin() {  return map.begin(); }
-  iterator end() {  return map.end(); }
+  // Directly wrapped calls
+  const_iterator find(const std::string& name) const { return map.find(name); }
+  const_iterator begin() const { return map.cbegin(); }
+  const_iterator end() const { return map.cend(); }
+  iterator begin() { return map.begin(); }
+  iterator end() { return map.end(); }
   void clear() { map.clear(); }
   size_t size() const { return map.size(); }
-  template <typename ... Args> std::pair<iterator, bool> emplace(Args&&... args) {
+  template <typename... Args>
+  std::pair<iterator, bool> emplace(Args&&... args) {
     return map.emplace(std::forward<Args>(args)...);
   }
-  std::pair<iterator, bool> insert_or_assign(const std::string& name, Value&& value) {
+  std::pair<iterator, bool> insert_or_assign(const std::string& name,
+                                             Value&& value) {
     return map.insert_or_assign(name, std::move(value));
   }
 
-  // Get value by name, without possibility of default-constructing a missing name
+  // Get value by name, without possibility of default-constructing a missing
+  // name
   //   return Value::undefined if key missing
   const Value& get(const std::string& name) const {
     auto result = map.find(name);
diff --git a/src/core/builtin_functions.cc b/src/core/builtin_functions.cc
index 630e46104..42a39fc2d 100644
--- a/src/core/builtin_functions.cc
+++ b/src/core/builtin_functions.cc
@@ -24,32 +24,32 @@
  *
  */
 
-#include "core/function.h"
 #include "core/AST.h"
 #include "core/Arguments.h"
-#include "core/Expression.h"
 #include "core/Builtins.h"
-#include "utils/printutils.h"
-#include "core/UserModule.h"
-#include "utils/degree_trig.h"
+#include "core/Expression.h"
 #include "core/FreetypeRenderer.h"
 #include "core/Parameters.h"
-#include "io/import.h"
+#include "core/UserModule.h"
+#include "core/function.h"
 #include "io/fileutils.h"
+#include "io/import.h"
+#include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
-#include <utility>
-#include <cstdint>
-#include <memory>
+#include <algorithm>
 #include <cmath>
-#include <sstream>
+#include <cstdint>
 #include <ctime>
 #include <limits>
-#include <algorithm>
+#include <memory>
 #include <random>
+#include <sstream>
+#include <utility>
 #include <vector>
 
-#include "utils/boost-utils.h"
 #include <boost/format.hpp>
+#include "utils/boost-utils.h"
 // hash double
 #include "geometry/linalg.h"
 
@@ -71,33 +71,43 @@ void initialize_rng() {
   seed_val ^= distributor(deterministic_rng);
 }
 
-
-static inline bool check_arguments(const char *function_name, const Arguments& arguments, const Location& loc, unsigned int expected_count, bool warn = true)
-{
+static inline bool check_arguments(const char* function_name,
+                                   const Arguments& arguments,
+                                   const Location& loc,
+                                   unsigned int expected_count,
+                                   bool warn = true) {
   if (arguments.size() != expected_count) {
     if (warn) {
-      print_argCnt_warning(function_name, arguments.size(), STR(expected_count), loc, arguments.documentRoot());
+      print_argCnt_warning(function_name, arguments.size(), STR(expected_count),
+                           loc, arguments.documentRoot());
     }
     return false;
   }
   return true;
 }
 /* // Commented due to compiler warning of unused function.
-   static inline bool try_check_arguments(const Arguments& arguments, int expected_count)
+   static inline bool try_check_arguments(const Arguments& arguments, int
+   expected_count)
    {
-   return check_arguments(nullptr, arguments, Location::NONE, expected_count, false);
+   return check_arguments(nullptr, arguments, Location::NONE, expected_count,
+   false);
    }
  */
 template <size_t N>
-static inline bool check_arguments(const char *function_name, const Arguments& arguments, const Location& loc, const Value::Type (& expected_types) [N], bool warn = true)
-{
+static inline bool check_arguments(const char* function_name,
+                                   const Arguments& arguments,
+                                   const Location& loc,
+                                   const Value::Type (&expected_types)[N],
+                                   bool warn = true) {
   if (!check_arguments(function_name, arguments, loc, N, warn)) {
     return false;
   }
   for (size_t i = 0; i < N; i++) {
     if (arguments[i]->type() != expected_types[i]) {
       if (warn) {
-        print_argConvert_positioned_warning(function_name, "argument " + STR(i), arguments[i]->clone(), {expected_types[i]}, loc, arguments.documentRoot());
+        print_argConvert_positioned_warning(
+            function_name, "argument " + STR(i), arguments[i]->clone(),
+            {expected_types[i]}, loc, arguments.documentRoot());
       }
       return false;
     }
@@ -106,76 +116,85 @@ static inline bool check_arguments(const char *function_name, const Arguments& a
 }
 
 template <size_t N>
-static inline bool try_check_arguments(const Arguments& arguments, const Value::Type (& expected_types) [N])
-{
-  return check_arguments(nullptr, arguments, Location::NONE, expected_types, false);
+static inline bool try_check_arguments(const Arguments& arguments,
+                                       const Value::Type (&expected_types)[N]) {
+  return check_arguments(nullptr, arguments, Location::NONE, expected_types,
+                         false);
 }
 
-Value builtin_abs(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("abs", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_abs(Arguments arguments, const Location& loc) {
+  if (!check_arguments("abs", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {std::fabs(arguments[0]->toDouble())};
 }
 
-Value builtin_sign(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sign", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_sign(Arguments arguments, const Location& loc) {
+  if (!check_arguments("sign", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   double x = arguments[0]->toDouble();
   return {(x < 0) ? -1.0 : ((x > 0) ? 1.0 : 0.0)};
 }
 
-Value builtin_rands(Arguments arguments, const Location& loc)
-{
+Value builtin_rands(Arguments arguments, const Location& loc) {
   if (arguments.size() < 3 || arguments.size() > 4) {
-    print_argCnt_warning("rands", arguments.size(), "3 or 4", loc, arguments.documentRoot());
+    print_argCnt_warning("rands", arguments.size(), "3 or 4", loc,
+                         arguments.documentRoot());
     return Value::undefined.clone();
   } else if (arguments.size() == 3) {
-    if (!check_arguments("rands", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER })) {
+    if (!check_arguments(
+            "rands", arguments, loc,
+            {Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER})) {
       return Value::undefined.clone();
     }
   } else {
-    if (!check_arguments("rands", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER })) {
+    if (!check_arguments("rands", arguments, loc,
+                         {Value::Type::NUMBER, Value::Type::NUMBER,
+                          Value::Type::NUMBER, Value::Type::NUMBER})) {
       return Value::undefined.clone();
     }
   }
 
   double min = arguments[0]->toDouble();
   if (std::isinf(min) || std::isnan(min)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() range min cannot be infinite");
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "rands() range min cannot be infinite");
     min = -std::numeric_limits<double>::max() / 2;
     LOG(message_group::Warning, "resetting to %1f", min);
   }
 
   double max = arguments[1]->toDouble();
-  if (std::isinf(max)  || std::isnan(max)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() range max cannot be infinite");
+  if (std::isinf(max) || std::isnan(max)) {
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "rands() range max cannot be infinite");
     max = std::numeric_limits<double>::max() / 2;
     LOG(message_group::Warning, "resetting to %1f", max);
   }
   if (max < min) {
-    double tmp = min; min = max; max = tmp;
+    double tmp = min;
+    min = max;
+    max = tmp;
   }
 
-  double numresultsd = std::abs(arguments[2]->toDouble() );
+  double numresultsd = std::abs(arguments[2]->toDouble());
   if (std::isinf(numresultsd) || std::isnan(numresultsd)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() cannot create an infinite number of results");
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "rands() cannot create an infinite number of results");
     LOG(message_group::Warning, "resetting number of results to 1");
     numresultsd = 1;
   }
   auto numresults = boost_numeric_cast<size_t, double>(numresultsd);
 
   if (arguments.size() > 3) {
-    auto seed = static_cast<uint32_t>(hash_floating_point(arguments[3]->toDouble() ));
+    auto seed =
+        static_cast<uint32_t>(hash_floating_point(arguments[3]->toDouble()));
     deterministic_rng.seed(seed);
   }
 
   VectorType vec(arguments.session());
   vec.reserve(numresults);
-  if (min >= max) { // uniform_real_distribution doesn't allow min == max
+  if (min >= max) {  // uniform_real_distribution doesn't allow min == max
     for (size_t i = 0; i < numresults; ++i)
       vec.emplace_back(min);
   } else {
@@ -187,18 +206,23 @@ Value builtin_rands(Arguments arguments, const Location& loc)
   return std::move(vec);
 }
 
-static std::vector<double> min_max_arguments(const Arguments& arguments, const Location& loc, const char *function_name)
-{
+static std::vector<double> min_max_arguments(const Arguments& arguments,
+                                             const Location& loc,
+                                             const char* function_name) {
   std::vector<double> output;
   // preserve special handling of the first argument
   // as a template for vector processing
   if (arguments.size() == 0) {
-    print_argCnt_warning(function_name, arguments.size(), "at least 1", loc, arguments.documentRoot());
+    print_argCnt_warning(function_name, arguments.size(), "at least 1", loc,
+                         arguments.documentRoot());
     return {};
-  } else if (arguments.size() == 1 && arguments[0]->type() == Value::Type::VECTOR) {
+  } else if (arguments.size() == 1 &&
+             arguments[0]->type() == Value::Type::VECTOR) {
     const auto& elements = arguments[0]->toVector();
     if (elements.size() == 0) {
-      print_argCnt_warning(function_name, elements.size(), "at least 1 vector element", loc, arguments.documentRoot());
+      print_argCnt_warning(function_name, elements.size(),
+                           "at least 1 vector element", loc,
+                           arguments.documentRoot());
       return {};
     }
     for (size_t i = 0; i < elements.size(); i++) {
@@ -206,7 +230,9 @@ static std::vector<double> min_max_arguments(const Arguments& arguments, const L
       // 4/20/14 semantic change per discussion:
       // break on any non-number
       if (element.type() != Value::Type::NUMBER) {
-        print_argConvert_positioned_warning(function_name, "vector element " + STR(i), element, {Value::Type::NUMBER}, loc, arguments.documentRoot());
+        print_argConvert_positioned_warning(
+            function_name, "vector element " + STR(i), element,
+            {Value::Type::NUMBER}, loc, arguments.documentRoot());
         return {};
       }
       output.push_back(element.toDouble());
@@ -217,7 +243,9 @@ static std::vector<double> min_max_arguments(const Arguments& arguments, const L
       // 4/20/14 semantic change per discussion:
       // break on any non-number
       if (argument->type() != Value::Type::NUMBER) {
-        print_argConvert_positioned_warning(function_name, "argument " + STR(i), argument->clone(), {Value::Type::NUMBER}, loc, arguments.documentRoot());
+        print_argConvert_positioned_warning(
+            function_name, "argument " + STR(i), argument->clone(),
+            {Value::Type::NUMBER}, loc, arguments.documentRoot());
         return {};
       }
       output.push_back(argument->toDouble());
@@ -226,8 +254,7 @@ static std::vector<double> min_max_arguments(const Arguments& arguments, const L
   return output;
 }
 
-Value builtin_min(Arguments arguments, const Location& loc)
-{
+Value builtin_min(Arguments arguments, const Location& loc) {
   std::vector<double> values = min_max_arguments(arguments, loc, "min");
   if (values.empty()) {
     return Value::undefined.clone();
@@ -235,8 +262,7 @@ Value builtin_min(Arguments arguments, const Location& loc)
   return {*std::min_element(values.begin(), values.end())};
 }
 
-Value builtin_max(Arguments arguments, const Location& loc)
-{
+Value builtin_max(Arguments arguments, const Location& loc) {
   std::vector<double> values = min_max_arguments(arguments, loc, "max");
   if (values.empty()) {
     return Value::undefined.clone();
@@ -244,133 +270,122 @@ Value builtin_max(Arguments arguments, const Location& loc)
   return {*std::max_element(values.begin(), values.end())};
 }
 
-Value builtin_sin(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sin", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_sin(Arguments arguments, const Location& loc) {
+  if (!check_arguments("sin", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {sin_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_cos(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("cos", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_cos(Arguments arguments, const Location& loc) {
+  if (!check_arguments("cos", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {cos_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_asin(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("asin", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_asin(Arguments arguments, const Location& loc) {
+  if (!check_arguments("asin", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {asin_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_acos(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("acos", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_acos(Arguments arguments, const Location& loc) {
+  if (!check_arguments("acos", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {acos_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_tan(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("tan", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_tan(Arguments arguments, const Location& loc) {
+  if (!check_arguments("tan", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {tan_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_atan(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("atan", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_atan(Arguments arguments, const Location& loc) {
+  if (!check_arguments("atan", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {atan_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_atan2(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("atan2", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
+Value builtin_atan2(Arguments arguments, const Location& loc) {
+  if (!check_arguments("atan2", arguments, loc,
+                       {Value::Type::NUMBER, Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {atan2_degrees(arguments[0]->toDouble(), arguments[1]->toDouble())};
 }
 
-Value builtin_pow(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("pow", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
+Value builtin_pow(Arguments arguments, const Location& loc) {
+  if (!check_arguments("pow", arguments, loc,
+                       {Value::Type::NUMBER, Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {pow(arguments[0]->toDouble(), arguments[1]->toDouble())};
 }
 
-Value builtin_round(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("round", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_round(Arguments arguments, const Location& loc) {
+  if (!check_arguments("round", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {round(arguments[0]->toDouble())};
 }
 
-Value builtin_ceil(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ceil", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_ceil(Arguments arguments, const Location& loc) {
+  if (!check_arguments("ceil", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {ceil(arguments[0]->toDouble())};
 }
 
-Value builtin_floor(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("floor", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_floor(Arguments arguments, const Location& loc) {
+  if (!check_arguments("floor", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {floor(arguments[0]->toDouble())};
 }
 
-Value builtin_sqrt(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sqrt", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_sqrt(Arguments arguments, const Location& loc) {
+  if (!check_arguments("sqrt", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {sqrt(arguments[0]->toDouble())};
 }
 
-Value builtin_exp(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("exp", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_exp(Arguments arguments, const Location& loc) {
+  if (!check_arguments("exp", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {exp(arguments[0]->toDouble())};
 }
 
-Value builtin_length(Arguments arguments, const Location& loc)
-{
-  if (try_check_arguments(arguments, { Value::Type::VECTOR })) {
+Value builtin_length(Arguments arguments, const Location& loc) {
+  if (try_check_arguments(arguments, {Value::Type::VECTOR})) {
     return {double(arguments[0]->toVector().size())};
   }
-  if (!check_arguments("len", arguments, loc, { Value::Type::STRING })) {
+  if (!check_arguments("len", arguments, loc, {Value::Type::STRING})) {
     return Value::undefined.clone();
   }
-  //Unicode glyph count for the length -- rather than the string (num. of bytes) length.
-  return {double( arguments[0]->toStrUtf8Wrapper().get_utf8_strlen() )};
+  // Unicode glyph count for the length -- rather than the string (num. of
+  // bytes) length.
+  return {double(arguments[0]->toStrUtf8Wrapper().get_utf8_strlen())};
 }
 
-Value builtin_log(Arguments arguments, const Location& loc)
-{
+Value builtin_log(Arguments arguments, const Location& loc) {
   double x, y;
   if (arguments.size() == 1) {
-    if (!check_arguments("log", arguments, loc, { Value::Type::NUMBER })) {
+    if (!check_arguments("log", arguments, loc, {Value::Type::NUMBER})) {
       return Value::undefined.clone();
     }
     x = 10.0;
     y = arguments[0]->toDouble();
   } else {
-    if (!check_arguments("log", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
+    if (!check_arguments("log", arguments, loc,
+                         {Value::Type::NUMBER, Value::Type::NUMBER})) {
       return Value::undefined.clone();
     }
     x = arguments[0]->toDouble();
@@ -379,16 +394,14 @@ Value builtin_log(Arguments arguments, const Location& loc)
   return {log(y) / log(x)};
 }
 
-Value builtin_ln(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ln", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_ln(Arguments arguments, const Location& loc) {
+  if (!check_arguments("ln", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {log(arguments[0]->toDouble())};
 }
 
-Value builtin_str(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_str(Arguments arguments, const Location& /*loc*/) {
   std::ostringstream stream;
   for (const auto& argument : arguments) {
     stream << argument->toString();
@@ -396,8 +409,7 @@ Value builtin_str(Arguments arguments, const Location& /*loc*/)
   return {stream.str()};
 }
 
-Value builtin_chr(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_chr(Arguments arguments, const Location& /*loc*/) {
   std::ostringstream stream;
   for (const auto& argument : arguments) {
     stream << argument->chrString();
@@ -405,14 +417,14 @@ Value builtin_chr(Arguments arguments, const Location& /*loc*/)
   return {stream.str()};
 }
 
-Value builtin_ord(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ord", arguments, loc, { Value::Type::STRING })) {
+Value builtin_ord(Arguments arguments, const Location& loc) {
+  if (!check_arguments("ord", arguments, loc, {Value::Type::STRING})) {
     return Value::undefined.clone();
   }
   const str_utf8_wrapper& arg_str = arguments[0]->toStrUtf8Wrapper();
   if (!arg_str.utf8_validate()) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "ord() argument '%1$s' is not a valid utf8 string", arg_str.toString());
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "ord() argument '%1$s' is not a valid utf8 string", arg_str.toString());
     return Value::undefined.clone();
   }
 
@@ -423,13 +435,13 @@ Value builtin_ord(Arguments arguments, const Location& loc)
   return {(double)arg_str.get_utf8_char()};
 }
 
-Value builtin_concat(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_concat(Arguments arguments, const Location& /*loc*/) {
   VectorType result(arguments.session());
   result.reserve(arguments.size());
   for (auto& argument : arguments) {
     if (argument->type() == Value::Type::VECTOR) {
-      result.emplace_back(EmbeddedVectorType(std::move(argument->toVectorNonConst())));
+      result.emplace_back(
+          EmbeddedVectorType(std::move(argument->toVectorNonConst())));
     } else {
       result.emplace_back(std::move(argument.value));
     }
@@ -437,91 +449,96 @@ Value builtin_concat(Arguments arguments, const Location& /*loc*/)
   return std::move(result);
 }
 
-#define OBJECT_HELP "In an unnamed list, entries must be [key,value] to set or [key] to delete. The key must be <string>."
-
-static std::string builtin_object_unnamed(ObjectType& result, const Value& value, int arg_index) {
+#define OBJECT_HELP                                                     \
+  "In an unnamed list, entries must be [key,value] to set or [key] to " \
+  "delete. The key must be <string>."
 
+static std::string builtin_object_unnamed(ObjectType& result,
+                                          const Value& value,
+                                          int arg_index) {
   std::string prior_args = "Argument " + std::to_string(arg_index) + " ";
 
-  switch (value.type()){
-  case Value::Type::OBJECT: {
-    const auto& obj = value.toObject();
-    for (const auto& key : obj.keys()) {
-      result.set(key, obj.get(key).clone());
-    }
-    return "";
-  }
-  case Value::Type::VECTOR: {
-
-    const VectorType& vector = value.toVector();
-    int element = 0;
-    for (const auto& member : vector) {
-      std::string prior_entries = "Element " + std::to_string(element++) + " ";
-
-      if (member.type() != Value::Type::VECTOR) {
-        return str(boost::format(
-                     "object( %s[%s<%s>] ) Entry type is not a list, it is <%s>. " OBJECT_HELP)
-                   % prior_args.c_str()
-                   % prior_entries.c_str()
-                   % Value::typeName(member.type())
-                   % Value::typeName(member.type()));
+  switch (value.type()) {
+    case Value::Type::OBJECT: {
+      const auto& obj = value.toObject();
+      for (const auto& key : obj.keys()) {
+        result.set(key, obj.get(key).clone());
       }
-
-      const auto& entry = member.toVector();
-      switch (entry.size()){
-      case 2:
-      case 1: {
-        if (entry[0].type() != Value::Type::STRING) {
-          const char *es = entry.size() == 1 ? "" : ",value";
-          return str(boost::format("object(%s[%s[<%s>%s]]) The key of the entry is not <string> but <%s>. " OBJECT_HELP)
-                     % prior_args
-                     % prior_entries
-                     % Value::typeName(entry[0].type())
-                     % es
-                     % Value::typeName(entry[0].type()));
-        }
-        const auto& key = entry[0].toString();
-        if (entry.size() == 1) {
-          result.del(key);
-        } else {
-          result.set(key, entry[1].clone());
+      return "";
+    }
+    case Value::Type::VECTOR: {
+      const VectorType& vector = value.toVector();
+      int element = 0;
+      for (const auto& member : vector) {
+        std::string prior_entries =
+            "Element " + std::to_string(element++) + " ";
+
+        if (member.type() != Value::Type::VECTOR) {
+          return str(boost::format("object( %s[%s<%s>] ) Entry type is not a "
+                                   "list, it is <%s>. " OBJECT_HELP) %
+                     prior_args.c_str() % prior_entries.c_str() %
+                     Value::typeName(member.type()) %
+                     Value::typeName(member.type()));
         }
-        break;
-      };
 
-      case 0: return str(boost::format("object(%s[%s[]]) Entry is empty. " OBJECT_HELP)
-                         % prior_args.c_str()
-                         % prior_entries.c_str());
-
-      default: return str(boost::format("object(%s[%s[...]]) Entry length is %d, must be 1 [key] or 2 [key,value]. " OBJECT_HELP)
-                          % prior_args
-                          % prior_entries
-                          % entry.size());
+        const auto& entry = member.toVector();
+        switch (entry.size()) {
+          case 2:
+          case 1: {
+            if (entry[0].type() != Value::Type::STRING) {
+              const char* es = entry.size() == 1 ? "" : ",value";
+              return str(
+                  boost::format("object(%s[%s[<%s>%s]]) The key of the entry "
+                                "is not <string> but <%s>. " OBJECT_HELP) %
+                  prior_args % prior_entries %
+                  Value::typeName(entry[0].type()) % es %
+                  Value::typeName(entry[0].type()));
+            }
+            const auto& key = entry[0].toString();
+            if (entry.size() == 1) {
+              result.del(key);
+            } else {
+              result.set(key, entry[1].clone());
+            }
+            break;
+          };
+
+          case 0:
+            return str(
+                boost::format("object(%s[%s[]]) Entry is empty. " OBJECT_HELP) %
+                prior_args.c_str() % prior_entries.c_str());
+
+          default:
+            return str(
+                boost::format("object(%s[%s[...]]) Entry length is %d, must be "
+                              "1 [key] or 2 [key,value]. " OBJECT_HELP) %
+                prior_args % prior_entries % entry.size());
+        }
       }
+      return "";
     }
-    return "";
-  }
-  default:
-    return str(boost::format("object(%s<%s>) An unnamed argument must be either <object> or <list>, it is <%s>. ")
-               % prior_args
-               % Value::typeName(value.type())
-               % Value::typeName(value.type()));
+    default:
+      return str(boost::format("object(%s<%s>) An unnamed argument must be "
+                               "either <object> or <list>, it is <%s>. ") %
+                 prior_args % Value::typeName(value.type()) %
+                 Value::typeName(value.type()));
   }
 }
 /**
     The builtin_object function takes either a named or unnamed argument.
-    A named argument is assigned with name=value to the result object. An unnamed
-    argument is either an object or a vector. An object will have its
+    A named argument is assigned with name=value to the result object. An
+   unnamed argument is either an object or a vector. An object will have its
     entries copied, potentially overwriting earlier entries. A vector
     must be of vectors. It can contain as member vectors:
 
         ["k"]       deletes key k
         ["k", v]    sets key k=v
 
-    Any other values are incorrect and will return undef and be logged as warning.
+    Any other values are incorrect and will return undef and be logged as
+   warning.
  */
-Value builtin_object(const std::shared_ptr<const Context>& context, const FunctionCall *call)
-{
+Value builtin_object(const std::shared_ptr<const Context>& context,
+                     const FunctionCall* call) {
   ObjectType result(context->session());
   int n = 0;
   for (const auto& argument : call->arguments) {
@@ -529,7 +546,8 @@ Value builtin_object(const std::shared_ptr<const Context>& context, const Functi
     if (argument->getName().empty()) {
       const auto error = builtin_object_unnamed(result, value, n);
       if (!error.empty()) {
-        LOG(message_group::Warning, call->location(), context->documentRoot(), error.c_str());
+        LOG(message_group::Warning, call->location(), context->documentRoot(),
+            error.c_str());
         return Value::undef(error);
       }
     } else {
@@ -540,9 +558,9 @@ Value builtin_object(const std::shared_ptr<const Context>& context, const Functi
   return result;
 }
 
-Value builtin_has_key(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("has_key", arguments, loc, { Value::Type::OBJECT, Value::Type::STRING })) {
+Value builtin_has_key(Arguments arguments, const Location& loc) {
+  if (!check_arguments("has_key", arguments, loc,
+                       {Value::Type::OBJECT, Value::Type::STRING})) {
     return Value::undefined.clone();
   }
   const auto& obj = arguments[0]->toObject();
@@ -550,14 +568,16 @@ Value builtin_has_key(Arguments arguments, const Location& loc)
   return obj.contains(key);
 }
 
-Value builtin_lookup(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("lookup", arguments, loc, { Value::Type::NUMBER, Value::Type::VECTOR })) {
+Value builtin_lookup(Arguments arguments, const Location& loc) {
+  if (!check_arguments("lookup", arguments, loc,
+                       {Value::Type::NUMBER, Value::Type::VECTOR})) {
     return Value::undefined.clone();
   }
   double p = arguments[0]->toDouble();
   if (!std::isfinite(p)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "lookup(%1$s, ...) first argument is not a number", arguments[0]->toEchoStringNoThrow());
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "lookup(%1$s, ...) first argument is not a number",
+        arguments[0]->toEchoStringNoThrow());
     return Value::undefined.clone();
   }
 
@@ -585,10 +605,12 @@ Value builtin_lookup(Arguments arguments, const Location& loc)
       }
     }
   }
-  if (p <= low_p) return {high_v};
-  if (p >= high_p) return {low_v};
+  if (p <= low_p)
+    return {high_v};
+  if (p >= high_p)
+    return {low_v};
   double f = (p - low_p) / (high_p - low_p);
-  return {high_v *f + low_v * (1 - f)};
+  return {high_v * f + low_v * (1 - f)};
 }
 
 /*
@@ -619,36 +641,43 @@ Value builtin_lookup(Arguments arguments, const Location& loc)
         - returns [0]
     search("e","abcdabcd",1);
         - returns []
-    search("a",[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ]);
+    search("a",[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ]);
         - returns [0,4]
 
    Search on different column; return Index values:
-    search(3,[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",3] ], 0, 1);
+    search(3,[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",3] ], 0,
+   1);
         - returns [0,8]
 
    Search on list of values:
     Return all matches per search vector element:
-      search("abc",[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ], 0);
+      search("abc",[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ],
+   0);
         - returns [[0,4],[1,5],[2,6]]
 
     Return first match per search vector element; special case return vector:
-      search("abc",[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ], 1);
+      search("abc",[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ],
+   1);
         - returns [0,1,2]
 
     Return first two matches per search vector element; vector of vectors:
-      search("abce",[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ], 2);
+      search("abce",[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ],
+   2);
         - returns [[0,4],[1,5],[2,6],[8]]
 
  */
 
-static VectorType search(
-  const str_utf8_wrapper& find,
-  const str_utf8_wrapper& table,
-  unsigned int num_returns_per_match,
-  EvaluationSession *session
-  ) {
+static VectorType search(const str_utf8_wrapper& find,
+                         const str_utf8_wrapper& table,
+                         unsigned int num_returns_per_match,
+                         EvaluationSession* session) {
   VectorType returnvec(session);
-  //Unicode glyph count for the length
+  // Unicode glyph count for the length
   size_t findThisSize = find.get_utf8_strlen();
   size_t searchTableSize = table.get_utf8_strlen();
   for (size_t i = 0; i < findThisSize; ++i) {
@@ -657,7 +686,8 @@ static VectorType search(
     const auto ft = find[i];
     for (size_t j = 0; j < searchTableSize; ++j) {
       const auto st = table[j];
-      if (!ft.empty() && !st.empty() && ft.get_utf8_char() == st.get_utf8_char()) {
+      if (!ft.empty() && !st.empty() &&
+          ft.get_utf8_char() == st.get_utf8_char()) {
         matchCount++;
         if (num_returns_per_match == 1) {
           returnvec.emplace_back(double(j));
@@ -677,16 +707,14 @@ static VectorType search(
   return returnvec;
 }
 
-static VectorType search(
-  const str_utf8_wrapper& find,
-  const VectorType& table,
-  unsigned int num_returns_per_match,
-  unsigned int index_col_num,
-  const Location& loc,
-  EvaluationSession *session
-  ) {
+static VectorType search(const str_utf8_wrapper& find,
+                         const VectorType& table,
+                         unsigned int num_returns_per_match,
+                         unsigned int index_col_num,
+                         const Location& loc,
+                         EvaluationSession* session) {
   VectorType returnvec(session);
-  //Unicode glyph count for the length
+  // Unicode glyph count for the length
   unsigned int findThisSize = find.get_utf8_strlen();
   unsigned int searchTableSize = table.size();
   for (size_t i = 0; i < findThisSize; ++i) {
@@ -696,10 +724,15 @@ static VectorType search(
     for (size_t j = 0; j < searchTableSize; ++j) {
       const auto& entryVec = table[j].toVector();
       if (entryVec.size() <= index_col_num) {
-        LOG(message_group::Warning, loc, session->documentRoot(), "Invalid entry in search vector at index %1$d, required number of values in the entry: %2$d. Invalid entry: %3$s", j, (index_col_num + 1), table[j].toEchoStringNoThrow());
+        LOG(message_group::Warning, loc, session->documentRoot(),
+            "Invalid entry in search vector at index %1$d, required number of "
+            "values in the entry: %2$d. Invalid entry: %3$s",
+            j, (index_col_num + 1), table[j].toEchoStringNoThrow());
         return {session};
       }
-      if (!ft.empty() && ft.get_utf8_char() == entryVec[index_col_num].toStrUtf8Wrapper().get_utf8_char()) {
+      if (!ft.empty() &&
+          ft.get_utf8_char() ==
+              entryVec[index_col_num].toStrUtf8Wrapper().get_utf8_char()) {
         matchCount++;
         if (num_returns_per_match == 1) {
           returnvec.emplace_back(double(j));
@@ -719,17 +752,19 @@ static VectorType search(
   return returnvec;
 }
 
-Value builtin_search(Arguments arguments, const Location& loc)
-{
+Value builtin_search(Arguments arguments, const Location& loc) {
   if (arguments.size() < 2 || arguments.size() > 4) {
-    print_argCnt_warning("search", arguments.size(), "between 2 and 4", loc, arguments.documentRoot());
+    print_argCnt_warning("search", arguments.size(), "between 2 and 4", loc,
+                         arguments.documentRoot());
     return Value::undefined.clone();
   }
 
   const Value& findThis = arguments[0].value;
   const Value& searchTable = arguments[1].value;
-  unsigned int num_returns_per_match = (arguments.size() > 2) ? (unsigned int)arguments[2]->toDouble() : 1;
-  unsigned int index_col_num = (arguments.size() > 3) ? (unsigned int)arguments[3]->toDouble() : 0;
+  unsigned int num_returns_per_match =
+      (arguments.size() > 2) ? (unsigned int)arguments[2]->toDouble() : 1;
+  unsigned int index_col_num =
+      (arguments.size() > 3) ? (unsigned int)arguments[3]->toDouble() : 0;
 
   VectorType returnvec(arguments.session());
 
@@ -742,15 +777,20 @@ Value builtin_search(Arguments arguments, const Location& loc)
            (findThis == search_element.toVector()[index_col_num]).toBool())) {
         returnvec.emplace_back(double(j));
         matchCount++;
-        if (num_returns_per_match != 0 && matchCount >= num_returns_per_match) break;
+        if (num_returns_per_match != 0 && matchCount >= num_returns_per_match)
+          break;
       }
       ++j;
     }
   } else if (findThis.type() == Value::Type::STRING) {
     if (searchTable.type() == Value::Type::STRING) {
-      returnvec = search(findThis.toStrUtf8Wrapper(), searchTable.toStrUtf8Wrapper(), num_returns_per_match, arguments.session());
+      returnvec =
+          search(findThis.toStrUtf8Wrapper(), searchTable.toStrUtf8Wrapper(),
+                 num_returns_per_match, arguments.session());
     } else {
-      returnvec = search(findThis.toStrUtf8Wrapper(), searchTable.toVector(), num_returns_per_match, index_col_num, loc, arguments.session());
+      returnvec = search(findThis.toStrUtf8Wrapper(), searchTable.toVector(),
+                         num_returns_per_match, index_col_num, loc,
+                         arguments.session());
     }
   } else if (findThis.type() == Value::Type::VECTOR) {
     const auto& findVec = findThis.toVector();
@@ -762,7 +802,8 @@ Value builtin_search(Arguments arguments, const Location& loc)
       for (const auto& search_element : searchTable.toVector()) {
         if ((index_col_num == 0 && (find_value == search_element).toBool()) ||
             (index_col_num < search_element.toVector().size() &&
-             (find_value == search_element.toVector()[index_col_num]).toBool())) {
+             (find_value == search_element.toVector()[index_col_num])
+                 .toBool())) {
           matchCount++;
           if (num_returns_per_match == 1) {
             returnvec.emplace_back(double(j));
@@ -770,13 +811,13 @@ Value builtin_search(Arguments arguments, const Location& loc)
           } else {
             resultvec.emplace_back(double(j));
           }
-          if (num_returns_per_match > 1 && matchCount >= num_returns_per_match) break;
+          if (num_returns_per_match > 1 && matchCount >= num_returns_per_match)
+            break;
         }
         ++j;
       }
       if ((num_returns_per_match == 1 && matchCount == 0) ||
-          num_returns_per_match == 0 ||
-          num_returns_per_match > 1) {
+          num_returns_per_match == 0 || num_returns_per_match > 1) {
         returnvec.emplace_back(std::move(resultvec));
       }
     }
@@ -786,11 +827,10 @@ Value builtin_search(Arguments arguments, const Location& loc)
   return std::move(returnvec);
 }
 
-#define QUOTE(x__) # x__
+#define QUOTE(x__) #x__
 #define QUOTED(x__) QUOTE(x__)
 
-Value builtin_version(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_version(Arguments arguments, const Location& /*loc*/) {
   VectorType vec(arguments.session());
   vec.emplace_back(double(OPENSCAD_YEAR));
   vec.emplace_back(double(OPENSCAD_MONTH));
@@ -800,9 +840,10 @@ Value builtin_version(Arguments arguments, const Location& /*loc*/)
   return std::move(vec);
 }
 
-Value builtin_version_num(Arguments arguments, const Location& loc)
-{
-  Value val = (arguments.size() == 0) ? builtin_version(std::move(arguments), loc) : std::move(arguments[0].value);
+Value builtin_version_num(Arguments arguments, const Location& loc) {
+  Value val = (arguments.size() == 0)
+                  ? builtin_version(std::move(arguments), loc)
+                  : std::move(arguments[0].value);
   double y, m, d;
   if (!val.getVec3(y, m, d, 0)) {
     return Value::undefined.clone();
@@ -810,12 +851,12 @@ Value builtin_version_num(Arguments arguments, const Location& loc)
   return {y * 10000 + m * 100 + d};
 }
 
-Value builtin_parent_module(Arguments arguments, const Location& loc)
-{
+Value builtin_parent_module(Arguments arguments, const Location& loc) {
   double d;
   if (arguments.size() == 0) {
     d = 1;
-  } else if (!check_arguments("parent_module", arguments, loc, { Value::Type::NUMBER })) {
+  } else if (!check_arguments("parent_module", arguments, loc,
+                              {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   } else {
     d = arguments[0]->toDouble();
@@ -824,19 +865,22 @@ Value builtin_parent_module(Arguments arguments, const Location& loc)
   int n = trunc(d);
   int s = UserModule::stack_size();
   if (n < 0) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Negative parent module index (%1$d) not allowed", n);
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "Negative parent module index (%1$d) not allowed", n);
     return Value::undefined.clone();
   }
   if (n >= s) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Parent module index (%1$d) greater than the number of modules on the stack", n);
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "Parent module index (%1$d) greater than the number of modules on the "
+        "stack",
+        n);
     return Value::undefined.clone();
   }
   return {UserModule::stack_element(s - 1 - n)};
 }
 
-Value builtin_norm(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("norm", arguments, loc, { Value::Type::VECTOR })) {
+Value builtin_norm(Arguments arguments, const Location& loc) {
+  if (!check_arguments("norm", arguments, loc, {Value::Type::VECTOR})) {
     return Value::undefined.clone();
   }
   double sum = 0;
@@ -845,60 +889,68 @@ Value builtin_norm(Arguments arguments, const Location& loc)
       double x = v.toDouble();
       sum += x * x;
     } else {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Incorrect arguments to norm()");
+      LOG(message_group::Warning, loc, arguments.documentRoot(),
+          "Incorrect arguments to norm()");
       return Value::undefined.clone();
     }
   }
   return {sqrt(sum)};
 }
 
-Value builtin_cross(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("cross", arguments, loc, { Value::Type::VECTOR, Value::Type::VECTOR })) {
+Value builtin_cross(Arguments arguments, const Location& loc) {
+  if (!check_arguments("cross", arguments, loc,
+                       {Value::Type::VECTOR, Value::Type::VECTOR})) {
     return Value::undefined.clone();
   }
 
   const auto& v0 = arguments[0]->toVector();
   const auto& v1 = arguments[1]->toVector();
   if ((v0.size() == 2) && (v1.size() == 2)) {
-    return {v0[0].toDouble() * v1[1].toDouble() - v0[1].toDouble() * v1[0].toDouble()};
+    return {v0[0].toDouble() * v1[1].toDouble() -
+            v0[1].toDouble() * v1[0].toDouble()};
   }
 
   if ((v0.size() != 3) || (v1.size() != 3)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid vector size of parameter for cross()");
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "Invalid vector size of parameter for cross()");
     return Value::undefined.clone();
   }
   for (unsigned int a = 0; a < 3; ++a) {
-    if ((v0[a].type() != Value::Type::NUMBER) || (v1[a].type() != Value::Type::NUMBER)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value in parameter vector for cross()");
+    if ((v0[a].type() != Value::Type::NUMBER) ||
+        (v1[a].type() != Value::Type::NUMBER)) {
+      LOG(message_group::Warning, loc, arguments.documentRoot(),
+          "Invalid value in parameter vector for cross()");
       return Value::undefined.clone();
     }
     double d0 = v0[a].toDouble();
     double d1 = v1[a].toDouble();
     if (std::isnan(d0) || std::isnan(d1)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value (NaN) in parameter vector for cross()");
+      LOG(message_group::Warning, loc, arguments.documentRoot(),
+          "Invalid value (NaN) in parameter vector for cross()");
       return Value::undefined.clone();
     }
     if (std::isinf(d0) || std::isinf(d1)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value (INF) in parameter vector for cross()");
+      LOG(message_group::Warning, loc, arguments.documentRoot(),
+          "Invalid value (INF) in parameter vector for cross()");
       return Value::undefined.clone();
     }
   }
 
-  double x = v0[1].toDouble() * v1[2].toDouble() - v0[2].toDouble() * v1[1].toDouble();
-  double y = v0[2].toDouble() * v1[0].toDouble() - v0[0].toDouble() * v1[2].toDouble();
-  double z = v0[0].toDouble() * v1[1].toDouble() - v0[1].toDouble() * v1[0].toDouble();
+  double x =
+      v0[1].toDouble() * v1[2].toDouble() - v0[2].toDouble() * v1[1].toDouble();
+  double y =
+      v0[2].toDouble() * v1[0].toDouble() - v0[0].toDouble() * v1[2].toDouble();
+  double z =
+      v0[0].toDouble() * v1[1].toDouble() - v0[1].toDouble() * v1[0].toDouble();
 
   return VectorType(arguments.session(), x, y, z);
 }
 
-Value builtin_textmetrics(Arguments arguments, const Location& loc)
-{
-  auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), loc,
-                                            { "text", "size", "font" },
-                                            { "direction", "language", "script", "halign", "valign", "spacing" }
-                                            );
+Value builtin_textmetrics(Arguments arguments, const Location& loc) {
+  auto* session = arguments.session();
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), loc, {"text", "size", "font"},
+      {"direction", "language", "script", "halign", "valign", "spacing"});
   parameters.set_caller("textmetrics");
 
   FreetypeRenderer::Params ftparams;
@@ -946,12 +998,10 @@ Value builtin_textmetrics(Arguments arguments, const Location& loc)
   return std::move(text_metrics);
 }
 
-Value builtin_fontmetrics(Arguments arguments, const Location& loc)
-{
-  auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), loc,
-                                            { "size", "font" }
-                                            );
+Value builtin_fontmetrics(Arguments arguments, const Location& loc) {
+  auto* session = arguments.session();
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), loc, {"size", "font"});
   parameters.set_caller("fontmetrics");
 
   FreetypeRenderer::Params ftparams;
@@ -986,13 +1036,15 @@ Value builtin_fontmetrics(Arguments arguments, const Location& loc)
   return std::move(font_metrics);
 }
 
-Value builtin_is_undef(const std::shared_ptr<const Context>& context, const FunctionCall *call)
-{
+Value builtin_is_undef(const std::shared_ptr<const Context>& context,
+                       const FunctionCall* call) {
   if (call->arguments.size() != 1) {
-    print_argCnt_warning("is_undef", call->arguments.size(), "1", call->location(), context->documentRoot());
+    print_argCnt_warning("is_undef", call->arguments.size(), "1",
+                         call->location(), context->documentRoot());
     return Value::undefined.clone();
   }
-  if (auto lookup = std::dynamic_pointer_cast<Lookup>(call->arguments[0]->getExpr())) {
+  if (auto lookup =
+          std::dynamic_pointer_cast<Lookup>(call->arguments[0]->getExpr())) {
     auto result = context->try_lookup_variable(lookup->get_name());
     return !result || result->isUndefined();
   } else {
@@ -1000,293 +1052,302 @@ Value builtin_is_undef(const std::shared_ptr<const Context>& context, const Func
   }
 }
 
-Value builtin_is_list(Arguments arguments, const Location& loc)
-{
+Value builtin_is_list(Arguments arguments, const Location& loc) {
   if (!check_arguments("is_list", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::VECTOR)};
 }
 
-Value builtin_is_num(Arguments arguments, const Location& loc)
-{
+Value builtin_is_num(Arguments arguments, const Location& loc) {
   if (!check_arguments("is_num", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
-  return {arguments[0]->isDefinedAs(Value::Type::NUMBER) && !std::isnan(arguments[0]->toDouble())};
+  return {arguments[0]->isDefinedAs(Value::Type::NUMBER) &&
+          !std::isnan(arguments[0]->toDouble())};
 }
 
-Value builtin_is_bool(Arguments arguments, const Location& loc)
-{
+Value builtin_is_bool(Arguments arguments, const Location& loc) {
   if (!check_arguments("is_bool", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::BOOL)};
 }
 
-Value builtin_is_string(Arguments arguments, const Location& loc)
-{
+Value builtin_is_string(Arguments arguments, const Location& loc) {
   if (!check_arguments("is_string", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::STRING)};
 }
 
-Value builtin_is_function(Arguments arguments, const Location& loc)
-{
+Value builtin_is_function(Arguments arguments, const Location& loc) {
   if (!check_arguments("is_function", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::FUNCTION)};
 }
 
-Value builtin_is_object(Arguments arguments, const Location& loc)
-{
+Value builtin_is_object(Arguments arguments, const Location& loc) {
   if (!check_arguments("is_object", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::OBJECT)};
 }
 
-Value builtin_import(Arguments arguments, const Location& loc)
-{
+Value builtin_import(Arguments arguments, const Location& loc) {
   auto session = arguments.session();
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file"});
+  const Parameters parameters =
+      Parameters::parse(std::move(arguments), loc, {}, {"file"});
   std::string raw_filename = parameters.get("file", "");
-  std::string file = lookup_file(raw_filename, loc.filePath().parent_path().string(), parameters.documentRoot());
+  std::string file =
+      lookup_file(raw_filename, loc.filePath().parent_path().string(),
+                  parameters.documentRoot());
   return import_json(file, session, loc);
 }
 
-void register_builtin_functions()
-{
+void register_builtin_functions() {
   Builtins::init("abs", new BuiltinFunction(&builtin_abs),
-  {
-    "abs(number) -> number",
-  });
+                 {
+                     "abs(number) -> number",
+                 });
 
   Builtins::init("sign", new BuiltinFunction(&builtin_sign),
-  {
-    "sign(number) -> -1, 0 or 1",
-  });
+                 {
+                     "sign(number) -> -1, 0 or 1",
+                 });
 
   Builtins::init("rands", new BuiltinFunction(&builtin_rands),
-  {
-    "rands(min, max, num_results) -> vector",
-    "rands(min, max, num_results, seed) -> vector",
-  });
+                 {
+                     "rands(min, max, num_results) -> vector",
+                     "rands(min, max, num_results, seed) -> vector",
+                 });
 
   Builtins::init("min", new BuiltinFunction(&builtin_min),
-  {
-    "min(number, number, ...) -> number",
-    "min(vector) -> number",
-  });
+                 {
+                     "min(number, number, ...) -> number",
+                     "min(vector) -> number",
+                 });
 
   Builtins::init("max", new BuiltinFunction(&builtin_max),
-  {
-    "max(number, number, ...) -> number",
-    "max(vector) -> number",
-  });
+                 {
+                     "max(number, number, ...) -> number",
+                     "max(vector) -> number",
+                 });
 
   Builtins::init("sin", new BuiltinFunction(&builtin_sin),
-  {
-    "sin(degrees) -> number",
-  });
+                 {
+                     "sin(degrees) -> number",
+                 });
 
   Builtins::init("cos", new BuiltinFunction(&builtin_cos),
-  {
-    "cos(degrees) -> number",
-  });
+                 {
+                     "cos(degrees) -> number",
+                 });
 
   Builtins::init("asin", new BuiltinFunction(&builtin_asin),
-  {
-    "asin(number) -> degrees",
-  });
+                 {
+                     "asin(number) -> degrees",
+                 });
 
   Builtins::init("acos", new BuiltinFunction(&builtin_acos),
-  {
-    "acos(number) -> degrees",
-  });
+                 {
+                     "acos(number) -> degrees",
+                 });
 
   Builtins::init("tan", new BuiltinFunction(&builtin_tan),
-  {
-    "tan(degrees) -> number",
-  });
+                 {
+                     "tan(degrees) -> number",
+                 });
 
   Builtins::init("atan", new BuiltinFunction(&builtin_atan),
-  {
-    "atan(number) -> degrees",
-  });
+                 {
+                     "atan(number) -> degrees",
+                 });
 
   Builtins::init("atan2", new BuiltinFunction(&builtin_atan2),
-  {
-    "atan2(number, number) -> degrees",
-  });
+                 {
+                     "atan2(number, number) -> degrees",
+                 });
 
   Builtins::init("round", new BuiltinFunction(&builtin_round),
-  {
-    "round(number) -> number",
-  });
+                 {
+                     "round(number) -> number",
+                 });
 
   Builtins::init("ceil", new BuiltinFunction(&builtin_ceil),
-  {
-    "ceil(number) -> number",
-  });
+                 {
+                     "ceil(number) -> number",
+                 });
 
   Builtins::init("floor", new BuiltinFunction(&builtin_floor),
-  {
-    "floor(number) -> number",
-  });
+                 {
+                     "floor(number) -> number",
+                 });
 
   Builtins::init("pow", new BuiltinFunction(&builtin_pow),
-  {
-    "pow(base, exponent) -> number",
-  });
+                 {
+                     "pow(base, exponent) -> number",
+                 });
 
   Builtins::init("sqrt", new BuiltinFunction(&builtin_sqrt),
-  {
-    "sqrt(number) -> number",
-  });
+                 {
+                     "sqrt(number) -> number",
+                 });
 
   Builtins::init("exp", new BuiltinFunction(&builtin_exp),
-  {
-    "exp(number) -> number",
-  });
+                 {
+                     "exp(number) -> number",
+                 });
 
   Builtins::init("len", new BuiltinFunction(&builtin_length),
-  {
-    "len(string) -> number",
-    "len(vector) -> number",
-  });
+                 {
+                     "len(string) -> number",
+                     "len(vector) -> number",
+                 });
 
   Builtins::init("log", new BuiltinFunction(&builtin_log),
-  {
-    "log(number) -> number",
-  });
+                 {
+                     "log(number) -> number",
+                 });
 
   Builtins::init("ln", new BuiltinFunction(&builtin_ln),
-  {
-    "ln(number) -> number",
-  });
+                 {
+                     "ln(number) -> number",
+                 });
 
   Builtins::init("str", new BuiltinFunction(&builtin_str),
-  {
-    "str(number or string, ...) -> string",
-  });
+                 {
+                     "str(number or string, ...) -> string",
+                 });
 
   Builtins::init("chr", new BuiltinFunction(&builtin_chr),
-  {
-    "chr(number) -> string",
-    "chr(vector) -> string",
-    "chr(range) -> string",
-  });
-
-  Builtins::init("textmetrics",
-                 new BuiltinFunction(&builtin_textmetrics,
-                                     &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "textmetrics(text, size, font, direction, language, script, halign, valign, spacing) -> object",
-  });
-
-  Builtins::init("fontmetrics",
-                 new BuiltinFunction(&builtin_fontmetrics,
-                                     &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "fontmetrics(size, font) -> object",
-  });
+                 {
+                     "chr(number) -> string",
+                     "chr(vector) -> string",
+                     "chr(range) -> string",
+                 });
+
+  Builtins::init(
+      "textmetrics",
+      new BuiltinFunction(&builtin_textmetrics,
+                          &Feature::ExperimentalTextMetricsFunctions),
+      {
+          "textmetrics(text, size, font, direction, language, script, halign, "
+          "valign, spacing) -> object",
+      });
+
+  Builtins::init(
+      "fontmetrics",
+      new BuiltinFunction(&builtin_fontmetrics,
+                          &Feature::ExperimentalTextMetricsFunctions),
+      {
+          "fontmetrics(size, font) -> object",
+      });
 
   Builtins::init("ord", new BuiltinFunction(&builtin_ord),
-  {
-    "ord(string) -> number",
-  });
+                 {
+                     "ord(string) -> number",
+                 });
 
   Builtins::init("concat", new BuiltinFunction(&builtin_concat),
-  {
-    "concat(number or string or vector, ...) -> vector",
-  });
+                 {
+                     "concat(number or string or vector, ...) -> vector",
+                 });
 
   Builtins::init("lookup", new BuiltinFunction(&builtin_lookup),
-  {
-    "lookup(key, <key,value> vector) -> value",
-  });
+                 {
+                     "lookup(key, <key,value> vector) -> value",
+                 });
 
   Builtins::init("search", new BuiltinFunction(&builtin_search),
-  {
-    "search(string , string or vector [, num_returns_per_match [, index_col_num ] ] ) -> vector",
-  });
+                 {
+                     "search(string , string or vector [, "
+                     "num_returns_per_match [, index_col_num ] ] ) -> vector",
+                 });
 
   Builtins::init("version", new BuiltinFunction(&builtin_version),
-  {
-    "version() -> vector",
-  });
+                 {
+                     "version() -> vector",
+                 });
 
   Builtins::init("version_num", new BuiltinFunction(&builtin_version_num),
-  {
-    "version_num() -> number",
-  });
+                 {
+                     "version_num() -> number",
+                 });
 
   Builtins::init("norm", new BuiltinFunction(&builtin_norm),
-  {
-    "norm(vector) -> number",
-  });
+                 {
+                     "norm(vector) -> number",
+                 });
 
   Builtins::init("cross", new BuiltinFunction(&builtin_cross),
-  {
-    "cross(vector, vector) -> vector",
-  });
+                 {
+                     "cross(vector, vector) -> vector",
+                 });
 
   Builtins::init("parent_module", new BuiltinFunction(&builtin_parent_module),
-  {
-    "parent_module(number) -> string",
-  });
+                 {
+                     "parent_module(number) -> string",
+                 });
 
   Builtins::init("is_undef", new BuiltinFunction(&builtin_is_undef),
-  {
-    "is_undef(arg) -> boolean",
-  });
+                 {
+                     "is_undef(arg) -> boolean",
+                 });
 
   Builtins::init("is_list", new BuiltinFunction(&builtin_is_list),
-  {
-    "is_list(arg) -> boolean",
-  });
+                 {
+                     "is_list(arg) -> boolean",
+                 });
 
   Builtins::init("is_num", new BuiltinFunction(&builtin_is_num),
-  {
-    "is_num(arg) -> boolean",
-  });
+                 {
+                     "is_num(arg) -> boolean",
+                 });
 
   Builtins::init("is_bool", new BuiltinFunction(&builtin_is_bool),
-  {
-    "is_bool(arg) -> boolean",
-  });
+                 {
+                     "is_bool(arg) -> boolean",
+                 });
 
   Builtins::init("is_string", new BuiltinFunction(&builtin_is_string),
-  {
-    "is_string(arg) -> boolean",
-  });
+                 {
+                     "is_string(arg) -> boolean",
+                 });
 
   Builtins::init("is_function", new BuiltinFunction(&builtin_is_function),
-  {
-    "is_function(arg) -> boolean",
-  });
-
-  Builtins::init("is_object", new BuiltinFunction(&builtin_is_object,
-                                                  &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "is_object(arg) -> boolean",
-  });
-
-  Builtins::init("object", new BuiltinFunction(&builtin_object, &Feature::ExperimentalObjectFunction),
-  {
-    "object([ object, ] [ key-val list, ] key=value, ...) -> object",
-  });
-
-  Builtins::init("has_key", new BuiltinFunction(&builtin_has_key, &Feature::ExperimentalObjectFunction),
-  {
-    "has_key(object, key) -> boolean",
-  });
-
-  Builtins::init("import", new BuiltinFunction(&builtin_import, &Feature::ExperimentalImportFunction),
-  {
-    "import(file) -> object",
-  });
+                 {
+                     "is_function(arg) -> boolean",
+                 });
+
+  Builtins::init(
+      "is_object",
+      new BuiltinFunction(&builtin_is_object,
+                          &Feature::ExperimentalTextMetricsFunctions),
+      {
+          "is_object(arg) -> boolean",
+      });
+
+  Builtins::init(
+      "object",
+      new BuiltinFunction(&builtin_object,
+                          &Feature::ExperimentalObjectFunction),
+      {
+          "object([ object, ] [ key-val list, ] key=value, ...) -> object",
+      });
+
+  Builtins::init("has_key",
+                 new BuiltinFunction(&builtin_has_key,
+                                     &Feature::ExperimentalObjectFunction),
+                 {
+                     "has_key(object, key) -> boolean",
+                 });
+
+  Builtins::init("import",
+                 new BuiltinFunction(&builtin_import,
+                                     &Feature::ExperimentalImportFunction),
+                 {
+                     "import(file) -> object",
+                 });
 }
diff --git a/src/core/control.cc b/src/core/control.cc
index 2598f886f..15eccfbe4 100644
--- a/src/core/control.cc
+++ b/src/core/control.cc
@@ -24,24 +24,24 @@
  *
  */
 
-#include <utility>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <utility>
 #include <vector>
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
-#include "core/node.h"
+#include <cstdint>
 #include "core/Arguments.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
 #include "core/Expression.h"
-#include "core/Builtins.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
+#include "core/node.h"
 #include "utils/printutils.h"
-#include <cstdint>
 
-static std::shared_ptr<AbstractNode> lazyUnionNode(const ModuleInstantiation *inst)
-{
+static std::shared_ptr<AbstractNode> lazyUnionNode(
+    const ModuleInstantiation* inst) {
   if (Feature::ExperimentalLazyUnion.is_enabled()) {
     return std::make_shared<ListNode>(inst);
   } else {
@@ -49,34 +49,50 @@ static std::shared_ptr<AbstractNode> lazyUnionNode(const ModuleInstantiation *in
   }
 }
 
-static boost::optional<size_t> validChildIndex(int n, const Children *children, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static boost::optional<size_t> validChildIndex(
+    int n,
+    const Children* children,
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
   if (n < 0 || n >= static_cast<int>(children->size())) {
-    LOG(message_group::Warning, inst->location(), context->documentRoot(), "Children index (%1$d) out of bounds (%2$d children)", n, children->size());
+    LOG(message_group::Warning, inst->location(), context->documentRoot(),
+        "Children index (%1$d) out of bounds (%2$d children)", n,
+        children->size());
     return boost::none;
   }
   return size_t(n);
 }
 
-static boost::optional<size_t> validChildIndex(const Value& value, const Children *children, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static boost::optional<size_t> validChildIndex(
+    const Value& value,
+    const Children* children,
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
   if (value.type() != Value::Type::NUMBER) {
-    LOG(message_group::Warning, inst->location(), context->documentRoot(), "Bad parameter type (%1$s) for children, only accept: empty, number, vector, range.", value.toString());
+    LOG(message_group::Warning, inst->location(), context->documentRoot(),
+        "Bad parameter type (%1$s) for children, only accept: empty, number, "
+        "vector, range.",
+        value.toString());
     return boost::none;
   }
-  return validChildIndex(static_cast<int>(value.toDouble()), children, inst, context);
+  return validChildIndex(static_cast<int>(value.toDouble()), children, inst,
+                         context);
 }
 
-static std::shared_ptr<AbstractNode> builtin_child(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  LOG(message_group::Deprecated, "child() will be removed in future releases. Use children() instead.");
+static std::shared_ptr<AbstractNode> builtin_child(
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
+  LOG(message_group::Deprecated,
+      "child() will be removed in future releases. Use children() instead.");
 
   Arguments arguments{inst->arguments, context};
 
   BuiltinModule::noChildren(inst, arguments);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {}, std::vector<std::string>{"index"});
-  const Children *children = context->user_module_children();
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {},
+                        std::vector<std::string>{"index"});
+  const Children* children = context->user_module_children();
   if (!children) {
     // child() called outside any user module
     return nullptr;
@@ -94,14 +110,17 @@ static std::shared_ptr<AbstractNode> builtin_child(const ModuleInstantiation *in
   return children->instantiate(lazyUnionNode(inst), {*index});
 }
 
-static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_children(
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
   Arguments arguments{inst->arguments, context};
 
   BuiltinModule::noChildren(inst, arguments);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {}, std::vector<std::string>{"index"});
-  const Children *children = context->user_module_children();
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {},
+                        std::vector<std::string>{"index"});
+  const Children* children = context->user_module_children();
   if (!children) {
     // children() called outside any user module
     return nullptr;
@@ -138,7 +157,8 @@ static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation
     }
     std::vector<size_t> indices;
     for (double d : range) {
-      auto index = validChildIndex(static_cast<int>(d), children, inst, context);
+      auto index =
+          validChildIndex(static_cast<int>(d), children, inst, context);
       if (index) {
         indices.push_back(*index);
       }
@@ -146,13 +166,18 @@ static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation
     return children->instantiate(lazyUnionNode(inst), indices);
   } else {
     // Invalid argument
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Bad parameter type (%1$s) for children, only accept: empty, number, vector, range", parameters["index"].toEchoStringNoThrow());
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Bad parameter type (%1$s) for children, only accept: empty, number, "
+        "vector, range",
+        parameters["index"].toEchoStringNoThrow());
     return {};
   }
 }
 
-static std::shared_ptr<AbstractNode> builtin_echo(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode> builtin_echo(
+    const ModuleInstantiation* inst,
+    Arguments arguments,
+    const Children& children) {
   LOG(message_group::Echo, "%1$s", STR(arguments));
 
   auto node = children.instantiate(lazyUnionNode(inst));
@@ -163,8 +188,9 @@ static std::shared_ptr<AbstractNode> builtin_echo(const ModuleInstantiation *ins
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_assert(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_assert(
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
   Assert::performAssert(inst->arguments, inst->location(), context);
 
   auto node = Children(&inst->scope, context).instantiate(lazyUnionNode(inst));
@@ -175,118 +201,133 @@ static std::shared_ptr<AbstractNode> builtin_assert(const ModuleInstantiation *i
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_let(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  return Children(&inst->scope, *Let::sequentialAssignmentContext(inst->arguments, inst->location(), context)).instantiate(lazyUnionNode(inst));
+static std::shared_ptr<AbstractNode> builtin_let(
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
+  return Children(&inst->scope, *Let::sequentialAssignmentContext(
+                                    inst->arguments, inst->location(), context))
+      .instantiate(lazyUnionNode(inst));
 }
 
-static std::shared_ptr<AbstractNode> builtin_assign(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_assign(
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
   // We create a new context to avoid arguments from influencing each other
   // -> parallel evaluation. This is to be backwards compatible.
   Arguments arguments{inst->arguments, context};
   ContextHandle<Context> assignContext{Context::create<Context>(context)};
   for (auto& argument : arguments) {
     if (!argument.name) {
-      LOG(message_group::Warning, inst->location(), context->documentRoot(), "Assignment without variable name %1$s", argument->toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), context->documentRoot(),
+          "Assignment without variable name %1$s",
+          argument->toEchoStringNoThrow());
     } else {
       if (assignContext->lookup_local_variable(*argument.name)) {
-        // TODO Should maybe quote the entire assignment with a new quoteExpr() or quoteStmt().
-        LOG(message_group::Warning, inst->location(), context->documentRoot(), "Duplicate variable assignment %1$s = %2$s", quoteVar(*argument.name), argument->toEchoStringNoThrow());
+        // TODO Should maybe quote the entire assignment with a new quoteExpr()
+        // or quoteStmt().
+        LOG(message_group::Warning, inst->location(), context->documentRoot(),
+            "Duplicate variable assignment %1$s = %2$s",
+            quoteVar(*argument.name), argument->toEchoStringNoThrow());
       }
       assignContext->set_variable(*argument.name, std::move(argument.value));
     }
   }
 
-  return Children(&inst->scope, *assignContext).instantiate(lazyUnionNode(inst));
+  return Children(&inst->scope, *assignContext)
+      .instantiate(lazyUnionNode(inst));
 }
 
-static std::shared_ptr<AbstractNode> builtin_for(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_for(
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
   auto node = lazyUnionNode(inst);
   if (!inst->arguments.empty()) {
-    LcFor::forEach(inst->arguments, inst->location(), context,
-                   [inst, node] (const std::shared_ptr<const Context>& iterationContext) {
-      Children(&inst->scope, iterationContext).instantiate(node);
-    }
-                   );
+    LcFor::forEach(
+        inst->arguments, inst->location(), context,
+        [inst, node](const std::shared_ptr<const Context>& iterationContext) {
+          Children(&inst->scope, iterationContext).instantiate(node);
+        });
   }
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_intersection_for(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_intersection_for(
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
   auto node = std::make_shared<AbstractIntersectionNode>(inst);
   if (!inst->arguments.empty()) {
-    LcFor::forEach(inst->arguments, inst->location(), context,
-                   [inst, node] (const std::shared_ptr<const Context>& iterationContext) {
-      Children(&inst->scope, iterationContext).instantiate(node);
-    }
-                   );
+    LcFor::forEach(
+        inst->arguments, inst->location(), context,
+        [inst, node](const std::shared_ptr<const Context>& iterationContext) {
+          Children(&inst->scope, iterationContext).instantiate(node);
+        });
   }
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_if(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_if(
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) {
   Arguments arguments{inst->arguments, context};
-  const auto *ifelse = dynamic_cast<const IfElseModuleInstantiation *>(inst);
+  const auto* ifelse = dynamic_cast<const IfElseModuleInstantiation*>(inst);
   if (arguments.size() > 0 && arguments[0]->toBool()) {
     return Children(&inst->scope, context).instantiate(lazyUnionNode(inst));
   } else if (ifelse->getElseScope()) {
-    return Children(ifelse->getElseScope(), context).instantiate(lazyUnionNode(inst));
+    return Children(ifelse->getElseScope(), context)
+        .instantiate(lazyUnionNode(inst));
   } else {
-    // "if" with failed condition, and no "else" should not count as valid CSGNode
+    // "if" with failed condition, and no "else" should not count as valid
+    // CSGNode
     return nullptr;
   }
 }
 
-void register_builtin_control()
-{
+void register_builtin_control() {
   Builtins::init("assign", new BuiltinModule(builtin_assign));
   Builtins::init("child", new BuiltinModule(builtin_child));
 
   Builtins::init("children", new BuiltinModule(builtin_children),
-  {
-    "children()",
-    "children(number)",
-    "children([start : step : end])",
-    "children([start : end])",
-    "children([vector])",
-  });
+                 {
+                     "children()",
+                     "children(number)",
+                     "children([start : step : end])",
+                     "children([start : end])",
+                     "children([vector])",
+                 });
 
   Builtins::init("echo", new BuiltinModule(builtin_echo),
-  {
-    "echo(arg, ...)",
-  });
+                 {
+                     "echo(arg, ...)",
+                 });
 
   Builtins::init("assert", new BuiltinModule(builtin_assert),
-  {
-    "assert(boolean)",
-    "assert(boolean, string)",
-  });
+                 {
+                     "assert(boolean)",
+                     "assert(boolean, string)",
+                 });
 
   Builtins::init("for", new BuiltinModule(builtin_for),
-  {
-    "for([start : increment : end])",
-    "for([start : end])",
-    "for([vector])",
-  });
+                 {
+                     "for([start : increment : end])",
+                     "for([start : end])",
+                     "for([vector])",
+                 });
 
   Builtins::init("let", new BuiltinModule(builtin_let),
-  {
-    "let(arg, ...) expression",
-  });
-
-  Builtins::init("intersection_for", new BuiltinModule(builtin_intersection_for),
-  {
-    "intersection_for([start : increment : end])",
-    "intersection_for([start : end])",
-    "intersection_for([vector])",
-  });
+                 {
+                     "let(arg, ...) expression",
+                 });
+
+  Builtins::init("intersection_for",
+                 new BuiltinModule(builtin_intersection_for),
+                 {
+                     "intersection_for([start : increment : end])",
+                     "intersection_for([start : end])",
+                     "intersection_for([vector])",
+                 });
 
   Builtins::init("if", new BuiltinModule(builtin_if),
-  {
-    "if(boolean)",
-  });
+                 {
+                     "if(boolean)",
+                 });
 }
diff --git a/src/core/customizer/Annotation.cc b/src/core/customizer/Annotation.cc
index d8b953414..bf669fdc0 100644
--- a/src/core/customizer/Annotation.cc
+++ b/src/core/customizer/Annotation.cc
@@ -24,22 +24,18 @@
  *
  */
 
-
 #include "core/customizer/Annotation.h"
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <string>
 #include <utility>
 
 #include "core/Expression.h"
 
 Annotation::Annotation(std::string name, std::shared_ptr<Expression> expr)
-  : name(std::move(name)), expr(std::move(expr))
-{
-}
+    : name(std::move(name)), expr(std::move(expr)) {}
 
-void Annotation::print(std::ostream& stream, const std::string& indent) const
-{
+void Annotation::print(std::ostream& stream, const std::string& indent) const {
   stream << indent << "//" << name << "(" << *this->expr << ")" << std::endl;
 }
diff --git a/src/core/customizer/Annotation.h b/src/core/customizer/Annotation.h
index 290c5626b..327217db0 100644
--- a/src/core/customizer/Annotation.h
+++ b/src/core/customizer/Annotation.h
@@ -1,24 +1,25 @@
 #pragma once
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <string>
-#include <vector>
 #include <unordered_map>
+#include <vector>
 
-class Annotation
-{
-public:
+class Annotation {
+ public:
   Annotation(std::string name, std::shared_ptr<class Expression> expr);
 
   void print(std::ostream& stream, const std::string& indent) const;
   [[nodiscard]] const std::string& getName() const { return name; }
-  [[nodiscard]] const std::shared_ptr<Expression>& getExpr() const { return expr; }
+  [[nodiscard]] const std::shared_ptr<Expression>& getExpr() const {
+    return expr;
+  }
 
-private:
+ private:
   std::string name;
   std::shared_ptr<Expression> expr;
 };
 
 using AnnotationList = std::vector<Annotation>;
-using AnnotationMap = std::unordered_map<std::string, Annotation *>;
+using AnnotationMap = std::unordered_map<std::string, Annotation*>;
diff --git a/src/core/customizer/CommentParser.cc b/src/core/customizer/CommentParser.cc
index d06545f5c..07850e66e 100644
--- a/src/core/customizer/CommentParser.cc
+++ b/src/core/customizer/CommentParser.cc
@@ -1,15 +1,16 @@
 #include "core/customizer/CommentParser.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 
-#include "core/Expression.h"
-#include "core/customizer/Annotation.h"
+#include <boost/range/adaptor/reversed.hpp>
 #include <string>
 #include <vector>
-#include <boost/range/adaptor/reversed.hpp>
+#include "core/Expression.h"
+#include "core/customizer/Annotation.h"
 // gcc 4.8 and earlier have issues with std::regex see
-// #2291 and https://stackoverflow.com/questions/12530406/is-gcc-4-8-or-earlier-buggy-about-regular-expressions
+// #2291 and
+// https://stackoverflow.com/questions/12530406/is-gcc-4-8-or-earlier-buggy-about-regular-expressions
 // therefore, we use boost::regex
 #include <boost/regex.hpp>
 
@@ -25,7 +26,7 @@ using GroupList = std::vector<GroupInfo>;
 
  */
 
-static int getLineToStop(const std::string& fulltext){
+static int getLineToStop(const std::string& fulltext) {
   int lineNo = 1;
   bool inString = false;
   for (unsigned int i = 0; i < fulltext.length(); ++i) {
@@ -41,7 +42,7 @@ static int getLineToStop(const std::string& fulltext){
       continue;
     }
 
-    //start or end of string negate the checkpoint
+    // start or end of string negate the checkpoint
     if (fulltext[i] == '"') {
       inString = !inString;
       continue;
@@ -49,12 +50,13 @@ static int getLineToStop(const std::string& fulltext){
 
     if (!inString && fulltext.compare(i, 2, "//") == 0) {
       i++;
-      while (i < fulltext.length() && fulltext[i] != '\n') i++;
+      while (i < fulltext.length() && fulltext[i] != '\n')
+        i++;
       lineNo++;
       continue;
     }
 
-    //start of multi line comment if check is true
+    // start of multi line comment if check is true
     if (!inString && fulltext.compare(i, 2, "/*") == 0) {
       i++;
       if (i < fulltext.length()) {
@@ -78,24 +80,26 @@ static int getLineToStop(const std::string& fulltext){
   return lineNo;
 }
 
-
 /*
    Finds the given line in the given source code text, and
    extracts the comment (excluding the "//" prefix)
  */
-static std::string getComment(const std::string& fulltext, int line)
-{
-  if (line < 1) return "";
+static std::string getComment(const std::string& fulltext, int line) {
+  if (line < 1)
+    return "";
 
   // Locate line
   std::size_t start = 0;
   for (; start < fulltext.length(); ++start) {
-    if (line <= 1) break;
-    if (fulltext[start] == '\n') line--;
+    if (line <= 1)
+      break;
+    if (fulltext[start] == '\n')
+      line--;
   }
 
   std::size_t end = start + 1;
-  while (end < fulltext.size() && fulltext[end] != '\n') end++;
+  while (end < fulltext.size() && fulltext[end] != '\n')
+    end++;
 
   std::string comment = fulltext.substr(start, end - start);
 
@@ -108,15 +112,20 @@ static std::string getComment(const std::string& fulltext, int line)
       startText++;
       continue;
     }
-    if (comment[startText] == '"') inString = !inString;
+    if (comment[startText] == '"')
+      inString = !inString;
     if (!inString) {
-      if (comment.compare(startText, 2, "//") == 0) break;
-      if (comment[startText] == ';' && noOfSemicolon > 0) return "";
-      if (comment[startText] == ';') noOfSemicolon++;
+      if (comment.compare(startText, 2, "//") == 0)
+        break;
+      if (comment[startText] == ';' && noOfSemicolon > 0)
+        return "";
+      if (comment[startText] == ';')
+        noOfSemicolon++;
     }
   }
 
-  if (startText + 2 > comment.length()) return "";
+  if (startText + 2 > comment.length())
+    return "";
 
   std::string result = comment.substr(startText + 2);
   return result;
@@ -126,24 +135,28 @@ static std::string getComment(const std::string& fulltext, int line)
    Extracts a parameter description from comment on the given line.
    Returns description, without any "//"
  */
-static std::string getDescription(const std::string& fulltext, int line)
-{
-  if (line < 1) return "";
+static std::string getDescription(const std::string& fulltext, int line) {
+  if (line < 1)
+    return "";
 
   unsigned int start = 0;
   for (; start < fulltext.length(); ++start) {
-    if (line <= 1) break;
-    if (fulltext[start] == '\n') line--;
+    if (line <= 1)
+      break;
+    if (fulltext[start] == '\n')
+      line--;
   }
 
   // not a valid description
-  if (fulltext.compare(start, 2, "//") != 0) return "";
+  if (fulltext.compare(start, 2, "//") != 0)
+    return "";
 
   // Jump over the two forward slashes
   start = start + 2;
 
-  //Jump over all the spaces
-  while (fulltext[start] == ' ' || fulltext[start] == '\t') start++;
+  // Jump over all the spaces
+  while (fulltext[start] == ' ' || fulltext[start] == '\t')
+    start++;
   std::string retString = "";
 
   // go till the end of the line
@@ -163,9 +176,8 @@ static std::string getDescription(const std::string& fulltext, int line)
 /*
    Create groups by parsing the multi line comment provided
  */
-static GroupInfo createGroup(std::string comment, int lineNo)
-{
-  //store info related to group
+static GroupInfo createGroup(std::string comment, int lineNo) {
+  // store info related to group
   GroupInfo groupInfo;
   std::string finalGroupName;
 
@@ -188,16 +200,14 @@ static GroupInfo createGroup(std::string comment, int lineNo)
   return groupInfo;
 }
 
-
 /*
    This function collect all groups of parameters described in the
    scad file.
  */
-static GroupList collectGroups(const std::string& fulltext)
-{
-  GroupList groupList; // container of all group names
-  int lineNo = 1; // tracks line number
-  bool inString = false; // check if its string or (line-) comment
+static GroupList collectGroups(const std::string& fulltext) {
+  GroupList groupList;    // container of all group names
+  int lineNo = 1;         // tracks line number
+  bool inString = false;  // check if its string or (line-) comment
 
   // iterate through whole scad file
   for (unsigned int i = 0; i < fulltext.length(); ++i) {
@@ -213,7 +223,7 @@ static GroupList collectGroups(const std::string& fulltext)
       continue;
     }
 
-    //start or end of string negate the checkpoint
+    // start or end of string negate the checkpoint
     if (fulltext[i] == '"') {
       inString = !inString;
       continue;
@@ -221,14 +231,15 @@ static GroupList collectGroups(const std::string& fulltext)
 
     if (!inString && fulltext.compare(i, 2, "//") == 0) {
       i++;
-      while (i < fulltext.length() && fulltext[i] != '\n') i++;
+      while (i < fulltext.length() && fulltext[i] != '\n')
+        i++;
       lineNo++;
       continue;
     }
 
-    //start of multi line comment if check is true
+    // start of multi line comment if check is true
     if (!inString && fulltext.compare(i, 2, "/*") == 0) {
-      //store comment
+      // store comment
       std::string comment;
       i++;
       if (i < fulltext.length()) {
@@ -247,20 +258,19 @@ static GroupList collectGroups(const std::string& fulltext)
         i++;
       }
 
-      if (isGroup) groupList.push_back(createGroup(comment, lineNo));
+      if (isGroup)
+        groupList.push_back(createGroup(comment, lineNo));
     }
   }
   return groupList;
 }
 
-
-
 /*!
    Insert Parameters in AST of given scad file
    form of annotations
  */
-void CommentParser::collectParameters(const std::string& fulltext, SourceFile *root_file)
-{
+void CommentParser::collectParameters(const std::string& fulltext,
+                                      SourceFile* root_file) {
   static auto EmptyStringLiteral(std::make_shared<Literal>(""));
 
   // Get all groups of parameters
@@ -268,48 +278,51 @@ void CommentParser::collectParameters(const std::string& fulltext, SourceFile *r
   int parseTill = getLineToStop(fulltext);
   // Extract parameters for all literal assignments
   for (auto& assignment : root_file->scope.assignments) {
-    if (!assignment->getExpr()->isLiteral()) continue; // Only consider literals
+    if (!assignment->getExpr()->isLiteral())
+      continue;  // Only consider literals
 
     // get location of assignment node
     auto firstLocation = assignment->location();
     auto overwriteLocation = assignment->locationOfOverwrite();
-    auto location = overwriteLocation.isNone() ? firstLocation : overwriteLocation;
+    auto location =
+        overwriteLocation.isNone() ? firstLocation : overwriteLocation;
 
     int firstLine = location.firstLine();
-    if (firstLine >= parseTill || (
-          location.fileName() != "" &&
-          location.fileName() != root_file->getFilename() &&
-          location.fileName() != root_file->getFullpath()
-          )) {
+    if (firstLine >= parseTill ||
+        (location.fileName() != "" &&
+         location.fileName() != root_file->getFilename() &&
+         location.fileName() != root_file->getFullpath())) {
       continue;
     }
     // making list to add annotations
-    auto *annotationList = new AnnotationList();
+    auto* annotationList = new AnnotationList();
 
     // Extracting the parameter comment
     std::shared_ptr<Expression> params;
     std::string comment = getComment(fulltext, firstLine);
-    if (comment.length() > 0) { // don't parse what doesn't exist, so we don't get bogus errors from the parser
+    if (comment.length() > 0) {  // don't parse what doesn't exist, so we don't
+                                 // get bogus errors from the parser
       // getting the node for parameter annotation
       params = CommentParser::parser(comment.c_str());
     }
-    if (!params) params = EmptyStringLiteral;
+    if (!params)
+      params = EmptyStringLiteral;
 
     // adding parameter to the list
     annotationList->push_back(Annotation("Parameter", params));
 
-    //extracting the description
+    // extracting the description
     std::string descr = getDescription(fulltext, firstLine - 1);
     if (descr != "") {
-      //creating node for description
+      // creating node for description
       std::shared_ptr<Expression> expr(new Literal(descr));
       annotationList->push_back(Annotation("Description", expr));
     }
 
     // Look for the group to which the given assignment belong
-    for (const auto& groupInfo :boost::adaptors::reverse(groupList)) {
+    for (const auto& groupInfo : boost::adaptors::reverse(groupList)) {
       if (groupInfo.lineNo < firstLine) {
-        //creating node for description
+        // creating node for description
         std::shared_ptr<Expression> expr(new Literal(groupInfo.commentString));
         annotationList->push_back(Annotation("Group", expr));
         break;
diff --git a/src/core/customizer/CommentParser.h b/src/core/customizer/CommentParser.h
index 25cdea291..83e2c00bc 100644
--- a/src/core/customizer/CommentParser.h
+++ b/src/core/customizer/CommentParser.h
@@ -7,7 +7,7 @@
 
 namespace CommentParser {
 
-std::shared_ptr<Expression> parser(const char *text);
-void collectParameters(const std::string& fulltext, SourceFile *root_file);
+std::shared_ptr<Expression> parser(const char* text);
+void collectParameters(const std::string& fulltext, SourceFile* root_file);
 
-}
+}  // namespace CommentParser
diff --git a/src/core/customizer/ParameterObject.cc b/src/core/customizer/ParameterObject.cc
index 44cba56f4..2ca367a79 100644
--- a/src/core/customizer/ParameterObject.cc
+++ b/src/core/customizer/ParameterObject.cc
@@ -1,27 +1,28 @@
 #include "core/customizer/ParameterObject.h"
 
 #include "core/AST.h"
-#include "core/customizer/Annotation.h"
 #include "core/Assignment.h"
 #include "core/Expression.h"
 #include "core/SourceFile.h"
+#include "core/customizer/Annotation.h"
 
-#include <variant>
+#include <boost/algorithm/string.hpp>
+#include <cstddef>
 #include <map>
-#include <utility>
 #include <memory>
-#include <cstddef>
 #include <sstream>
 #include <string>
+#include <utility>
+#include <variant>
 #include <vector>
-#include <boost/algorithm/string.hpp>
 
 namespace {
 
-bool set_enum_value(json& o, const std::string& name, const EnumParameter::EnumItem& item)
-{
+bool set_enum_value(json& o,
+                    const std::string& name,
+                    const EnumParameter::EnumItem& item) {
   EnumParameter::EnumValue itemValue = item.value;
-  double *doubleValue = std::get_if<double>(&itemValue);
+  double* doubleValue = std::get_if<double>(&itemValue);
   if (doubleValue) {
     o[name] = *doubleValue;
     return true;
@@ -31,10 +32,10 @@ bool set_enum_value(json& o, const std::string& name, const EnumParameter::EnumI
   }
 }
 
-}
+}  // namespace
 
-bool BoolParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool BoolParameter::importValue(boost::property_tree::ptree encodedValue,
+                                bool store) {
   boost::optional<bool> decoded = encodedValue.get_value_optional<bool>();
   if (!decoded) {
     return false;
@@ -45,42 +46,42 @@ bool BoolParameter::importValue(boost::property_tree::ptree encodedValue, bool s
   return true;
 }
 
-boost::property_tree::ptree BoolParameter::exportValue() const
-{
+boost::property_tree::ptree BoolParameter::exportValue() const {
   boost::property_tree::ptree output;
   output.put_value<bool>(value);
   return output;
 }
 
-json BoolParameter::jsonValue() const
-{
+json BoolParameter::jsonValue() const {
   json o;
   o["type"] = "boolean";
   o["initial"] = defaultValue;
   return o;
 }
 
-void BoolParameter::apply(Assignment *assignment) const
-{
+void BoolParameter::apply(Assignment* assignment) const {
   assignment->setExpr(std::make_shared<Literal>(value));
 }
 
-StringParameter::StringParameter(
-  const std::string& name, const std::string& description, const std::string& group,
-  const std::string& defaultValue,
-  boost::optional<size_t> maximumSize
-  ) :
-  ParameterObject(name, description, group, ParameterObject::ParameterType::String),
-  value(defaultValue), defaultValue(defaultValue),
-  maximumSize(maximumSize)
-{
+StringParameter::StringParameter(const std::string& name,
+                                 const std::string& description,
+                                 const std::string& group,
+                                 const std::string& defaultValue,
+                                 boost::optional<size_t> maximumSize)
+    : ParameterObject(name,
+                      description,
+                      group,
+                      ParameterObject::ParameterType::String),
+      value(defaultValue),
+      defaultValue(defaultValue),
+      maximumSize(maximumSize) {
   if (maximumSize && defaultValue.size() > *maximumSize) {
     maximumSize = defaultValue.size();
   }
 }
 
-bool StringParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool StringParameter::importValue(boost::property_tree::ptree encodedValue,
+                                  bool store) {
   if (store) {
     value = encodedValue.data();
     if (maximumSize && value.size() > *maximumSize) {
@@ -90,15 +91,13 @@ bool StringParameter::importValue(boost::property_tree::ptree encodedValue, bool
   return true;
 }
 
-boost::property_tree::ptree StringParameter::exportValue() const
-{
+boost::property_tree::ptree StringParameter::exportValue() const {
   boost::property_tree::ptree output;
   output.data() = value;
   return output;
 }
 
-json StringParameter::jsonValue() const
-{
+json StringParameter::jsonValue() const {
   json o;
   o["type"] = "string";
   o["initial"] = defaultValue;
@@ -108,13 +107,12 @@ json StringParameter::jsonValue() const
   return o;
 }
 
-void StringParameter::apply(Assignment *assignment) const
-{
+void StringParameter::apply(Assignment* assignment) const {
   assignment->setExpr(std::make_shared<Literal>(value));
 }
 
-bool NumberParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool NumberParameter::importValue(boost::property_tree::ptree encodedValue,
+                                  bool store) {
   boost::optional<double> decoded = encodedValue.get_value_optional<double>();
   if (!decoded) {
     return false;
@@ -131,15 +129,13 @@ bool NumberParameter::importValue(boost::property_tree::ptree encodedValue, bool
   return true;
 }
 
-boost::property_tree::ptree NumberParameter::exportValue() const
-{
+boost::property_tree::ptree NumberParameter::exportValue() const {
   boost::property_tree::ptree output;
   output.put_value<double>(value);
   return output;
 }
 
-json NumberParameter::jsonValue() const
-{
+json NumberParameter::jsonValue() const {
   json o;
   o["type"] = "number";
   o["initial"] = defaultValue;
@@ -152,18 +148,20 @@ json NumberParameter::jsonValue() const
   return o;
 }
 
-void NumberParameter::apply(Assignment *assignment) const
-{
+void NumberParameter::apply(Assignment* assignment) const {
   assignment->setExpr(std::make_shared<Literal>(value));
 }
 
-bool VectorParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool VectorParameter::importValue(boost::property_tree::ptree encodedValue,
+                                  bool store) {
   std::vector<double> decoded;
 
-  // NOLINTBEGIN(*NewDeleteLeaks) LLVM bug https://github.com/llvm/llvm-project/issues/40486
-  std::string encoded = boost::algorithm::erase_all_copy(encodedValue.data(), " ");
-  if (encoded.size() < 2 || encoded[0] != '[' || encoded[encoded.size() - 1] != ']') {
+  // NOLINTBEGIN(*NewDeleteLeaks) LLVM bug
+  // https://github.com/llvm/llvm-project/issues/40486
+  std::string encoded =
+      boost::algorithm::erase_all_copy(encodedValue.data(), " ");
+  if (encoded.size() < 2 || encoded[0] != '[' ||
+      encoded[encoded.size() - 1] != ']') {
     return false;
   }
   encoded.erase(encoded.begin());
@@ -201,8 +199,7 @@ bool VectorParameter::importValue(boost::property_tree::ptree encodedValue, bool
   return true;
 }
 
-boost::property_tree::ptree VectorParameter::exportValue() const
-{
+boost::property_tree::ptree VectorParameter::exportValue() const {
   std::stringstream encoded;
   encoded << "[";
   for (size_t i = 0; i < value.size(); i++) {
@@ -218,8 +215,7 @@ boost::property_tree::ptree VectorParameter::exportValue() const
   return output;
 }
 
-json VectorParameter::jsonValue() const
-{
+json VectorParameter::jsonValue() const {
   json o;
   o["type"] = "number";
   o["initial"] = defaultValue;
@@ -232,8 +228,7 @@ json VectorParameter::jsonValue() const
   return o;
 }
 
-void VectorParameter::apply(Assignment *assignment) const
-{
+void VectorParameter::apply(Assignment* assignment) const {
   std::shared_ptr<Vector> vector = std::make_shared<Vector>(Location::NONE);
   for (double item : value) {
     vector->emplace_back(new Literal(item));
@@ -241,13 +236,15 @@ void VectorParameter::apply(Assignment *assignment) const
   assignment->setExpr(std::move(vector));
 }
 
-bool EnumParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool EnumParameter::importValue(boost::property_tree::ptree encodedValue,
+                                bool store) {
   bool found = false;
   int index;
-  boost::optional<double> decodedDouble = encodedValue.get_value_optional<double>();
+  boost::optional<double> decodedDouble =
+      encodedValue.get_value_optional<double>();
   for (size_t i = 0; i < items.size(); i++) {
-    if ((decodedDouble && items[i].value == EnumValue(*decodedDouble)) || items[i].value == EnumValue(encodedValue.data())) {
+    if ((decodedDouble && items[i].value == EnumValue(*decodedDouble)) ||
+        items[i].value == EnumValue(encodedValue.data())) {
       index = i;
       found = true;
       break;
@@ -263,8 +260,7 @@ bool EnumParameter::importValue(boost::property_tree::ptree encodedValue, bool s
   return true;
 }
 
-boost::property_tree::ptree EnumParameter::exportValue() const
-{
+boost::property_tree::ptree EnumParameter::exportValue() const {
   const EnumValue& itemValue = items[valueIndex].value;
   boost::property_tree::ptree output;
   if (std::holds_alternative<double>(itemValue)) {
@@ -275,8 +271,7 @@ boost::property_tree::ptree EnumParameter::exportValue() const
   return output;
 }
 
-json EnumParameter::jsonValue() const
-{
+json EnumParameter::jsonValue() const {
   json o;
   if (set_enum_value(o, "initial", items[defaultValueIndex])) {
     o["type"] = "number";
@@ -296,28 +291,26 @@ json EnumParameter::jsonValue() const
   return o;
 }
 
-void EnumParameter::apply(Assignment *assignment) const
-{
+void EnumParameter::apply(Assignment* assignment) const {
   const EnumValue& itemValue = items[valueIndex].value;
   if (std::holds_alternative<double>(itemValue)) {
     assignment->setExpr(std::make_shared<Literal>(std::get<double>(itemValue)));
   } else {
-    assignment->setExpr(std::make_shared<Literal>(std::get<std::string>(itemValue)));
+    assignment->setExpr(
+        std::make_shared<Literal>(std::get<std::string>(itemValue)));
   }
 }
 
-
-
-struct EnumValues
-{
+struct EnumValues {
   std::vector<EnumParameter::EnumItem> items;
   int defaultValueIndex;
 };
-static EnumValues parseEnumItems(const Expression *parameter, const std::string& defaultKey, const EnumParameter::EnumValue& defaultValue)
-{
+static EnumValues parseEnumItems(const Expression* parameter,
+                                 const std::string& defaultKey,
+                                 const EnumParameter::EnumValue& defaultValue) {
   EnumValues output;
 
-  const auto *expression = dynamic_cast<const Vector *>(parameter);
+  const auto* expression = dynamic_cast<const Vector*>(parameter);
   if (!expression) {
     return output;
   }
@@ -326,7 +319,8 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
   const auto& elements = expression->getChildren();
   for (const auto& elementPointer : elements) {
     EnumParameter::EnumItem item;
-    if (const auto *element = dynamic_cast<const Literal *>(elementPointer.get())) {
+    if (const auto* element =
+            dynamic_cast<const Literal*>(elementPointer.get())) {
       // string or number literal
       if (element->isDouble()) {
         if (elements.size() == 1) {
@@ -342,13 +336,15 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
       } else {
         return output;
       }
-    } else if (const auto *element = dynamic_cast<const Vector *>(elementPointer.get())) {
+    } else if (const auto* element =
+                   dynamic_cast<const Vector*>(elementPointer.get())) {
       // [value, key] vector
       if (element->getChildren().size() != 2) {
         return output;
       }
 
-      const auto *key = dynamic_cast<const Literal *>(element->getChildren()[1].get());
+      const auto* key =
+          dynamic_cast<const Literal*>(element->getChildren()[1].get());
       if (!key) {
         return output;
       }
@@ -360,7 +356,8 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
         return output;
       }
 
-      const auto *value = dynamic_cast<const Literal *>(element->getChildren()[0].get());
+      const auto* value =
+          dynamic_cast<const Literal*>(element->getChildren()[0].get());
       if (!value) {
         return output;
       }
@@ -392,38 +389,35 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
   return output;
 }
 
-struct NumericLimits
-{
+struct NumericLimits {
   boost::optional<double> minimum;
   boost::optional<double> maximum;
   boost::optional<double> step;
 };
-static NumericLimits parseNumericLimits(const Expression *parameter, const std::vector<double>& values)
-{
+static NumericLimits parseNumericLimits(const Expression* parameter,
+                                        const std::vector<double>& values) {
   NumericLimits output;
 
-  if (const auto *step = dynamic_cast<const Literal *>(parameter)) {
+  if (const auto* step = dynamic_cast<const Literal*>(parameter)) {
     if (step->isDouble()) {
       output.step = step->toDouble();
     }
-  } else if (const auto *maximum = dynamic_cast<const Vector *>(parameter)) {
+  } else if (const auto* maximum = dynamic_cast<const Vector*>(parameter)) {
     if (maximum->getChildren().size() == 1) {
-      const auto *maximumChild = dynamic_cast<const Literal *>(maximum->getChildren()[0].get());
+      const auto* maximumChild =
+          dynamic_cast<const Literal*>(maximum->getChildren()[0].get());
       if (maximumChild && maximumChild->isDouble()) {
         output.maximum = maximumChild->toDouble();
       }
     }
-  } else if (const auto *range = dynamic_cast<const Range *>(parameter)) {
-    const auto *minimum = dynamic_cast<const Literal *>(range->getBegin());
-    const auto *maximum = dynamic_cast<const Literal *>(range->getEnd());
-    if (
-      minimum && minimum->isDouble()
-      && maximum && maximum->isDouble()
-      ) {
+  } else if (const auto* range = dynamic_cast<const Range*>(parameter)) {
+    const auto* minimum = dynamic_cast<const Literal*>(range->getBegin());
+    const auto* maximum = dynamic_cast<const Literal*>(range->getEnd());
+    if (minimum && minimum->isDouble() && maximum && maximum->isDouble()) {
       output.minimum = minimum->toDouble();
       output.maximum = maximum->toDouble();
 
-      const auto *step = dynamic_cast<const Literal *>(range->getStep());
+      const auto* step = dynamic_cast<const Literal*>(range->getStep());
       if (step && step->isDouble()) {
         output.step = step->toDouble();
       }
@@ -441,41 +435,45 @@ static NumericLimits parseNumericLimits(const Expression *parameter, const std::
   return output;
 }
 
-std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignment *assignment)
-{
+std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(
+    const Assignment* assignment) {
   std::string name = assignment->getName();
 
-  const Expression *parameter = nullptr;
-  const Annotation *parameterAnnotation = assignment->annotation("Parameter");
+  const Expression* parameter = nullptr;
+  const Annotation* parameterAnnotation = assignment->annotation("Parameter");
   if (!parameterAnnotation) {
     return nullptr;
   }
   parameter = parameterAnnotation->getExpr().get();
 
   std::string description;
-  const Annotation *descriptionAnnotation = assignment->annotation("Description");
+  const Annotation* descriptionAnnotation =
+      assignment->annotation("Description");
   if (descriptionAnnotation) {
-    const auto *expression = dynamic_cast<const Literal *>(descriptionAnnotation->getExpr().get());
+    const auto* expression =
+        dynamic_cast<const Literal*>(descriptionAnnotation->getExpr().get());
     if (expression && expression->isString()) {
       description = expression->toString();
     }
   }
 
   std::string group = "Parameters";
-  const Annotation *groupAnnotation = assignment->annotation("Group");
+  const Annotation* groupAnnotation = assignment->annotation("Group");
   if (groupAnnotation) {
-    const auto *expression = dynamic_cast<const Literal *>(groupAnnotation->getExpr().get());
+    const auto* expression =
+        dynamic_cast<const Literal*>(groupAnnotation->getExpr().get());
     if (expression && expression->isString()) {
       group = boost::algorithm::trim_copy(expression->toString());
-
     }
-    if (group == "Hidden") return nullptr;
+    if (group == "Hidden")
+      return nullptr;
   }
 
-  const Expression *valueExpression = assignment->getExpr().get();
-  if (const auto *expression = dynamic_cast<const Literal *>(valueExpression)) {
+  const Expression* valueExpression = assignment->getExpr().get();
+  if (const auto* expression = dynamic_cast<const Literal*>(valueExpression)) {
     if (expression->isBool()) {
-      return std::make_unique<BoolParameter>(name, description, group, expression->toBool());
+      return std::make_unique<BoolParameter>(name, description, group,
+                                             expression->toBool());
     }
 
     if (expression->isDouble() || expression->isString()) {
@@ -490,33 +488,40 @@ std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignmen
       }
       EnumValues values = parseEnumItems(parameter, key, value);
       if (!values.items.empty()) {
-        return std::make_unique<EnumParameter>(name, description, group, values.defaultValueIndex, values.items);
+        return std::make_unique<EnumParameter>(
+            name, description, group, values.defaultValueIndex, values.items);
       }
     }
 
     if (expression->isString()) {
       std::string value = expression->toString();
       boost::optional<size_t> maximumSize = boost::none;
-      const auto *maximumSizeExpression = dynamic_cast<const Literal *>(parameter);
+      const auto* maximumSizeExpression =
+          dynamic_cast<const Literal*>(parameter);
       if (maximumSizeExpression && maximumSizeExpression->isDouble()) {
         maximumSize = (size_t)(maximumSizeExpression->toDouble());
       }
-      return std::make_unique<StringParameter>(name, description, group, value, maximumSize);
+      return std::make_unique<StringParameter>(name, description, group, value,
+                                               maximumSize);
     }
 
     if (expression->isDouble()) {
       double value = expression->toDouble();
       NumericLimits limits = parseNumericLimits(parameter, {value});
-      return std::make_unique<NumberParameter>(name, description, group, value, limits.minimum, limits.maximum, limits.step);
+      return std::make_unique<NumberParameter>(name, description, group, value,
+                                               limits.minimum, limits.maximum,
+                                               limits.step);
     }
-  } else if (const auto *expression = dynamic_cast<const Vector *>(valueExpression)) {
-    if (expression->getChildren().size() < 1 || expression->getChildren().size() > 4) {
+  } else if (const auto* expression =
+                 dynamic_cast<const Vector*>(valueExpression)) {
+    if (expression->getChildren().size() < 1 ||
+        expression->getChildren().size() > 4) {
       return nullptr;
     }
 
     std::vector<double> value;
     for (const auto& element : expression->getChildren()) {
-      const auto *item = dynamic_cast<const Literal *>(element.get());
+      const auto* item = dynamic_cast<const Literal*>(element.get());
       if (!item) {
         return nullptr;
       }
@@ -527,16 +532,19 @@ std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignmen
     }
 
     NumericLimits limits = parseNumericLimits(parameter, value);
-    return std::make_unique<VectorParameter>(name, description, group, value, limits.minimum, limits.maximum, limits.step);
+    return std::make_unique<VectorParameter>(name, description, group, value,
+                                             limits.minimum, limits.maximum,
+                                             limits.step);
   }
   return nullptr;
 }
 
-ParameterObjects ParameterObjects::fromSourceFile(const SourceFile *sourceFile)
-{
+ParameterObjects ParameterObjects::fromSourceFile(
+    const SourceFile* sourceFile) {
   ParameterObjects output;
   for (const auto& assignment : sourceFile->scope.assignments) {
-    std::unique_ptr<ParameterObject> parameter = ParameterObject::fromAssignment(assignment.get());
+    std::unique_ptr<ParameterObject> parameter =
+        ParameterObject::fromAssignment(assignment.get());
     if (parameter) {
       output.push_back(std::move(parameter));
     }
@@ -544,15 +552,13 @@ ParameterObjects ParameterObjects::fromSourceFile(const SourceFile *sourceFile)
   return output;
 }
 
-void ParameterObjects::reset()
-{
+void ParameterObjects::reset() {
   for (const auto& parameter : *this) {
     parameter->reset();
   }
 }
 
-void ParameterObjects::importValues(const ParameterSet& values)
-{
+void ParameterObjects::importValues(const ParameterSet& values) {
   for (const auto& parameter : *this) {
     auto it = values.find(parameter->name());
     if (it == values.end()) {
@@ -563,8 +569,7 @@ void ParameterObjects::importValues(const ParameterSet& values)
   }
 }
 
-ParameterSet ParameterObjects::exportValues(const std::string& setName)
-{
+ParameterSet ParameterObjects::exportValues(const std::string& setName) {
   ParameterSet output;
   output.setName(setName);
   for (const auto& parameter : *this) {
@@ -573,9 +578,8 @@ ParameterSet ParameterObjects::exportValues(const std::string& setName)
   return output;
 }
 
-void ParameterObjects::apply(SourceFile *sourceFile) const
-{
-  std::map<std::string, ParameterObject *> namedParameters;
+void ParameterObjects::apply(SourceFile* sourceFile) const {
+  std::map<std::string, ParameterObject*> namedParameters;
   for (const auto& parameter : *this) {
     namedParameters[parameter->name()] = parameter.get();
   }
diff --git a/src/core/customizer/ParameterObject.h b/src/core/customizer/ParameterObject.h
index e4d12e0b4..a0d730d9d 100644
--- a/src/core/customizer/ParameterObject.h
+++ b/src/core/customizer/ParameterObject.h
@@ -1,12 +1,12 @@
 #pragma once
 
-#include <memory>
 #include <cstddef>
-#include "json/json.hpp"
+#include <memory>
 #include <string>
 #include <utility>
 #include <variant>
 #include <vector>
+#include "json/json.hpp"
 
 #include "core/customizer/ParameterSet.h"
 using json = nlohmann::json;
@@ -14,13 +14,13 @@ using json = nlohmann::json;
 class SourceFile;
 class Assignment;
 
-class ParameterObject
-{
-public:
+class ParameterObject {
+ public:
   enum class ParameterType { Bool, String, Number, Vector, Enum };
 
   virtual ~ParameterObject() = default;
-  static std::unique_ptr<ParameterObject> fromAssignment(const Assignment *assignment);
+  static std::unique_ptr<ParameterObject> fromAssignment(
+      const Assignment* assignment);
 
   [[nodiscard]] ParameterType type() const { return type_; }
   [[nodiscard]] const std::string& name() const { return name_; }
@@ -28,14 +28,21 @@ public:
   [[nodiscard]] const std::string& group() const { return group_; }
 
   virtual void reset() = 0;
-  virtual bool importValue(boost::property_tree::ptree encodedValue, bool store) = 0;
+  virtual bool importValue(boost::property_tree::ptree encodedValue,
+                           bool store) = 0;
   [[nodiscard]] virtual boost::property_tree::ptree exportValue() const = 0;
   [[nodiscard]] virtual json jsonValue() const = 0;
-  virtual void apply(Assignment *assignment) const = 0;
-
-protected:
-  ParameterObject(std::string name, std::string description, std::string group, ParameterType type) :
-    type_(type), name_(std::move(name)), description_(std::move(description)), group_(std::move(group)) {}
+  virtual void apply(Assignment* assignment) const = 0;
+
+ protected:
+  ParameterObject(std::string name,
+                  std::string description,
+                  std::string group,
+                  ParameterType type)
+      : type_(type),
+        name_(std::move(name)),
+        description_(std::move(description)),
+        group_(std::move(group)) {}
 
   ParameterType type_;
   std::string name_;
@@ -43,65 +50,75 @@ protected:
   std::string group_;
 };
 
-class BoolParameter : public ParameterObject
-{
-public:
-  BoolParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    bool defaultValue
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Bool),
-    value(defaultValue), defaultValue(defaultValue)
-  {}
+class BoolParameter : public ParameterObject {
+ public:
+  BoolParameter(const std::string& name,
+                const std::string& description,
+                const std::string& group,
+                bool defaultValue)
+      : ParameterObject(name,
+                        description,
+                        group,
+                        ParameterObject::ParameterType::Bool),
+        value(defaultValue),
+        defaultValue(defaultValue) {}
 
   void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+  void apply(Assignment* assignment) const override;
 
   bool value;
   bool defaultValue;
 };
 
-class StringParameter : public ParameterObject
-{
-public:
-  StringParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    const std::string& defaultValue,
-    boost::optional<size_t> maximumSize
-    );
+class StringParameter : public ParameterObject {
+ public:
+  StringParameter(const std::string& name,
+                  const std::string& description,
+                  const std::string& group,
+                  const std::string& defaultValue,
+                  boost::optional<size_t> maximumSize);
 
   void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+  void apply(Assignment* assignment) const override;
 
   std::string value;
   std::string defaultValue;
   boost::optional<size_t> maximumSize;
 };
 
-class NumberParameter : public ParameterObject
-{
-public:
-  NumberParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    double defaultValue,
-    boost::optional<double> minimum, boost::optional<double> maximum, boost::optional<double> step
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Number),
-    value(defaultValue), defaultValue(defaultValue),
-    minimum(minimum), maximum(maximum), step(step)
-  {}
+class NumberParameter : public ParameterObject {
+ public:
+  NumberParameter(const std::string& name,
+                  const std::string& description,
+                  const std::string& group,
+                  double defaultValue,
+                  boost::optional<double> minimum,
+                  boost::optional<double> maximum,
+                  boost::optional<double> step)
+      : ParameterObject(name,
+                        description,
+                        group,
+                        ParameterObject::ParameterType::Number),
+        value(defaultValue),
+        defaultValue(defaultValue),
+        minimum(minimum),
+        maximum(maximum),
+        step(step) {}
 
   void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+  void apply(Assignment* assignment) const override;
 
   double value;
   double defaultValue;
@@ -110,24 +127,31 @@ public:
   boost::optional<double> step;
 };
 
-class VectorParameter : public ParameterObject
-{
-public:
-  VectorParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    const std::vector<double>& defaultValue,
-    boost::optional<double> minimum, boost::optional<double> maximum, boost::optional<double> step
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Vector),
-    value(defaultValue), defaultValue(defaultValue),
-    minimum(minimum), maximum(maximum), step(step)
-  {}
+class VectorParameter : public ParameterObject {
+ public:
+  VectorParameter(const std::string& name,
+                  const std::string& description,
+                  const std::string& group,
+                  const std::vector<double>& defaultValue,
+                  boost::optional<double> minimum,
+                  boost::optional<double> maximum,
+                  boost::optional<double> step)
+      : ParameterObject(name,
+                        description,
+                        group,
+                        ParameterObject::ParameterType::Vector),
+        value(defaultValue),
+        defaultValue(defaultValue),
+        minimum(minimum),
+        maximum(maximum),
+        step(step) {}
 
   void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+  void apply(Assignment* assignment) const override;
 
   std::vector<double> value;
   std::vector<double> defaultValue;
@@ -136,42 +160,44 @@ public:
   boost::optional<double> step;
 };
 
-class EnumParameter : public ParameterObject
-{
-public:
+class EnumParameter : public ParameterObject {
+ public:
   using EnumValue = std::variant<double, std::string>;
   struct EnumItem {
     std::string key;
     EnumValue value;
   };
 
-  EnumParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    int defaultValueIndex,
-    std::vector<EnumItem> items
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Enum),
-    valueIndex(defaultValueIndex), defaultValueIndex(defaultValueIndex),
-    items(std::move(items))
-  {}
+  EnumParameter(const std::string& name,
+                const std::string& description,
+                const std::string& group,
+                int defaultValueIndex,
+                std::vector<EnumItem> items)
+      : ParameterObject(name,
+                        description,
+                        group,
+                        ParameterObject::ParameterType::Enum),
+        valueIndex(defaultValueIndex),
+        defaultValueIndex(defaultValueIndex),
+        items(std::move(items)) {}
 
   void reset() override { valueIndex = defaultValueIndex; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+  void apply(Assignment* assignment) const override;
 
   int valueIndex;
   int defaultValueIndex;
   std::vector<EnumItem> items;
 };
 
-class ParameterObjects : public std::vector<std::unique_ptr<ParameterObject>>
-{
-public:
-  static ParameterObjects fromSourceFile(const SourceFile *sourceFile);
+class ParameterObjects : public std::vector<std::unique_ptr<ParameterObject>> {
+ public:
+  static ParameterObjects fromSourceFile(const SourceFile* sourceFile);
   void reset();
   void importValues(const ParameterSet& values);
   ParameterSet exportValues(const std::string& setName);
-  void apply(SourceFile *sourceFile) const;
+  void apply(SourceFile* sourceFile) const;
 };
diff --git a/src/core/customizer/ParameterSet.cc b/src/core/customizer/ParameterSet.cc
index 304daef70..676d5632f 100644
--- a/src/core/customizer/ParameterSet.cc
+++ b/src/core/customizer/ParameterSet.cc
@@ -1,6 +1,6 @@
 #include "core/customizer/ParameterSet.h"
-#include "utils/printutils.h"
 #include <boost/property_tree/json_parser.hpp>
+#include "utils/printutils.h"
 
 #include <string>
 
@@ -8,18 +8,19 @@ static std::string parameterSetsKey("parameterSets");
 static std::string fileFormatVersionKey("fileFormatVersion");
 static std::string fileFormatVersionValue("1");
 
-bool ParameterSets::readFile(const std::string& filename)
-{
+bool ParameterSets::readFile(const std::string& filename) {
   boost::property_tree::ptree root;
 
   try {
     boost::property_tree::read_json(filename, root);
   } catch (const boost::property_tree::json_parser_error& e) {
-    LOG(message_group::Error, "Cannot open Parameter Set '%1$s': %2$s", filename, e.what());
+    LOG(message_group::Error, "Cannot open Parameter Set '%1$s': %2$s",
+        filename, e.what());
     return false;
   }
 
-  boost::optional<boost::property_tree::ptree&> sets = root.get_child_optional(parameterSetsKey);
+  boost::optional<boost::property_tree::ptree&> sets =
+      root.get_child_optional(parameterSetsKey);
   if (!sets) {
     return false;
   }
@@ -35,24 +36,27 @@ bool ParameterSets::readFile(const std::string& filename)
   return true;
 }
 
-void ParameterSets::writeFile(const std::string& filename) const
-{
+void ParameterSets::writeFile(const std::string& filename) const {
   boost::property_tree::ptree sets;
   for (const auto& set : *this) {
     boost::property_tree::ptree setTree;
     for (const auto& parameter : set) {
-      setTree.push_back(boost::property_tree::ptree::value_type(parameter.first, parameter.second));
+      setTree.push_back(boost::property_tree::ptree::value_type(
+          parameter.first, parameter.second));
     }
-    sets.push_back(boost::property_tree::ptree::value_type(set.name(), setTree));
+    sets.push_back(
+        boost::property_tree::ptree::value_type(set.name(), setTree));
   }
 
   boost::property_tree::ptree root;
   root.put<std::string>(fileFormatVersionKey, fileFormatVersionValue);
-  root.push_back(boost::property_tree::ptree::value_type(parameterSetsKey, sets));
+  root.push_back(
+      boost::property_tree::ptree::value_type(parameterSetsKey, sets));
 
   try {
     boost::property_tree::write_json(filename, root);
   } catch (const boost::property_tree::json_parser_error& e) {
-    LOG(message_group::Error, "Cannot write Parameter Set '%1$s': %2$s", filename, e.what());
+    LOG(message_group::Error, "Cannot write Parameter Set '%1$s': %2$s",
+        filename, e.what());
   }
 }
diff --git a/src/core/customizer/ParameterSet.h b/src/core/customizer/ParameterSet.h
index b842c146d..6920f5ea2 100644
--- a/src/core/customizer/ParameterSet.h
+++ b/src/core/customizer/ParameterSet.h
@@ -1,23 +1,21 @@
 #pragma once
 
+#include <boost/property_tree/ptree.hpp>
 #include <map>
 #include <string>
 #include <vector>
-#include <boost/property_tree/ptree.hpp>
 
-class ParameterSet : public std::map<std::string, boost::property_tree::ptree>
-{
-public:
+class ParameterSet : public std::map<std::string, boost::property_tree::ptree> {
+ public:
   [[nodiscard]] const std::string& name() const { return _name; }
   void setName(const std::string& name) { _name = name; }
 
-private:
+ private:
   std::string _name;
 };
 
-class ParameterSets : public std::vector<ParameterSet>
-{
-public:
+class ParameterSets : public std::vector<ParameterSet> {
+ public:
   bool readFile(const std::string& filename);
   void writeFile(const std::string& filename) const;
 };
diff --git a/src/core/enums.h b/src/core/enums.h
index 46a20e422..b1e8ffcdc 100644
--- a/src/core/enums.h
+++ b/src/core/enums.h
@@ -1,5 +1,5 @@
 #pragma once
-#undef DIFFERENCE //#defined in winuser.h
+#undef DIFFERENCE  // #defined in winuser.h
 
 enum class OpenSCADOperator {
   UNION,
diff --git a/src/core/function.cc b/src/core/function.cc
index af785370a..7df41cd5d 100644
--- a/src/core/function.cc
+++ b/src/core/function.cc
@@ -30,37 +30,41 @@
 #include "core/Arguments.h"
 #include "core/Expression.h"
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <ostream>
 #include <utility>
 
-BuiltinFunction::BuiltinFunction(Value(*f)(const std::shared_ptr<const Context>&, const FunctionCall *), const Feature *feature) :
-  evaluate(f),
-  feature(feature)
-{}
+BuiltinFunction::BuiltinFunction(
+    Value (*f)(const std::shared_ptr<const Context>&, const FunctionCall*),
+    const Feature* feature)
+    : evaluate(f), feature(feature) {}
 
-BuiltinFunction::BuiltinFunction(Value(*f)(Arguments, const Location&), const Feature *feature) :
-  feature(feature)
-{
-  evaluate = [f] (const std::shared_ptr<const Context>& context, const FunctionCall *call) {
-      return f(Arguments(call->arguments, context), call->location());
-    };
+BuiltinFunction::BuiltinFunction(Value (*f)(Arguments, const Location&),
+                                 const Feature* feature)
+    : feature(feature) {
+  evaluate = [f](const std::shared_ptr<const Context>& context,
+                 const FunctionCall* call) {
+    return f(Arguments(call->arguments, context), call->location());
+  };
 }
 
-UserFunction::UserFunction(const char *name, AssignmentList& parameters, std::shared_ptr<Expression> expr, const Location& loc)
-  : ASTNode(loc), name(name), parameters(parameters), expr(std::move(expr))
-{
-}
+UserFunction::UserFunction(const char* name,
+                           AssignmentList& parameters,
+                           std::shared_ptr<Expression> expr,
+                           const Location& loc)
+    : ASTNode(loc), name(name), parameters(parameters), expr(std::move(expr)) {}
 
-void UserFunction::print(std::ostream& stream, const std::string& indent) const
-{
+void UserFunction::print(std::ostream& stream,
+                         const std::string& indent) const {
   stream << indent << "function " << name << "(";
   for (size_t i = 0; i < parameters.size(); ++i) {
     const auto& parameter = parameters[i];
-    if (i > 0) stream << ", ";
+    if (i > 0)
+      stream << ", ";
     stream << parameter->getName();
-    if (parameter->getExpr()) stream << " = " << *parameter->getExpr();
+    if (parameter->getExpr())
+      stream << " = " << *parameter->getExpr();
   }
   stream << ") = " << *expr << ";\n";
 }
diff --git a/src/core/function.h b/src/core/function.h
index 6cb6fb016..5066d6a53 100644
--- a/src/core/function.h
+++ b/src/core/function.h
@@ -1,51 +1,58 @@
 #pragma once
 
+#include "Feature.h"
 #include "core/AST.h"
 #include "core/Assignment.h"
-#include "Feature.h"
 #include "core/Value.h"
 
-#include <ostream>
-#include <memory>
 #include <functional>
+#include <memory>
+#include <ostream>
 #include <string>
 #include <variant>
 
 class Arguments;
 class FunctionCall;
 
-class BuiltinFunction
-{
-public:
-  std::function<Value(const std::shared_ptr<const Context>&, const FunctionCall *)> evaluate;
+class BuiltinFunction {
+ public:
+  std::function<Value(const std::shared_ptr<const Context>&,
+                      const FunctionCall*)>
+      evaluate;
 
-private:
-  const Feature *feature;
+ private:
+  const Feature* feature;
 
-public:
-  BuiltinFunction(Value(*f)(const std::shared_ptr<const Context>&, const FunctionCall *), const Feature *feature = nullptr);
-  BuiltinFunction(Value(*f)(Arguments, const Location&), const Feature *feature = nullptr);
+ public:
+  BuiltinFunction(Value (*f)(const std::shared_ptr<const Context>&,
+                             const FunctionCall*),
+                  const Feature* feature = nullptr);
+  BuiltinFunction(Value (*f)(Arguments, const Location&),
+                  const Feature* feature = nullptr);
 
   [[nodiscard]] bool is_experimental() const { return feature != nullptr; }
-  [[nodiscard]] bool is_enabled() const { return (feature == nullptr) || feature->is_enabled(); }
+  [[nodiscard]] bool is_enabled() const {
+    return (feature == nullptr) || feature->is_enabled();
+  }
 };
 
-class UserFunction : public ASTNode
-{
-public:
+class UserFunction : public ASTNode {
+ public:
   std::string name;
   AssignmentList parameters;
   std::shared_ptr<Expression> expr;
 
-  UserFunction(const char *name, AssignmentList& parameters, std::shared_ptr<Expression> expr, const Location& loc);
+  UserFunction(const char* name,
+               AssignmentList& parameters,
+               std::shared_ptr<Expression> expr,
+               const Location& loc);
 
   void print(std::ostream& stream, const std::string& indent) const override;
 };
 
-
-struct CallableUserFunction
-{
+struct CallableUserFunction {
   std::shared_ptr<const Context> defining_context;
-  const UserFunction *function;
+  const UserFunction* function;
 };
-using CallableFunction = std::variant<const BuiltinFunction *, CallableUserFunction, Value, const Value *>;
+using CallableFunction = std::
+    variant<const BuiltinFunction*, CallableUserFunction, Value, const Value*>;
diff --git a/src/core/module.cc b/src/core/module.cc
index d5d57dd50..84937462b 100644
--- a/src/core/module.cc
+++ b/src/core/module.cc
@@ -26,47 +26,61 @@
 
 #include "core/module.h"
 
-#include <utility>
-#include <string>
 #include <memory>
+#include <string>
+#include <utility>
 #include "core/Arguments.h"
 #include "core/Children.h"
 #include "core/Context.h"
 #include "core/ModuleInstantiation.h"
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, const std::shared_ptr<const Context>&), const Feature *feature) :
-  AbstractModule(feature),
-  do_instantiate(instantiate)
-{}
+BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode> (*instantiate)(
+                                 const ModuleInstantiation*,
+                                 const std::shared_ptr<const Context>&),
+                             const Feature* feature)
+    : AbstractModule(feature), do_instantiate(instantiate) {}
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments, const Children&), const Feature *feature) :
-  AbstractModule(feature)
-{
-  do_instantiate = [instantiate](const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) {
-      return instantiate(inst, Arguments(inst->arguments, context), Children(&inst->scope, context));
-    };
+BuiltinModule::BuiltinModule(
+    std::shared_ptr<AbstractNode> (*instantiate)(const ModuleInstantiation*,
+                                                 Arguments,
+                                                 const Children&),
+    const Feature* feature)
+    : AbstractModule(feature) {
+  do_instantiate = [instantiate](
+                       const ModuleInstantiation* inst,
+                       const std::shared_ptr<const Context>& context) {
+    return instantiate(inst, Arguments(inst->arguments, context),
+                       Children(&inst->scope, context));
+  };
 }
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments), const Feature *feature) :
-  AbstractModule(feature)
-{
-  do_instantiate = [instantiate](const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) {
-      Arguments arguments(inst->arguments, context);
-      noChildren(inst, arguments);
-      return instantiate(inst, std::move(arguments));
-    };
+BuiltinModule::BuiltinModule(
+    std::shared_ptr<AbstractNode> (*instantiate)(const ModuleInstantiation*,
+                                                 Arguments),
+    const Feature* feature)
+    : AbstractModule(feature) {
+  do_instantiate = [instantiate](
+                       const ModuleInstantiation* inst,
+                       const std::shared_ptr<const Context>& context) {
+    Arguments arguments(inst->arguments, context);
+    noChildren(inst, arguments);
+    return instantiate(inst, std::move(arguments));
+  };
 }
 
-
-std::shared_ptr<AbstractNode> BuiltinModule::instantiate(const std::shared_ptr<const Context>& /*defining_context*/, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const
-{
+std::shared_ptr<AbstractNode> BuiltinModule::instantiate(
+    const std::shared_ptr<const Context>& /*defining_context*/,
+    const ModuleInstantiation* inst,
+    const std::shared_ptr<const Context>& context) const {
   return do_instantiate(inst, context);
 }
 
-void BuiltinModule::noChildren(const ModuleInstantiation *inst, Arguments& arguments, std::string auxmsg) {
+void BuiltinModule::noChildren(const ModuleInstantiation* inst,
+                               Arguments& arguments,
+                               std::string auxmsg) {
   if (inst->scope.hasChildren()) {
     LOG(message_group::Warning, inst->location(), arguments.documentRoot(),
         "module %1$s() does not support child modules%2$s%3$s", inst->name(),
-        auxmsg.size() != 0  ? " " : "", auxmsg);
+        auxmsg.size() != 0 ? " " : "", auxmsg);
   }
 }
diff --git a/src/core/module.h b/src/core/module.h
index 49d60236a..65fd75b95 100644
--- a/src/core/module.h
+++ b/src/core/module.h
@@ -1,8 +1,8 @@
 #pragma once
 
-#include <string>
-#include <memory>
 #include <functional>
+#include <memory>
+#include <string>
 #include "Feature.h"
 
 class AbstractNode;
@@ -11,35 +11,57 @@ class Children;
 class Context;
 class ModuleInstantiation;
 
-class AbstractModule
-{
-private:
-  const Feature *feature;
-public:
+class AbstractModule {
+ private:
+  const Feature* feature;
+
+ public:
   AbstractModule() : feature(nullptr) {}
   AbstractModule(const Feature& feature) : feature(&feature) {}
-  AbstractModule(const Feature *feature) : feature(feature) {}
+  AbstractModule(const Feature* feature) : feature(feature) {}
   virtual ~AbstractModule() = default;
-  [[nodiscard]] virtual bool is_experimental() const { return feature != nullptr; }
-  [[nodiscard]] virtual bool is_enabled() const { return (feature == nullptr) || feature->is_enabled(); }
-  virtual std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const = 0;
+  [[nodiscard]] virtual bool is_experimental() const {
+    return feature != nullptr;
+  }
+  [[nodiscard]] virtual bool is_enabled() const {
+    return (feature == nullptr) || feature->is_enabled();
+  }
+  virtual std::shared_ptr<AbstractNode> instantiate(
+      const std::shared_ptr<const Context>& defining_context,
+      const ModuleInstantiation* inst,
+      const std::shared_ptr<const Context>& context) const = 0;
 };
 
-class BuiltinModule : public AbstractModule
-{
-public:
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, const std::shared_ptr<const Context>&), const Feature *feature = nullptr);
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments, const Children&), const Feature *feature = nullptr);
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments), const Feature *feature = nullptr);
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const override;
-  static void noChildren(const ModuleInstantiation *, Arguments&, std::string auxmsg = {});
+class BuiltinModule : public AbstractModule {
+ public:
+  BuiltinModule(std::shared_ptr<AbstractNode> (*instantiate)(
+                    const ModuleInstantiation*,
+                    const std::shared_ptr<const Context>&),
+                const Feature* feature = nullptr);
+  BuiltinModule(
+      std::shared_ptr<AbstractNode> (*instantiate)(const ModuleInstantiation*,
+                                                   Arguments,
+                                                   const Children&),
+      const Feature* feature = nullptr);
+  BuiltinModule(std::shared_ptr<AbstractNode> (
+                    *instantiate)(const ModuleInstantiation*, Arguments),
+                const Feature* feature = nullptr);
+  std::shared_ptr<AbstractNode> instantiate(
+      const std::shared_ptr<const Context>& defining_context,
+      const ModuleInstantiation* inst,
+      const std::shared_ptr<const Context>& context) const override;
+  static void noChildren(const ModuleInstantiation*,
+                         Arguments&,
+                         std::string auxmsg = {});
 
-private:
-  std::function<std::shared_ptr<AbstractNode>(const ModuleInstantiation *, const std::shared_ptr<const Context>&)> do_instantiate;
+ private:
+  std::function<std::shared_ptr<AbstractNode>(
+      const ModuleInstantiation*,
+      const std::shared_ptr<const Context>&)>
+      do_instantiate;
 };
 
-struct InstantiableModule
-{
+struct InstantiableModule {
   std::shared_ptr<const Context> defining_context;
-  const AbstractModule *module;
+  const AbstractModule* module;
 };
diff --git a/src/core/node.cc b/src/core/node.cc
index 87ba927be..b34086bfe 100644
--- a/src/core/node.cc
+++ b/src/core/node.cc
@@ -29,29 +29,26 @@
 #include "core/ModuleInstantiation.h"
 #include "core/progress.h"
 
-#include <deque>
-#include <memory>
+#include <algorithm>
 #include <cstddef>
+#include <deque>
 #include <functional>
 #include <iostream>
-#include <algorithm>
+#include <memory>
 #include <string>
 
 size_t AbstractNode::idx_counter;
 
-AbstractNode::AbstractNode(const ModuleInstantiation *mi) :
-  modinst(mi),
-  idx(idx_counter++)
-{
-}
+AbstractNode::AbstractNode(const ModuleInstantiation* mi)
+    : modinst(mi), idx(idx_counter++) {}
 
-std::string AbstractNode::toString() const
-{
+std::string AbstractNode::toString() const {
   return this->name() + "()";
 }
 
-std::shared_ptr<const AbstractNode> AbstractNode::getNodeByID(int idx, std::deque<std::shared_ptr<const AbstractNode>>& path) const
-{
+std::shared_ptr<const AbstractNode> AbstractNode::getNodeByID(
+    int idx,
+    std::deque<std::shared_ptr<const AbstractNode>>& path) const {
   auto self = shared_from_this();
   if (this->idx == idx) {
     path.push_back(self);
@@ -67,16 +64,20 @@ std::shared_ptr<const AbstractNode> AbstractNode::getNodeByID(int idx, std::dequ
   return nullptr;
 }
 
-void AbstractNode::getCodeLocation(int currentLevel,  int includeLevel,
-                                   int *firstLine, int *firstColumn, int *lastLine, int *lastColumn,
-                                   int nestedModuleDepth) const
-{
+void AbstractNode::getCodeLocation(int currentLevel,
+                                   int includeLevel,
+                                   int* firstLine,
+                                   int* firstColumn,
+                                   int* lastLine,
+                                   int* lastColumn,
+                                   int nestedModuleDepth) const {
   auto location = modinst->location();
   if (currentLevel >= includeLevel && nestedModuleDepth == 0) {
     if (*firstLine < 0 || *firstLine > location.firstLine()) {
       *firstLine = location.firstLine();
       *firstColumn = location.firstColumn();
-    } else if (*firstLine == location.firstLine() && *firstColumn > location.firstColumn()) {
+    } else if (*firstLine == location.firstLine() &&
+               *firstColumn > location.firstColumn()) {
       *firstColumn = location.firstColumn();
     }
 
@@ -87,13 +88,15 @@ void AbstractNode::getCodeLocation(int currentLevel,  int includeLevel,
       if (*firstLine < 0 || *firstLine > location.firstLine()) {
         *firstLine = location.firstLine();
         *firstColumn = location.firstColumn();
-      } else if (*firstLine == location.firstLine() && *firstColumn > location.firstColumn()) {
+      } else if (*firstLine == location.firstLine() &&
+                 *firstColumn > location.firstColumn()) {
         *firstColumn = location.firstColumn();
       }
       if (*lastLine < 0 || *lastLine < location.lastLine()) {
         *lastLine = location.lastLine();
         *lastColumn = location.lastColumn();
-      } else if (*lastLine == location.lastLine() && *lastColumn < location.lastColumn()) {
+      } else if (*lastLine == location.lastLine() &&
+                 *lastColumn < location.lastColumn()) {
         *lastColumn = location.lastColumn();
       }
     }
@@ -108,14 +111,16 @@ void AbstractNode::getCodeLocation(int currentLevel,  int includeLevel,
 
   if (nestedModuleDepth >= 0) {
     for (const auto& node : children) {
-      node->getCodeLocation(currentLevel + 1, includeLevel, firstLine,  firstColumn, lastLine,
-                            lastColumn, nestedModuleDepth);
+      node->getCodeLocation(currentLevel + 1, includeLevel, firstLine,
+                            firstColumn, lastLine, lastColumn,
+                            nestedModuleDepth);
     }
   }
 }
 
-void AbstractNode::findNodesWithSameMod(const std::shared_ptr<const AbstractNode>& node_mod,
-                                        std::vector<std::shared_ptr<const AbstractNode>>& nodes) const {
+void AbstractNode::findNodesWithSameMod(
+    const std::shared_ptr<const AbstractNode>& node_mod,
+    std::vector<std::shared_ptr<const AbstractNode>>& nodes) const {
   if (node_mod->modinst == modinst) {
     nodes.push_back(shared_from_this());
   }
@@ -124,51 +129,44 @@ void AbstractNode::findNodesWithSameMod(const std::shared_ptr<const AbstractNode
   }
 }
 
-std::string GroupNode::name() const
-{
+std::string GroupNode::name() const {
   return "group";
 }
 
-std::string GroupNode::verbose_name() const
-{
+std::string GroupNode::verbose_name() const {
   return this->_name;
 }
 
-std::string ListNode::name() const
-{
+std::string ListNode::name() const {
   return "list";
 }
 
-std::string RootNode::name() const
-{
+std::string RootNode::name() const {
   return "root";
 }
 
-std::string AbstractIntersectionNode::toString() const
-{
+std::string AbstractIntersectionNode::toString() const {
   return this->name() + "()";
 }
 
-std::string AbstractIntersectionNode::name() const
-{
+std::string AbstractIntersectionNode::name() const {
   // We write intersection here since the module will have to be evaluated
-  // before we get here and it will not longer retain the intersection_for parameters
+  // before we get here and it will not longer retain the intersection_for
+  // parameters
   return "intersection";
 }
 
-void AbstractNode::progress_prepare()
-{
-  std::for_each(this->children.begin(), this->children.end(), std::mem_fn(&AbstractNode::progress_prepare));
+void AbstractNode::progress_prepare() {
+  std::for_each(this->children.begin(), this->children.end(),
+                std::mem_fn(&AbstractNode::progress_prepare));
   this->progress_mark = ++progress_report_count;
 }
 
-void AbstractNode::progress_report() const
-{
+void AbstractNode::progress_report() const {
   progress_update(shared_from_this(), this->progress_mark);
 }
 
-std::ostream& operator<<(std::ostream& stream, const AbstractNode& node)
-{
+std::ostream& operator<<(std::ostream& stream, const AbstractNode& node) {
   stream << node.toString();
   return stream;
 }
@@ -176,29 +174,33 @@ std::ostream& operator<<(std::ostream& stream, const AbstractNode& node)
 /*!
    Locates and returns the node containing a root modifier (!).
    Returns nullptr if no root modifier was found.
-   If a second root modifier was found, nextLocation (if non-zero) will be set to point to
-   the location of that second modifier.
+   If a second root modifier was found, nextLocation (if non-zero) will be set
+   to point to the location of that second modifier.
  */
-std::shared_ptr<AbstractNode> find_root_tag(const std::shared_ptr<AbstractNode>& node, const Location **nextLocation)
-{
+std::shared_ptr<AbstractNode> find_root_tag(
+    const std::shared_ptr<AbstractNode>& node,
+    const Location** nextLocation) {
   std::shared_ptr<AbstractNode> rootTag;
 
-  std::function<void (const std::shared_ptr<const AbstractNode>&)> recursive_find_tag = [&](const std::shared_ptr<const AbstractNode>& node) {
-      for (const auto& child : node->children) {
-        if (child->modinst->tag_root) {
-          if (!rootTag) {
-            rootTag = child;
-            // shortcut if we're not interested in further root modifiers
-            if (!nextLocation) return;
-          } else if (nextLocation && rootTag->modinst != child->modinst) {
-            // Throw if we have more than one root modifier in the source
-            *nextLocation = &child->modinst->location();
-            return;
-          }
-        }
-        recursive_find_tag(child);
-      }
-    };
+  std::function<void(const std::shared_ptr<const AbstractNode>&)>
+      recursive_find_tag =
+          [&](const std::shared_ptr<const AbstractNode>& node) {
+            for (const auto& child : node->children) {
+              if (child->modinst->tag_root) {
+                if (!rootTag) {
+                  rootTag = child;
+                  // shortcut if we're not interested in further root modifiers
+                  if (!nextLocation)
+                    return;
+                } else if (nextLocation && rootTag->modinst != child->modinst) {
+                  // Throw if we have more than one root modifier in the source
+                  *nextLocation = &child->modinst->location();
+                  return;
+                }
+              }
+              recursive_find_tag(child);
+            }
+          };
 
   recursive_find_tag(node);
 
diff --git a/src/core/node.h b/src/core/node.h
index 070abb0e2..d671505e7 100644
--- a/src/core/node.h
+++ b/src/core/node.h
@@ -1,22 +1,29 @@
 #pragma once
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <deque>
+#include <memory>
+#include <ostream>
+#include <string>
 #include <utility>
 #include <vector>
-#include <string>
-#include <deque>
 
-#include "core/BaseVisitable.h"
 #include "core/AST.h"
+#include "core/BaseVisitable.h"
 #include "core/ModuleInstantiation.h"
 
 extern int progress_report_count;
-extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
-extern void *progress_report_vp;
-
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *vp, int mark), void *vp);
+extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&,
+                                 void*,
+                                 int);
+extern void* progress_report_vp;
+
+void progress_report_prep(
+    const std::shared_ptr<AbstractNode>& root,
+    void (*f)(const std::shared_ptr<const AbstractNode>& node,
+              void* vp,
+              int mark),
+    void* vp);
 void progress_report_fin();
 
 /*!
@@ -26,24 +33,24 @@ void progress_report_fin();
    scratch for each compile.
 
  */
-class AbstractNode : public BaseVisitable, public std::enable_shared_from_this<AbstractNode>
-{
+class AbstractNode : public BaseVisitable,
+                     public std::enable_shared_from_this<AbstractNode> {
   // FIXME: the idx_counter/idx is mostly (only?) for debugging.
   // We can hash on pointer value or smth. else.
   //  -> remove and
   // use smth. else to display node identifier in CSG tree output?
-  static size_t idx_counter; // Node instantiation index
-public:
+  static size_t idx_counter;  // Node instantiation index
+ public:
   VISITABLE();
-  AbstractNode(const ModuleInstantiation *mi);
+  AbstractNode(const ModuleInstantiation* mi);
   virtual std::string toString() const;
   /*! The 'OpenSCAD name' of this node, defaults to classname, but can be
-      overloaded to provide specialization for e.g. CSG nodes, primitive nodes etc.
-      Used for human-readable output. */
+      overloaded to provide specialization for e.g. CSG nodes, primitive nodes
+     etc. Used for human-readable output. */
   virtual std::string name() const = 0;
 
-  /*| When a more specific name for user interaction shall be used, such as module names,
-      the verbose name shall be overloaded. */
+  /*| When a more specific name for user interaction shall be used, such as
+     module names, the verbose name shall be overloaded. */
   virtual std::string verbose_name() const { return this->name(); }
 
   const std::vector<std::shared_ptr<AbstractNode>>& getChildren() const {
@@ -55,7 +62,7 @@ public:
 
   // FIXME: Make protected
   std::vector<std::shared_ptr<AbstractNode>> children;
-  const ModuleInstantiation *modinst;
+  const ModuleInstantiation* modinst;
 
   // progress_mark is a running number used for progress indication
   // FIXME: Make all progress handling external, put it in the traverser class?
@@ -63,50 +70,52 @@ public:
   void progress_prepare();
   void progress_report() const;
 
-  int idx; // Node index (unique per tree)
+  int idx;  // Node index (unique per tree)
 
-  std::shared_ptr<const AbstractNode> getNodeByID(int idx, std::deque<std::shared_ptr<const AbstractNode>>& path) const;
+  std::shared_ptr<const AbstractNode> getNodeByID(
+      int idx,
+      std::deque<std::shared_ptr<const AbstractNode>>& path) const;
 
   // returns the precise source code location associated with the node
-  void getCodeLocation(int currentLevel,  int includeLevel, int *firstLine,
-                       int *firstColumn, int *lastLine, int *lastColumn, int nestedModuleDepth) const;
-
-  void findNodesWithSameMod(const std::shared_ptr<const AbstractNode>& node_mod,
-                            std::vector<std::shared_ptr<const AbstractNode>>& nodes) const;
+  void getCodeLocation(int currentLevel,
+                       int includeLevel,
+                       int* firstLine,
+                       int* firstColumn,
+                       int* lastLine,
+                       int* lastColumn,
+                       int nestedModuleDepth) const;
+
+  void findNodesWithSameMod(
+      const std::shared_ptr<const AbstractNode>& node_mod,
+      std::vector<std::shared_ptr<const AbstractNode>>& nodes) const;
 
   std::shared_ptr<AbstractNode> clone(void);
 };
 
-class AbstractIntersectionNode : public AbstractNode
-{
-public:
+class AbstractIntersectionNode : public AbstractNode {
+ public:
   VISITABLE();
-  AbstractIntersectionNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  AbstractIntersectionNode(const ModuleInstantiation* mi) : AbstractNode(mi) {}
   std::string toString() const override;
   std::string name() const override;
 };
 
-class AbstractPolyNode : public AbstractNode
-{
-public:
+class AbstractPolyNode : public AbstractNode {
+ public:
   VISITABLE();
-  AbstractPolyNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  AbstractPolyNode(const ModuleInstantiation* mi) : AbstractNode(mi) {}
 
-  enum class render_mode_e {
-    RENDER_CGAL,
-    RENDER_OPENCSG
-  };
+  enum class render_mode_e { RENDER_CGAL, RENDER_OPENCSG };
 };
 
 /*!
    Used for organizing objects into lists which should not be grouped but merely
    unpacked by the parent node.
  */
-class ListNode : public AbstractNode
-{
-public:
+class ListNode : public AbstractNode {
+ public:
   VISITABLE();
-  ListNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  ListNode(const ModuleInstantiation* mi) : AbstractNode(mi) {}
   std::string name() const override;
 };
 
@@ -114,37 +123,39 @@ public:
    Logically groups objects together. Used as a way of passing
    objects around without having to perform unions on them.
  */
-class GroupNode : public AbstractNode
-{
-public:
+class GroupNode : public AbstractNode {
+ public:
   VISITABLE();
-  GroupNode(const ModuleInstantiation *mi, std::string name = "") : AbstractNode(mi), _name(std::move(name)) { }
+  GroupNode(const ModuleInstantiation* mi, std::string name = "")
+      : AbstractNode(mi), _name(std::move(name)) {}
   std::string name() const override;
   std::string verbose_name() const override;
-private:
+
+ private:
   const std::string _name;
 };
 
 /*!
    Only instantiated once, for the top-level file.
  */
-class RootNode : public GroupNode
-{
-public:
+class RootNode : public GroupNode {
+ public:
   VISITABLE();
-  RootNode() : GroupNode(&mi), mi("group") { }
+  RootNode() : GroupNode(&mi), mi("group") {}
   std::string name() const override;
-private:
+
+ private:
   ModuleInstantiation mi;
 };
 
-class LeafNode : public AbstractPolyNode
-{
-public:
+class LeafNode : public AbstractPolyNode {
+ public:
   VISITABLE();
-  LeafNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
+  LeafNode(const ModuleInstantiation* mi) : AbstractPolyNode(mi) {}
   virtual std::unique_ptr<const class Geometry> createGeometry() const = 0;
 };
 
 std::ostream& operator<<(std::ostream& stream, const AbstractNode& node);
-std::shared_ptr<AbstractNode> find_root_tag(const std::shared_ptr<AbstractNode>& node, const Location **nextLocation = nullptr);
+std::shared_ptr<AbstractNode> find_root_tag(
+    const std::shared_ptr<AbstractNode>& node,
+    const Location** nextLocation = nullptr);
diff --git a/src/core/node_clone.cc b/src/core/node_clone.cc
index b383f13a3..975bab145 100644
--- a/src/core/node_clone.cc
+++ b/src/core/node_clone.cc
@@ -24,89 +24,74 @@
  *
  */
 
-#include "geometry/linalg.h"
-#include "geometry/GeometryUtils.h"
-#include "core/primitives.h"
-#include "core/TransformNode.h"
-#include "core/RotateExtrudeNode.h"
-#include "core/LinearExtrudeNode.h"
 #include "core/CgalAdvNode.h"
-#include "core/CsgOpNode.h"
 #include "core/ColorNode.h"
-#include "core/RoofNode.h"
+#include "core/CsgOpNode.h"
+#include "core/ImportNode.h"
+#include "core/LinearExtrudeNode.h"
+#include "core/OffsetNode.h"
+#include "core/ProjectionNode.h"
 #include "core/RenderNode.h"
+#include "core/RoofNode.h"
+#include "core/RotateExtrudeNode.h"
 #include "core/SurfaceNode.h"
 #include "core/TextNode.h"
-#include "core/OffsetNode.h"
-#include "core/ProjectionNode.h"
-#include "core/ImportNode.h"
+#include "core/TransformNode.h"
+#include "core/primitives.h"
+#include "geometry/GeometryUtils.h"
+#include "geometry/linalg.h"
 
-std::vector<ModuleInstantiation *> modinsts_list;
+std::vector<ModuleInstantiation*> modinsts_list;
 
-#define NodeCloneFunc(T) std::shared_ptr<T> clone_what(const T * node) { \
-          ModuleInstantiation *inst = new ModuleInstantiation(node->modinst->name(), \
-                                                              node->modinst->arguments, node->modinst->location()); \
-          modinsts_list.push_back(inst); \
-          auto clone = std::make_shared<T>(*node); \
-          clone->modinst = inst; \
-          return clone; \
-}
+#define NodeCloneFunc(T)                                 \
+  std::shared_ptr<T> clone_what(const T* node) {         \
+    ModuleInstantiation* inst = new ModuleInstantiation( \
+        node->modinst->name(), node->modinst->arguments, \
+        node->modinst->location());                      \
+    modinsts_list.push_back(inst);                       \
+    auto clone = std::make_shared<T>(*node);             \
+    clone->modinst = inst;                               \
+    return clone;                                        \
+  }
 
-#define NodeCloneUse(T) { const T *node = dynamic_cast<const T *>(this); if ((node) != nullptr) clone = clone_what(node); }
-NodeCloneFunc(CubeNode)
-NodeCloneFunc(SphereNode)
-NodeCloneFunc(CylinderNode)
-NodeCloneFunc(PolyhedronNode)
-NodeCloneFunc(SquareNode)
-NodeCloneFunc(CircleNode)
-NodeCloneFunc(PolygonNode)
-NodeCloneFunc(TransformNode)
-NodeCloneFunc(ColorNode)
-NodeCloneFunc(RotateExtrudeNode)
-NodeCloneFunc(LinearExtrudeNode)
-NodeCloneFunc(CsgOpNode)
-NodeCloneFunc(CgalAdvNode)
-NodeCloneFunc(RenderNode)
-NodeCloneFunc(SurfaceNode)
-NodeCloneFunc(TextNode)
-NodeCloneFunc(OffsetNode)
-NodeCloneFunc(ProjectionNode)
-NodeCloneFunc(GroupNode)
-NodeCloneFunc(ImportNode)
+#define NodeCloneUse(T)                           \
+  {                                               \
+    const T* node = dynamic_cast<const T*>(this); \
+    if ((node) != nullptr)                        \
+      clone = clone_what(node);                   \
+  }
+NodeCloneFunc(CubeNode) NodeCloneFunc(SphereNode) NodeCloneFunc(
+    CylinderNode) NodeCloneFunc(PolyhedronNode) NodeCloneFunc(SquareNode)
+    NodeCloneFunc(CircleNode) NodeCloneFunc(PolygonNode) NodeCloneFunc(
+        TransformNode) NodeCloneFunc(ColorNode) NodeCloneFunc(RotateExtrudeNode)
+        NodeCloneFunc(LinearExtrudeNode) NodeCloneFunc(CsgOpNode) NodeCloneFunc(
+            CgalAdvNode) NodeCloneFunc(RenderNode) NodeCloneFunc(SurfaceNode)
+            NodeCloneFunc(TextNode) NodeCloneFunc(OffsetNode)
+                NodeCloneFunc(ProjectionNode) NodeCloneFunc(GroupNode)
+                    NodeCloneFunc(ImportNode)
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-NodeCloneFunc(RoofNode)
+                        NodeCloneFunc(RoofNode)
 #endif
 
-std::shared_ptr<AbstractNode> AbstractNode::clone(void)
-{
+                            std::shared_ptr<AbstractNode> AbstractNode::clone(
+                                void) {
   std::shared_ptr<AbstractNode> clone = nullptr;
-  NodeCloneUse(CubeNode)
-  NodeCloneUse(SphereNode)
-  NodeCloneUse(CylinderNode)
-  NodeCloneUse(PolyhedronNode)
-  NodeCloneUse(SquareNode)
-  NodeCloneUse(CircleNode)
-  NodeCloneUse(PolygonNode)
-  NodeCloneUse(TransformNode)
-  NodeCloneUse(ColorNode)
-  NodeCloneUse(RotateExtrudeNode)
-  NodeCloneUse(LinearExtrudeNode)
-  NodeCloneUse(CsgOpNode)
-  NodeCloneUse(CgalAdvNode)
-  NodeCloneUse(RenderNode)
-  NodeCloneUse(SurfaceNode)
-  NodeCloneUse(TextNode)
-  NodeCloneUse(OffsetNode)
-  NodeCloneUse(ProjectionNode)
-  NodeCloneUse(GroupNode)
-  NodeCloneUse(ImportNode)
+  NodeCloneUse(CubeNode) NodeCloneUse(SphereNode) NodeCloneUse(CylinderNode)
+      NodeCloneUse(PolyhedronNode) NodeCloneUse(SquareNode) NodeCloneUse(
+          CircleNode) NodeCloneUse(PolygonNode) NodeCloneUse(TransformNode)
+          NodeCloneUse(ColorNode) NodeCloneUse(RotateExtrudeNode)
+              NodeCloneUse(LinearExtrudeNode) NodeCloneUse(CsgOpNode)
+                  NodeCloneUse(CgalAdvNode) NodeCloneUse(RenderNode)
+                      NodeCloneUse(SurfaceNode) NodeCloneUse(TextNode)
+                          NodeCloneUse(OffsetNode) NodeCloneUse(ProjectionNode)
+                              NodeCloneUse(GroupNode) NodeCloneUse(ImportNode)
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  NodeCloneUse(RoofNode)
+                                  NodeCloneUse(RoofNode)
 #endif
-  if (clone != nullptr) {
+                                      if (clone != nullptr) {
     clone->idx = idx_counter++;
     clone->children.clear();
-    for (const auto& child: this->children) {
+    for (const auto& child : this->children) {
       clone->children.push_back(child->clone());
     }
     return clone;
diff --git a/src/core/parsersettings.cc b/src/core/parsersettings.cc
index 2a867fdb6..f11a4f44e 100644
--- a/src/core/parsersettings.cc
+++ b/src/core/parsersettings.cc
@@ -1,35 +1,33 @@
 #include "core/parsersettings.h"
 
 #include <algorithm>
-#include <iterator>
 #include <cassert>
+#include <iterator>
 #include <string>
 #include <vector>
 
-#include <filesystem>
 #include <boost/algorithm/string.hpp>
+#include <filesystem>
 #include "platform/PlatformUtils.h"
 
 namespace fs = std::filesystem;
 
 std::vector<std::string> librarypath;
 
-static void add_librarydir(const std::string& libdir)
-{
+static void add_librarydir(const std::string& libdir) {
   librarypath.push_back(libdir);
 }
 
-const std::vector<std::string>& get_library_path()
-{
+const std::vector<std::string>& get_library_path() {
   return librarypath;
 }
 
 /*!
-   Searces for the given file in library paths and returns the full path if found.
-   Returns an empty path if file cannot be found or filename is a directory.
+   Searces for the given file in library paths and returns the full path if
+   found. Returns an empty path if file cannot be found or filename is a
+   directory.
  */
-fs::path search_libs(const fs::path& localpath)
-{
+fs::path search_libs(const fs::path& localpath) {
   for (const auto& dir : librarypath) {
     fs::path usepath = fs::path(dir) / localpath;
     if (fs::exists(usepath) && !fs::is_directory(usepath)) {
@@ -40,10 +38,10 @@ fs::path search_libs(const fs::path& localpath)
 }
 
 // files must be 'ordinary' - they must exist and be non-directories
-// FIXME: We cannot print any output here since these function is called periodically
-// from "Automatic reload and compile"
-static bool check_valid(const fs::path& p, const std::vector<std::string> *openfilenames)
-{
+// FIXME: We cannot print any output here since these function is called
+// periodically from "Automatic reload and compile"
+static bool check_valid(const fs::path& p,
+                        const std::vector<std::string>* openfilenames) {
   if (p.empty()) {
     // LOG(message_group::Warning,,"File path is blank: %1$s",p);
     return false;
@@ -82,10 +80,10 @@ static bool check_valid(const fs::path& p, const std::vector<std::string> *openf
    Returns the absolute path to a valid file, or an empty path if no
    valid files could be found.
  */
-inline fs::path find_valid_path_(const fs::path& sourcepath,
-                                 const fs::path& localpath,
-                                 const std::vector<std::string> *openfilenames)
-{
+inline fs::path find_valid_path_(
+    const fs::path& sourcepath,
+    const fs::path& localpath,
+    const std::vector<std::string>* openfilenames) {
   if (localpath.is_absolute()) {
     if (check_valid(localpath, openfilenames)) {
 #ifndef __EMSCRIPTEN__
@@ -97,30 +95,32 @@ inline fs::path find_valid_path_(const fs::path& sourcepath,
   } else {
     fs::path fpath = sourcepath / localpath;
 #ifndef __EMSCRIPTEN__
-    if (fs::exists(fpath)) fpath = fs::canonical(fpath);
+    if (fs::exists(fpath))
+      fpath = fs::canonical(fpath);
 #endif
-    if (check_valid(fpath, openfilenames)) return fpath;
+    if (check_valid(fpath, openfilenames))
+      return fpath;
     fpath = search_libs(localpath);
-    if (!fpath.empty() && check_valid(fpath, openfilenames)) return fpath;
+    if (!fpath.empty() && check_valid(fpath, openfilenames))
+      return fpath;
   }
   return {};
 }
 
 fs::path find_valid_path(const fs::path& sourcepath,
                          const fs::path& localpath,
-                         const std::vector<std::string> *openfilenames)
-{
-  return {find_valid_path_(sourcepath, localpath, openfilenames).generic_string()};
+                         const std::vector<std::string>* openfilenames) {
+  return {
+      find_valid_path_(sourcepath, localpath, openfilenames).generic_string()};
 }
 
-
-static bool path_contains_file(fs::path dir, fs::path file)
-{
+static bool path_contains_file(fs::path dir, fs::path file) {
   // from https://stackoverflow.com/a/15549954/1080604
   // If dir ends with "/" and isn't the root directory, then the final
   // component returned by iterators will include "." and will interfere
   // with the std::equal check below, so we strip it before proceeding.
-  if (dir.filename() == ".") dir.remove_filename();
+  if (dir.filename() == ".")
+    dir.remove_filename();
   // We're also not interested in the file's name.
   assert(file.has_filename());
   file.remove_filename();
@@ -129,15 +129,15 @@ static bool path_contains_file(fs::path dir, fs::path file)
   // reside in dir.
   auto dir_len = std::distance(dir.begin(), dir.end());
   auto file_len = std::distance(file.begin(), file.end());
-  if (dir_len > file_len) return false;
+  if (dir_len > file_len)
+    return false;
 
   // This stops checking when it reaches dir.end(), so it's OK if file
   // has more directory components afterward. They won't be checked.
   return std::equal(dir.begin(), dir.end(), file.begin());
 }
 
-fs::path get_library_for_path(const fs::path& localpath)
-{
+fs::path get_library_for_path(const fs::path& localpath) {
   for (const auto& libpath : librarypath) {
     if (path_contains_file(fs::path(libpath), localpath)) {
       return libpath;
@@ -146,18 +146,19 @@ fs::path get_library_for_path(const fs::path& localpath)
   return {};
 }
 
-
-void parser_init()
-{
+void parser_init() {
   // Add paths from OPENSCADPATH before adding built-in paths
-  const char *openscadpaths = getenv("OPENSCADPATH");
+  const char* openscadpaths = getenv("OPENSCADPATH");
   if (openscadpaths) {
     std::string paths(openscadpaths);
     std::string sep = PlatformUtils::pathSeparatorChar();
     using string_split_iterator = boost::split_iterator<std::string::iterator>;
-    for (string_split_iterator it = boost::make_split_iterator(paths, boost::first_finder(sep, boost::is_iequal())); it != string_split_iterator(); ++it) {
+    for (string_split_iterator it = boost::make_split_iterator(
+             paths, boost::first_finder(sep, boost::is_iequal()));
+         it != string_split_iterator(); ++it) {
       auto str{boost::copy_range<std::string>(*it)};
-      fs::path abspath = str.empty() ? fs::current_path() : fs::absolute(fs::path(str));
+      fs::path abspath =
+          str.empty() ? fs::current_path() : fs::absolute(fs::path(str));
       add_librarydir(abspath.generic_string());
     }
   }
diff --git a/src/core/parsersettings.h b/src/core/parsersettings.h
index 7ae3a9a5e..5534a259d 100644
--- a/src/core/parsersettings.h
+++ b/src/core/parsersettings.h
@@ -1,8 +1,8 @@
 #pragma once
 
+#include <filesystem>
 #include <string>
 #include <vector>
-#include <filesystem>
 
 namespace fs = std::filesystem;
 
@@ -14,9 +14,10 @@ extern int parser_error_pos;
 void parser_init();
 
 fs::path search_libs(const fs::path& localpath);
-fs::path find_valid_path(const fs::path& sourcepath,
-                         const fs::path& localpath,
-                         const std::vector<std::string> *openfilenames = nullptr);
+fs::path find_valid_path(
+    const fs::path& sourcepath,
+    const fs::path& localpath,
+    const std::vector<std::string>* openfilenames = nullptr);
 fs::path get_library_for_path(const fs::path& localpath);
 
 const std::vector<std::string>& get_library_path();
\ No newline at end of file
diff --git a/src/core/primitives.cc b/src/core/primitives.cc
index 3db0f7aba..72f9fba50 100644
--- a/src/core/primitives.cc
+++ b/src/core/primitives.cc
@@ -25,40 +25,43 @@
  */
 
 #include "core/primitives.h"
-#include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "core/Builtins.h"
-#include "core/Children.h"
-#include "core/ModuleInstantiation.h"
-#include "core/Parameters.h"
-#include "geometry/PolySet.h"
-#include "geometry/Polygon2d.h"
-#include "utils/calc.h"
-#include "core/node.h"
-#include "utils/degree_trig.h"
-#include "core/module.h"
-#include "utils/printutils.h"
 #include <algorithm>
-#include <utility>
 #include <boost/assign/std/vector.hpp>
 #include <cassert>
-#include <cstddef>
 #include <cmath>
+#include <cstddef>
 #include <iterator>
 #include <memory>
 #include <sstream>
 #include <string>
+#include <utility>
 #include <vector>
+#include "core/Builtins.h"
+#include "core/Children.h"
+#include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/module.h"
+#include "core/node.h"
+#include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
+#include "utils/calc.h"
+#include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
-using namespace boost::assign; // bring 'operator+=()' into scope
+using namespace boost::assign;  // bring 'operator+=()' into scope
 
 #define F_MINIMUM 0.01
 
 template <class InsertIterator>
-static void generate_circle(InsertIterator iter, double r, double z, int fragments) {
+static void generate_circle(InsertIterator iter,
+                            double r,
+                            double z,
+                            int fragments) {
   for (int i = 0; i < fragments; ++i) {
     double phi = (360.0 * i) / fragments;
-    *(iter++) = {r *cos_degrees(phi), r *sin_degrees(phi), z};
+    *(iter++) = {r * cos_degrees(phi), r * sin_degrees(phi), z};
   }
 }
 
@@ -71,11 +74,13 @@ static void generate_circle(InsertIterator iter, double r, double z, int fragmen
  * @param inst containing instantiation.
  * @param radius_var name of the variable to lookup for the radius value.
  * @param diameter_var name of the variable to lookup for the diameter value.
- * @return radius value of type Value::Type::NUMBER or Value::Type::UNDEFINED if both
- *         variables are invalid or not set.
+ * @return radius value of type Value::Type::NUMBER or Value::Type::UNDEFINED if
+ * both variables are invalid or not set.
  */
-static Value lookup_radius(const Parameters& parameters, const ModuleInstantiation *inst, const std::string& diameter_var, const std::string& radius_var)
-{
+static Value lookup_radius(const Parameters& parameters,
+                           const ModuleInstantiation* inst,
+                           const std::string& diameter_var,
+                           const std::string& radius_var) {
   const auto& d = parameters[diameter_var];
   const auto& r = parameters[radius_var];
   const auto r_defined = (r.type() == Value::Type::NUMBER);
@@ -94,8 +99,11 @@ static Value lookup_radius(const Parameters& parameters, const ModuleInstantiati
   }
 }
 
-static void set_fragments(const Parameters& parameters, const ModuleInstantiation *inst, double& fn, double& fs, double& fa)
-{
+static void set_fragments(const Parameters& parameters,
+                          const ModuleInstantiation* inst,
+                          double& fn,
+                          double& fs,
+                          double& fa) {
   fn = parameters["$fn"].toDouble();
   fs = parameters["$fs"].toDouble();
   fa = parameters["$fa"].toDouble();
@@ -112,14 +120,9 @@ static void set_fragments(const Parameters& parameters, const ModuleInstantiatio
   }
 }
 
-
-
-std::unique_ptr<const Geometry> CubeNode::createGeometry() const
-{
-  if (this->x <= 0 || !std::isfinite(this->x)
-      || this->y <= 0 || !std::isfinite(this->y)
-      || this->z <= 0 || !std::isfinite(this->z)
-      ) {
+std::unique_ptr<const Geometry> CubeNode::createGeometry() const {
+  if (this->x <= 0 || !std::isfinite(this->x) || this->y <= 0 ||
+      !std::isfinite(this->y) || this->z <= 0 || !std::isfinite(this->z)) {
     return PolySet::createEmpty();
   }
 
@@ -143,22 +146,24 @@ std::unique_ptr<const Geometry> CubeNode::createGeometry() const
                               i & 4 ? z2 : z1);
   }
   ps->indices = {
-    {4, 5, 7, 6},   // top
-    {2, 3, 1, 0},   // bottom
-    {0, 1, 5, 4},   // front
-    {1, 3, 7, 5},   // right
-    {3, 2, 6, 7},   // back
-    {2, 0, 4, 6},   // left
+      {4, 5, 7, 6},  // top
+      {2, 3, 1, 0},  // bottom
+      {0, 1, 5, 4},  // front
+      {1, 3, 7, 5},  // right
+      {3, 2, 6, 7},  // back
+      {2, 0, 4, 6},  // left
   };
 
   return ps;
 }
 
-static std::shared_ptr<AbstractNode> builtin_cube(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_cube(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<CubeNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"size", "center"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"size", "center"});
 
   const auto& size = parameters["size"];
   if (size.isDefined()) {
@@ -168,12 +173,17 @@ static std::shared_ptr<AbstractNode> builtin_cube(const ModuleInstantiation *ins
     converted |= size.getDouble(node->z);
     converted |= size.getVec3(node->x, node->y, node->z);
     if (!converted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert cube(size=%1$s, ...) parameter to a number or a vec3 of numbers", size.toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Unable to convert cube(size=%1$s, ...) parameter to a number or a "
+          "vec3 of numbers",
+          size.toEchoStringNoThrow());
     } else if (OpenSCAD::rangeCheck) {
       bool ok = (node->x > 0) && (node->y > 0) && (node->z > 0);
-      ok &= std::isfinite(node->x) && std::isfinite(node->y) && std::isfinite(node->z);
+      ok &= std::isfinite(node->x) && std::isfinite(node->y) &&
+            std::isfinite(node->z);
       if (!ok) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "cube(size=%1$s, ...)", size.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "cube(size=%1$s, ...)", size.toEchoStringNoThrow());
       }
     }
   }
@@ -184,8 +194,7 @@ static std::shared_ptr<AbstractNode> builtin_cube(const ModuleInstantiation *ins
   return node;
 }
 
-std::unique_ptr<const Geometry> SphereNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> SphereNode::createGeometry() const {
   if (this->r <= 0 || !std::isfinite(this->r)) {
     return PolySet::createEmpty();
   }
@@ -194,8 +203,8 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
   size_t num_rings = (num_fragments + 1) / 2;
   // Uncomment the following three lines to enable experimental sphere
   // tessellation
-  //  if (num_rings % 2 == 0) num_rings++; // To ensure that the middle ring is at
-  //  phi == 0 degrees
+  //  if (num_rings % 2 == 0) num_rings++; // To ensure that the middle ring is
+  //  at phi == 0 degrees
 
   auto polyset = std::make_unique<PolySet>(3, /*convex*/ true);
   polyset->vertices.reserve(num_rings * num_fragments);
@@ -205,7 +214,8 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
     //                double phi = (180.0 * (i + offset)) / (fragments/2);
     const double phi = (180.0 * (i + 0.5)) / num_rings;
     const double radius = r * sin_degrees(phi);
-    generate_circle(std::back_inserter(polyset->vertices), radius, r * cos_degrees(phi), num_fragments);
+    generate_circle(std::back_inserter(polyset->vertices), radius,
+                    r * cos_degrees(phi), num_fragments);
   }
 
   polyset->indices.push_back({});
@@ -216,10 +226,10 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
   for (int i = 0; i < num_rings - 1; ++i) {
     for (int r = 0; r < num_fragments; ++r) {
       polyset->indices.push_back({
-        i *num_fragments + (r + 1) % num_fragments,
-        i * num_fragments + r,
-        (i + 1) * num_fragments + r,
-        (i + 1) * num_fragments + (r + 1) % num_fragments,
+          i * num_fragments + (r + 1) % num_fragments,
+          i * num_fragments + r,
+          (i + 1) * num_fragments + r,
+          (i + 1) * num_fragments + (r + 1) % num_fragments,
       });
     }
   }
@@ -232,11 +242,13 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
   return polyset;
 }
 
-static std::shared_ptr<AbstractNode> builtin_sphere(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_sphere(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<SphereNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
 
   set_fragments(parameters, inst, node->fn, node->fs, node->fa);
   const auto r = lookup_radius(parameters, inst, "d", "r");
@@ -251,20 +263,15 @@ static std::shared_ptr<AbstractNode> builtin_sphere(const ModuleInstantiation *i
   return node;
 }
 
-
-
-std::unique_ptr<const Geometry> CylinderNode::createGeometry() const
-{
-  if (
-    this->h <= 0 || !std::isfinite(this->h)
-    || this->r1 < 0 || !std::isfinite(this->r1)
-    || this->r2 < 0 || !std::isfinite(this->r2)
-    || (this->r1 <= 0 && this->r2 <= 0)
-    ) {
+std::unique_ptr<const Geometry> CylinderNode::createGeometry() const {
+  if (this->h <= 0 || !std::isfinite(this->h) || this->r1 < 0 ||
+      !std::isfinite(this->r1) || this->r2 < 0 || !std::isfinite(this->r2) ||
+      (this->r1 <= 0 && this->r2 <= 0)) {
     return PolySet::createEmpty();
   }
 
-  auto num_fragments = Calc::get_fragments_from_r(std::fmax(this->r1, this->r2), this->fn, this->fs, this->fa);
+  auto num_fragments = Calc::get_fragments_from_r(std::fmax(this->r1, this->r2),
+                                                  this->fn, this->fs, this->fa);
 
   double z1, z2;
   if (this->center) {
@@ -279,24 +286,30 @@ std::unique_ptr<const Geometry> CylinderNode::createGeometry() const
   bool inverted_cone = (r1 == 0.0);
 
   auto polyset = std::make_unique<PolySet>(3, /*convex*/ true);
-  polyset->vertices.reserve((cone || inverted_cone) ? num_fragments + 1 : 2 * num_fragments);
+  polyset->vertices.reserve((cone || inverted_cone) ? num_fragments + 1
+                                                    : 2 * num_fragments);
 
   if (inverted_cone) {
     polyset->vertices.emplace_back(0.0, 0.0, z1);
   } else {
-    generate_circle(std::back_inserter(polyset->vertices), r1, z1, num_fragments);
+    generate_circle(std::back_inserter(polyset->vertices), r1, z1,
+                    num_fragments);
   }
   if (cone) {
     polyset->vertices.emplace_back(0.0, 0.0, z2);
   } else {
-    generate_circle(std::back_inserter(polyset->vertices), r2, z2, num_fragments);
+    generate_circle(std::back_inserter(polyset->vertices), r2, z2,
+                    num_fragments);
   }
 
   for (int i = 0; i < num_fragments; ++i) {
     int j = (i + 1) % num_fragments;
-    if (cone) polyset->indices.push_back({i, j, num_fragments});
-    else if (inverted_cone) polyset->indices.push_back({0, j + 1, i + 1});
-    else polyset->indices.push_back({i, j, j + num_fragments, i + num_fragments});
+    if (cone)
+      polyset->indices.push_back({i, j, num_fragments});
+    else if (inverted_cone)
+      polyset->indices.push_back({0, j + 1, i + 1});
+    else
+      polyset->indices.push_back({i, j, j + num_fragments, i + num_fragments});
   }
 
   if (!inverted_cone) {
@@ -316,11 +329,14 @@ std::unique_ptr<const Geometry> CylinderNode::createGeometry() const
   return polyset;
 }
 
-static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_cylinder(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<CylinderNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"h", "r1", "r2", "center"}, {"r", "d", "d1", "d2"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(),
+                        {"h", "r1", "r2", "center"}, {"r", "d", "d1", "d2"});
 
   set_fragments(parameters, inst, node->fn, node->fs, node->fa);
   if (parameters["h"].type() == Value::Type::NUMBER) {
@@ -331,9 +347,9 @@ static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation
   auto r1 = lookup_radius(parameters, inst, "d1", "r1");
   auto r2 = lookup_radius(parameters, inst, "d2", "r2");
   if (r.type() == Value::Type::NUMBER &&
-      (r1.type() == Value::Type::NUMBER || r2.type() == Value::Type::NUMBER)
-      ) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Cylinder parameters ambiguous");
+      (r1.type() == Value::Type::NUMBER || r2.type() == Value::Type::NUMBER)) {
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Cylinder parameters ambiguous");
   }
 
   if (r.type() == Value::Type::NUMBER) {
@@ -349,13 +365,17 @@ static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation
 
   if (OpenSCAD::rangeCheck) {
     if (node->h <= 0 || !std::isfinite(node->h)) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "cylinder(h=%1$s, ...)", parameters["h"].toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "cylinder(h=%1$s, ...)", parameters["h"].toEchoStringNoThrow());
     }
-    if (node->r1 < 0 || node->r2 < 0 || (node->r1 == 0 && node->r2 == 0) || !std::isfinite(node->r1) || !std::isfinite(node->r2)) {
+    if (node->r1 < 0 || node->r2 < 0 || (node->r1 == 0 && node->r2 == 0) ||
+        !std::isfinite(node->r1) || !std::isfinite(node->r2)) {
       LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
           "cylinder(r1=%1$s, r2=%2$s, ...)",
-          (r1.type() == Value::Type::NUMBER ? r1.toEchoStringNoThrow() : r.toEchoStringNoThrow()),
-          (r2.type() == Value::Type::NUMBER ? r2.toEchoStringNoThrow() : r.toEchoStringNoThrow()));
+          (r1.type() == Value::Type::NUMBER ? r1.toEchoStringNoThrow()
+                                            : r.toEchoStringNoThrow()),
+          (r2.type() == Value::Type::NUMBER ? r2.toEchoStringNoThrow()
+                                            : r.toEchoStringNoThrow()));
     }
   }
 
@@ -366,9 +386,7 @@ static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation
   return node;
 }
 
-
-std::string PolyhedronNode::toString() const
-{
+std::string PolyhedronNode::toString() const {
   std::ostringstream stream;
   stream << "polyhedron(points = [";
   bool firstPoint = true;
@@ -404,8 +422,7 @@ std::string PolyhedronNode::toString() const
   return stream.str();
 }
 
-std::unique_ptr<const Geometry> PolyhedronNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> PolyhedronNode::createGeometry() const {
   auto p = PolySet::createEmpty();
   p->setConvexity(this->convexity);
   p->vertices = this->points;
@@ -421,58 +438,78 @@ std::unique_ptr<const Geometry> PolyhedronNode::createGeometry() const
   return p;
 }
 
-static std::shared_ptr<AbstractNode> builtin_polyhedron(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_polyhedron(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<PolyhedronNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"points", "faces", "convexity"}, {"triangles"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(),
+                        {"points", "faces", "convexity"}, {"triangles"});
 
   if (parameters["points"].type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points = %1$s to a vector of coordinates", parameters["points"].toEchoStringNoThrow());
+    LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+        "Unable to convert points = %1$s to a vector of coordinates",
+        parameters["points"].toEchoStringNoThrow());
     return node;
   }
   node->points.reserve(parameters["points"].toVector().size());
   for (const Value& pointValue : parameters["points"].toVector()) {
     Vector3d point;
     if (!pointValue.getVec3(point[0], point[1], point[2], 0.0) ||
-        !std::isfinite(point[0]) || !std::isfinite(point[1]) || !std::isfinite(point[2])
-        ) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points[%1$d] = %2$s to a vec3 of numbers", node->points.size(), pointValue.toEchoStringNoThrow());
+        !std::isfinite(point[0]) || !std::isfinite(point[1]) ||
+        !std::isfinite(point[2])) {
+      LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+          "Unable to convert points[%1$d] = %2$s to a vec3 of numbers",
+          node->points.size(), pointValue.toEchoStringNoThrow());
       node->points.push_back({0, 0, 0});
     } else {
       node->points.push_back(point);
     }
   }
 
-  const Value *faces = nullptr;
-  if (parameters["faces"].type() == Value::Type::UNDEFINED && parameters["triangles"].type() != Value::Type::UNDEFINED) {
+  const Value* faces = nullptr;
+  if (parameters["faces"].type() == Value::Type::UNDEFINED &&
+      parameters["triangles"].type() != Value::Type::UNDEFINED) {
     // backwards compatible
-    LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in future releases. Use polyhedron(faces=[]) instead.");
+    LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(),
+        "polyhedron(triangles=[]) will be removed in future releases. Use "
+        "polyhedron(faces=[]) instead.");
     faces = &parameters["triangles"];
   } else {
     faces = &parameters["faces"];
   }
   if (faces->type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces = %1$s to a vector of vector of point indices", faces->toEchoStringNoThrow());
+    LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+        "Unable to convert faces = %1$s to a vector of vector of point indices",
+        faces->toEchoStringNoThrow());
     return node;
   }
   size_t faceIndex = 0;
   node->faces.reserve(faces->toVector().size());
   for (const Value& faceValue : faces->toVector()) {
     if (faceValue.type() != Value::Type::VECTOR) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces[%1$d] = %2$s to a vector of numbers", faceIndex, faceValue.toEchoStringNoThrow());
+      LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+          "Unable to convert faces[%1$d] = %2$s to a vector of numbers",
+          faceIndex, faceValue.toEchoStringNoThrow());
     } else {
       size_t pointIndexIndex = 0;
       IndexedFace face;
       for (const Value& pointIndexValue : faceValue.toVector()) {
         if (pointIndexValue.type() != Value::Type::NUMBER) {
-          LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces[%1$d][%2$d] = %3$s to a number", faceIndex, pointIndexIndex, pointIndexValue.toEchoStringNoThrow());
+          LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+              "Unable to convert faces[%1$d][%2$d] = %3$s to a number",
+              faceIndex, pointIndexIndex,
+              pointIndexValue.toEchoStringNoThrow());
         } else {
           auto pointIndex = (size_t)pointIndexValue.toDouble();
           if (pointIndex < node->points.size()) {
             face.push_back(pointIndex);
           } else {
-            LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Point index %1$d is out of bounds (from faces[%2$d][%3$d])", pointIndex, faceIndex, pointIndexIndex);
+            LOG(message_group::Warning, inst->location(),
+                parameters.documentRoot(),
+                "Point index %1$d is out of bounds (from faces[%2$d][%3$d])",
+                pointIndex, faceIndex, pointIndexIndex);
           }
         }
         pointIndexIndex++;
@@ -486,16 +523,15 @@ static std::shared_ptr<AbstractNode> builtin_polyhedron(const ModuleInstantiatio
   }
 
   node->convexity = (int)parameters["convexity"].toDouble();
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return node;
 }
 
-
-std::unique_ptr<const Geometry> SquareNode::createGeometry() const
-{
-  if (this->x <= 0 || !std::isfinite(this->x) ||
-      this->y <= 0 || !std::isfinite(this->y)) {
+std::unique_ptr<const Geometry> SquareNode::createGeometry() const {
+  if (this->x <= 0 || !std::isfinite(this->x) || this->y <= 0 ||
+      !std::isfinite(this->y)) {
     return std::make_unique<Polygon2d>();
   }
 
@@ -511,11 +547,13 @@ std::unique_ptr<const Geometry> SquareNode::createGeometry() const
   return std::make_unique<Polygon2d>(o);
 }
 
-static std::shared_ptr<AbstractNode> builtin_square(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_square(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<SquareNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"size", "center"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"size", "center"});
 
   const auto& size = parameters["size"];
   if (size.isDefined()) {
@@ -524,13 +562,17 @@ static std::shared_ptr<AbstractNode> builtin_square(const ModuleInstantiation *i
     converted |= size.getDouble(node->y);
     converted |= size.getVec2(node->x, node->y);
     if (!converted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert square(size=%1$s, ...) parameter to a number or a vec2 of numbers", size.toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Unable to convert square(size=%1$s, ...) parameter to a number or a "
+          "vec2 of numbers",
+          size.toEchoStringNoThrow());
     } else if (OpenSCAD::rangeCheck) {
       bool ok = true;
       ok &= (node->x > 0) && (node->y > 0);
       ok &= std::isfinite(node->x) && std::isfinite(node->y);
       if (!ok) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "square(size=%1$s, ...)", size.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "square(size=%1$s, ...)", size.toEchoStringNoThrow());
       }
     }
   }
@@ -541,13 +583,13 @@ static std::shared_ptr<AbstractNode> builtin_square(const ModuleInstantiation *i
   return node;
 }
 
-std::unique_ptr<const Geometry> CircleNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> CircleNode::createGeometry() const {
   if (this->r <= 0 || !std::isfinite(this->r)) {
     return std::make_unique<Polygon2d>();
   }
 
-  auto fragments = Calc::get_fragments_from_r(this->r, this->fn, this->fs, this->fa);
+  auto fragments =
+      Calc::get_fragments_from_r(this->r, this->fn, this->fs, this->fa);
   Outline2d o;
   o.vertices.resize(fragments);
   for (int i = 0; i < fragments; ++i) {
@@ -557,11 +599,13 @@ std::unique_ptr<const Geometry> CircleNode::createGeometry() const
   return std::make_unique<Polygon2d>(o);
 }
 
-static std::shared_ptr<AbstractNode> builtin_circle(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_circle(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<CircleNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
 
   set_fragments(parameters, inst, node->fn, node->fs, node->fa);
   const auto r = lookup_radius(parameters, inst, "d", "r");
@@ -576,10 +620,7 @@ static std::shared_ptr<AbstractNode> builtin_circle(const ModuleInstantiation *i
   return node;
 }
 
-
-
-std::string PolygonNode::toString() const
-{
+std::string PolygonNode::toString() const {
   std::ostringstream stream;
   stream << "polygon(points = [";
   bool firstPoint = true;
@@ -621,8 +662,7 @@ std::string PolygonNode::toString() const
   return stream.str();
 }
 
-std::unique_ptr<const Geometry> PolygonNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> PolygonNode::createGeometry() const {
   auto p = std::make_unique<Polygon2d>();
   if (this->paths.empty() && this->points.size() > 2) {
     Outline2d outline;
@@ -631,7 +671,7 @@ std::unique_ptr<const Geometry> PolygonNode::createGeometry() const
     }
     p->addOutline(outline);
   } else {
-    bool positive = true; // First outline is positive
+    bool positive = true;  // First outline is positive
     for (const auto& path : this->paths) {
       Outline2d outline;
       for (const auto& index : path) {
@@ -641,7 +681,7 @@ std::unique_ptr<const Geometry> PolygonNode::createGeometry() const
       }
       outline.positive = positive;
       p->addOutline(outline);
-      positive = false; // Subsequent outlines are holes
+      positive = false;  // Subsequent outlines are holes
     }
   }
   if (p->outlines().size() > 0) {
@@ -650,22 +690,27 @@ std::unique_ptr<const Geometry> PolygonNode::createGeometry() const
   return p;
 }
 
-static std::shared_ptr<AbstractNode> builtin_polygon(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode> builtin_polygon(
+    const ModuleInstantiation* inst,
+    Arguments arguments) {
   auto node = std::make_shared<PolygonNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"points", "paths", "convexity"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"points", "paths", "convexity"});
 
   if (parameters["points"].type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points = %1$s to a vector of coordinates", parameters["points"].toEchoStringNoThrow());
+    LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+        "Unable to convert points = %1$s to a vector of coordinates",
+        parameters["points"].toEchoStringNoThrow());
     return node;
   }
   for (const Value& pointValue : parameters["points"].toVector()) {
     Vector2d point;
-    if (!pointValue.getVec2(point[0], point[1]) ||
-        !std::isfinite(point[0]) || !std::isfinite(point[1])
-        ) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points[%1$d] = %2$s to a vec2 of numbers", node->points.size(), pointValue.toEchoStringNoThrow());
+    if (!pointValue.getVec2(point[0], point[1]) || !std::isfinite(point[0]) ||
+        !std::isfinite(point[1])) {
+      LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+          "Unable to convert points[%1$d] = %2$s to a vec2 of numbers",
+          node->points.size(), pointValue.toEchoStringNoThrow());
       node->points.push_back({0, 0});
     } else {
       node->points.push_back(point);
@@ -676,19 +721,28 @@ static std::shared_ptr<AbstractNode> builtin_polygon(const ModuleInstantiation *
     size_t pathIndex = 0;
     for (const Value& pathValue : parameters["paths"].toVector()) {
       if (pathValue.type() != Value::Type::VECTOR) {
-        LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths[%1$d] = %2$s to a vector of numbers", pathIndex, pathValue.toEchoStringNoThrow());
+        LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+            "Unable to convert paths[%1$d] = %2$s to a vector of numbers",
+            pathIndex, pathValue.toEchoStringNoThrow());
       } else {
         size_t pointIndexIndex = 0;
         std::vector<size_t> path;
         for (const Value& pointIndexValue : pathValue.toVector()) {
           if (pointIndexValue.type() != Value::Type::NUMBER) {
-            LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths[%1$d][%2$d] = %3$s to a number", pathIndex, pointIndexIndex, pointIndexValue.toEchoStringNoThrow());
+            LOG(message_group::Error, inst->location(),
+                parameters.documentRoot(),
+                "Unable to convert paths[%1$d][%2$d] = %3$s to a number",
+                pathIndex, pointIndexIndex,
+                pointIndexValue.toEchoStringNoThrow());
           } else {
             auto pointIndex = (size_t)pointIndexValue.toDouble();
             if (pointIndex < node->points.size()) {
               path.push_back(pointIndex);
             } else {
-              LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Point index %1$d is out of bounds (from paths[%2$d][%3$d])", pointIndex, pathIndex, pointIndexIndex);
+              LOG(message_group::Warning, inst->location(),
+                  parameters.documentRoot(),
+                  "Point index %1$d is out of bounds (from paths[%2$d][%3$d])",
+                  pointIndex, pathIndex, pointIndexIndex);
             }
           }
           pointIndexIndex++;
@@ -698,64 +752,65 @@ static std::shared_ptr<AbstractNode> builtin_polygon(const ModuleInstantiation *
       pathIndex++;
     }
   } else if (parameters["paths"].type() != Value::Type::UNDEFINED) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths = %1$s to a vector of vector of point indices", parameters["paths"].toEchoStringNoThrow());
+    LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+        "Unable to convert paths = %1$s to a vector of vector of point indices",
+        parameters["paths"].toEchoStringNoThrow());
     return node;
   }
 
   node->convexity = (int)parameters["convexity"].toDouble();
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return node;
 }
 
-
-
-void register_builtin_primitives()
-{
+void register_builtin_primitives() {
   Builtins::init("cube", new BuiltinModule(builtin_cube),
-  {
-    "cube(size)",
-    "cube([width, depth, height])",
-    "cube([width, depth, height], center = true)",
-  });
+                 {
+                     "cube(size)",
+                     "cube([width, depth, height])",
+                     "cube([width, depth, height], center = true)",
+                 });
 
   Builtins::init("sphere", new BuiltinModule(builtin_sphere),
-  {
-    "sphere(radius)",
-    "sphere(r = radius)",
-    "sphere(d = diameter)",
-  });
-
-  Builtins::init("cylinder", new BuiltinModule(builtin_cylinder),
-  {
-    "cylinder(h, r1, r2)",
-    "cylinder(h = height, r = radius, center = true)",
-    "cylinder(h = height, r1 = bottom, r2 = top, center = true)",
-    "cylinder(h = height, d = diameter, center = true)",
-    "cylinder(h = height, d1 = bottom, d2 = top, center = true)",
-  });
+                 {
+                     "sphere(radius)",
+                     "sphere(r = radius)",
+                     "sphere(d = diameter)",
+                 });
+
+  Builtins::init(
+      "cylinder", new BuiltinModule(builtin_cylinder),
+      {
+          "cylinder(h, r1, r2)",
+          "cylinder(h = height, r = radius, center = true)",
+          "cylinder(h = height, r1 = bottom, r2 = top, center = true)",
+          "cylinder(h = height, d = diameter, center = true)",
+          "cylinder(h = height, d1 = bottom, d2 = top, center = true)",
+      });
 
   Builtins::init("polyhedron", new BuiltinModule(builtin_polyhedron),
-  {
-    "polyhedron(points, faces, convexity)",
-  });
+                 {
+                     "polyhedron(points, faces, convexity)",
+                 });
 
   Builtins::init("square", new BuiltinModule(builtin_square),
-  {
-    "square(size, center = true)",
-    "square([width,height], center = true)",
-  });
+                 {
+                     "square(size, center = true)",
+                     "square([width,height], center = true)",
+                 });
 
   Builtins::init("circle", new BuiltinModule(builtin_circle),
-  {
-    "circle(radius)",
-    "circle(r = radius)",
-    "circle(d = diameter)",
-  });
+                 {
+                     "circle(radius)",
+                     "circle(r = radius)",
+                     "circle(d = diameter)",
+                 });
 
   Builtins::init("polygon", new BuiltinModule(builtin_polygon),
-  {
-    "polygon([points])",
-    "polygon([points], [paths])",
-  });
+                 {
+                     "polygon([points])",
+                     "polygon([points], [paths])",
+                 });
 }
diff --git a/src/core/primitives.h b/src/core/primitives.h
index 19c005e6c..47885fcde 100644
--- a/src/core/primitives.h
+++ b/src/core/primitives.h
@@ -24,30 +24,25 @@
  *
  */
 
-#include "geometry/GeometryUtils.h"
 #include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/Geometry.h"
+#include "geometry/GeometryUtils.h"
 #include "geometry/linalg.h"
-#include "core/node.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <sstream>
 #include <string>
 #include <vector>
 
-class CubeNode : public LeafNode
-{
-public:
-  CubeNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+class CubeNode : public LeafNode {
+ public:
+  CubeNode(const ModuleInstantiation* mi) : LeafNode(mi) {}
+  std::string toString() const override {
     std::ostringstream stream;
-    stream << "cube(size = ["
-           << x << ", "
-           << y << ", "
-           << z << "], center = "
-           << (center ? "true" : "false") << ")";
+    stream << "cube(size = [" << x << ", " << y << ", " << z
+           << "], center = " << (center ? "true" : "false") << ")";
     return stream.str();
   }
   std::string name() const override { return "cube"; }
@@ -57,20 +52,14 @@ public:
   bool center = false;
 };
 
-
-class SphereNode : public LeafNode
-{
-public:
-  SphereNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+class SphereNode : public LeafNode {
+ public:
+  SphereNode(const ModuleInstantiation* mi) : LeafNode(mi) {}
+  std::string toString() const override {
     std::ostringstream stream;
     stream << "sphere"
-           << "($fn = " << fn
-           << ", $fa = " << fa
-           << ", $fs = " << fs
-           << ", r = " << r
-           << ")";
+           << "($fn = " << fn << ", $fa = " << fa << ", $fs = " << fs
+           << ", r = " << r << ")";
     return stream.str();
   }
   std::string name() const override { return "sphere"; }
@@ -80,23 +69,15 @@ public:
   double r = 1;
 };
 
-
-class CylinderNode : public LeafNode
-{
-public:
-  CylinderNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+class CylinderNode : public LeafNode {
+ public:
+  CylinderNode(const ModuleInstantiation* mi) : LeafNode(mi) {}
+  std::string toString() const override {
     std::ostringstream stream;
     stream << "cylinder"
-           << "($fn = " << fn
-           << ", $fa = " << fa
-           << ", $fs = " << fs
-           << ", h = " << h
-           << ", r1 = " << r1
-           << ", r2 = " << r2
-           << ", center = " << (center ? "true" : "false")
-           << ")";
+           << "($fn = " << fn << ", $fa = " << fa << ", $fs = " << fs
+           << ", h = " << h << ", r1 = " << r1 << ", r2 = " << r2
+           << ", center = " << (center ? "true" : "false") << ")";
     return stream.str();
   }
   std::string name() const override { return "cylinder"; }
@@ -107,11 +88,9 @@ public:
   bool center = false;
 };
 
-
-class PolyhedronNode : public LeafNode
-{
-public:
-  PolyhedronNode (const ModuleInstantiation *mi) : LeafNode(mi) {}
+class PolyhedronNode : public LeafNode {
+ public:
+  PolyhedronNode(const ModuleInstantiation* mi) : LeafNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "polyhedron"; }
   std::unique_ptr<const Geometry> createGeometry() const override;
@@ -121,18 +100,13 @@ public:
   int convexity = 1;
 };
 
-
-class SquareNode : public LeafNode
-{
-public:
-  SquareNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+class SquareNode : public LeafNode {
+ public:
+  SquareNode(const ModuleInstantiation* mi) : LeafNode(mi) {}
+  std::string toString() const override {
     std::ostringstream stream;
-    stream << "square(size = ["
-           << x << ", "
-           << y << "], center = "
-           << (center ? "true" : "false") << ")";
+    stream << "square(size = [" << x << ", " << y
+           << "], center = " << (center ? "true" : "false") << ")";
     return stream.str();
   }
   std::string name() const override { return "square"; }
@@ -142,20 +116,14 @@ public:
   bool center = false;
 };
 
-
-class CircleNode : public LeafNode
-{
-public:
-  CircleNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+class CircleNode : public LeafNode {
+ public:
+  CircleNode(const ModuleInstantiation* mi) : LeafNode(mi) {}
+  std::string toString() const override {
     std::ostringstream stream;
     stream << "circle"
-           << "($fn = " << fn
-           << ", $fa = " << fa
-           << ", $fs = " << fs
-           << ", r = " << r
-           << ")";
+           << "($fn = " << fn << ", $fa = " << fa << ", $fs = " << fs
+           << ", r = " << r << ")";
     return stream.str();
   }
   std::string name() const override { return "circle"; }
@@ -165,11 +133,9 @@ public:
   double r = 1;
 };
 
-
-class PolygonNode : public LeafNode
-{
-public:
-  PolygonNode (const ModuleInstantiation *mi) : LeafNode(mi) {}
+class PolygonNode : public LeafNode {
+ public:
+  PolygonNode(const ModuleInstantiation* mi) : LeafNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "polygon"; }
   std::unique_ptr<const Geometry> createGeometry() const override;
diff --git a/src/core/progress.cc b/src/core/progress.cc
index c011714f6..6eb33fa41 100644
--- a/src/core/progress.cc
+++ b/src/core/progress.cc
@@ -5,33 +5,39 @@
 
 int progress_report_count;
 int progress_mark_;
-void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
-void *progress_report_userdata;
+void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&,
+                          void*,
+                          int);
+void* progress_report_userdata;
 
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *userdata, int mark), void *userdata)
-{
+void progress_report_prep(
+    const std::shared_ptr<AbstractNode>& root,
+    void (*f)(const std::shared_ptr<const AbstractNode>& node,
+              void* userdata,
+              int mark),
+    void* userdata) {
   progress_report_count = 0;
   progress_report_f = f;
   progress_report_userdata = userdata;
   root->progress_prepare();
 }
 
-void progress_report_fin()
-{
+void progress_report_fin() {
   progress_report_count = 0;
   progress_report_f = nullptr;
   progress_report_userdata = nullptr;
 }
 
-void progress_update(const std::shared_ptr<const AbstractNode>& node, int mark)
-{
+void progress_update(const std::shared_ptr<const AbstractNode>& node,
+                     int mark) {
   if (progress_report_f) {
     progress_mark_ = mark;
     progress_report_f(node, progress_report_userdata, progress_mark_);
   }
 }
 
-void progress_tick()
-{
-  if (progress_report_f) progress_report_f(std::shared_ptr<const AbstractNode>(), progress_report_userdata, ++progress_mark_);
+void progress_tick() {
+  if (progress_report_f)
+    progress_report_f(std::shared_ptr<const AbstractNode>(),
+                      progress_report_userdata, ++progress_mark_);
 }
diff --git a/src/core/progress.h b/src/core/progress.h
index b7c5ad176..c18cc1f9a 100644
--- a/src/core/progress.h
+++ b/src/core/progress.h
@@ -4,18 +4,25 @@
 
 class AbstractNode;
 
-// Reset to 0 in _prep() and increased for each Node instance in progress_prepare()
+// Reset to 0 in _prep() and increased for each Node instance in
+// progress_prepare()
 extern int progress_report_count;
 
-extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
-extern void *progress_report_userdata;
+extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&,
+                                 void*,
+                                 int);
+extern void* progress_report_userdata;
 
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *userdata, int mark), void *userdata);
+void progress_report_prep(
+    const std::shared_ptr<AbstractNode>& root,
+    void (*f)(const std::shared_ptr<const AbstractNode>& node,
+              void* userdata,
+              int mark),
+    void* userdata);
 void progress_report_fin();
 void progress_update(const std::shared_ptr<const AbstractNode>& node, int mark);
-// CGALUtils::applyUnion3D may process nodes out of order, so allow for an increment instead of tracking exact node
+// CGALUtils::applyUnion3D may process nodes out of order, so allow for an
+// increment instead of tracking exact node
 void progress_tick();
 
-class ProgressCancelException
-{
-};
+class ProgressCancelException {};
diff --git a/src/core/str_utf8_wrapper.h b/src/core/str_utf8_wrapper.h
index 67ed584ab..d87cf4d01 100644
--- a/src/core/str_utf8_wrapper.h
+++ b/src/core/str_utf8_wrapper.h
@@ -1,66 +1,75 @@
 #pragma once
 
-#include <iterator>
-#include <utility>
-#include <cstdint>
 #include <cstddef>
+#include <cstdint>
+#include <iterator>
 #include <memory>
 #include <string>
+#include <utility>
 
 #include <glib.h>
 
-class str_utf8_wrapper
-{
-private:
+class str_utf8_wrapper {
+ private:
   // store the cached length in glong, paired with its string
   struct str_utf8_t {
     static constexpr size_t LENGTH_UNKNOWN = -1;
-    str_utf8_t() : u8str(), u8len(0) {
-    }
-    str_utf8_t(std::string s) : u8str(std::move(s)) {
-    }
-    str_utf8_t(const char *cstr) : u8str(cstr) {
-    }
-    str_utf8_t(const char *cstr, size_t size, size_t u8len) : u8str(cstr, size), u8len(u8len) {
-    }
+    str_utf8_t() : u8str(), u8len(0) {}
+    str_utf8_t(std::string s) : u8str(std::move(s)) {}
+    str_utf8_t(const char* cstr) : u8str(cstr) {}
+    str_utf8_t(const char* cstr, size_t size, size_t u8len)
+        : u8str(cstr, size), u8len(u8len) {}
     const std::string u8str;
     size_t u8len = LENGTH_UNKNOWN;
   };
   // private constructor for copying members
-  explicit str_utf8_wrapper(const std::shared_ptr<str_utf8_t>& str_in) : str_ptr(str_in) { }
+  explicit str_utf8_wrapper(const std::shared_ptr<str_utf8_t>& str_in)
+      : str_ptr(str_in) {}
 
-public:
-  class iterator
-  {
-public:
+ public:
+  class iterator {
+   public:
     // iterator_traits required types:
     using iterator_category = std::forward_iterator_tag;
     using value_type = str_utf8_wrapper;
     using difference_type = void;
-    using reference = value_type; // type used by operator*(), not actually a reference
+    using reference =
+        value_type;  // type used by operator*(), not actually a reference
     using pointer = void;
-    iterator() : ptr(&nullterm) {} // DefaultConstructible
-    iterator(const str_utf8_wrapper& str) : ptr(str.c_str()), len(char_len()) { }
-    iterator(const str_utf8_wrapper& str, bool /*end*/) : ptr(str.c_str() + str.size()) { }
+    iterator() : ptr(&nullterm) {}  // DefaultConstructible
+    iterator(const str_utf8_wrapper& str) : ptr(str.c_str()), len(char_len()) {}
+    iterator(const str_utf8_wrapper& str, bool /*end*/)
+        : ptr(str.c_str() + str.size()) {}
 
-    iterator& operator++() { ptr += len; len = char_len(); return *this; }
-    reference operator*() { return {ptr, len}; } // Note: returns a new str_utf8_wrapper **by value**, representing a single UTF8 character.
+    iterator& operator++() {
+      ptr += len;
+      len = char_len();
+      return *this;
+    }
+    reference operator*() {
+      return {ptr, len};
+    }  // Note: returns a new str_utf8_wrapper **by value**, representing a
+       // single UTF8 character.
     bool operator==(const iterator& other) const { return ptr == other.ptr; }
     bool operator!=(const iterator& other) const { return ptr != other.ptr; }
-private:
+
+   private:
     size_t char_len() { return g_utf8_next_char(ptr) - ptr; }
     static const char nullterm = '\0';
-    const char *ptr;
+    const char* ptr;
     size_t len = 0;
   };
 
   [[nodiscard]] iterator begin() const { return {*this}; }
   [[nodiscard]] iterator end() const { return {*this, true}; }
-  str_utf8_wrapper() : str_ptr(std::make_shared<str_utf8_t>()) { }
-  str_utf8_wrapper(const std::string& s) : str_ptr(std::make_shared<str_utf8_t>(s)) { }
-  str_utf8_wrapper(const char *cstr) : str_ptr(std::make_shared<str_utf8_t>(cstr)) { }
+  str_utf8_wrapper() : str_ptr(std::make_shared<str_utf8_t>()) {}
+  str_utf8_wrapper(const std::string& s)
+      : str_ptr(std::make_shared<str_utf8_t>(s)) {}
+  str_utf8_wrapper(const char* cstr)
+      : str_ptr(std::make_shared<str_utf8_t>(cstr)) {}
   // for enumerating single utf8 chars from iterator
-  str_utf8_wrapper(const char *cstr, size_t clen) : str_ptr(std::make_shared<str_utf8_t>(cstr, clen, 1)) { }
+  str_utf8_wrapper(const char* cstr, size_t clen)
+      : str_ptr(std::make_shared<str_utf8_t>(cstr, clen, 1)) {}
   str_utf8_wrapper(uint32_t unicode) {
     char out[6] = " ";
     if (unicode != 0 && g_unichar_validate(unicode)) {
@@ -68,28 +77,49 @@ private:
     }
     str_ptr = std::make_shared<str_utf8_t>(out);
   }
-  str_utf8_wrapper(const str_utf8_wrapper&) = delete; // never copy, move instead
-  str_utf8_wrapper& operator=(const str_utf8_wrapper&) = delete; // never copy, move instead
+  str_utf8_wrapper(const str_utf8_wrapper&) =
+      delete;  // never copy, move instead
+  str_utf8_wrapper& operator=(const str_utf8_wrapper&) =
+      delete;  // never copy, move instead
   str_utf8_wrapper(str_utf8_wrapper&&) = default;
   str_utf8_wrapper& operator=(str_utf8_wrapper&&) = default;
   ~str_utf8_wrapper() = default;
-  [[nodiscard]] str_utf8_wrapper clone() const { return str_utf8_wrapper(this->str_ptr); } // makes a copy of shared_ptr
+  [[nodiscard]] str_utf8_wrapper clone() const {
+    return str_utf8_wrapper(this->str_ptr);
+  }  // makes a copy of shared_ptr
 
-  bool operator==(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str == rhs.str_ptr->u8str; }
-  bool operator!=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str != rhs.str_ptr->u8str; }
-  bool operator<(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str < rhs.str_ptr->u8str; }
-  bool operator>(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str > rhs.str_ptr->u8str; }
-  bool operator<=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str <= rhs.str_ptr->u8str; }
-  bool operator>=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str >= rhs.str_ptr->u8str; }
+  bool operator==(const str_utf8_wrapper& rhs) const {
+    return this->str_ptr->u8str == rhs.str_ptr->u8str;
+  }
+  bool operator!=(const str_utf8_wrapper& rhs) const {
+    return this->str_ptr->u8str != rhs.str_ptr->u8str;
+  }
+  bool operator<(const str_utf8_wrapper& rhs) const {
+    return this->str_ptr->u8str < rhs.str_ptr->u8str;
+  }
+  bool operator>(const str_utf8_wrapper& rhs) const {
+    return this->str_ptr->u8str > rhs.str_ptr->u8str;
+  }
+  bool operator<=(const str_utf8_wrapper& rhs) const {
+    return this->str_ptr->u8str <= rhs.str_ptr->u8str;
+  }
+  bool operator>=(const str_utf8_wrapper& rhs) const {
+    return this->str_ptr->u8str >= rhs.str_ptr->u8str;
+  }
   [[nodiscard]] bool empty() const { return this->str_ptr->u8str.empty(); }
-  [[nodiscard]] const char *c_str() const { return this->str_ptr->u8str.c_str(); }
-  [[nodiscard]] const std::string& toString() const { return this->str_ptr->u8str; }
+  [[nodiscard]] const char* c_str() const {
+    return this->str_ptr->u8str.c_str();
+  }
+  [[nodiscard]] const std::string& toString() const {
+    return this->str_ptr->u8str;
+  }
   [[nodiscard]] size_t size() const { return this->str_ptr->u8str.size(); }
   str_utf8_wrapper operator[](const size_t idx) const {
     if (idx < this->size()) {
       // Ensure character (not byte) index is inside the character/glyph array
       if (idx < this->get_utf8_strlen()) {
-        gchar utf8_of_cp[6] = ""; //A buffer for a single unicode character to be copied into
+        gchar utf8_of_cp[6] =
+            "";  // A buffer for a single unicode character to be copied into
         auto ptr = g_utf8_offset_to_pointer(str_ptr->u8str.c_str(), idx);
         if (ptr) {
           g_utf8_strncpy(utf8_of_cp, ptr, 1);
@@ -102,7 +132,8 @@ private:
 
   [[nodiscard]] size_t get_utf8_strlen() const {
     if (str_ptr->u8len == str_utf8_t::LENGTH_UNKNOWN) {
-      str_ptr->u8len = g_utf8_strlen(str_ptr->u8str.c_str(), static_cast<gssize>(str_ptr->u8str.size()));
+      str_ptr->u8len = g_utf8_strlen(
+          str_ptr->u8str.c_str(), static_cast<gssize>(str_ptr->u8str.size()));
     }
     return str_ptr->u8len;
   }
@@ -115,6 +146,6 @@ private:
     return g_utf8_validate(str_ptr->u8str.c_str(), -1, nullptr);
   }
 
-private:
+ private:
   std::shared_ptr<str_utf8_t> str_ptr;
 };
diff --git a/src/geometry/ClipperUtils.cc b/src/geometry/ClipperUtils.cc
index b221c9254..3d96c2980 100644
--- a/src/geometry/ClipperUtils.cc
+++ b/src/geometry/ClipperUtils.cc
@@ -1,16 +1,16 @@
 #include "geometry/ClipperUtils.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "clipper2/clipper.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
-#include <algorithm>
 #include <clipper2/clipper.engine.h>
-#include <cmath>
+#include <algorithm>
 #include <cassert>
-#include <utility>
-#include <memory>
+#include <cmath>
 #include <cstddef>
+#include <memory>
+#include <utility>
 #include <vector>
 
 namespace ClipperUtils {
@@ -19,8 +19,7 @@ namespace {
 
 Clipper2Lib::Paths64 process(const Clipper2Lib::Paths64& polygons,
                              Clipper2Lib::ClipType cliptype,
-                             Clipper2Lib::FillRule polytype)
-{
+                             Clipper2Lib::FillRule polytype) {
   Clipper2Lib::Paths64 result;
   Clipper2Lib::Clipper64 clipper;
   clipper.PreserveCollinear(false);
@@ -29,13 +28,16 @@ Clipper2Lib::Paths64 process(const Clipper2Lib::Paths64& polygons,
   return result;
 }
 
-// This is a copy-paste from Clipper2Lib with the modification that the union operation is not performed
-// The reason is numeric robustness. With the insides missing, the intersection points created by the union operation may
-// (due to rounding) be located at slightly different locations than the original geometry and this
-// can give rise to cracks
-void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path64& path,
-                       Clipper2Lib::Paths64& quads, bool isSum, bool isClosed)
-{
+// This is a copy-paste from Clipper2Lib with the modification that the union
+// operation is not performed The reason is numeric robustness. With the insides
+// missing, the intersection points created by the union operation may (due to
+// rounding) be located at slightly different locations than the original
+// geometry and this can give rise to cracks
+void minkowski_outline(const Clipper2Lib::Path64& poly,
+                       const Clipper2Lib::Path64& path,
+                       Clipper2Lib::Paths64& quads,
+                       bool isSum,
+                       bool isClosed) {
   int delta = (isClosed ? 1 : 0);
   size_t polyCnt = poly.size();
   size_t pathCnt = path.size();
@@ -46,7 +48,8 @@ void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path6
       Clipper2Lib::Path64 p;
       p.reserve(polyCnt);
       for (auto point : poly) {
-        p.push_back(Clipper2Lib::Point64(path[i].x + point.x, path[i].y + point.y));
+        p.push_back(
+            Clipper2Lib::Point64(path[i].x + point.x, path[i].y + point.y));
       }
       pp.push_back(p);
     }
@@ -55,7 +58,8 @@ void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path6
       Clipper2Lib::Path64 p;
       p.reserve(polyCnt);
       for (auto point : poly) {
-        p.push_back(Clipper2Lib::Point64(path[i].x - point.x, path[i].y - point.y));
+        p.push_back(
+            Clipper2Lib::Point64(path[i].x - point.x, path[i].y - point.y));
       }
       pp.push_back(p);
     }
@@ -69,23 +73,23 @@ void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path6
       quad.push_back(pp[(i + 1) % pathCnt][j % polyCnt]);
       quad.push_back(pp[(i + 1) % pathCnt][(j + 1) % polyCnt]);
       quad.push_back(pp[i % pathCnt][(j + 1) % polyCnt]);
-      if (!IsPositive(quad)) std::reverse(quad.begin(), quad.end());
+      if (!IsPositive(quad))
+        std::reverse(quad.begin(), quad.end());
       quads.push_back(quad);
     }
 }
 
-// Add the polygon a translated to an arbitrary point of each separate component of b.
-// Ideally, we would translate to the midpoint of component b, but the point can
-// be chosen arbitrarily since the translated object would always stay inside
-// the minkowski sum.
+// Add the polygon a translated to an arbitrary point of each separate component
+// of b. Ideally, we would translate to the midpoint of component b, but the
+// point can be chosen arbitrarily since the translated object would always stay
+// inside the minkowski sum.
 void fill_minkowski_insides(const Clipper2Lib::Paths64& a,
                             const Clipper2Lib::Paths64& b,
-                            Clipper2Lib::Paths64& target)
-{
+                            Clipper2Lib::Paths64& target) {
   for (const auto& b_path : b) {
     // We only need to add for positive components of b
     if (!b_path.empty() && Clipper2Lib::IsPositive(b_path) == 1) {
-      const auto& delta = b_path[0]; // arbitrary point
+      const auto& delta = b_path[0];  // arbitrary point
       for (const auto& path : a) {
         target.push_back(path);
         for (auto& point : target.back()) {
@@ -97,9 +101,12 @@ void fill_minkowski_insides(const Clipper2Lib::Paths64& a,
   }
 }
 
-void SimplifyPolyTree(const Clipper2Lib::PolyPath64& polytree, double epsilon, Clipper2Lib::PolyPath64& result) {
+void SimplifyPolyTree(const Clipper2Lib::PolyPath64& polytree,
+                      double epsilon,
+                      Clipper2Lib::PolyPath64& result) {
   for (const auto& child : polytree) {
-    Clipper2Lib::PolyPath64 *newchild = result.AddChild(Clipper2Lib::SimplifyPath(child->Polygon(), epsilon));
+    Clipper2Lib::PolyPath64* newchild =
+        result.AddChild(Clipper2Lib::SimplifyPath(child->Polygon(), epsilon));
     SimplifyPolyTree(*child, epsilon, *newchild);
   }
 }
@@ -107,28 +114,24 @@ void SimplifyPolyTree(const Clipper2Lib::PolyPath64& polytree, double epsilon, C
 }  // namespace
 
 // Using 1 bit less precision than the maximum possible, to limit the chance
-// of data loss when converting back to double (see https://github.com/openscad/openscad/issues/5253).
-const int CLIPPER_BITS{ std::ilogb(0x3FFFFFFFFFFFFFFFLL) };
-
-int scaleBitsFromBounds(const BoundingBox& bounds, int total_bits)
-{
-  const double maxCoeff = std::max({
-      bounds.min().cwiseAbs().maxCoeff(),
-      bounds.max().cwiseAbs().maxCoeff(),
-      bounds.sizes().maxCoeff()
-    });
+// of data loss when converting back to double (see
+// https://github.com/openscad/openscad/issues/5253).
+const int CLIPPER_BITS{std::ilogb(0x3FFFFFFFFFFFFFFFLL)};
+
+int scaleBitsFromBounds(const BoundingBox& bounds, int total_bits) {
+  const double maxCoeff =
+      std::max({bounds.min().cwiseAbs().maxCoeff(),
+                bounds.max().cwiseAbs().maxCoeff(), bounds.sizes().maxCoeff()});
   const int exp = std::ilogb(maxCoeff) + 1;
   const int actual_bits = (total_bits == 0) ? CLIPPER_BITS : total_bits;
   return (actual_bits - 1) - exp;
 }
 
-int scaleBitsFromPrecision(int precision)
-{
+int scaleBitsFromPrecision(int precision) {
   return std::ilogb(std::pow(10, precision)) + 1;
 }
 
-Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly, int scale_bits)
-{
+Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly, int scale_bits) {
   const bool keep_orientation = poly.isSanitized();
   const double scale = std::ldexp(1.0, scale_bits);
   Clipper2Lib::Paths64 result;
@@ -139,19 +142,19 @@ Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly, int scale_bits)
     }
     // Make sure all polygons point up, since we project also
     // back-facing polygon in PolySetUtils::project()
-    if (!keep_orientation && !Clipper2Lib::IsPositive(p)) std::reverse(p.begin(), p.end());
+    if (!keep_orientation && !Clipper2Lib::IsPositive(p))
+      std::reverse(p.begin(), p.end());
     result.push_back(std::move(p));
   }
   return result;
 }
 
-Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly)
-{
+Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly) {
   return fromPolygon2d(poly, scaleBitsFromPrecision());
 }
 
-std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(const Clipper2Lib::Paths64& paths)
-{
+std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(
+    const Clipper2Lib::Paths64& paths) {
   auto result = std::make_unique<Clipper2Lib::PolyTree64>();
   Clipper2Lib::Clipper64 clipper;
   clipper.PreserveCollinear(false);
@@ -164,12 +167,12 @@ std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(const Clipper2Lib::Paths64& pa
     // TODO: Is this needed for Clipper2?
     LOG(message_group::Warning, "Range check failed for polygon. skipping");
   }
-  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::EvenOdd, *result);
+  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::EvenOdd,
+                  *result);
   return result;
 }
 
-std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly)
-{
+std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly) {
   auto scale_bits = scaleBitsFromPrecision();
 
   auto paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
@@ -179,33 +182,38 @@ std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly)
 /*!
    We want to use a PolyTree to convert to Polygon2d, since only PolyTrees
    have an explicit notion of holes.
-   We could use a Paths structure, but we'd have to check the orientation of each
-   path before adding it to the Polygon2d.
+   We could use a Paths structure, but we'd have to check the orientation of
+   each path before adding it to the Polygon2d.
  */
-std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& polytree, int scale_bits)
-{
+std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& polytree,
+                                       int scale_bits) {
   auto result = std::make_unique<Polygon2d>();
   const double scale = std::ldexp(1.0, -scale_bits);
-  auto processChildren = [scale, &result](auto&& processChildren, const Clipper2Lib::PolyPath64& node) -> void {
-      Outline2d outline;
-      // When using offset, clipper can get the hole status wrong.
-      // IsPositive() calculates the area of the polygon, and if it's negative, it's a hole.
-      outline.positive = IsPositive(node.Polygon());
-
-      constexpr double epsilon = 1.1415; // Epsilon taken from Clipper1's default epsilon.
-      const auto cleaned_path = Clipper2Lib::SimplifyPath(node.Polygon(), epsilon);
-
-      // SimplifyPath can potentially reduce the polygon down to no vertices
-      if (cleaned_path.size() >= 3) {
-        for (const auto& ip : cleaned_path) {
-          outline.vertices.emplace_back(scale * ip.x, scale * ip.y);
-        }
-        result->addOutline(outline);
-      }
-      for (const auto& child : node) {
-        processChildren(processChildren, *child);
+  auto processChildren = [scale, &result](
+                             auto&& processChildren,
+                             const Clipper2Lib::PolyPath64& node) -> void {
+    Outline2d outline;
+    // When using offset, clipper can get the hole status wrong.
+    // IsPositive() calculates the area of the polygon, and if it's negative,
+    // it's a hole.
+    outline.positive = IsPositive(node.Polygon());
+
+    constexpr double epsilon =
+        1.1415;  // Epsilon taken from Clipper1's default epsilon.
+    const auto cleaned_path =
+        Clipper2Lib::SimplifyPath(node.Polygon(), epsilon);
+
+    // SimplifyPath can potentially reduce the polygon down to no vertices
+    if (cleaned_path.size() >= 3) {
+      for (const auto& ip : cleaned_path) {
+        outline.vertices.emplace_back(scale * ip.x, scale * ip.y);
       }
-    };
+      result->addOutline(outline);
+    }
+    for (const auto& child : node) {
+      processChildren(processChildren, *child);
+    }
+  };
   for (const auto& node : polytree) {
     processChildren(processChildren, *node);
   }
@@ -218,14 +226,17 @@ std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& polytree,
 
    May return an empty Polygon2d, but will not return nullptr.
  */
-std::unique_ptr<Polygon2d> apply(const std::vector<Clipper2Lib::Paths64>& pathsvector,
-                                 Clipper2Lib::ClipType clipType, int scale_bits)
-{
+std::unique_ptr<Polygon2d> apply(
+    const std::vector<Clipper2Lib::Paths64>& pathsvector,
+    Clipper2Lib::ClipType clipType,
+    int scale_bits) {
   Clipper2Lib::Clipper64 clipper;
   clipper.PreserveCollinear(false);
 
-  if (clipType == Clipper2Lib::ClipType::Intersection && pathsvector.size() >= 2) {
-    // intersection operations must be split into a sequence of binary operations
+  if (clipType == Clipper2Lib::ClipType::Intersection &&
+      pathsvector.size() >= 2) {
+    // intersection operations must be split into a sequence of binary
+    // operations
     auto source = pathsvector[0];
     Clipper2Lib::PolyTree64 result;
     for (unsigned int i = 1; i < pathsvector.size(); ++i) {
@@ -262,9 +273,9 @@ std::unique_ptr<Polygon2d> apply(const std::vector<Clipper2Lib::Paths64>& pathsv
 
    May return an empty Polygon2d, but will not return nullptr.
  */
-std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon2d>>& polygons,
-                                 Clipper2Lib::ClipType clipType)
-{
+std::unique_ptr<Polygon2d> apply(
+    const std::vector<std::shared_ptr<const Polygon2d>>& polygons,
+    Clipper2Lib::ClipType clipType) {
   const int scale_bits = scaleBitsFromPrecision();
 
   std::vector<Clipper2Lib::Paths64> pathsvector;
@@ -276,7 +287,8 @@ std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon
       }
       pathsvector.push_back(std::move(polypaths));
     } else {
-      // Insert empty object as this could be the positive object in a difference
+      // Insert empty object as this could be the positive object in a
+      // difference
       pathsvector.emplace_back();
     }
   }
@@ -285,23 +297,28 @@ std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon
   return res;
 }
 
-std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<const Polygon2d>>& polygons)
-{
+std::unique_ptr<Polygon2d> applyMinkowski(
+    const std::vector<std::shared_ptr<const Polygon2d>>& polygons) {
   if (polygons.size() == 1) {
-    return polygons[0] ? std::make_unique<Polygon2d>(*polygons[0]) : nullptr; // Just copy
+    return polygons[0] ? std::make_unique<Polygon2d>(*polygons[0])
+                       : nullptr;  // Just copy
   }
 
   auto it = polygons.begin();
-  while (it != polygons.end() && !(*it)) ++it;
-  if (it == polygons.end()) return nullptr;
+  while (it != polygons.end() && !(*it))
+    ++it;
+  if (it == polygons.end())
+    return nullptr;
   const int scale_bits = scaleBitsFromPrecision();
 
   Clipper2Lib::Clipper64 clipper;
   clipper.PreserveCollinear(false);
-  auto lhs = fromPolygon2d(polygons[0] ? *polygons[0] : Polygon2d(), scale_bits);
+  auto lhs =
+      fromPolygon2d(polygons[0] ? *polygons[0] : Polygon2d(), scale_bits);
 
   for (size_t i = 1; i < polygons.size(); ++i) {
-    if (!polygons[i]) continue;
+    if (!polygons[i])
+      continue;
     Clipper2Lib::Paths64 minkowski_terms;
     auto rhs = fromPolygon2d(*polygons[i], scale_bits);
 
@@ -310,7 +327,8 @@ std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<cons
       for (auto const& lhs_path : lhs) {
         Clipper2Lib::Paths64 result;
         minkowski_outline(lhs_path, rhs_path, result, true, true);
-        minkowski_terms.insert(minkowski_terms.end(), result.begin(), result.end());
+        minkowski_terms.insert(minkowski_terms.end(), result.begin(),
+                               result.end());
       }
     }
 
@@ -318,31 +336,34 @@ std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<cons
     fill_minkowski_insides(lhs, rhs, minkowski_terms);
     fill_minkowski_insides(rhs, lhs, minkowski_terms);
 
-    // This union operation must be performed at each iteration since the minkowski_terms
-    // now contain lots of small quads
+    // This union operation must be performed at each iteration since the
+    // minkowski_terms now contain lots of small quads
     clipper.Clear();
     clipper.AddSubject(minkowski_terms);
 
     if (i != polygons.size() - 1) {
-      clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, lhs);
+      clipper.Execute(Clipper2Lib::ClipType::Union,
+                      Clipper2Lib::FillRule::NonZero, lhs);
     }
   }
 
   Clipper2Lib::PolyTree64 polytree;
-  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, polytree);
+  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero,
+                  polytree);
   return toPolygon2d(polytree, scale_bits);
 }
 
-std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly, double offset, Clipper2Lib::JoinType joinType,
-                                       double miter_limit, double arc_tolerance)
-{
+std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly,
+                                       double offset,
+                                       Clipper2Lib::JoinType joinType,
+                                       double miter_limit,
+                                       double arc_tolerance) {
   const bool isMiter = joinType == Clipper2Lib::JoinType::Miter;
   const bool isRound = joinType == Clipper2Lib::JoinType::Round;
   const int scale_bits = scaleBitsFromPrecision();
   Clipper2Lib::ClipperOffset co(
-    isMiter ? miter_limit : 2.0,
-    isRound ? std::ldexp(arc_tolerance, scale_bits) : 1.0
-    );
+      isMiter ? miter_limit : 2.0,
+      isRound ? std::ldexp(arc_tolerance, scale_bits) : 1.0);
   auto p = ClipperUtils::fromPolygon2d(poly, scale_bits);
   co.AddPaths(p, joinType, Clipper2Lib::EndType::Polygon);
   Clipper2Lib::PolyTree64 result;
@@ -350,30 +371,35 @@ std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly, double offset, Cli
   return toPolygon2d(result, scale_bits);
 }
 
-std::unique_ptr<Polygon2d> applyProjection(const std::vector<std::shared_ptr<const Polygon2d>>& polygons)
-{
+std::unique_ptr<Polygon2d> applyProjection(
+    const std::vector<std::shared_ptr<const Polygon2d>>& polygons) {
   const int scale_bits = scaleBitsFromPrecision();
 
   Clipper2Lib::Clipper64 sumclipper;
   sumclipper.PreserveCollinear(false);
   for (const auto& poly : polygons) {
-    Clipper2Lib::Paths64 result = ClipperUtils::fromPolygon2d(*poly, scale_bits);
+    Clipper2Lib::Paths64 result =
+        ClipperUtils::fromPolygon2d(*poly, scale_bits);
     // Using NonZero ensures that we don't create holes from polygons sharing
     // edges since we're unioning a mesh
-    result = ClipperUtils::process(result, Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero);
+    result = ClipperUtils::process(result, Clipper2Lib::ClipType::Union,
+                                   Clipper2Lib::FillRule::NonZero);
     // Add correctly winded polygons to the main clipper
     sumclipper.AddSubject(result);
   }
 
   Clipper2Lib::PolyTree64 sumresult;
-  // This is key - without StrictlySimple, we tend to get self-intersecting results
-  // FIXME: StrictlySimple doesn't exist in Clipper2. Check if it still exposes problems without
+  // This is key - without StrictlySimple, we tend to get self-intersecting
+  // results
+  // FIXME: StrictlySimple doesn't exist in Clipper2. Check if it still exposes
+  // problems without
   //  sumclipper.StrictlySimple(true);
-  sumclipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, sumresult);
+  sumclipper.Execute(Clipper2Lib::ClipType::Union,
+                     Clipper2Lib::FillRule::NonZero, sumresult);
   if (sumresult.Count() > 0) {
     return ClipperUtils::toPolygon2d(sumresult, scale_bits);
   }
   return {};
 }
 
-} // namespace ClipperUtils
+}  // namespace ClipperUtils
diff --git a/src/geometry/ClipperUtils.h b/src/geometry/ClipperUtils.h
index daf9657b5..7abbd9f8e 100644
--- a/src/geometry/ClipperUtils.h
+++ b/src/geometry/ClipperUtils.h
@@ -1,8 +1,8 @@
 #pragma once
 
 #include "clipper2/clipper.h"
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
 #include <memory>
 #include <vector>
@@ -14,14 +14,24 @@ constexpr int DEFAULT_PRECISION = 8;
 int scaleBitsFromBounds(const BoundingBox& bounds, int bits = 0);
 int scaleBitsFromPrecision(int precision = DEFAULT_PRECISION);
 
-std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(const Clipper2Lib::Paths64& paths);
+std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(
+    const Clipper2Lib::Paths64& paths);
 std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly);
 
 Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly, int scale_bits);
-std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& poly, int scale_bits);
-
-std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly, double offset, Clipper2Lib::JoinType joinType, double miter_limit, double arc_tolerance);
-std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<const Polygon2d>>& polygons);
-std::unique_ptr<Polygon2d> applyProjection(const std::vector<std::shared_ptr<const Polygon2d>>& polygons);
-std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon2d>>& polygons, Clipper2Lib::ClipType);
-}
+std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& poly,
+                                       int scale_bits);
+
+std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly,
+                                       double offset,
+                                       Clipper2Lib::JoinType joinType,
+                                       double miter_limit,
+                                       double arc_tolerance);
+std::unique_ptr<Polygon2d> applyMinkowski(
+    const std::vector<std::shared_ptr<const Polygon2d>>& polygons);
+std::unique_ptr<Polygon2d> applyProjection(
+    const std::vector<std::shared_ptr<const Polygon2d>>& polygons);
+std::unique_ptr<Polygon2d> apply(
+    const std::vector<std::shared_ptr<const Polygon2d>>& polygons,
+    Clipper2Lib::ClipType);
+}  // namespace ClipperUtils
diff --git a/src/geometry/Geometry.cc b/src/geometry/Geometry.cc
index d9a46927e..d13b77b41 100644
--- a/src/geometry/Geometry.cc
+++ b/src/geometry/Geometry.cc
@@ -1,24 +1,21 @@
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "utils/printutils.h"
-#include <sstream>
-#include <memory>
 #include <boost/foreach.hpp>
 #include <cstddef>
+#include <memory>
+#include <sstream>
 #include <string>
 #include <utility>
+#include "geometry/linalg.h"
+#include "utils/printutils.h"
 
-GeometryList::GeometryList(Geometry::Geometries geometries) : children(std::move(geometries))
-{
-}
+GeometryList::GeometryList(Geometry::Geometries geometries)
+    : children(std::move(geometries)) {}
 
-std::unique_ptr<Geometry> GeometryList::copy() const
-{
+std::unique_ptr<Geometry> GeometryList::copy() const {
   return std::make_unique<GeometryList>(*this);
 }
 
-size_t GeometryList::memsize() const
-{
+size_t GeometryList::memsize() const {
   size_t sum = 0;
   for (const auto& item : this->children) {
     sum += item.second->memsize();
@@ -26,8 +23,7 @@ size_t GeometryList::memsize() const
   return sum;
 }
 
-BoundingBox GeometryList::getBoundingBox() const
-{
+BoundingBox GeometryList::getBoundingBox() const {
   BoundingBox bbox;
   for (const auto& item : this->children) {
     bbox.extend(item.second->getBoundingBox());
@@ -35,8 +31,7 @@ BoundingBox GeometryList::getBoundingBox() const
   return bbox;
 }
 
-std::string GeometryList::dump() const
-{
+std::string GeometryList::dump() const {
   std::stringstream out;
   for (const auto& item : this->children) {
     out << item.second->dump();
@@ -44,11 +39,11 @@ std::string GeometryList::dump() const
   return out.str();
 }
 
-unsigned int GeometryList::getDimension() const
-{
+unsigned int GeometryList::getDimension() const {
   unsigned int dim = 0;
   for (const auto& item : this->children) {
-    if (!dim) dim = item.second->getDimension();
+    if (!dim)
+      dim = item.second->getDimension();
     else if (dim != item.second->getDimension()) {
       LOG(message_group::Warning, "Mixing 2D and 3D objects is not supported.");
       break;
@@ -57,18 +52,19 @@ unsigned int GeometryList::getDimension() const
   return dim;
 }
 
-bool GeometryList::isEmpty() const
-{
+bool GeometryList::isEmpty() const {
   for (const auto& item : this->children) {
-    if (!item.second->isEmpty()) return false;
+    if (!item.second->isEmpty())
+      return false;
   }
   return true;
 }
 
-void flatten(const GeometryList& geomlist, GeometryList::Geometries& childlist)
-{
+void flatten(const GeometryList& geomlist,
+             GeometryList::Geometries& childlist) {
   for (const auto& item : geomlist.getChildren()) {
-    if (const auto chlist = std::dynamic_pointer_cast<const GeometryList>(item.second)) {
+    if (const auto chlist =
+            std::dynamic_pointer_cast<const GeometryList>(item.second)) {
       flatten(*chlist, childlist);
     } else {
       childlist.push_back(item);
@@ -81,8 +77,7 @@ void flatten(const GeometryList& geomlist, GeometryList::Geometries& childlist)
    children directly reachable GeometryLists are collected in a flat
    list)
  */
-Geometry::Geometries GeometryList::flatten() const
-{
+Geometry::Geometries GeometryList::flatten() const {
   Geometries newchildren;
   ::flatten(*this, newchildren);
   return newchildren;
diff --git a/src/geometry/Geometry.h b/src/geometry/Geometry.h
index 6ae983c06..b90076132 100644
--- a/src/geometry/Geometry.h
+++ b/src/geometry/Geometry.h
@@ -1,11 +1,11 @@
 #pragma once
 
 #include <cassert>
-#include <utility>
 #include <cstddef>
-#include <string>
 #include <list>
 #include <memory>
+#include <string>
+#include <utility>
 
 #include "geometry/linalg.h"
 
@@ -19,10 +19,10 @@ class PolySet;
 class ManifoldGeometry;
 #endif
 
-class Geometry
-{
-public:
-  using GeometryItem = std::pair<std::shared_ptr<const AbstractNode>, std::shared_ptr<const Geometry>>;
+class Geometry {
+ public:
+  using GeometryItem = std::pair<std::shared_ptr<const AbstractNode>,
+                                 std::shared_ptr<const Geometry>>;
   using Geometries = std::list<GeometryItem>;
 
   Geometry() = default;
@@ -43,22 +43,26 @@ public:
   void setConvexity(int c) { this->convexity = c; }
   virtual void setColor(const Color4f& c) {}
 
-  virtual void transform(const Transform3d& /*mat*/) { assert(!"transform not implemented!"); }
-  virtual void resize(const Vector3d& /*newsize*/, const Eigen::Matrix<bool, 3, 1>& /*autosize*/) {
+  virtual void transform(const Transform3d& /*mat*/) {
+    assert(!"transform not implemented!");
+  }
+  virtual void resize(const Vector3d& /*newsize*/,
+                      const Eigen::Matrix<bool, 3, 1>& /*autosize*/) {
     assert(!"resize not implemented!");
   }
 
   virtual void accept(GeometryVisitor& visitor) const = 0;
-protected:
+
+ protected:
   int convexity{1};
 };
 
 /**
- * A Base class for simple visitors to process different Geometry subclasses uniformly
+ * A Base class for simple visitors to process different Geometry subclasses
+ * uniformly
  */
-class GeometryVisitor
-{
-public:
+class GeometryVisitor {
+ public:
   virtual void visit(const GeometryList& node) = 0;
   virtual void visit(const PolySet& node) = 0;
   virtual void visit(const Polygon2d& node) = 0;
@@ -71,14 +75,13 @@ public:
   virtual ~GeometryVisitor() = default;
 };
 
-#define VISITABLE_GEOMETRY() \
-        void accept(GeometryVisitor & visitor) const override { \
-          visitor.visit(*this); \
-        }
+#define VISITABLE_GEOMETRY()                             \
+  void accept(GeometryVisitor& visitor) const override { \
+    visitor.visit(*this);                                \
+  }
 
-class GeometryList : public Geometry
-{
-public:
+class GeometryList : public Geometry {
+ public:
   VISITABLE_GEOMETRY();
   Geometries children;
 
@@ -91,12 +94,12 @@ public:
   [[nodiscard]] unsigned int getDimension() const override;
   [[nodiscard]] bool isEmpty() const override;
   [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
-  [[nodiscard]] size_t numFacets() const override { assert(false && "not implemented"); return 0; }
-
-  [[nodiscard]] const Geometries& getChildren() const {
-    return this->children;
+  [[nodiscard]] size_t numFacets() const override {
+    assert(false && "not implemented");
+    return 0;
   }
 
-  [[nodiscard]] Geometries flatten() const;
+  [[nodiscard]] const Geometries& getChildren() const { return this->children; }
 
+  [[nodiscard]] Geometries flatten() const;
 };
diff --git a/src/geometry/GeometryCache.cc b/src/geometry/GeometryCache.cc
index a1877f17e..b4488afbd 100644
--- a/src/geometry/GeometryCache.cc
+++ b/src/geometry/GeometryCache.cc
@@ -1,67 +1,67 @@
 #include "geometry/GeometryCache.h"
-#include "utils/printutils.h"
 #include "geometry/Geometry.h"
+#include "utils/printutils.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALNefGeometry.h"
 #endif
 
-GeometryCache *GeometryCache::inst = nullptr;
+GeometryCache* GeometryCache::inst = nullptr;
 
-std::shared_ptr<const Geometry> GeometryCache::get(const std::string& id) const
-{
+std::shared_ptr<const Geometry> GeometryCache::get(
+    const std::string& id) const {
   const auto& geom = this->cache[id]->geom;
 #ifdef DEBUG
-  PRINTDB("Geometry Cache hit: %s (%d bytes)", id.substr(0, 40) % (geom ? geom->memsize() : 0));
+  PRINTDB("Geometry Cache hit: %s (%d bytes)",
+          id.substr(0, 40) % (geom ? geom->memsize() : 0));
 #endif
   return geom;
 }
 
-bool GeometryCache::insert(const std::string& id, const std::shared_ptr<const Geometry>& geom)
-{
-  auto inserted = this->cache.insert(id, new cache_entry(geom), geom ? geom->memsize() : 0);
+bool GeometryCache::insert(const std::string& id,
+                           const std::shared_ptr<const Geometry>& geom) {
+  auto inserted =
+      this->cache.insert(id, new cache_entry(geom), geom ? geom->memsize() : 0);
 #if defined(ENABLE_CGAL) && defined(DEBUG)
-  assert(!dynamic_cast<const CGALNefGeometry *>(geom.get()));
-  if (inserted) PRINTDB("Geometry Cache insert: %s (%d bytes)",
-                        id.substr(0, 40) % (geom ? geom->memsize() : 0));
-  else PRINTDB("Geometry Cache insert failed: %s (%d bytes)",
-               id.substr(0, 40) % (geom ? geom->memsize() : 0));
+  assert(!dynamic_cast<const CGALNefGeometry*>(geom.get()));
+  if (inserted)
+    PRINTDB("Geometry Cache insert: %s (%d bytes)",
+            id.substr(0, 40) % (geom ? geom->memsize() : 0));
+  else
+    PRINTDB("Geometry Cache insert failed: %s (%d bytes)",
+            id.substr(0, 40) % (geom ? geom->memsize() : 0));
 #endif
   return inserted;
 }
 
-size_t GeometryCache::size() const
-{
+size_t GeometryCache::size() const {
   return cache.size();
 }
 
-size_t GeometryCache::totalCost() const
-{
+size_t GeometryCache::totalCost() const {
   return cache.totalCost();
 }
 
-size_t GeometryCache::maxSizeMB() const
-{
+size_t GeometryCache::maxSizeMB() const {
   return this->cache.maxCost() / (1024ul * 1024ul);
 }
 
-void GeometryCache::setMaxSizeMB(size_t limit)
-{
+void GeometryCache::setMaxSizeMB(size_t limit) {
   this->cache.setMaxCost(limit * 1024ul * 1024ul);
 }
 
-void GeometryCache::print()
-{
+void GeometryCache::print() {
   LOG("Geometries in cache: %1$d", this->cache.size());
   LOG("Geometry cache size in bytes: %1$d", this->cache.totalCost());
 }
 
-GeometryCache::cache_entry::cache_entry(const std::shared_ptr<const Geometry>& geom)
-  : geom(geom)
-{
-  if (print_messages_stack.size() > 0) this->msg = print_messages_stack.back();
+GeometryCache::cache_entry::cache_entry(
+    const std::shared_ptr<const Geometry>& geom)
+    : geom(geom) {
+  if (print_messages_stack.size() > 0)
+    this->msg = print_messages_stack.back();
 }
diff --git a/src/geometry/GeometryCache.h b/src/geometry/GeometryCache.h
index 7bbcd3e55..33b7a7276 100644
--- a/src/geometry/GeometryCache.h
+++ b/src/geometry/GeometryCache.h
@@ -7,16 +7,23 @@
 #include "Cache.h"
 #include "geometry/Geometry.h"
 
-class GeometryCache
-{
-public:
-  GeometryCache(size_t memorylimit = 100ul * 1024ul * 1024ul) : cache(memorylimit) {}
-
-  static GeometryCache *instance() { if (!inst) inst = new GeometryCache; return inst; }
-
-  bool contains(const std::string& id) const { return this->cache.contains(id); }
+class GeometryCache {
+ public:
+  GeometryCache(size_t memorylimit = 100ul * 1024ul * 1024ul)
+      : cache(memorylimit) {}
+
+  static GeometryCache* instance() {
+    if (!inst)
+      inst = new GeometryCache;
+    return inst;
+  }
+
+  bool contains(const std::string& id) const {
+    return this->cache.contains(id);
+  }
   std::shared_ptr<const class Geometry> get(const std::string& id) const;
-  bool insert(const std::string& id, const std::shared_ptr<const Geometry>& geom);
+  bool insert(const std::string& id,
+              const std::shared_ptr<const Geometry>& geom);
   size_t size() const;
   size_t totalCost() const;
   size_t maxSizeMB() const;
@@ -24,8 +31,8 @@ public:
   void clear() { cache.clear(); }
   void print();
 
-private:
-  static GeometryCache *inst;
+ private:
+  static GeometryCache* inst;
 
   struct cache_entry {
     std::shared_ptr<const class Geometry> geom;
diff --git a/src/geometry/GeometryEvaluator.cc b/src/geometry/GeometryEvaluator.cc
index d65ae2270..9b76a9709 100644
--- a/src/geometry/GeometryEvaluator.cc
+++ b/src/geometry/GeometryEvaluator.cc
@@ -1,45 +1,44 @@
 #include "geometry/GeometryEvaluator.h"
-#include "geometry/Geometry.h"
-#include "geometry/cgal/cgal.h"
-#include "geometry/linalg.h"
-#include "core/Tree.h"
-#include "geometry/GeometryCache.h"
-#include "geometry/Polygon2d.h"
-#include "core/ModuleInstantiation.h"
-#include "core/State.h"
+#include <cassert>
+#include <iterator>
+#include <list>
+#include <memory>
+#include <utility>
+#include "core/CgalAdvNode.h"
 #include "core/ColorNode.h"
-#include "core/OffsetNode.h"
-#include "core/TransformNode.h"
+#include "core/CsgOpNode.h"
 #include "core/LinearExtrudeNode.h"
+#include "core/ModuleInstantiation.h"
+#include "core/OffsetNode.h"
+#include "core/ProjectionNode.h"
+#include "core/RenderNode.h"
 #include "core/RoofNode.h"
-#include "geometry/roof_ss.h"
-#include "geometry/roof_vd.h"
 #include "core/RotateExtrudeNode.h"
-#include "core/CgalAdvNode.h"
-#include "core/ProjectionNode.h"
-#include "core/CsgOpNode.h"
+#include "core/State.h"
 #include "core/TextNode.h"
-#include "core/RenderNode.h"
+#include "core/TransformNode.h"
+#include "core/Tree.h"
 #include "geometry/ClipperUtils.h"
-#include "geometry/PolySetUtils.h"
+#include "geometry/Geometry.h"
+#include "geometry/GeometryCache.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
-#include "utils/calc.h"
-#include "utils/printutils.h"
-#include "utils/calc.h"
+#include "geometry/PolySetUtils.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/boolean_utils.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/linalg.h"
+#include "geometry/roof_ss.h"
+#include "geometry/roof_vd.h"
 #include "glview/RenderSettings.h"
+#include "utils/calc.h"
 #include "utils/degree_trig.h"
-#include <iterator>
-#include <cassert>
-#include <list>
-#include <utility>
-#include <memory>
-#include "geometry/boolean_utils.h"
+#include "utils/printutils.h"
 #ifdef ENABLE_CGAL
+#include <CGAL/Point_2.h>
+#include <CGAL/convex_hull_2.h>
 #include "geometry/cgal/CGALCache.h"
 #include "geometry/cgal/cgalutils.h"
-#include <CGAL/convex_hull_2.h>
-#include <CGAL/Point_2.h>
 #endif
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/manifoldutils.h"
@@ -53,19 +52,22 @@ class Geometry;
 class Polygon2d;
 class Tree;
 
-GeometryEvaluator::GeometryEvaluator(const Tree& tree) : tree(tree) { }
+GeometryEvaluator::GeometryEvaluator(const Tree& tree) : tree(tree) {}
 
 /*!
    Set allownef to false to force the result to _not_ be a Nef polyhedron
 
    There are some guarantees on the returned geometry:
- * 2D and 3D geometry cannot be mixed; we will return either _only_ 2D or _only_ 3D geometries
- * PolySet geometries are always 3D. 2D Polysets are only created for special-purpose rendering operations downstream from here.
- * Needs validation: Implementation-specific geometries shouldn't be mixed (Nef polyhedron, Manifold)
+ * 2D and 3D geometry cannot be mixed; we will return either _only_ 2D or _only_
+ 3D geometries
+ * PolySet geometries are always 3D. 2D Polysets are only created for
+ special-purpose rendering operations downstream from here.
+ * Needs validation: Implementation-specific geometries shouldn't be mixed (Nef
+ polyhedron, Manifold)
  */
-std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(const AbstractNode& node,
-                                                                    bool allownef)
-{
+std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(
+    const AbstractNode& node,
+    bool allownef) {
   auto result = smartCacheGet(node, allownef);
   if (!result) {
     // If not found in any caches, we need to evaluate the geometry
@@ -79,15 +81,19 @@ std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(const Abstra
   }
 
   // Convert engine-specific 3D geometry to PolySet if needed
-  // Note: we don't store the converted into the cache as it would conflict with subsequent calls where allownef is true.
+  // Note: we don't store the converted into the cache as it would conflict with
+  // subsequent calls where allownef is true.
   if (!allownef) {
     if (auto ps = PolySetUtils::getGeometryAsPolySet(result)) {
       assert(ps->getDimension() == 3);
       // We cannot render concave polygons, so tessellate any PolySets
       if (!ps->isEmpty() && !ps->isTriangular()) {
-        // Since is_convex() doesn't handle non-planar faces, we need to tessellate
-        // also in the indeterminate state so we cannot just use a boolean comparison. See #1061
-        bool convex = bool(ps->convexValue()); // bool is true only if tribool is true, (not indeterminate and not false)
+        // Since is_convex() doesn't handle non-planar faces, we need to
+        // tessellate also in the indeterminate state so we cannot just use a
+        // boolean comparison. See #1061
+        bool convex =
+            bool(ps->convexValue());  // bool is true only if tribool is true,
+                                      // (not indeterminate and not false)
         if (!convex) {
           ps = PolySetUtils::tessellate_faces(*ps);
         }
@@ -98,25 +104,34 @@ std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(const Abstra
   return result;
 }
 
-bool GeometryEvaluator::isValidDim(const Geometry::GeometryItem& item, unsigned int& dim) const {
+bool GeometryEvaluator::isValidDim(const Geometry::GeometryItem& item,
+                                   unsigned int& dim) const {
   if (!item.first->modinst->isBackground() && item.second) {
-    if (!dim) dim = item.second->getDimension();
+    if (!dim)
+      dim = item.second->getDimension();
     else if (dim != item.second->getDimension() && !item.second->isEmpty()) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Mixing 2D and 3D objects is not supported");
+      LOG(message_group::Warning, item.first->modinst->location(),
+          this->tree.getDocumentPath(),
+          "Mixing 2D and 3D objects is not supported");
       return false;
     }
   }
   return true;
 }
 
-GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren(const AbstractNode& node, OpenSCADOperator op)
-{
+GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren(
+    const AbstractNode& node,
+    OpenSCADOperator op) {
   unsigned int dim = 0;
   for (const auto& item : this->visitedchildren[node.index()]) {
-    if (!isValidDim(item, dim)) break;
+    if (!isValidDim(item, dim))
+      break;
   }
-  if (dim == 2) return ResultObject::mutableResult(std::shared_ptr<Geometry>(applyToChildren2D(node, op)));
-  else if (dim == 3) return applyToChildren3D(node, op);
+  if (dim == 2)
+    return ResultObject::mutableResult(
+        std::shared_ptr<Geometry>(applyToChildren2D(node, op)));
+  else if (dim == 3)
+    return applyToChildren3D(node, op);
   return {};
 }
 
@@ -125,81 +140,94 @@ GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren(const Abstrac
 
    May return nullptr or any 3D Geometry object
  */
-GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren3D(const AbstractNode& node, OpenSCADOperator op)
-{
+GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren3D(
+    const AbstractNode& node,
+    OpenSCADOperator op) {
   Geometry::Geometries children = collectChildren3D(node);
-  if (children.empty()) return {};
+  if (children.empty())
+    return {};
 
   if (op == OpenSCADOperator::HULL) {
-    return ResultObject::mutableResult(std::shared_ptr<Geometry>(applyHull(children)));
+    return ResultObject::mutableResult(
+        std::shared_ptr<Geometry>(applyHull(children)));
   } else if (op == OpenSCADOperator::FILL) {
     for (const auto& item : children) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "fill() not yet implemented for 3D");
+      LOG(message_group::Warning, item.first->modinst->location(),
+          this->tree.getDocumentPath(), "fill() not yet implemented for 3D");
     }
   }
 
   // Only one child -> this is a noop
-  if (children.size() == 1) return ResultObject::constResult(children.front().second);
+  if (children.size() == 1)
+    return ResultObject::constResult(children.front().second);
 
   switch (op) {
-  case OpenSCADOperator::MINKOWSKI:
-  {
-    Geometry::Geometries actualchildren;
-    for (const auto& item : children) {
-      if (item.second && !item.second->isEmpty()) actualchildren.push_back(item);
-    }
-    if (actualchildren.empty()) return {};
-    if (actualchildren.size() == 1) return ResultObject::constResult(actualchildren.front().second);
-    return ResultObject::constResult(applyMinkowski(actualchildren));
-    break;
-  }
-  case OpenSCADOperator::UNION:
-  {
-    Geometry::Geometries actualchildren;
-    for (const auto& item : children) {
-      if (item.second && !item.second->isEmpty()) actualchildren.push_back(item);
+    case OpenSCADOperator::MINKOWSKI: {
+      Geometry::Geometries actualchildren;
+      for (const auto& item : children) {
+        if (item.second && !item.second->isEmpty())
+          actualchildren.push_back(item);
+      }
+      if (actualchildren.empty())
+        return {};
+      if (actualchildren.size() == 1)
+        return ResultObject::constResult(actualchildren.front().second);
+      return ResultObject::constResult(applyMinkowski(actualchildren));
+      break;
     }
-    if (actualchildren.empty()) return {};
-    if (actualchildren.size() == 1) return ResultObject::constResult(actualchildren.front().second);
+    case OpenSCADOperator::UNION: {
+      Geometry::Geometries actualchildren;
+      for (const auto& item : children) {
+        if (item.second && !item.second->isEmpty())
+          actualchildren.push_back(item);
+      }
+      if (actualchildren.empty())
+        return {};
+      if (actualchildren.size() == 1)
+        return ResultObject::constResult(actualchildren.front().second);
 #ifdef ENABLE_MANIFOLD
-    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      return ResultObject::mutableResult(ManifoldUtils::applyOperator3DManifold(actualchildren, op));
-    }
+      if (RenderSettings::inst()->backend3D ==
+          RenderBackend3D::ManifoldBackend) {
+        return ResultObject::mutableResult(
+            ManifoldUtils::applyOperator3DManifold(actualchildren, op));
+      }
 #endif
 #ifdef ENABLE_CGAL
-    return ResultObject::constResult(std::shared_ptr<const Geometry>(CGALUtils::applyUnion3D(actualchildren.begin(), actualchildren.end())));
+      return ResultObject::constResult(
+          std::shared_ptr<const Geometry>(CGALUtils::applyUnion3D(
+              actualchildren.begin(), actualchildren.end())));
 #else
-    assert(false && "No boolean backend available");
+      assert(false && "No boolean backend available");
 #endif
-    break;
-  }
-  default:
-  {
-#ifdef ENABLE_MANIFOLD
-    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      return ResultObject::mutableResult(ManifoldUtils::applyOperator3DManifold(children, op));
+      break;
     }
+    default: {
+#ifdef ENABLE_MANIFOLD
+      if (RenderSettings::inst()->backend3D ==
+          RenderBackend3D::ManifoldBackend) {
+        return ResultObject::mutableResult(
+            ManifoldUtils::applyOperator3DManifold(children, op));
+      }
 #endif
 #ifdef ENABLE_CGAL
-    return ResultObject::constResult(CGALUtils::applyOperator3D(children, op));
+      return ResultObject::constResult(
+          CGALUtils::applyOperator3D(children, op));
 #else
-    assert(false && "No boolean backend available");
-    #endif
-    break;
-  }
+      assert(false && "No boolean backend available");
+#endif
+      break;
+    }
   }
 }
 
-
-
 /*!
    Apply 2D hull.
 
    May return an empty geometry but will not return nullptr.
  */
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D(const AbstractNode& node)
-{
+std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D(
+    const AbstractNode& node) {
   auto children = collectChildren2D(node);
   auto geometry = std::make_unique<Polygon2d>();
 
@@ -220,7 +248,8 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D(const AbstractNode& no
     // Apply hull
     std::list<CGALPoint2> result;
     try {
-      CGAL::convex_hull_2(points.begin(), points.end(), std::back_inserter(result));
+      CGAL::convex_hull_2(points.begin(), points.end(),
+                          std::back_inserter(result));
       // Construct Polygon2d
       Outline2d outline;
       for (const auto& p : result) {
@@ -229,17 +258,20 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D(const AbstractNode& no
       geometry->addOutline(outline);
       geometry->setSanitized(true);
     } catch (const CGAL::Failure_exception& e) {
-      LOG(message_group::Warning, "GeometryEvaluator::applyHull2D() during CGAL::convex_hull_2(): %1$s", e.what());
+      LOG(message_group::Warning,
+          "GeometryEvaluator::applyHull2D() during CGAL::convex_hull_2(): %1$s",
+          e.what());
     }
   }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
   return geometry;
 }
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyFill2D(const AbstractNode& node)
-{
+std::unique_ptr<Polygon2d> GeometryEvaluator::applyFill2D(
+    const AbstractNode& node) {
   // Merge and sanitize input geometry
-  auto geometry_in = ClipperUtils::apply(collectChildren2D(node), Clipper2Lib::ClipType::Union);
+  auto geometry_in = ClipperUtils::apply(collectChildren2D(node),
+                                         Clipper2Lib::ClipType::Union);
   assert(geometry_in->isSanitized());
 
   std::vector<std::shared_ptr<const Polygon2d>> newchildren;
@@ -254,16 +286,16 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyFill2D(const AbstractNode& no
   return ClipperUtils::apply(newchildren, Clipper2Lib::ClipType::Union);
 }
 
-std::unique_ptr<Geometry> GeometryEvaluator::applyHull3D(const AbstractNode& node)
-{
+std::unique_ptr<Geometry> GeometryEvaluator::applyHull3D(
+    const AbstractNode& node) {
   Geometry::Geometries children = collectChildren3D(node);
 
   auto P = PolySet::createEmpty();
   return applyHull(children);
 }
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyMinkowski2D(const AbstractNode& node)
-{
+std::unique_ptr<Polygon2d> GeometryEvaluator::applyMinkowski2D(
+    const AbstractNode& node) {
   auto children = collectChildren2D(node);
   if (!children.empty()) {
     return ClipperUtils::applyMinkowski(children);
@@ -275,13 +307,14 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyMinkowski2D(const AbstractNod
    Returns a list of Polygon2d children of the given node.
    May return empty Polygon2d object, but not nullptr objects
  */
-std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren2D(const AbstractNode& node)
-{
+std::vector<std::shared_ptr<const Polygon2d>>
+GeometryEvaluator::collectChildren2D(const AbstractNode& node) {
   std::vector<std::shared_ptr<const Polygon2d>> children;
   for (const auto& item : this->visitedchildren[node.index()]) {
     auto& chnode = item.first;
     auto& chgeom = item.second;
-    if (chnode->modinst->isBackground()) continue;
+    if (chnode->modinst->isBackground())
+      continue;
 
     // NB! We insert into the cache here to ensure that all children of
     // a node is a valid object. If we inserted as we created them, the
@@ -291,13 +324,16 @@ std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren
 
     if (chgeom) {
       if (chgeom->getDimension() == 3) {
-        LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Ignoring 3D child object for 2D operation");
-        children.push_back(nullptr); // replace 3D geometry with empty geometry
+        LOG(message_group::Warning, item.first->modinst->location(),
+            this->tree.getDocumentPath(),
+            "Ignoring 3D child object for 2D operation");
+        children.push_back(nullptr);  // replace 3D geometry with empty geometry
       } else {
         if (chgeom->isEmpty()) {
           children.push_back(nullptr);
         } else {
-          const auto polygon2d = std::dynamic_pointer_cast<const Polygon2d>(chgeom);
+          const auto polygon2d =
+              std::dynamic_pointer_cast<const Polygon2d>(chgeom);
           assert(polygon2d);
           children.push_back(polygon2d);
         }
@@ -310,13 +346,13 @@ std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren
 }
 
 /*!
-   Since we can generate both Nef and non-Nef geometry, we need to insert it into
-   the appropriate cache.
-   This method inserts the geometry into the appropriate cache if it's not already cached.
+   Since we can generate both Nef and non-Nef geometry, we need to insert it
+   into the appropriate cache. This method inserts the geometry into the
+   appropriate cache if it's not already cached.
  */
-void GeometryEvaluator::smartCacheInsert(const AbstractNode& node,
-                                         const std::shared_ptr<const Geometry>& geom)
-{
+void GeometryEvaluator::smartCacheInsert(
+    const AbstractNode& node,
+    const std::shared_ptr<const Geometry>& geom) {
   const std::string& key = this->tree.getIdString(node);
 
   if (CGALCache::acceptsGeometry(geom)) {
@@ -331,24 +367,28 @@ void GeometryEvaluator::smartCacheInsert(const AbstractNode& node,
 
     // Perhaps add acceptsGeometry() to GeometryCache as well?
     if (!GeometryCache::instance()->insert(key, geom)) {
-      LOG(message_group::Warning, "GeometryEvaluator: Node didn't fit into cache.");
+      LOG(message_group::Warning,
+          "GeometryEvaluator: Node didn't fit into cache.");
     }
   }
 }
 
-bool GeometryEvaluator::isSmartCached(const AbstractNode& node)
-{
+bool GeometryEvaluator::isSmartCached(const AbstractNode& node) {
   const std::string& key = this->tree.getIdString(node);
-  return GeometryCache::instance()->contains(key) || CGALCache::instance()->contains(key);
+  return GeometryCache::instance()->contains(key) ||
+         CGALCache::instance()->contains(key);
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::smartCacheGet(const AbstractNode& node, bool preferNef)
-{
+std::shared_ptr<const Geometry> GeometryEvaluator::smartCacheGet(
+    const AbstractNode& node,
+    bool preferNef) {
   const std::string& key = this->tree.getIdString(node);
   const bool hasgeom = GeometryCache::instance()->contains(key);
   const bool hascgal = CGALCache::instance()->contains(key);
-  if (hascgal && (preferNef || !hasgeom)) return CGALCache::instance()->get(key);
-  if (hasgeom) return GeometryCache::instance()->get(key);
+  if (hascgal && (preferNef || !hasgeom))
+    return CGALCache::instance()->get(key);
+  if (hasgeom)
+    return GeometryCache::instance()->get(key);
   return {};
 }
 
@@ -356,13 +396,14 @@ std::shared_ptr<const Geometry> GeometryEvaluator::smartCacheGet(const AbstractN
    Returns a list of 3D Geometry children of the given node.
    May return empty geometries, but not nullptr objects
  */
-Geometry::Geometries GeometryEvaluator::collectChildren3D(const AbstractNode& node)
-{
+Geometry::Geometries GeometryEvaluator::collectChildren3D(
+    const AbstractNode& node) {
   Geometry::Geometries children;
   for (const auto& item : this->visitedchildren[node.index()]) {
     auto& chnode = item.first;
     const std::shared_ptr<const Geometry>& chgeom = item.second;
-    if (chnode->modinst->isBackground()) continue;
+    if (chnode->modinst->isBackground())
+      continue;
 
     // NB! We insert into the cache here to ensure that all children of
     // a node is a valid object. If we inserted as we created them, the
@@ -371,8 +412,11 @@ Geometry::Geometries GeometryEvaluator::collectChildren3D(const AbstractNode& no
     smartCacheInsert(*chnode, chgeom);
 
     if (chgeom && chgeom->getDimension() == 2) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Ignoring 2D child object for 3D operation");
-      children.push_back(std::make_pair(item.first, nullptr)); // replace 2D geometry with empty geometry
+      LOG(message_group::Warning, item.first->modinst->location(),
+          this->tree.getDocumentPath(),
+          "Ignoring 2D child object for 3D operation");
+      children.push_back(std::make_pair(
+          item.first, nullptr));  // replace 2D geometry with empty geometry
     } else {
       // Add children if geometry is 3D OR null/empty
       children.push_back(item);
@@ -384,8 +428,9 @@ Geometry::Geometries GeometryEvaluator::collectChildren3D(const AbstractNode& no
 /*!
 
  */
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNode& node, OpenSCADOperator op)
-{
+std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(
+    const AbstractNode& node,
+    OpenSCADOperator op) {
   node.progress_report();
   if (op == OpenSCADOperator::MINKOWSKI) {
     return applyMinkowski2D(node);
@@ -403,7 +448,7 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNo
 
   if (children.size() == 1) {
     if (children[0]) {
-      return std::make_unique<Polygon2d>(*children[0]); // Copy
+      return std::make_unique<Polygon2d>(*children[0]);  // Copy
     } else {
       return nullptr;
     }
@@ -411,19 +456,19 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNo
 
   Clipper2Lib::ClipType clipType;
   switch (op) {
-  case OpenSCADOperator::UNION:
-    clipType = Clipper2Lib::ClipType::Union;
-    break;
-  case OpenSCADOperator::INTERSECTION:
-    clipType = Clipper2Lib::ClipType::Intersection;
-    break;
-  case OpenSCADOperator::DIFFERENCE:
-    clipType = Clipper2Lib::ClipType::Difference;
-    break;
-  default:
-    LOG(message_group::Error, "Unknown boolean operation %1$d", int(op));
-    return nullptr;
-    break;
+    case OpenSCADOperator::UNION:
+      clipType = Clipper2Lib::ClipType::Union;
+      break;
+    case OpenSCADOperator::INTERSECTION:
+      clipType = Clipper2Lib::ClipType::Intersection;
+      break;
+    case OpenSCADOperator::DIFFERENCE:
+      clipType = Clipper2Lib::ClipType::Difference;
+      break;
+    default:
+      LOG(message_group::Error, "Unknown boolean operation %1$d", int(op));
+      return nullptr;
+      break;
   }
 
   return ClipperUtils::apply(children, clipType);
@@ -438,13 +483,14 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNo
 
    The added geometry can be nullptr if it wasn't possible to evaluate it.
  */
-void GeometryEvaluator::addToParent(const State& state,
-                                    const AbstractNode& node,
-                                    const std::shared_ptr<const Geometry>& geom)
-{
+void GeometryEvaluator::addToParent(
+    const State& state,
+    const AbstractNode& node,
+    const std::shared_ptr<const Geometry>& geom) {
   this->visitedchildren.erase(node.index());
   if (state.parent()) {
-    this->visitedchildren[state.parent()->index()].push_back(std::make_pair(node.shared_from_this(), geom));
+    this->visitedchildren[state.parent()->index()].push_back(
+        std::make_pair(node.shared_from_this(), geom));
   } else {
     // Root node
     this->root = geom;
@@ -452,9 +498,9 @@ void GeometryEvaluator::addToParent(const State& state,
   }
 }
 
-Response GeometryEvaluator::visit(State& state, const ColorNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State& state, const ColorNode& node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
@@ -462,7 +508,8 @@ Response GeometryEvaluator::visit(State& state, const ColorNode& node)
       ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
       if ((geom = res.constptr())) {
         auto mutableGeom = res.asMutableGeometry();
-        if (mutableGeom) mutableGeom->setColor(node.color);
+        if (mutableGeom)
+          mutableGeom->setColor(node.color);
         geom = mutableGeom;
       }
     } else {
@@ -477,11 +524,12 @@ Response GeometryEvaluator::visit(State& state, const ColorNode& node)
 /*!
    Custom nodes are handled here => implicit union
  */
-Response GeometryEvaluator::visit(State& state, const AbstractNode& node)
-{
+Response GeometryEvaluator::visit(State& state, const AbstractNode& node) {
   if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+    if (isSmartCached(node))
+      return Response::PruneTraversal;
+    state.setPreferNef(
+        true);  // Improve quality of CSG by avoiding conversion loss
   }
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
@@ -499,17 +547,18 @@ Response GeometryEvaluator::visit(State& state, const AbstractNode& node)
 /*!
    Pass children to parent without touching them. Used by e.g. for loops
  */
-Response GeometryEvaluator::visit(State& state, const ListNode& node)
-{
+Response GeometryEvaluator::visit(State& state, const ListNode& node) {
   if (state.parent()) {
     if (state.isPrefix() && node.modinst->isBackground()) {
-      if (node.modinst->isBackground()) state.setBackground(true);
+      if (node.modinst->isBackground())
+        state.setBackground(true);
       return Response::PruneTraversal;
     }
     if (state.isPostfix()) {
       unsigned int dim = 0;
       for (const auto& item : this->visitedchildren[node.index()]) {
-        if (!isValidDim(item, dim)) break;
+        if (!isValidDim(item, dim))
+          break;
         auto& chnode = item.first;
         const std::shared_ptr<const Geometry>& chgeom = item.second;
         addToParent(state, *chnode, chgeom);
@@ -525,12 +574,12 @@ Response GeometryEvaluator::visit(State& state, const ListNode& node)
 
 /*!
  */
-Response GeometryEvaluator::visit(State& state, const GroupNode& node)
-{
+Response GeometryEvaluator::visit(State& state, const GroupNode& node) {
   return visit(state, (const AbstractNode&)node);
 }
 
-Response GeometryEvaluator::lazyEvaluateRootNode(State& state, const AbstractNode& node) {
+Response GeometryEvaluator::lazyEvaluateRootNode(State& state,
+                                                 const AbstractNode& node) {
   if (state.isPrefix()) {
     if (node.modinst->isBackground()) {
       state.setBackground(true);
@@ -546,20 +595,25 @@ Response GeometryEvaluator::lazyEvaluateRootNode(State& state, const AbstractNod
     unsigned int dim = 0;
     GeometryList::Geometries geometries;
     for (const auto& item : this->visitedchildren[node.index()]) {
-      if (!isValidDim(item, dim)) break;
+      if (!isValidDim(item, dim))
+        break;
       auto& chnode = item.first;
       const std::shared_ptr<const Geometry>& chgeom = item.second;
-      if (chnode->modinst->isBackground()) continue;
+      if (chnode->modinst->isBackground())
+        continue;
       // NB! We insert into the cache here to ensure that all children of
       // a node is a valid object. If we inserted as we created them, the
-      // cache could have been modified before we reach this point due to a large
-      // sibling object.
+      // cache could have been modified before we reach this point due to a
+      // large sibling object.
       smartCacheInsert(*chnode, chgeom);
       // Only use valid geometries
-      if (chgeom && !chgeom->isEmpty()) geometries.push_back(item);
+      if (chgeom && !chgeom->isEmpty())
+        geometries.push_back(item);
     }
-    if (geometries.size() == 1) geom = geometries.front().second;
-    else if (geometries.size() > 1) geom = std::make_shared<GeometryList>(geometries);
+    if (geometries.size() == 1)
+      geom = geometries.front().second;
+    else if (geometries.size() > 1)
+      geom = std::make_shared<GeometryList>(geometries);
 
     this->root = geom;
   }
@@ -573,8 +627,7 @@ Response GeometryEvaluator::lazyEvaluateRootNode(State& state, const AbstractNod
    NB! This is likely a temporary measure until a better implementation of
    group nodes is in place.
  */
-Response GeometryEvaluator::visit(State& state, const RootNode& node)
-{
+Response GeometryEvaluator::visit(State& state, const RootNode& node) {
   // If we didn't enable lazy unions, just union the top-level objects
   if (!Feature::ExperimentalLazyUnion.is_enabled()) {
     return visit(state, (const GroupNode&)node);
@@ -582,18 +635,22 @@ Response GeometryEvaluator::visit(State& state, const RootNode& node)
   return lazyEvaluateRootNode(state, node);
 }
 
-Response GeometryEvaluator::visit(State& state, const OffsetNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State& state, const OffsetNode& node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
-      if (const auto polygon = applyToChildren2D(node, OpenSCADOperator::UNION)) {
-        // ClipperLib documentation: The formula for the number of steps in a full
-        // circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
-        double n = Calc::get_fragments_from_r(std::abs(node.delta), node.fn, node.fs, node.fa);
-        double arc_tolerance = std::abs(node.delta) * (1 - cos_degrees(180 / n));
-        geom = ClipperUtils::applyOffset(*polygon, node.delta, node.join_type, node.miter_limit, arc_tolerance);
+      if (const auto polygon =
+              applyToChildren2D(node, OpenSCADOperator::UNION)) {
+        // ClipperLib documentation: The formula for the number of steps in a
+        // full circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
+        double n = Calc::get_fragments_from_r(std::abs(node.delta), node.fn,
+                                              node.fs, node.fa);
+        double arc_tolerance =
+            std::abs(node.delta) * (1 - cos_degrees(180 / n));
+        geom = ClipperUtils::applyOffset(*polygon, node.delta, node.join_type,
+                                         node.miter_limit, arc_tolerance);
         assert(geom);
       }
     } else {
@@ -608,18 +665,20 @@ Response GeometryEvaluator::visit(State& state, const OffsetNode& node)
 /*!
    RenderNodes just pass on convexity
  */
-Response GeometryEvaluator::visit(State& state, const RenderNode& node)
-{
+Response GeometryEvaluator::visit(State& state, const RenderNode& node) {
   if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+    if (isSmartCached(node))
+      return Response::PruneTraversal;
+    state.setPreferNef(
+        true);  // Improve quality of CSG by avoiding conversion loss
   }
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
       ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
       auto mutableGeom = res.asMutableGeometry();
-      if (mutableGeom) mutableGeom->setConvexity(node.convexity);
+      if (mutableGeom)
+        mutableGeom->setConvexity(node.convexity);
       geom = mutableGeom;
     } else {
       geom = smartCacheGet(node, state.preferNef());
@@ -636,19 +695,20 @@ Response GeometryEvaluator::visit(State& state, const RenderNode& node)
    input: None
    output: PolySet or Polygon2d
  */
-Response GeometryEvaluator::visit(State& state, const LeafNode& node)
-{
+Response GeometryEvaluator::visit(State& state, const LeafNode& node) {
   if (state.isPrefix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
       geom = node.createGeometry();
       assert(geom);
-      if (const auto polygon = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+      if (const auto polygon =
+              std::dynamic_pointer_cast<const Polygon2d>(geom)) {
         if (!polygon->isSanitized()) {
           geom = ClipperUtils::sanitize(*polygon);
         }
-      } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-//        assert(!ps->hasDegeneratePolygons());
+      } else if (const auto ps =
+                     std::dynamic_pointer_cast<const PolySet>(geom)) {
+        //        assert(!ps->hasDegeneratePolygons());
       }
     } else {
       geom = smartCacheGet(node, state.preferNef());
@@ -659,8 +719,7 @@ Response GeometryEvaluator::visit(State& state, const LeafNode& node)
   return Response::PruneTraversal;
 }
 
-Response GeometryEvaluator::visit(State& state, const TextNode& node)
-{
+Response GeometryEvaluator::visit(State& state, const TextNode& node) {
   if (state.isPrefix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
@@ -675,18 +734,18 @@ Response GeometryEvaluator::visit(State& state, const TextNode& node)
   return Response::PruneTraversal;
 }
 
-
 /*!
    input: List of 2D or 3D objects (not mixed)
    output: Polygon2d or 3D PolySet
    operation:
     o Perform csg op on children
  */
-Response GeometryEvaluator::visit(State& state, const CsgOpNode& node)
-{
+Response GeometryEvaluator::visit(State& state, const CsgOpNode& node) {
   if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+    if (isSmartCached(node))
+      return Response::PruneTraversal;
+    state.setPreferNef(
+        true);  // Improve quality of CSG by avoiding conversion loss
   }
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
@@ -708,39 +767,47 @@ Response GeometryEvaluator::visit(State& state, const CsgOpNode& node)
     o Union all children
     o Perform transform
  */
-Response GeometryEvaluator::visit(State& state, const TransformNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State& state, const TransformNode& node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
-      if (matrix_contains_infinity(node.matrix) || matrix_contains_nan(node.matrix)) {
-        // due to the way parse/eval works we can't currently distinguish between NaN and Inf
-        LOG(message_group::Warning, node.modinst->location(), this->tree.getDocumentPath(), "Transformation matrix contains Not-a-Number and/or Infinity - removing object.");
+      if (matrix_contains_infinity(node.matrix) ||
+          matrix_contains_nan(node.matrix)) {
+        // due to the way parse/eval works we can't currently distinguish
+        // between NaN and Inf
+        LOG(message_group::Warning, node.modinst->location(),
+            this->tree.getDocumentPath(),
+            "Transformation matrix contains Not-a-Number and/or Infinity - "
+            "removing object.");
       } else {
         // First union all children
         ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
         if ((geom = res.constptr())) {
           if (geom->getDimension() == 2) {
-            auto polygons = std::dynamic_pointer_cast<Polygon2d>(res.asMutableGeometry());
+            auto polygons =
+                std::dynamic_pointer_cast<Polygon2d>(res.asMutableGeometry());
             assert(polygons);
 
             Transform2d mat2;
-            mat2.matrix() <<
-              node.matrix(0, 0), node.matrix(0, 1), node.matrix(0, 3),
-              node.matrix(1, 0), node.matrix(1, 1), node.matrix(1, 3),
-              node.matrix(3, 0), node.matrix(3, 1), node.matrix(3, 3);
+            mat2.matrix() << node.matrix(0, 0), node.matrix(0, 1),
+                node.matrix(0, 3), node.matrix(1, 0), node.matrix(1, 1),
+                node.matrix(1, 3), node.matrix(3, 0), node.matrix(3, 1),
+                node.matrix(3, 3);
             polygons->transform(mat2);
-            // FIXME: We lose the transform if we copied a const geometry above. Probably similar issue in multiple places
-            // A 2D transformation may flip the winding order of a polygon.
-            // If that happens with a sanitized polygon, we need to reverse
-            // the winding order for it to be correct.
+            // FIXME: We lose the transform if we copied a const geometry above.
+            // Probably similar issue in multiple places A 2D transformation may
+            // flip the winding order of a polygon. If that happens with a
+            // sanitized polygon, we need to reverse the winding order for it to
+            // be correct.
             if (polygons->isSanitized() && mat2.matrix().determinant() <= 0) {
               geom = ClipperUtils::sanitize(*polygons);
             }
           } else if (geom->getDimension() == 3) {
             auto mutableGeom = res.asMutableGeometry();
-            if (mutableGeom) mutableGeom->transform(node.matrix);
+            if (mutableGeom)
+              mutableGeom->transform(node.matrix);
             geom = mutableGeom;
           }
         }
@@ -761,15 +828,17 @@ Response GeometryEvaluator::visit(State& state, const TransformNode& node)
     o Union all children
     o Perform extrude
  */
-Response GeometryEvaluator::visit(State& state, const LinearExtrudeNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State& state, const LinearExtrudeNode& node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
-      const std::shared_ptr<const Geometry> geometry = applyToChildren2D(node, OpenSCADOperator::UNION);
+      const std::shared_ptr<const Geometry> geometry =
+          applyToChildren2D(node, OpenSCADOperator::UNION);
       if (geometry) {
-        const auto polygons = std::dynamic_pointer_cast<const Polygon2d>(geometry);
+        const auto polygons =
+            std::dynamic_pointer_cast<const Polygon2d>(geometry);
         geom = extrudePolygon(node, *polygons);
         assert(geom);
       }
@@ -789,13 +858,14 @@ Response GeometryEvaluator::visit(State& state, const LinearExtrudeNode& node)
     o Union all children
     o Perform extrude
  */
-Response GeometryEvaluator::visit(State& state, const RotateExtrudeNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State& state, const RotateExtrudeNode& node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
-      const std::shared_ptr<const Polygon2d> geometry = applyToChildren2D(node, OpenSCADOperator::UNION);
+      const std::shared_ptr<const Polygon2d> geometry =
+          applyToChildren2D(node, OpenSCADOperator::UNION);
       if (geometry) {
         geom = rotatePolygon(node, *geometry);
       }
@@ -811,16 +881,17 @@ Response GeometryEvaluator::visit(State& state, const RotateExtrudeNode& node)
 /*!
    FIXME: Not in use
  */
-Response GeometryEvaluator::visit(State& /*state*/, const AbstractPolyNode& /*node*/)
-{
+Response GeometryEvaluator::visit(State& /*state*/,
+                                  const AbstractPolyNode& /*node*/) {
   assert(false);
   return Response::AbortTraversal;
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::projectionCut(const ProjectionNode& node)
-{
+std::shared_ptr<const Geometry> GeometryEvaluator::projectionCut(
+    const ProjectionNode& node) {
   std::shared_ptr<const Geometry> geom;
-  std::shared_ptr<const Geometry> newgeom = applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
+  std::shared_ptr<const Geometry> newgeom =
+      applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
   if (newgeom) {
 #ifdef ENABLE_MANIFOLD
     if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
@@ -845,11 +916,12 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionCut(const Projectio
   return geom;
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const ProjectionNode& node)
-{
+std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(
+    const ProjectionNode& node) {
 #ifdef ENABLE_MANIFOLD
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    const std::shared_ptr<const Geometry> newgeom = applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
+    const std::shared_ptr<const Geometry> newgeom =
+        applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
     if (newgeom) {
       auto manifold = ManifoldUtils::createManifoldFromGeometry(newgeom);
       if (manifold != nullptr) {
@@ -860,11 +932,12 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const Project
       return std::make_shared<Polygon2d>();
     }
   }
-#endif // ifdef ENABLE_MANIFOLD
+#endif  // ifdef ENABLE_MANIFOLD
 
   std::vector<std::shared_ptr<const Polygon2d>> tmp_geom;
   for (const auto& [chnode, chgeom] : this->visitedchildren[node.index()]) {
-    if (chnode->modinst->isBackground()) continue;
+    if (chnode->modinst->isBackground())
+      continue;
 
     // Clipper version of Geometry projection
     // Clipper doesn't handle meshes very well.
@@ -880,7 +953,6 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const Project
   return std::shared_ptr(std::move(projected));
 }
 
-
 /*!
    input: List of 3D objects
    output: Polygon2d
@@ -888,9 +960,9 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const Project
     o Union all children
     o Perform projection
  */
-Response GeometryEvaluator::visit(State& state, const ProjectionNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State& state, const ProjectionNode& node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (isSmartCached(node)) {
@@ -914,44 +986,44 @@ Response GeometryEvaluator::visit(State& state, const ProjectionNode& node)
    operation:
     o Perform cgal operation
  */
-Response GeometryEvaluator::visit(State& state, const CgalAdvNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State& state, const CgalAdvNode& node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
       switch (node.type) {
-      case CgalAdvType::MINKOWSKI: {
-        ResultObject res = applyToChildren(node, OpenSCADOperator::MINKOWSKI);
-        geom = res.constptr();
-        // If we added convexity, we need to pass it on
-        if (geom && geom->getConvexity() != node.convexity) {
+        case CgalAdvType::MINKOWSKI: {
+          ResultObject res = applyToChildren(node, OpenSCADOperator::MINKOWSKI);
+          geom = res.constptr();
+          // If we added convexity, we need to pass it on
+          if (geom && geom->getConvexity() != node.convexity) {
+            auto editablegeom = res.asMutableGeometry();
+            editablegeom->setConvexity(node.convexity);
+            geom = editablegeom;
+          }
+          break;
+        }
+        case CgalAdvType::HULL: {
+          geom = applyToChildren(node, OpenSCADOperator::HULL).constptr();
+          break;
+        }
+        case CgalAdvType::FILL: {
+          geom = applyToChildren(node, OpenSCADOperator::FILL).constptr();
+          break;
+        }
+        case CgalAdvType::RESIZE: {
+          ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
           auto editablegeom = res.asMutableGeometry();
-          editablegeom->setConvexity(node.convexity);
           geom = editablegeom;
+          if (editablegeom) {
+            editablegeom->setConvexity(node.convexity);
+            editablegeom->resize(node.newsize, node.autosize);
+          }
+          break;
         }
-        break;
-      }
-      case CgalAdvType::HULL: {
-        geom = applyToChildren(node, OpenSCADOperator::HULL).constptr();
-        break;
-      }
-      case CgalAdvType::FILL: {
-        geom = applyToChildren(node, OpenSCADOperator::FILL).constptr();
-        break;
-      }
-      case CgalAdvType::RESIZE: {
-        ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
-        auto editablegeom = res.asMutableGeometry();
-        geom = editablegeom;
-        if (editablegeom) {
-          editablegeom->setConvexity(node.convexity);
-          editablegeom->resize(node.newsize, node.autosize);
-        }
-        break;
-      }
-      default:
-        assert(false && "not implemented");
+        default:
+          assert(false && "not implemented");
       }
     } else {
       geom = smartCacheGet(node, state.preferNef());
@@ -962,11 +1034,13 @@ Response GeometryEvaluator::visit(State& state, const CgalAdvNode& node)
   return Response::ContinueTraversal;
 }
 
-Response GeometryEvaluator::visit(State& state, const AbstractIntersectionNode& node)
-{
+Response GeometryEvaluator::visit(State& state,
+                                  const AbstractIntersectionNode& node) {
   if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+    if (isSmartCached(node))
+      return Response::PruneTraversal;
+    state.setPreferNef(
+        true);  // Improve quality of CSG by avoiding conversion loss
   }
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
@@ -983,8 +1057,8 @@ Response GeometryEvaluator::visit(State& state, const AbstractIntersectionNode&
 
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
 // FIXME: What is the convex/manifold situation of the resulting PolySet?
-static std::unique_ptr<Geometry> roofOverPolygon(const RoofNode& node, const Polygon2d& poly)
-{
+static std::unique_ptr<Geometry> roofOverPolygon(const RoofNode& node,
+                                                 const Polygon2d& poly) {
   std::unique_ptr<PolySet> roof;
   if (node.method == "voronoi") {
     roof = roof_vd::voronoi_diagram_roof(poly, node.fa, node.fs);
@@ -999,9 +1073,9 @@ static std::unique_ptr<Geometry> roofOverPolygon(const RoofNode& node, const Pol
   return roof;
 }
 
-Response GeometryEvaluator::visit(State& state, const RoofNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State& state, const RoofNode& node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
@@ -1011,7 +1085,8 @@ Response GeometryEvaluator::visit(State& state, const RoofNode& node)
         try {
           roof = roofOverPolygon(node, *polygon2d);
         } catch (RoofNode::roof_exception& e) {
-          LOG(message_group::Error, node.modinst->location(), this->tree.getDocumentPath(),
+          LOG(message_group::Error, node.modinst->location(),
+              this->tree.getDocumentPath(),
               "Skeleton computation error. " + e.message());
           roof = PolySet::createEmpty();
         }
@@ -1025,4 +1100,4 @@ Response GeometryEvaluator::visit(State& state, const RoofNode& node)
   }
   return Response::ContinueTraversal;
 }
-#endif // if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
+#endif  // if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
diff --git a/src/geometry/GeometryEvaluator.h b/src/geometry/GeometryEvaluator.h
index 1b72de0d1..fdbf9e565 100644
--- a/src/geometry/GeometryEvaluator.h
+++ b/src/geometry/GeometryEvaluator.h
@@ -1,29 +1,31 @@
 #pragma once
 
 #include "core/NodeVisitor.h"
-#include "geometry/linalg.h"
 #include "core/enums.h"
 #include "geometry/Geometry.h"
+#include "geometry/linalg.h"
 
 #include <cassert>
+#include <map>
 #include <memory>
 #include <utility>
 #include <vector>
-#include <map>
 
 class CGALNefGeometry;
 class Polygon2d;
 class Tree;
 
-// This evaluates a node tree into concrete geometry usign an underlying geometry engine
-// FIXME: Ideally, each engine should implement its own subtype. Instead we currently have
-// multiple embedded engines with varoius methods of selecting the right one.
-class GeometryEvaluator : public NodeVisitor
-{
-public:
+// This evaluates a node tree into concrete geometry usign an underlying
+// geometry engine
+// FIXME: Ideally, each engine should implement its own subtype. Instead we
+// currently have multiple embedded engines with varoius methods of selecting
+// the right one.
+class GeometryEvaluator : public NodeVisitor {
+ public:
   GeometryEvaluator(const Tree& tree);
 
-  std::shared_ptr<const Geometry> evaluateGeometry(const AbstractNode& node, bool allownef);
+  std::shared_ptr<const Geometry> evaluateGeometry(const AbstractNode& node,
+                                                   bool allownef);
 
   Response visit(State& state, const AbstractNode& node) override;
   Response visit(State& state, const ColorNode& node) override;
@@ -48,62 +50,86 @@ public:
 
   [[nodiscard]] const Tree& getTree() const { return this->tree; }
 
-private:
-  class ResultObject
-  {
-public:
+ private:
+  class ResultObject {
+   public:
     // This makes it explicit if we want a const vs. non-const result.
     // This is important to avoid inadvertently tagging a geometry as const when
     // the underlying geometry is actually mutable.
     // The template trick, combined with private constructors, makes it possible
     // to create a ResultObject containing a const, _only_ from const objects
     // (i.e. no implicit conversion from non-const to const).
-    template <class T> static ResultObject constResult(std::shared_ptr<const T> geom) {return {geom};}
-    template <class T> static ResultObject mutableResult(std::shared_ptr<T> geom) {return {geom};}
+    template <class T>
+    static ResultObject constResult(std::shared_ptr<const T> geom) {
+      return {geom};
+    }
+    template <class T>
+    static ResultObject mutableResult(std::shared_ptr<T> geom) {
+      return {geom};
+    }
 
     // Default constructor with nullptr can be used to represent empty geometry,
     // for example union() with no children, etc.
     ResultObject() : is_const(true) {}
-    std::shared_ptr<Geometry> ptr() { assert(!is_const); return pointer; }
+    std::shared_ptr<Geometry> ptr() {
+      assert(!is_const);
+      return pointer;
+    }
     [[nodiscard]] std::shared_ptr<const Geometry> constptr() const {
-      return is_const ? const_pointer : std::static_pointer_cast<const Geometry>(pointer);
+      return is_const ? const_pointer
+                      : std::static_pointer_cast<const Geometry>(pointer);
     }
     std::shared_ptr<Geometry> asMutableGeometry() {
-      if (is_const) return {constptr() ? constptr()->copy() : nullptr};
-      else return ptr();
+      if (is_const)
+        return {constptr() ? constptr()->copy() : nullptr};
+      else
+        return ptr();
     }
-private:
-    template <class T> ResultObject(std::shared_ptr<const T> g) : is_const(true), const_pointer(std::move(g)) {}
-    template <class T> ResultObject(std::shared_ptr<T> g) : is_const(false), pointer(std::move(g)) {}
+
+   private:
+    template <class T>
+    ResultObject(std::shared_ptr<const T> g)
+        : is_const(true), const_pointer(std::move(g)) {}
+    template <class T>
+    ResultObject(std::shared_ptr<T> g)
+        : is_const(false), pointer(std::move(g)) {}
 
     bool is_const;
     std::shared_ptr<Geometry> pointer;
     std::shared_ptr<const Geometry> const_pointer;
   };
 
-  void smartCacheInsert(const AbstractNode& node, const std::shared_ptr<const Geometry>& geom);
-  std::shared_ptr<const Geometry> smartCacheGet(const AbstractNode& node, bool preferNef);
+  void smartCacheInsert(const AbstractNode& node,
+                        const std::shared_ptr<const Geometry>& geom);
+  std::shared_ptr<const Geometry> smartCacheGet(const AbstractNode& node,
+                                                bool preferNef);
   bool isSmartCached(const AbstractNode& node);
   bool isValidDim(const Geometry::GeometryItem& item, unsigned int& dim) const;
-  std::vector<std::shared_ptr<const Polygon2d>> collectChildren2D(const AbstractNode& node);
+  std::vector<std::shared_ptr<const Polygon2d>> collectChildren2D(
+      const AbstractNode& node);
   Geometry::Geometries collectChildren3D(const AbstractNode& node);
   std::unique_ptr<Polygon2d> applyMinkowski2D(const AbstractNode& node);
   std::unique_ptr<Polygon2d> applyHull2D(const AbstractNode& node);
   std::unique_ptr<Polygon2d> applyFill2D(const AbstractNode& node);
   std::unique_ptr<Geometry> applyHull3D(const AbstractNode& node);
-  void applyResize3D(CGALNefGeometry& N, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize);
-  std::unique_ptr<Polygon2d> applyToChildren2D(const AbstractNode& node, OpenSCADOperator op);
+  void applyResize3D(CGALNefGeometry& N,
+                     const Vector3d& newsize,
+                     const Eigen::Matrix<bool, 3, 1>& autosize);
+  std::unique_ptr<Polygon2d> applyToChildren2D(const AbstractNode& node,
+                                               OpenSCADOperator op);
   ResultObject applyToChildren3D(const AbstractNode& node, OpenSCADOperator op);
   ResultObject applyToChildren(const AbstractNode& node, OpenSCADOperator op);
   std::shared_ptr<const Geometry> projectionCut(const ProjectionNode& node);
   std::shared_ptr<const Geometry> projectionNoCut(const ProjectionNode& node);
 
-  void addToParent(const State& state, const AbstractNode& node, const std::shared_ptr<const Geometry>& geom);
+  void addToParent(const State& state,
+                   const AbstractNode& node,
+                   const std::shared_ptr<const Geometry>& geom);
   Response lazyEvaluateRootNode(State& state, const AbstractNode& node);
 
   std::map<int, Geometry::Geometries> visitedchildren;
   const Tree& tree;
   std::shared_ptr<const Geometry> root;
 
-public:
+ public:
 };
diff --git a/src/geometry/GeometryUtils.cc b/src/geometry/GeometryUtils.cc
index 09d09425d..cf538930c 100644
--- a/src/geometry/GeometryUtils.cc
+++ b/src/geometry/GeometryUtils.cc
@@ -1,40 +1,40 @@
 #include "geometry/GeometryUtils.h"
 
 #include <algorithm>
-#include <cassert>
-#include <unordered_map>
-#include <list>
-#include <utility>
 #include <boost/functional/hash.hpp>
-#include <cstddef>
+#include <cassert>
 #include <cmath>
+#include <cstddef>
+#include <list>
 #include <memory>
 #include <string>
+#include <unordered_map>
+#include <utility>
 #include <vector>
 
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
+#include "geometry/Reindexer.h"
 #include "geometry/linalg.h"
+#include "glview/RenderSettings.h"
 #include "libtess2/Include/tesselator.h"
 #include "utils/printutils.h"
-#include "geometry/Reindexer.h"
-#include "glview/RenderSettings.h"
-#include "geometry/PolySet.h"
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
 
 #ifdef ENABLE_MANIFOLD
-#include "geometry/manifold/manifoldutils.h"
 #include "geometry/manifold/ManifoldGeometry.h"
+#include "geometry/manifold/manifoldutils.h"
 #endif
 
-static void *stdAlloc(void *userData, unsigned int size) {
+static void* stdAlloc(void* userData, unsigned int size) {
   TESS_NOTUSED(userData);
   return malloc(size);
 }
 
-static void stdFree(void *userData, void *ptr) {
+static void stdFree(void* userData, void* ptr) {
   TESS_NOTUSED(userData);
   free(ptr);
 }
@@ -45,19 +45,21 @@ using IndexedEdge = std::pair<int, int>;
    Helper class for keeping track of edges in a mesh.
    Can probably be replaced with a proper HalfEdge mesh later on
  */
-class EdgeDict
-{
-public:
-// Counts occurrences of edges
-  using IndexedEdgeDict = std::unordered_map<IndexedEdge, int, boost::hash<IndexedEdge>>;
+class EdgeDict {
+ public:
+  // Counts occurrences of edges
+  using IndexedEdgeDict =
+      std::unordered_map<IndexedEdge, int, boost::hash<IndexedEdge>>;
 
   EdgeDict() = default;
 
   void add(const IndexedFace& face) {
     for (size_t i = 0; i < face.size(); ++i) {
       IndexedEdge e(face[(i + 1) % face.size()], face[i]);
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+      if (this->count(e) > 0)
+        this->remove(e);
+      else
+        this->add(e.second, e.first);
     }
   }
 
@@ -65,8 +67,10 @@ public:
     for (int i = 0; i < 3; ++i) {
       IndexedEdge e(t[i], t[(i + 1) % 3]);
       // If the edge exist, remove it
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+      if (this->count(e) > 0)
+        this->remove(e);
+      else
+        this->add(e.second, e.first);
     }
   }
 
@@ -74,37 +78,35 @@ public:
     for (int i = 0; i < 3; ++i) {
       IndexedEdge e(t[(i + 1) % 3], t[i]);
       // If an opposite edge exists, they cancel out
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+      if (this->count(e) > 0)
+        this->remove(e);
+      else
+        this->add(e.second, e.first);
     }
   }
 
-  void add(int start, int end) {
-    this->add(IndexedEdge(start, end));
-  }
+  void add(int start, int end) { this->add(IndexedEdge(start, end)); }
 
   void add(const IndexedEdge& e) {
     this->edges[e]++;
-//    PRINTDB("add: (%d,%d)", e.first % e.second);
+    //    PRINTDB("add: (%d,%d)", e.first % e.second);
   }
 
-  void remove(int start, int end) {
-    this->remove(IndexedEdge(start, end));
-  }
+  void remove(int start, int end) { this->remove(IndexedEdge(start, end)); }
 
   void remove(const IndexedEdge& e) {
     this->edges[e]--;
-    if (this->edges[e] == 0) this->edges.erase(e);
-//    PRINTDB("remove: (%d,%d)", e.first % e.second);
+    if (this->edges[e] == 0)
+      this->edges.erase(e);
+    //    PRINTDB("remove: (%d,%d)", e.first % e.second);
   }
 
-  int count(int start, int end) {
-    return this->count(IndexedEdge(start, end));
-  }
+  int count(int start, int end) { return this->count(IndexedEdge(start, end)); }
 
   int count(const IndexedEdge& e) {
     auto it = this->edges.find(e);
-    if (it != edges.end()) return it->second;
+    if (it != edges.end())
+      return it->second;
     return 0;
   }
 
@@ -113,31 +115,38 @@ public:
   size_t size() const { return this->edges.size(); }
 
   void print() const {
-//    for (const auto& v : this->edges) {
-//      const auto& e = v.first;
-//      PRINTDB("     (%d,%d)%s", e.first % e.second % ((v.second > 1) ? std::to_string(v.second).c_str() : ""));
-//    }
+    //    for (const auto& v : this->edges) {
+    //      const auto& e = v.first;
+    //      PRINTDB("     (%d,%d)%s", e.first % e.second % ((v.second > 1) ?
+    //      std::to_string(v.second).c_str() : ""));
+    //    }
   }
 
   void remove_from_v2e(int vidx, int next, int prev) {
     auto& l = v2e[vidx];
     auto it = std::find(l.begin(), l.end(), next);
-    if (it != l.end()) l.erase(it);
-    if (l.empty()) v2e.erase(vidx);
+    if (it != l.end())
+      l.erase(it);
+    if (l.empty())
+      v2e.erase(vidx);
 
     auto& l2 = v2e_reverse[vidx];
     it = std::find(l2.begin(), l2.end(), prev);
-    if (it != l2.end()) l2.erase(it);
-    if (l2.empty()) v2e_reverse.erase(vidx);
+    if (it != l2.end())
+      l2.erase(it);
+    if (l2.empty())
+      v2e_reverse.erase(vidx);
   }
 
-  void extractTriangle(int vidx, int next, std::vector<IndexedTriangle>& triangles) {
+  void extractTriangle(int vidx,
+                       int next,
+                       std::vector<IndexedTriangle>& triangles) {
     assert(v2e_reverse.find(vidx) != v2e_reverse.end());
     assert(!v2e_reverse[vidx].empty());
     auto prev = v2e_reverse[vidx].front();
 
     IndexedTriangle t(prev, vidx, next);
-//    PRINTDB("Clipping ear: %d %d %d", t[0] % t[1] % t[2]);
+    //    PRINTDB("Clipping ear: %d %d %d", t[0] % t[1] % t[2]);
     triangles.push_back(t);
     // Remove the generated triangle from the original.
     // Add new boundary edges to the edge dict
@@ -170,7 +179,7 @@ public:
     while (!v2e.empty()) {
       std::unordered_map<int, std::list<int>>::iterator it;
       for (it = v2e.begin(); it != v2e.end(); ++it) {
-        if (it->second.size() == 1) { // First single vertex
+        if (it->second.size() == 1) {  // First single vertex
           auto vidx = it->first;
           auto next = it->second.front();
           extractTriangle(vidx, next, triangles);
@@ -191,7 +200,6 @@ public:
   std::unordered_map<int, std::list<int>> v2e_reverse;
 };
 
-
 /*!
    Tessellates input contours into a triangle mesh.
 
@@ -210,11 +218,11 @@ public:
 
    Returns true on error, false on success.
  */
-bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vertices,
-                                               const std::vector<IndexedFace>& faces,
-                                               std::vector<IndexedTriangle>& triangles,
-                                               const Vector3f *normal)
-{
+bool GeometryUtils::tessellatePolygonWithHoles(
+    const std::vector<Vector3f>& vertices,
+    const std::vector<IndexedFace>& faces,
+    std::vector<IndexedTriangle>& triangles,
+    const Vector3f* normal) {
   // Algorithm outline:
   // o Remove consecutive equal vertices and null ears (i.e. 23,24,23)
   // o Ignore polygons with < 3 vertices
@@ -223,18 +231,23 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   // o Postprocess to clean up misbehaviors in libtess2
 
   // No polygon. FIXME: Will this ever happen or can we assert here?
-  if (faces.empty()) return false;
+  if (faces.empty())
+    return false;
 
   // Remove consecutive equal vertices, as well as null ears
   auto cleanfaces = faces;
   for (auto& face : cleanfaces) {
     size_t i = 0;
     while (face.size() >= 3 && i < face.size()) {
-      if (face[i] == face[(i + 1) % face.size()]) { // Two consecutively equal indices
+      if (face[i] ==
+          face[(i + 1) % face.size()]) {  // Two consecutively equal indices
         face.erase(face.begin() + i);
-      } else if (face[(i + face.size() - 1) % face.size()] == face[(i + 1) % face.size()]) { // Null ear
-        if (i == 0) face.erase(face.begin() + i, face.begin() + i + 2);
-        else face.erase(face.begin() + i - 1, face.begin() + i + 1);
+      } else if (face[(i + face.size() - 1) % face.size()] ==
+                 face[(i + 1) % face.size()]) {  // Null ear
+        if (i == 0)
+          face.erase(face.begin() + i, face.begin() + i + 2);
+        else
+          face.erase(face.begin() + i - 1, face.begin() + i + 1);
         i--;
       } else {
         // Filter away inf and nan vertices as they cause libtess2 to crash
@@ -246,12 +259,14 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
             break;
           }
         }
-        if (k == 3) i++;
+        if (k == 3)
+          i++;
       }
     }
   }
   // First polygon has < 3 points - no output
-  if (cleanfaces[0].size() < 3) return false;
+  if (cleanfaces[0].size() < 3)
+    return false;
   // Remove collapsed holes
   for (size_t i = 1; i < cleanfaces.size(); ++i) {
     if (cleanfaces[i].size() < 3) {
@@ -262,8 +277,10 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
 
   if (cleanfaces.size() == 1 && cleanfaces[0].size() == 3) {
     // Input polygon has 3 points. shortcut tessellation.
-    //PRINTDB("  tri: %d %d %d", cleanfaces[0][0] % cleanfaces[0][1] % cleanfaces[0][2]);
-    triangles.emplace_back(cleanfaces[0][0], cleanfaces[0][1], cleanfaces[0][2]);
+    // PRINTDB("  tri: %d %d %d", cleanfaces[0][0] % cleanfaces[0][1] %
+    // cleanfaces[0][2]);
+    triangles.emplace_back(cleanfaces[0][0], cleanfaces[0][1],
+                           cleanfaces[0][2]);
     return false;
   }
 
@@ -275,7 +292,7 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
     edges.add(face);
   }
 
-  TESSreal *normalvec = nullptr;
+  TESSreal* normalvec = nullptr;
   TESSreal passednormal[3];
   if (normal) {
     passednormal[0] = (*normal)[0];
@@ -285,18 +302,19 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   }
 
   TESSalloc ma;
-  TESStesselator *tess = nullptr;
+  TESStesselator* tess = nullptr;
 
   memset(&ma, 0, sizeof(ma));
   ma.memalloc = stdAlloc;
   ma.memfree = stdFree;
-  ma.extraVertices = 256; // realloc not provided, allow 256 extra vertices.
+  ma.extraVertices = 256;  // realloc not provided, allow 256 extra vertices.
 
-  if (!(tess = tessNewTess(&ma))) return true;
+  if (!(tess = tessNewTess(&ma)))
+    return true;
 
   std::vector<TESSreal> contour;
-  // Since libtess2's indices is based on the running number of points added, we need to map back
-  // to our indices. allindices does the mapping.
+  // Since libtess2's indices is based on the running number of points added, we
+  // need to map back to our indices. allindices does the mapping.
   std::vector<int> allindices;
   for (const auto& face : cleanfaces) {
     contour.clear();
@@ -308,10 +326,13 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
       allindices.push_back(idx);
     }
     assert(face.size() >= 3);
-    tessAddContour(tess, 3, &contour.front(), sizeof(TESSreal) * 3, face.size());
+    tessAddContour(tess, 3, &contour.front(), sizeof(TESSreal) * 3,
+                   face.size());
   }
 
-  if (!tessTesselate(tess, TESS_WINDING_ODD, TESS_CONSTRAINED_DELAUNAY_TRIANGLES, 3, 3, normalvec)) return false;
+  if (!tessTesselate(tess, TESS_WINDING_ODD,
+                     TESS_CONSTRAINED_DELAUNAY_TRIANGLES, 3, 3, normalvec))
+    return false;
 
   const auto vindices = tessGetVertexIndices(tess);
   const auto elements = tessGetElements(tess);
@@ -332,10 +353,12 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
      Algorithm:
      A) Collect all triangles using _only_ existing vertices -> triangles
      B) Locate all unused vertices
-     C) For each unused vertex, create a triangle connecting it to the existing mesh
+     C) For each unused vertex, create a triangle connecting it to the existing
+     mesh
    */
-  auto inputSize = allindices.size(); // inputSize is number of points added to libtess2
-  std::vector<int> vflags(inputSize); // Inits with 0's
+  auto inputSize =
+      allindices.size();  // inputSize is number of points added to libtess2
+  std::vector<int> vflags(inputSize);  // Inits with 0's
 
   IndexedTriangle tri;
   IndexedTriangle mappedtri;
@@ -347,7 +370,7 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
       if (vidx == TESS_UNDEF) {
         err = true;
       } else {
-        tri[i] = vidx; // A)
+        tri[i] = vidx;  // A)
         mappedtri[i] = allindices[vidx];
       }
     }
@@ -355,18 +378,18 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
     //         elements[t * 3 + 0] % mappedtri[0] %
     //         elements[t * 3 + 1] % mappedtri[1] %
     //         elements[t * 3 + 2] % mappedtri[2]);
-    // FIXME: We ignore self-intersecting triangles rather than detecting and handling this
+    // FIXME: We ignore self-intersecting triangles rather than detecting and
+    // handling this
     if (!err) {
-      vflags[tri[0]]++; // B)
+      vflags[tri[0]]++;  // B)
       vflags[tri[1]]++;
       vflags[tri[2]]++;
 
-      // For each edge in mappedtri, locate the opposite edge in the original polygon.
-      // If an opposite edge was found, we need to flip.
-      // In addition, remove each edge from the dict to be able to later find
-      // missing edges.
-      // Note: In some degenerate cases, we create triangles with mixed edge directions.
-      // In this case, don't reverse, but attempt to carry on
+      // For each edge in mappedtri, locate the opposite edge in the original
+      // polygon. If an opposite edge was found, we need to flip. In addition,
+      // remove each edge from the dict to be able to later find missing edges.
+      // Note: In some degenerate cases, we create triangles with mixed edge
+      // directions. In this case, don't reverse, but attempt to carry on
       auto reverse = false;
       for (int i = 0; i < 3; ++i) {
         const IndexedEdge e(mappedtri[i], mappedtri[(i + 1) % 3]);
@@ -379,7 +402,8 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
       }
       if (reverse) {
         mappedtri.reverseInPlace();
-//        PRINTDB("  reversed: %d %d %d", mappedtri[0] % mappedtri[1] % mappedtri[2]);
+        //        PRINTDB("  reversed: %d %d %d", mappedtri[0] % mappedtri[1] %
+        //        mappedtri[2]);
       }
 
       // Remove the generated triangle from the original.
@@ -421,7 +445,7 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
       i = j;
     }
   }
-#endif // if 0
+#endif  // if 0
 
   tessDeleteTess(tess);
 
@@ -432,22 +456,25 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
    Tessellates a single contour. Non-indexed version.
    Appends resulting triangles to triangles.
  */
-bool GeometryUtils::tessellatePolygon(const Polygon& polygon, Polygons& triangles,
-                                      const Vector3f *normal)
-{
+bool GeometryUtils::tessellatePolygon(const Polygon& polygon,
+                                      Polygons& triangles,
+                                      const Vector3f* normal) {
   auto err = false;
   Reindexer<Vector3f> uniqueVertices;
   std::vector<IndexedFace> indexedfaces{{}};
   auto& currface = indexedfaces.back();
   for (const auto& v : polygon) {
     auto idx = uniqueVertices.lookup(v.cast<float>());
-    if (currface.empty() || idx != currface.back()) currface.push_back(idx);
+    if (currface.empty() || idx != currface.back())
+      currface.push_back(idx);
   }
-  if (currface.front() == currface.back()) currface.pop_back();
-  if (currface.size() >= 3) { // Cull empty triangles
+  if (currface.front() == currface.back())
+    currface.pop_back();
+  if (currface.size() >= 3) {  // Cull empty triangles
     const auto& verts = uniqueVertices.getArray();
     std::vector<IndexedTriangle> indexedtriangles;
-    err = tessellatePolygonWithHoles(verts, indexedfaces, indexedtriangles, normal);
+    err = tessellatePolygonWithHoles(verts, indexedfaces, indexedtriangles,
+                                     normal);
     for (const auto& t : indexedtriangles) {
       triangles.push_back(Polygon());
       Polygon& p = triangles.back();
@@ -459,15 +486,15 @@ bool GeometryUtils::tessellatePolygon(const Polygon& polygon, Polygons& triangle
   return err;
 }
 
-int GeometryUtils::findUnconnectedEdges(const std::vector<std::vector<IndexedFace>>& polygons)
-{
+int GeometryUtils::findUnconnectedEdges(
+    const std::vector<std::vector<IndexedFace>>& polygons) {
   EdgeDict edges;
   for (const auto& faces : polygons) {
     for (const auto& face : faces) {
       edges.add(face);
     }
   }
-#if 1 // for debugging
+#if 1  // for debugging
   if (!edges.empty()) {
     PRINTD("Unconnected:");
     edges.print();
@@ -476,13 +503,13 @@ int GeometryUtils::findUnconnectedEdges(const std::vector<std::vector<IndexedFac
   return edges.size();
 }
 
-int GeometryUtils::findUnconnectedEdges(const std::vector<IndexedTriangle>& triangles)
-{
+int GeometryUtils::findUnconnectedEdges(
+    const std::vector<IndexedTriangle>& triangles) {
   EdgeDict edges;
   for (const auto& t : triangles) {
     edges.add(t);
   }
-#if 1 // for debugging
+#if 1  // for debugging
   if (!edges.empty()) {
     PRINTD("Unconnected:");
     edges.print();
@@ -492,27 +519,31 @@ int GeometryUtils::findUnconnectedEdges(const std::vector<IndexedTriangle>& tria
   return edges.size();
 }
 
-Transform3d GeometryUtils::getResizeTransform(const BoundingBox& bbox, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+Transform3d GeometryUtils::getResizeTransform(
+    const BoundingBox& bbox,
+    const Vector3d& newsize,
+    const Eigen::Matrix<bool, 3, 1>& autosize) {
   // Find largest dimension
   int maxdim = 0;
-  for (int i = 1; i < 3; ++i) if (newsize[i] > newsize[maxdim]) maxdim = i;
+  for (int i = 1; i < 3; ++i)
+    if (newsize[i] > newsize[maxdim])
+      maxdim = i;
 
   // Default scale (scale with 1 if the new size is 0)
   Vector3d scale(1, 1, 1);
-  for (int i = 0; i < 3; ++i) if (newsize[i] > 0) scale[i] = newsize[i] / bbox.sizes()[i];
+  for (int i = 0; i < 3; ++i)
+    if (newsize[i] > 0)
+      scale[i] = newsize[i] / bbox.sizes()[i];
 
   // Autoscale where applicable
   double autoscale = scale[maxdim];
   Vector3d newscale;
-  for (int i = 0; i < 3; ++i) newscale[i] = !autosize[i] || (newsize[i] > 0) ? scale[i] : autoscale;
+  for (int i = 0; i < 3; ++i)
+    newscale[i] = !autosize[i] || (newsize[i] > 0) ? scale[i] : autoscale;
 
   Transform3d t;
-  t.matrix() <<
-    newscale[0], 0, 0, 0,
-    0, newscale[1], 0, 0,
-    0, 0, newscale[2], 0,
-    0, 0, 0, 1;
+  t.matrix() << newscale[0], 0, 0, 0, 0, newscale[1], 0, 0, 0, 0, newscale[2],
+      0, 0, 0, 0, 1;
 
   return t;
 }
@@ -520,27 +551,30 @@ Transform3d GeometryUtils::getResizeTransform(const BoundingBox& bbox, const Vec
 // Return or force creation of backend-specific geometry.
 // Will prefer Manifold if multiple backends are enabled.
 // geom must be a 3D PolySet or the correct backend-specific geometry.
-std::shared_ptr<const Geometry> GeometryUtils::getBackendSpecificGeometry(const std::shared_ptr<const Geometry>& geom)
-{
+std::shared_ptr<const Geometry> GeometryUtils::getBackendSpecificGeometry(
+    const std::shared_ptr<const Geometry>& geom) {
 #if ENABLE_MANIFOLD
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
     if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-      std::shared_ptr<ManifoldGeometry> mani = ManifoldUtils::createManifoldFromPolySet(*ps);
+      std::shared_ptr<ManifoldGeometry> mani =
+          ManifoldUtils::createManifoldFromPolySet(*ps);
       if (mani == nullptr) {
         mani = std::make_shared<ManifoldGeometry>();
       }
       return mani;
-    } else if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+    } else if (auto mani =
+                   std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
       return geom;
     } else {
       assert(false && "Unexpected geometry");
     }
   }
-#endif // if ENABLE_MANIFOLD
+#endif  // if ENABLE_MANIFOLD
 #if ENABLE_CGAL
   if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     return CGALUtils::createNefPolyhedronFromPolySet(*ps);
-  } else if (auto poly = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (auto poly =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     return geom;
   } else {
     assert(false && "Unexpected geometry");
diff --git a/src/geometry/GeometryUtils.h b/src/geometry/GeometryUtils.h
index 7ea5d5ee6..81d2afcaf 100644
--- a/src/geometry/GeometryUtils.h
+++ b/src/geometry/GeometryUtils.h
@@ -1,10 +1,10 @@
 #pragma once
 
-#include "geometry/linalg.h"
-#include "geometry/Geometry.h"
-#include <vector>
 #include <boost/container/small_vector.hpp>
 #include <memory>
+#include <vector>
+#include "geometry/Geometry.h"
+#include "geometry/linalg.h"
 
 using Polygon = std::vector<Vector3d>;
 using Polygons = std::vector<Polygon>;
@@ -34,16 +34,19 @@ namespace GeometryUtils {
 
 bool tessellatePolygon(const Polygon& polygon,
                        Polygons& triangles,
-                       const Vector3f *normal = nullptr);
+                       const Vector3f* normal = nullptr);
 bool tessellatePolygonWithHoles(const std::vector<Vector3f>& vertices,
                                 const std::vector<IndexedFace>& faces,
                                 std::vector<IndexedTriangle>& triangles,
-                                const Vector3f *normal = nullptr);
+                                const Vector3f* normal = nullptr);
 
 int findUnconnectedEdges(const std::vector<std::vector<IndexedFace>>& polygons);
 int findUnconnectedEdges(const std::vector<IndexedTriangle>& triangles);
 
-Transform3d getResizeTransform(const BoundingBox& bbox, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize);
-std::shared_ptr<const Geometry> getBackendSpecificGeometry(const std::shared_ptr<const Geometry>& geom);
+Transform3d getResizeTransform(const BoundingBox& bbox,
+                               const Vector3d& newsize,
+                               const Eigen::Matrix<bool, 3, 1>& autosize);
+std::shared_ptr<const Geometry> getBackendSpecificGeometry(
+    const std::shared_ptr<const Geometry>& geom);
 
-}
+}  // namespace GeometryUtils
diff --git a/src/geometry/Grid.h b/src/geometry/Grid.h
index ea26ed9df..ba5798603 100644
--- a/src/geometry/Grid.h
+++ b/src/geometry/Grid.h
@@ -1,16 +1,16 @@
 #pragma once
 
-#include "geometry/linalg.h"
-#include "utils/hash.h"
 #include <boost/functional/hash.hpp>
 #include <cmath>
+#include "geometry/linalg.h"
+#include "utils/hash.h"
 
-#include <cstdint> // int64_t
+#include <cstdint>  // int64_t
 #include <unordered_map>
 #include <utility>
 
-//const double GRID_COARSE = 0.001;
-//const double GRID_FINE   = 0.000001;
+// const double GRID_COARSE = 0.001;
+// const double GRID_FINE   = 0.000001;
 /* Using decimals that are exactly convertible to binary floating point
    (and then converted exactly to a GMPQ Rational that uses a small amount
    of bytes aka "limbs" in CGAL's engine) provides at least a 5% speedup
@@ -20,19 +20,19 @@ const double GRID_COARSE = 0.0009765625;
 const double GRID_FINE = 0.00000095367431640625;
 
 template <typename T>
-class Grid2d
-{
-public:
+class Grid2d {
+ public:
   double res;
-  std::unordered_map<std::pair<int64_t, int64_t>, T, boost::hash<std::pair<int64_t, int64_t>>> db;
+  std::unordered_map<std::pair<int64_t, int64_t>,
+                     T,
+                     boost::hash<std::pair<int64_t, int64_t>>>
+      db;
 
-  Grid2d(double resolution) {
-    res = resolution;
-  }
+  Grid2d(double resolution) { res = resolution; }
   /*!
      Aligns x,y to the grid or to existing point if one close enough exists.
-     Returns the value stored if a point already existing or an uninitialized new value
-     if not.
+     Returns the value stored if a point already existing or an uninitialized
+     new value if not.
    */
   T& align(double& x, double& y) {
     auto ix = (int64_t)std::round(x / res);
@@ -41,7 +41,8 @@ public:
       int dist = 10;
       for (int64_t jx = ix - 1; jx <= ix + 1; ++jx) {
         for (int64_t jy = iy - 1; jy <= iy + 1; ++jy) {
-          if (db.find(std::make_pair(jx, jy)) == db.end()) continue;
+          if (db.find(std::make_pair(jx, jy)) == db.end())
+            continue;
           int d = abs(int(ix - jx)) + abs(int(iy - jy));
           if (d < dist) {
             dist = d;
@@ -58,10 +59,12 @@ public:
   [[nodiscard]] bool has(double x, double y) const {
     auto ix = (int64_t)std::round(x / res);
     auto iy = (int64_t)std::round(y / res);
-    if (db.find(std::make_pair(ix, iy)) != db.end()) return true;
+    if (db.find(std::make_pair(ix, iy)) != db.end())
+      return true;
     for (int64_t jx = ix - 1; jx <= ix + 1; ++jx)
       for (int64_t jy = iy - 1; jy <= iy + 1; ++jy) {
-        if (db.find(std::make_pair(jx, jy)) != db.end()) return true;
+        if (db.find(std::make_pair(jx, jy)) != db.end())
+          return true;
       }
     return false;
   }
@@ -69,29 +72,23 @@ public:
   bool eq(double x1, double y1, double x2, double y2) {
     align(x1, y1);
     align(x2, y2);
-    if (fabs(x1 - x2) < res && fabs(y1 - y2) < res) return true;
+    if (fabs(x1 - x2) < res && fabs(y1 - y2) < res)
+      return true;
     return false;
   }
-  T& data(double x, double y) {
-    return align(x, y);
-  }
-  T& operator()(double x, double y) {
-    return align(x, y);
-  }
+  T& data(double x, double y) { return align(x, y); }
+  T& operator()(double x, double y) { return align(x, y); }
 };
 
 template <typename T>
-class Grid3d
-{
-public:
+class Grid3d {
+ public:
   double res;
   using Key = Vector3l;
   using GridContainer = std::unordered_map<Key, T>;
   GridContainer db;
 
-  Grid3d(double resolution) {
-    res = resolution;
-  }
+  Grid3d(double resolution) { res = resolution; }
 
   inline void createGridVertex(const Vector3d& v, Vector3l& i) {
     i[0] = int64_t(v[0] / this->res);
@@ -106,13 +103,14 @@ public:
     createGridVertex(v, key);
     auto iter = db.find(key);
     if (iter == db.end()) {
-      float dist = 10.0f; // > max possible distance
+      float dist = 10.0f;  // > max possible distance
       for (int64_t jx = key[0] - 1; jx <= key[0] + 1; ++jx) {
         for (int64_t jy = key[1] - 1; jy <= key[1] + 1; ++jy) {
           for (int64_t jz = key[2] - 1; jz <= key[2] + 1; ++jz) {
             Vector3l k(jx, jy, jz);
             auto tmpiter = db.find(k);
-            if (tmpiter == db.end()) continue;
+            if (tmpiter == db.end())
+              continue;
             float d = sqrt((key - k).squaredNorm());
             if (d < dist) {
               dist = d;
@@ -124,7 +122,7 @@ public:
     }
 
     T data;
-    if (iter == db.end()) { // Not found: insert using key
+    if (iter == db.end()) {  // Not found: insert using key
       data = db.size();
       db[key] = data;
     } else {
@@ -141,11 +139,12 @@ public:
     return data;
   }
 
-  bool has(const Vector3d& v, T *data = nullptr) {
+  bool has(const Vector3d& v, T* data = nullptr) {
     Vector3l key = createGridVertex(v);
     typename GridContainer::iterator pos = db.find(key);
     if (pos != db.end()) {
-      if (data) *data = pos->second;
+      if (data)
+        *data = pos->second;
       return true;
     }
     for (int64_t jx = key[0] - 1; jx <= key[0] + 1; ++jx)
@@ -153,15 +152,13 @@ public:
         for (int64_t jz = key[2] - 1; jz <= key[2] + 1; ++jz) {
           pos = db.find(Vector3l(jx, jy, jz));
           if (pos != db.end()) {
-            if (data) *data = pos->second;
+            if (data)
+              *data = pos->second;
             return true;
           }
         }
     return false;
   }
 
-  T data(Vector3d v) {
-    return align(v);
-  }
-
+  T data(Vector3d v) { return align(v); }
 };
diff --git a/src/geometry/PolySet.cc b/src/geometry/PolySet.cc
index a7e81d446..c99bd62d1 100644
--- a/src/geometry/PolySet.cc
+++ b/src/geometry/PolySet.cc
@@ -25,18 +25,18 @@
  */
 
 #include "geometry/PolySet.h"
-#include "geometry/Geometry.h"
-#include "geometry/PolySetUtils.h"
-#include "geometry/linalg.h"
-#include "utils/printutils.h"
-#include "geometry/Grid.h"
-#include <algorithm>
-#include <sstream>
-#include <memory>
 #include <Eigen/LU>
+#include <algorithm>
 #include <cstddef>
+#include <memory>
+#include <sstream>
 #include <string>
 #include <vector>
+#include "geometry/Geometry.h"
+#include "geometry/Grid.h"
+#include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
+#include "utils/printutils.h"
 
 /*! /class PolySet
 
@@ -53,22 +53,17 @@
  */
 
 PolySet::PolySet(unsigned int dim, boost::tribool convex)
-  : dim_(dim), convex_(convex)
-{
-}
+    : dim_(dim), convex_(convex) {}
 
 std::unique_ptr<Geometry> PolySet::copy() const {
   return std::make_unique<PolySet>(*this);
 }
 
-std::string PolySet::dump() const
-{
+std::string PolySet::dump() const {
   std::ostringstream out;
   out << "PolySet:"
-      << "\n dimensions:" << dim_
-      << "\n convexity:" << this->convexity
-      << "\n num polygons: " << indices.size()
-      << "\n polygons data:";
+      << "\n dimensions:" << dim_ << "\n convexity:" << this->convexity
+      << "\n num polygons: " << indices.size() << "\n polygons data:";
   for (const auto& polygon : indices) {
     out << "\n  polygon begin:";
     for (auto v : polygon) {
@@ -79,8 +74,7 @@ std::string PolySet::dump() const
   return out.str();
 }
 
-BoundingBox PolySet::getBoundingBox() const
-{
+BoundingBox PolySet::getBoundingBox() const {
   if (bbox_.isNull()) {
     for (const auto& v : vertices) {
       bbox_.extend(v);
@@ -89,17 +83,18 @@ BoundingBox PolySet::getBoundingBox() const
   return bbox_;
 }
 
-size_t PolySet::memsize() const
-{
+size_t PolySet::memsize() const {
   size_t mem = 0;
-  for (const auto& p : this->indices) mem += p.size() * sizeof(int);
-  for (const auto& p : this->vertices) mem += p.size() * sizeof(Vector3d);
+  for (const auto& p : this->indices)
+    mem += p.size() * sizeof(int);
+  for (const auto& p : this->vertices)
+    mem += p.size() * sizeof(Vector3d);
   mem += sizeof(PolySet);
   return mem;
 }
-void PolySet::transform(const Transform3d& mat)
-{
-  // If mirroring transform, flip faces to avoid the object to end up being inside-out
+void PolySet::transform(const Transform3d& mat) {
+  // If mirroring transform, flip faces to avoid the object to end up being
+  // inside-out
   bool mirrored = mat.matrix().determinant() < 0;
 
   for (auto& v : this->vertices)
@@ -118,28 +113,30 @@ void PolySet::setColor(const Color4f& c) {
 }
 
 bool PolySet::isConvex() const {
-  if (convex_ || this->isEmpty()) return true;
-  if (!convex_) return false;
+  if (convex_ || this->isEmpty())
+    return true;
+  if (!convex_)
+    return false;
   bool is_convex = PolySetUtils::is_approximately_convex(*this);
   convex_ = is_convex;
   return is_convex;
 }
 
-void PolySet::resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize)
-{
-  this->transform(GeometryUtils::getResizeTransform(this->getBoundingBox(), newsize, autosize));
+void PolySet::resize(const Vector3d& newsize,
+                     const Eigen::Matrix<bool, 3, 1>& autosize) {
+  this->transform(GeometryUtils::getResizeTransform(this->getBoundingBox(),
+                                                    newsize, autosize));
 }
 
 /*!
-   Quantizes vertices by gridding them as well as merges close vertices belonging to
-   neighboring grids.
-   May reduce the number of polygons if polygons collapse into < 3 vertices.
+   Quantizes vertices by gridding them as well as merges close vertices
+   belonging to neighboring grids. May reduce the number of polygons if polygons
+   collapse into < 3 vertices.
  */
-void PolySet::quantizeVertices(std::vector<Vector3d> *pPointsOut)
-{
+void PolySet::quantizeVertices(std::vector<Vector3d>* pPointsOut) {
   const bool has_colors = !this->color_indices.empty();
   Grid3d<unsigned int> grid(GRID_FINE);
-  std::vector<unsigned int> polygon_indices; // Vertex indices in one polygon
+  std::vector<unsigned int> polygon_indices;  // Vertex indices in one polygon
   for (size_t i = 0; i < this->indices.size();) {
     IndexedFace& ind_f = this->indices[i];
     polygon_indices.resize(ind_f.size());
@@ -153,7 +150,8 @@ void PolySet::quantizeVertices(std::vector<Vector3d> *pPointsOut)
     // Remove consecutive duplicate vertices
     auto currp = ind_f.begin();
     for (unsigned int i = 0; i < polygon_indices.size(); ++i) {
-      if (polygon_indices[i] != polygon_indices[(i + 1) % polygon_indices.size()]) {
+      if (polygon_indices[i] !=
+          polygon_indices[(i + 1) % polygon_indices.size()]) {
         (*currp++) = ind_f[i];
       }
     }
@@ -161,7 +159,8 @@ void PolySet::quantizeVertices(std::vector<Vector3d> *pPointsOut)
     if (ind_f.size() < 3) {
       PRINTD("Removing collapsed polygon due to quantizing");
       this->indices.erase(this->indices.begin() + i);
-      if (has_colors) this->color_indices.erase(this->color_indices.begin() + i);
+      if (has_colors)
+        this->color_indices.erase(this->color_indices.begin() + i);
     } else {
       i++;
     }
diff --git a/src/geometry/PolySet.h b/src/geometry/PolySet.h
index 9c8e5dd58..bd08dd2b2 100644
--- a/src/geometry/PolySet.h
+++ b/src/geometry/PolySet.h
@@ -1,27 +1,28 @@
 #pragma once
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/GeometryUtils.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "utils/boost-utils.h"
 
+#include <cstddef>
 #include <cstdint>
 #include <memory>
-#include <cstddef>
 #include <string>
 #include <vector>
 
 class PolySetBuilder;
 
-class PolySet : public Geometry
-{
+class PolySet : public Geometry {
   friend class PolySetBuilder;
-public:
+
+ public:
   VISITABLE_GEOMETRY();
   PolygonIndices indices;
   std::vector<Vector3d> vertices;
-  // Per polygon color, indexing the colors vector below. Can be empty, and -1 means no specific color.
+  // Per polygon color, indexing the colors vector below. Can be empty, and -1
+  // means no specific color.
   std::vector<int32_t> color_indices;
   std::vector<Color4f> colors;
 
@@ -34,10 +35,11 @@ public:
   bool isEmpty() const override { return indices.empty(); }
   std::unique_ptr<Geometry> copy() const override;
 
-  void quantizeVertices(std::vector<Vector3d> *pPointsOut = nullptr);
+  void quantizeVertices(std::vector<Vector3d>* pPointsOut = nullptr);
   size_t numFacets() const override { return indices.size(); }
   void transform(const Transform3d& mat) override;
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
+  void resize(const Vector3d& newsize,
+              const Eigen::Matrix<bool, 3, 1>& autosize) override;
   void setColor(const Color4f& c) override;
 
   bool isConvex() const;
@@ -46,9 +48,11 @@ public:
   bool isTriangular() const { return is_triangular_; }
   void setTriangular(bool triangular) { is_triangular_ = triangular; }
 
-  static std::unique_ptr<PolySet> createEmpty() { return std::make_unique<PolySet>(3); }
+  static std::unique_ptr<PolySet> createEmpty() {
+    return std::make_unique<PolySet>(3);
+  }
 
-private:
+ private:
   bool is_triangular_ = false;
   unsigned int dim_;
   mutable boost::tribool convex_;
diff --git a/src/geometry/PolySetBuilder.cc b/src/geometry/PolySetBuilder.cc
index 1cd05f100..5bdc4c6e7 100644
--- a/src/geometry/PolySetBuilder.cc
+++ b/src/geometry/PolySetBuilder.cc
@@ -25,48 +25,50 @@
  */
 
 #include "geometry/PolySetBuilder.h"
-#include "geometry/linalg.h"
-#include "geometry/PolySet.h"
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
+#include "geometry/linalg.h"
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgalutils.h"
 #endif
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
 #include <algorithm>
-#include <iterator>
 #include <cassert>
-#include <utility>
 #include <cstdint>
+#include <iterator>
 #include <memory>
+#include <utility>
 #include <vector>
 
-PolySetBuilder::PolySetBuilder(int vertices_count, int indices_count, int dim, boost::tribool convex)
-  : dim_(dim), convex_(convex)
-{
+PolySetBuilder::PolySetBuilder(int vertices_count,
+                               int indices_count,
+                               int dim,
+                               boost::tribool convex)
+    : dim_(dim), convex_(convex) {
   reserve(vertices_count, indices_count);
 }
 
 void PolySetBuilder::reserve(int vertices_count, int indices_count) {
-  if (vertices_count != 0) vertices_.reserve(vertices_count);
-  if (indices_count != 0) indices_.reserve(indices_count);
+  if (vertices_count != 0)
+    vertices_.reserve(vertices_count);
+  if (indices_count != 0)
+    indices_.reserve(indices_count);
 }
 
-void PolySetBuilder::setConvexity(int convexity){
+void PolySetBuilder::setConvexity(int convexity) {
   convexity_ = convexity;
 }
 
-void PolySetBuilder::addColor(const Color4f& color)
-{
+void PolySetBuilder::addColor(const Color4f& color) {
   colors_.push_back(color);
 }
 
-void PolySetBuilder::addColorIndex(const int32_t idx)
-{
+void PolySetBuilder::addColorIndex(const int32_t idx) {
   color_indices_.push_back(idx);
 }
 
@@ -82,50 +84,52 @@ bool PolySetBuilder::isEmpty() const {
   return vertices_.size() == 0 && indices_.size() == 0;
 }
 
-int PolySetBuilder::vertexIndex(const Vector3d& pt)
-{
+int PolySetBuilder::vertexIndex(const Vector3d& pt) {
   return vertices_.lookup(pt);
 }
 
-void PolySetBuilder::appendGeometry(const std::shared_ptr<const Geometry>& geom)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+void PolySetBuilder::appendGeometry(
+    const std::shared_ptr<const Geometry>& geom) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     for (const Geometry::GeometryItem& item : geomlist->getChildren()) {
       appendGeometry(item.second);
     }
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     appendPolySet(*ps);
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     if (const auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*(N->p3))) {
       appendPolySet(*ps);
     } else {
       LOG(message_group::Error, "Nef->PolySet failed");
     }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     appendPolySet(*mani->toPolySet());
 #endif
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { // NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const Polygon2d>(
+                 geom)) {  // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported geometry");
-  } else { // NOLINT(bugprone-branch-clone)
+  } else {  // NOLINT(bugprone-branch-clone)
     assert(false && "Not implemented");
   }
-
 }
 
-void PolySetBuilder::appendPolygon(const std::vector<int>& inds)
-{
+void PolySetBuilder::appendPolygon(const std::vector<int>& inds) {
   beginPolygon(inds.size());
-  for (int idx : inds) addVertex(idx);
+  for (int idx : inds)
+    addVertex(idx);
   endPolygon();
 }
 
-void PolySetBuilder::appendPolygon(const std::vector<Vector3d>& polygon)
-{
+void PolySetBuilder::appendPolygon(const std::vector<Vector3d>& polygon) {
   beginPolygon(polygon.size());
-  for (const auto& v: polygon) addVertex(v);
+  for (const auto& v : polygon)
+    addVertex(v);
   endPolygon();
 }
 
@@ -134,21 +138,21 @@ void PolySetBuilder::beginPolygon(int nvertices) {
   current_polygon_.reserve(nvertices);
 }
 
-void PolySetBuilder::addVertex(int ind)
-{
+void PolySetBuilder::addVertex(int ind) {
   // Ignore consecutive duplicate indices
-  if (current_polygon_.empty() || (ind != current_polygon_.back() && ind != current_polygon_.front())) {
+  if (current_polygon_.empty() ||
+      (ind != current_polygon_.back() && ind != current_polygon_.front())) {
     current_polygon_.push_back(ind);
   }
 }
 
-void PolySetBuilder::addVertex(const Vector3d& v)
-{
+void PolySetBuilder::addVertex(const Vector3d& v) {
   addVertex(vertexIndex(v));
 }
 
 void PolySetBuilder::endPolygon(const Color4f& color) {
-  // FIXME: Should we check for self-touching polygons (non-consecutive duplicate indices)?
+  // FIXME: Should we check for self-touching polygons (non-consecutive
+  // duplicate indices)?
 
   // FIXME: Can we move? What would the state of current_polygon_ be after move?
   if (current_polygon_.size() >= 3) {
@@ -170,8 +174,7 @@ void PolySetBuilder::endPolygon(const Color4f& color) {
   current_polygon_.clear();
 }
 
-void PolySetBuilder::appendPolySet(const PolySet& ps)
-{
+void PolySetBuilder::appendPolySet(const PolySet& ps) {
   // Copy color indices lazily.
   if (!ps.color_indices.empty()) {
     // If we hadn't built color_indices_ yet, catch up / fill w/ -1.
@@ -197,22 +200,23 @@ void PolySetBuilder::appendPolySet(const PolySet& ps)
       color_indices_.push_back(color_index < 0 ? -1 : color_map[color_index]);
     }
   } else if (!color_indices_.empty()) {
-    // If we already built color_indices_ but don't have colors with this ps, fill with -1.
+    // If we already built color_indices_ but don't have colors with this ps,
+    // fill with -1.
     color_indices_.resize(color_indices_.size() + ps.indices.size(), -1);
   }
 
-  reserve(numVertices() + ps.vertices.size(), numPolygons() + ps.indices.size());
+  reserve(numVertices() + ps.vertices.size(),
+          numPolygons() + ps.indices.size());
   for (const auto& poly : ps.indices) {
     beginPolygon(poly.size());
-    for (const auto& ind: poly) {
+    for (const auto& ind : poly) {
       addVertex(ps.vertices[ind]);
     }
     endPolygon();
   }
 }
 
-std::unique_ptr<PolySet> PolySetBuilder::build()
-{
+std::unique_ptr<PolySet> PolySetBuilder::build() {
   endPolygon();
   std::unique_ptr<PolySet> polyset;
   polyset = std::make_unique<PolySet>(dim_, convex_);
diff --git a/src/geometry/PolySetBuilder.h b/src/geometry/PolySetBuilder.h
index 04363f933..2f987d287 100644
--- a/src/geometry/PolySetBuilder.h
+++ b/src/geometry/PolySetBuilder.h
@@ -4,19 +4,21 @@
 #include <memory>
 #include <vector>
 
-#include "geometry/Reindexer.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
+#include "geometry/GeometryUtils.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/Reindexer.h"
+#include "geometry/linalg.h"
 #include "utils/boost-utils.h"
-#include "geometry/GeometryUtils.h"
 
 class PolySet;
 
-class PolySetBuilder
-{
-public:
-  PolySetBuilder(int vertices_count = 0, int indices_count = 0, int dim = 3, boost::tribool convex = unknown);
+class PolySetBuilder {
+ public:
+  PolySetBuilder(int vertices_count = 0,
+                 int indices_count = 0,
+                 int dim = 3,
+                 boost::tribool convex = unknown);
   void reserve(int vertices_count = 0, int indices_count = 0);
   void setConvexity(int n);
   int vertexIndex(const Vector3d& coord);
@@ -32,14 +34,16 @@ public:
   void beginPolygon(int nvertices);
   void addVertex(int ind);
   void addVertex(const Vector3d& v);
-  // Calling this is optional; will be called automatically when adding a new polygon or building the PolySet
+  // Calling this is optional; will be called automatically when adding a new
+  // polygon or building the PolySet
   void endPolygon(const Color4f& color = {});
 
   void addColor(const Color4f& color);
-  void addColorIndex(int idx); // should be paired with begin/endPolygon()
+  void addColorIndex(int idx);  // should be paired with begin/endPolygon()
 
   std::unique_ptr<PolySet> build();
-private:
+
+ private:
   Reindexer<Vector3d> vertices_;
   PolygonIndices indices_;
   std::vector<int32_t> color_indices_;
diff --git a/src/geometry/PolySetUtils.cc b/src/geometry/PolySetUtils.cc
index d58ace789..a74599822 100644
--- a/src/geometry/PolySetUtils.cc
+++ b/src/geometry/PolySetUtils.cc
@@ -1,21 +1,21 @@
 #include "geometry/PolySetUtils.h"
 
 #include <cassert>
+#include <cstddef>
 #include <cstdint>
 #include <memory>
-#include <cstddef>
 #include <sstream>
 #include <vector>
 
 #include <boost/range/adaptor/reversed.hpp>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
+#include "geometry/GeometryUtils.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
-#include "geometry/GeometryUtils.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
@@ -62,8 +62,7 @@ std::unique_ptr<Polygon2d> project(const PolySet& ps) {
    polyset has simple polygon faces with no holes.
    The tessellation will be robust wrt. degenerate and self-intersecting
  */
-std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
-{
+std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset) {
   int degeneratePolygons = 0;
   auto result = std::make_unique<PolySet>(3, polyset.convexValue());
   result->setConvexity(polyset.getConvexity());
@@ -99,10 +98,13 @@ std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
     auto& currface = polygons.emplace_back();
     for (const auto& ind : pgon) {
       const Vector3f v = polyset.vertices[ind].cast<float>();
-      if (currface.empty() || v != polyset.vertices[currface.back()].cast<float>())currface.push_back(ind);
+      if (currface.empty() ||
+          v != polyset.vertices[currface.back()].cast<float>())
+        currface.push_back(ind);
     }
     const Vector3f head = polyset.vertices[currface.front()].cast<float>();
-    while (!currface.empty() && head == polyset.vertices[currface.back()].cast<float>())
+    while (!currface.empty() &&
+           head == polyset.vertices[currface.back()].cast<float>())
       currface.pop_back();
     if (currface.size() < 3) {
       polygons.pop_back();
@@ -141,18 +143,21 @@ std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
     if (face.size() == 3) {
       // trivial case - triangles cannot be concave or have holes
       result->indices.push_back({face[0], face[1], face[2]});
-      if (has_colors)result->color_indices.push_back(polygon_color_indices[i]);
+      if (has_colors)
+        result->color_indices.push_back(polygon_color_indices[i]);
     }
     // Quads seem trivial, but can be concave, and can have degenerate cases.
     // So everything more complex than triangles goes into the general case.
     else {
       triangles.clear();
       facesBuffer[0] = face;
-      auto err = GeometryUtils::tessellatePolygonWithHoles(verts, facesBuffer, triangles, nullptr);
+      auto err = GeometryUtils::tessellatePolygonWithHoles(verts, facesBuffer,
+                                                           triangles, nullptr);
       if (!err) {
         for (const auto& t : triangles) {
           result->indices.push_back({t[0], t[1], t[2]});
-          if (has_colors)result->color_indices.push_back(polygon_color_indices[i]);
+          if (has_colors)
+            result->color_indices.push_back(polygon_color_indices[i]);
         }
       }
     }
@@ -172,9 +177,10 @@ bool is_approximately_convex(const PolySet& ps) {
 }
 
 // Get as or convert the geometry to a PolySet.
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const Geometry>& geom)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+std::shared_ptr<const PolySet> getGeometryAsPolySet(
+    const std::shared_ptr<const Geometry>& geom) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     PolySetBuilder builder;
     builder.appendGeometry(geom);
     return builder.build();
@@ -192,7 +198,7 @@ std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const
     }
     return PolySet::createEmpty();
   }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
   if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     return mani->toPolySet();
@@ -201,9 +207,7 @@ std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const
   return nullptr;
 }
 
-
-std::string polySetToPolyhedronSource(const PolySet& ps)
-{
+std::string polySetToPolyhedronSource(const PolySet& ps) {
   std::stringstream sstr;
   sstr << "polyhedron(\n";
   sstr << "  points=[\n";
@@ -224,4 +228,4 @@ std::string polySetToPolyhedronSource(const PolySet& ps)
   return sstr.str();
 }
 
-} // namespace PolySetUtils
+}  // namespace PolySetUtils
diff --git a/src/geometry/PolySetUtils.h b/src/geometry/PolySetUtils.h
index 086417aa7..22f396047 100644
--- a/src/geometry/PolySetUtils.h
+++ b/src/geometry/PolySetUtils.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <string>
 #include <memory>
+#include <string>
 
 #include "geometry/Geometry.h"
 
@@ -14,8 +14,9 @@ std::unique_ptr<Polygon2d> project(const PolySet& ps);
 std::unique_ptr<PolySet> tessellate_faces(const PolySet& inps);
 bool is_approximately_convex(const PolySet& ps);
 
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const class Geometry>&);
+std::shared_ptr<const PolySet> getGeometryAsPolySet(
+    const std::shared_ptr<const class Geometry>&);
 
 std::string polySetToPolyhedronSource(const PolySet& ps);
 
-}
+}  // namespace PolySetUtils
diff --git a/src/geometry/Polygon2d.cc b/src/geometry/Polygon2d.cc
index 409d306de..bdf4e7ce3 100644
--- a/src/geometry/Polygon2d.cc
+++ b/src/geometry/Polygon2d.cc
@@ -1,10 +1,10 @@
 #include "geometry/Polygon2d.h"
 
-#include <sstream>
-#include <utility>
 #include <cstddef>
-#include <string>
 #include <memory>
+#include <sstream>
+#include <string>
+#include <utility>
 
 #include "geometry/Geometry.h"
 #include "geometry/linalg.h"
@@ -12,18 +12,16 @@
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/manifoldutils.h"
 #endif
-#include "geometry/cgal/cgalutils.h"
 #include "Feature.h"
 #include "geometry/PolySet.h"
+#include "geometry/cgal/cgalutils.h"
 #include "glview/RenderSettings.h"
 
-
 Polygon2d::Polygon2d(Outline2d outline) : sanitized(true) {
   addOutline(std::move(outline));
 }
 
-std::unique_ptr<Geometry> Polygon2d::copy() const
-{
+std::unique_ptr<Geometry> Polygon2d::copy() const {
   return std::make_unique<Polygon2d>(*this);
 }
 
@@ -50,8 +48,7 @@ BoundingBox Outline2d::getBoundingBox() const {
    the flag can be set manually.
  */
 
-size_t Polygon2d::memsize() const
-{
+size_t Polygon2d::memsize() const {
   size_t mem = 0;
   for (const auto& o : this->outlines()) {
     mem += o.vertices.size() * sizeof(Vector2d) + sizeof(Outline2d);
@@ -60,8 +57,7 @@ size_t Polygon2d::memsize() const
   return mem;
 }
 
-BoundingBox Polygon2d::getBoundingBox() const
-{
+BoundingBox Polygon2d::getBoundingBox() const {
   BoundingBox bbox;
   for (const auto& o : this->outlines()) {
     bbox.extend(o.getBoundingBox());
@@ -69,8 +65,7 @@ BoundingBox Polygon2d::getBoundingBox() const
   return bbox;
 }
 
-std::string Polygon2d::dump() const
-{
+std::string Polygon2d::dump() const {
   std::ostringstream out;
   for (const auto& o : this->theoutlines) {
     out << "contour:\n";
@@ -82,13 +77,11 @@ std::string Polygon2d::dump() const
   return out.str();
 }
 
-bool Polygon2d::isEmpty() const
-{
+bool Polygon2d::isEmpty() const {
   return this->theoutlines.empty();
 }
 
-void Polygon2d::transform(const Transform2d& mat)
-{
+void Polygon2d::transform(const Transform2d& mat) {
   if (mat.matrix().determinant() == 0) {
     LOG(message_group::Warning, "Scaling a 2D object with 0 - removing object");
     this->theoutlines.clear();
@@ -101,8 +94,8 @@ void Polygon2d::transform(const Transform2d& mat)
   }
 }
 
-void Polygon2d::resize(const Vector2d& newsize, const Eigen::Matrix<bool, 2, 1>& autosize)
-{
+void Polygon2d::resize(const Vector2d& newsize,
+                       const Eigen::Matrix<bool, 2, 1>& autosize) {
   auto bbox = this->getBoundingBox();
 
   // Find largest dimension
@@ -113,23 +106,22 @@ void Polygon2d::resize(const Vector2d& newsize, const Eigen::Matrix<bool, 2, 1>&
                  newsize[1] > 0 ? newsize[1] / bbox.sizes()[1] : 1);
 
   // Autoscale where applicable
-  double autoscale = newsize[maxdim] > 0 ? newsize[maxdim] / bbox.sizes()[maxdim] : 1;
+  double autoscale =
+      newsize[maxdim] > 0 ? newsize[maxdim] / bbox.sizes()[maxdim] : 1;
   Vector2d newscale(!autosize[0] || (newsize[0] > 0) ? scale[0] : autoscale,
                     !autosize[1] || (newsize[1] > 0) ? scale[1] : autoscale);
 
   Transform2d t;
-  t.matrix() <<
-    newscale[0], 0, 0,
-    0, newscale[1], 0,
-    0, 0, 1;
+  t.matrix() << newscale[0], 0, 0, 0, newscale[1], 0, 0, 0, 1;
 
   this->transform(t);
 }
 
-bool Polygon2d::is_convex() const
-{
-  if (theoutlines.size() > 1) return false;
-  if (theoutlines.empty()) return true;
+bool Polygon2d::is_convex() const {
+  if (theoutlines.size() > 1)
+    return false;
+  if (theoutlines.empty())
+    return true;
 
   auto const& pts = theoutlines[0].vertices;
   int N = pts.size();
@@ -139,13 +131,13 @@ bool Polygon2d::is_convex() const
     const auto& d1 = pts[(i + 1) % N] - pts[i];
     const auto& d2 = pts[(i + 2) % N] - pts[(i + 1) % N];
     double zcross = d1[0] * d2[1] - d1[1] * d2[0];
-    if (zcross < 0) return false;
+    if (zcross < 0)
+      return false;
   }
   return true;
 }
 
-double Polygon2d::area() const
-{
+double Polygon2d::area() const {
   auto ps = tessellate();
   if (ps == nullptr) {
     return 0;
@@ -156,10 +148,8 @@ double Polygon2d::area() const
     const auto& v1 = ps->vertices[poly[0]];
     const auto& v2 = ps->vertices[poly[1]];
     const auto& v3 = ps->vertices[poly[2]];
-    area += 0.5 * (
-      v1.x() * (v2.y() - v3.y())
-      + v2.x() * (v3.y() - v1.y())
-      + v3.x() * (v1.y() - v2.y()));
+    area += 0.5 * (v1.x() * (v2.y() - v3.y()) + v2.x() * (v3.y() - v1.y()) +
+                   v3.x() * (v1.y() - v2.y()));
   }
   return area;
 }
@@ -172,17 +162,18 @@ double Polygon2d::area() const
  * Rendering (both preview and render mode)
  * Polygon area calculation
  *
- * One use-case is special: For geometry construction in Manifold mode, we require this function to
- * guarantee that vertices and their order are untouched (apart from adding a zero 3rd dimension)
+ * One use-case is special: For geometry construction in Manifold mode, we
+ require this function to
+ * guarantee that vertices and their order are untouched (apart from adding a
+ zero 3rd dimension)
  *
  */
-std::unique_ptr<PolySet> Polygon2d::tessellate() const
-{
+std::unique_ptr<PolySet> Polygon2d::tessellate() const {
   PRINTDB("Polygon2d::tessellate(): %d outlines", this->outlines().size());
 #if defined(ENABLE_MANIFOLD) && defined(USE_MANIFOLD_TRIANGULATOR)
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
     return ManifoldUtils::createTriangulatedPolySetFromPolygon2d(*this);
   } else
 #endif
-  return CGALUtils::createTriangulatedPolySetFromPolygon2d(*this);
+    return CGALUtils::createTriangulatedPolySetFromPolygon2d(*this);
 }
diff --git a/src/geometry/Polygon2d.h b/src/geometry/Polygon2d.h
index 948dda826..22f23f349 100644
--- a/src/geometry/Polygon2d.h
+++ b/src/geometry/Polygon2d.h
@@ -1,17 +1,18 @@
 #pragma once
 
-#include <utility>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <numeric>
 #include <string>
+#include <utility>
 #include <vector>
 #include "geometry/Geometry.h"
 #include "geometry/linalg.h"
-#include <numeric>
 
 /*!
    A single contour.
-   positive is (optionally) used to distinguish between polygon contours and hole contours.
+   positive is (optionally) used to distinguish between polygon contours and
+   hole contours.
  */
 struct Outline2d {
   Outline2d() = default;
@@ -20,9 +21,8 @@ struct Outline2d {
   [[nodiscard]] BoundingBox getBoundingBox() const;
 };
 
-class Polygon2d : public Geometry
-{
-public:
+class Polygon2d : public Geometry {
+ public:
   VISITABLE_GEOMETRY();
   Polygon2d() = default;
   Polygon2d(Outline2d outline);
@@ -33,13 +33,13 @@ public:
   [[nodiscard]] bool isEmpty() const override;
   [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
   [[nodiscard]] size_t numFacets() const override {
-    return std::accumulate(theoutlines.begin(), theoutlines.end(), 0,
-                           [](size_t a, const Outline2d& b) {
-      return a + b.vertices.size();
-    }
-                           );
+    return std::accumulate(
+        theoutlines.begin(), theoutlines.end(), 0,
+        [](size_t a, const Outline2d& b) { return a + b.vertices.size(); });
+  }
+  void addOutline(Outline2d outline) {
+    this->theoutlines.push_back(std::move(outline));
   }
-  void addOutline(Outline2d outline) { this->theoutlines.push_back(std::move(outline)); }
   [[nodiscard]] std::unique_ptr<PolySet> tessellate() const;
   [[nodiscard]] double area() const;
 
@@ -52,15 +52,19 @@ public:
   using Geometry::transform;
 
   void transform(const Transform2d& mat);
-  void resize(const Vector2d& newsize, const Eigen::Matrix<bool, 2, 1>& autosize);
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override {
-    resize(Vector2d(newsize[0], newsize[1]), Eigen::Matrix<bool, 2, 1>(autosize[0], autosize[1]));
+  void resize(const Vector2d& newsize,
+              const Eigen::Matrix<bool, 2, 1>& autosize);
+  void resize(const Vector3d& newsize,
+              const Eigen::Matrix<bool, 3, 1>& autosize) override {
+    resize(Vector2d(newsize[0], newsize[1]),
+           Eigen::Matrix<bool, 2, 1>(autosize[0], autosize[1]));
   }
 
   [[nodiscard]] bool isSanitized() const { return this->sanitized; }
   void setSanitized(bool s) { this->sanitized = s; }
   [[nodiscard]] bool is_convex() const;
-private:
+
+ private:
   Outlines2d theoutlines;
   bool sanitized{false};
 };
diff --git a/src/geometry/Reindexer.h b/src/geometry/Reindexer.h
index c43a58920..9e7a9d371 100644
--- a/src/geometry/Reindexer.h
+++ b/src/geometry/Reindexer.h
@@ -1,28 +1,28 @@
 #pragma once
 
+#include <algorithm>
 #include <cstddef>
 #include <unordered_map>
 #include <vector>
-#include <algorithm>
-#include "utils/hash.h" // IWYU pragma: keep
+#include "utils/hash.h"  // IWYU pragma: keep
 
 /*!
    Reindexes a collection of elements of type T.
-   Typically used to compress an element array by creating and reusing indexes to
-   a new array or to merge two index tables to two arrays into a common index.
-   The latter is necessary for VBO's or for unifying texture coordinate indices to
-   multiple texture coordinate arrays.
+   Typically used to compress an element array by creating and reusing indexes
+   to a new array or to merge two index tables to two arrays into a common
+   index. The latter is necessary for VBO's or for unifying texture coordinate
+   indices to multiple texture coordinate arrays.
  */
 template <typename T>
-class Reindexer
-{
-public:
+class Reindexer {
+ public:
   /*!
      Looks up a value. Will insert the value if it doesn't already exist.
      Returns the new index. */
   int lookup(const T& val) {
     auto iter = this->map.find(val);
-    if (iter != this->map.end()) return iter->second;
+    if (iter != this->map.end())
+      return iter->second;
     else {
       this->map.insert(std::make_pair(val, this->map.size()));
       return this->map.size() - 1;
@@ -32,16 +32,12 @@ public:
   /*!
      Returns the current size of the new element array
    */
-  [[nodiscard]] std::size_t size() const {
-    return this->map.size();
-  }
+  [[nodiscard]] std::size_t size() const { return this->map.size(); }
 
   /*!
      Reserve the requested size for the new element map
    */
-  void reserve(std::size_t n) {
-    return this->map.reserve(n);
-  }
+  void reserve(std::size_t n) { return this->map.reserve(n); }
 
   /*!
      Return a copy of the new element array
@@ -57,12 +53,13 @@ public:
   /*!
      Copies the internal vector to the given destination
    */
-  template <class OutputIterator> void copy(OutputIterator dest) {
+  template <class OutputIterator>
+  void copy(OutputIterator dest) {
     this->getArray();
     std::copy(this->vec.begin(), this->vec.end(), dest);
   }
 
-private:
+ private:
   std::unordered_map<T, int> map;
   std::vector<T> vec;
 };
diff --git a/src/geometry/boolean_utils.cc b/src/geometry/boolean_utils.cc
index 0b34760f9..a6b64f518 100644
--- a/src/geometry/boolean_utils.cc
+++ b/src/geometry/boolean_utils.cc
@@ -1,13 +1,13 @@
 #include "geometry/boolean_utils.h"
 
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/CGALNefGeometry.h"
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
 #include <CGAL/convex_hull_3.h>
+#include "geometry/cgal/CGALNefGeometry.h"
 #include "geometry/cgal/cgalutils.h"
 #endif  // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
@@ -15,100 +15,102 @@
 #include "geometry/manifold/manifoldutils.h"
 #endif  // ENABLE_MANIFOLD
 
-#include "glview/RenderSettings.h"
 #include "geometry/PolySet.h"
+#include "glview/RenderSettings.h"
 #include "utils/printutils.h"
 
-#include "geometry/Reindexer.h"
 #include "geometry/GeometryUtils.h"
+#include "geometry/Reindexer.h"
 
 #ifdef ENABLE_CGAL
-std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children)
-{
+std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children) {
   using Hull_kernel = CGAL::Epick;
   // Collect point cloud
   Reindexer<Hull_kernel::Point_3> reindexer;
 
   auto addCapacity = [&](const auto n) {
-      reindexer.reserve(reindexer.size() + n);
-    };
+    reindexer.reserve(reindexer.size() + n);
+  };
 
-  auto addPoint = [&](const auto& v) {
-      reindexer.lookup(v);
-    };
+  auto addPoint = [&](const auto& v) { reindexer.lookup(v); };
 
   for (const auto& item : children) {
     auto& chgeom = item.second;
 #ifdef ENABLE_CGAL
-    if (const auto *N = dynamic_cast<const CGALNefGeometry *>(chgeom.get())) {
+    if (const auto* N = dynamic_cast<const CGALNefGeometry*>(chgeom.get())) {
       if (!N->isEmpty()) {
         addCapacity(N->p3->number_of_vertices());
-        for (auto it = N->p3->vertices_begin(); it != N->p3->vertices_end(); ++it) {
-          addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(it->point()));
+        for (auto it = N->p3->vertices_begin(); it != N->p3->vertices_end();
+             ++it) {
+          addPoint(
+              CGALUtils::vector_convert<Hull_kernel::Point_3>(it->point()));
         }
       }
 #endif  // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto *mani = dynamic_cast<const ManifoldGeometry *>(chgeom.get())) {
-    addCapacity(mani->numVertices());
-    mani->foreachVertexUntilTrue([&](auto& p) {
-      addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(p));
-      return false;
-    });
+    } else if (const auto* mani =
+                   dynamic_cast<const ManifoldGeometry*>(chgeom.get())) {
+      addCapacity(mani->numVertices());
+      mani->foreachVertexUntilTrue([&](auto& p) {
+        addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(p));
+        return false;
+      });
 #endif  // ENABLE_MANIFOLD
-  } else if (const auto *ps = dynamic_cast<const PolySet *>(chgeom.get())) {
-    addCapacity(ps->indices.size() * 3);
-    for (const auto& p : ps->indices) {
-      for (const auto& ind : p) {
-        addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(ps->vertices[ind]));
+    } else if (const auto* ps = dynamic_cast<const PolySet*>(chgeom.get())) {
+      addCapacity(ps->indices.size() * 3);
+      for (const auto& p : ps->indices) {
+        for (const auto& ind : p) {
+          addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(
+              ps->vertices[ind]));
+        }
       }
     }
   }
-}
 
-const auto& points = reindexer.getArray();
-if (points.size() <= 3) return nullptr;
+  const auto& points = reindexer.getArray();
+  if (points.size() <= 3)
+    return nullptr;
 
-// Apply hull
-if (points.size() >= 4) {
-  try {
-    CGAL::Polyhedron_3<Hull_kernel> r;
-    CGAL::convex_hull_3(points.begin(), points.end(), r);
-    PRINTDB("After hull vertices: %d", r.size_of_vertices());
-    PRINTDB("After hull facets: %d", r.size_of_facets());
-    PRINTDB("After hull closed: %d", r.is_closed());
-    PRINTDB("After hull valid: %d", r.is_valid());
-    // FIXME: Make sure PolySet is set to convex.
-    // FIXME: Can we guarantee a manifold PolySet here?
-    return CGALUtils::createPolySetFromPolyhedron(r);
-  } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Error, "CGAL error in applyHull(): %1$s", e.what());
+  // Apply hull
+  if (points.size() >= 4) {
+    try {
+      CGAL::Polyhedron_3<Hull_kernel> r;
+      CGAL::convex_hull_3(points.begin(), points.end(), r);
+      PRINTDB("After hull vertices: %d", r.size_of_vertices());
+      PRINTDB("After hull facets: %d", r.size_of_facets());
+      PRINTDB("After hull closed: %d", r.is_closed());
+      PRINTDB("After hull valid: %d", r.is_valid());
+      // FIXME: Make sure PolySet is set to convex.
+      // FIXME: Can we guarantee a manifold PolySet here?
+      return CGALUtils::createPolySetFromPolyhedron(r);
+    } catch (const CGAL::Failure_exception& e) {
+      LOG(message_group::Error, "CGAL error in applyHull(): %1$s", e.what());
+    }
   }
-}
-return nullptr;
+  return nullptr;
 
-/*!
-   children cannot contain nullptr objects
+  /*!
+     children cannot contain nullptr objects
 
-   FIXME: This shouldn't return const, but it does due to internal implementation details
- */
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
+     FIXME: This shouldn't return const, but it does due to internal
+     implementation details
+   */
+  std::shared_ptr<const Geometry> applyMinkowski(
+      const Geometry::Geometries& children) {
 #if ENABLE_MANIFOLD
-  if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    return ManifoldUtils::applyMinkowski(children);
-  }
+    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
+      return ManifoldUtils::applyMinkowski(children);
+    }
 #endif  // ENABLE_MANIFOLD
-  return CGALUtils::applyMinkowski3D(children);
-}
-#else  // ENABLE_CGAL
-std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children)
-{
+    return CGALUtils::applyMinkowski3D(children);
+  }
+#else   // ENABLE_CGAL
+std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children) {
   return std::make_unique<PolySet>(3, true);
 }
 
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
+std::shared_ptr<const Geometry> applyMinkowski(
+    const Geometry::Geometries& children) {
   return std::make_shared<PolySet>(3);
 }
 #endif  // !ENABLE_CGAL
diff --git a/src/geometry/boolean_utils.h b/src/geometry/boolean_utils.h
index 082a23e87..f011e21e3 100644
--- a/src/geometry/boolean_utils.h
+++ b/src/geometry/boolean_utils.h
@@ -1,8 +1,9 @@
 #pragma once
 
 #include <memory>
-#include "geometry/PolySet.h"
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
 
 std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children);
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children);
+std::shared_ptr<const Geometry> applyMinkowski(
+    const Geometry::Geometries& children);
diff --git a/src/geometry/cgal/CGALCache.cc b/src/geometry/cgal/CGALCache.cc
index a5e895a18..6ac1c5a58 100644
--- a/src/geometry/cgal/CGALCache.cc
+++ b/src/geometry/cgal/CGALCache.cc
@@ -1,8 +1,8 @@
 #include "geometry/cgal/CGALCache.h"
 
 #include <cassert>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
 
 #include "geometry/Geometry.h"
@@ -14,17 +14,15 @@
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
-CGALCache *CGALCache::inst = nullptr;
+CGALCache* CGALCache::inst = nullptr;
 
-CGALCache::CGALCache(size_t limit) : cache(limit)
-{
-}
+CGALCache::CGALCache(size_t limit) : cache(limit) {}
 
-std::shared_ptr<const Geometry> CGALCache::get(const std::string& id) const
-{
+std::shared_ptr<const Geometry> CGALCache::get(const std::string& id) const {
   const auto& N = this->cache[id]->N;
 #ifdef DEBUG
-  LOG("CGAL Cache hit: %1$s (%2$d bytes)", id.substr(0, 40), N ? N->memsize() : 0);
+  LOG("CGAL Cache hit: %1$s (%2$d bytes)", id.substr(0, 40),
+      N ? N->memsize() : 0);
 #endif
   return N;
 }
@@ -37,53 +35,52 @@ bool CGALCache::acceptsGeometry(const std::shared_ptr<const Geometry>& geom) {
 #ifdef ENABLE_MANIFOLD
          || std::dynamic_pointer_cast<const ManifoldGeometry>(geom) != nullptr
 #endif
-  ;
+      ;
 }
 
-bool CGALCache::insert(const std::string& id, const std::shared_ptr<const Geometry>& N)
-{
+bool CGALCache::insert(const std::string& id,
+                       const std::shared_ptr<const Geometry>& N) {
   assert(acceptsGeometry(N));
-  auto inserted = this->cache.insert(id, new cache_entry(N), N ? N->memsize() : 0);
+  auto inserted =
+      this->cache.insert(id, new cache_entry(N), N ? N->memsize() : 0);
 #ifdef DEBUG
-  if (inserted) LOG("CGAL Cache insert: %1$s (%2$d bytes)", id.substr(0, 40), (N ? N->memsize() : 0));
-  else LOG("CGAL Cache insert failed: %1$s (%2$d bytes)", id.substr(0, 40), (N ? N->memsize() : 0));
+  if (inserted)
+    LOG("CGAL Cache insert: %1$s (%2$d bytes)", id.substr(0, 40),
+        (N ? N->memsize() : 0));
+  else
+    LOG("CGAL Cache insert failed: %1$s (%2$d bytes)", id.substr(0, 40),
+        (N ? N->memsize() : 0));
 #endif
   return inserted;
 }
 
-size_t CGALCache::size() const
-{
+size_t CGALCache::size() const {
   return cache.size();
 }
 
-size_t CGALCache::totalCost() const
-{
+size_t CGALCache::totalCost() const {
   return cache.totalCost();
 }
 
-size_t CGALCache::maxSizeMB() const
-{
+size_t CGALCache::maxSizeMB() const {
   return this->cache.maxCost() / (1024ul * 1024ul);
 }
 
-void CGALCache::setMaxSizeMB(size_t limit)
-{
+void CGALCache::setMaxSizeMB(size_t limit) {
   this->cache.setMaxCost(limit * 1024ul * 1024ul);
 }
 
-void CGALCache::clear()
-{
+void CGALCache::clear() {
   cache.clear();
 }
 
-void CGALCache::print()
-{
+void CGALCache::print() {
   LOG("CGAL Polyhedrons in cache: %1$d", this->cache.size());
   LOG("CGAL cache size in bytes: %1$d", this->cache.totalCost());
 }
 
 CGALCache::cache_entry::cache_entry(const std::shared_ptr<const Geometry>& N)
-  : N(N)
-{
-  if (print_messages_stack.size() > 0) this->msg = print_messages_stack.back();
+    : N(N) {
+  if (print_messages_stack.size() > 0)
+    this->msg = print_messages_stack.back();
 }
diff --git a/src/geometry/cgal/CGALCache.h b/src/geometry/cgal/CGALCache.h
index 4653b6663..eea95a17b 100644
--- a/src/geometry/cgal/CGALCache.h
+++ b/src/geometry/cgal/CGALCache.h
@@ -1,20 +1,25 @@
 #pragma once
 
-#include "Cache.h"
 #include <cstddef>
 #include <memory>
 #include <string>
+#include "Cache.h"
 #include "geometry/Geometry.h"
 
-class CGALCache
-{
-public:
-  CGALCache(size_t limit = 100ul *1024ul *1024ul);
+class CGALCache {
+ public:
+  CGALCache(size_t limit = 100ul * 1024ul * 1024ul);
 
-  static CGALCache *instance() { if (!inst) inst = new CGALCache; return inst; }
+  static CGALCache* instance() {
+    if (!inst)
+      inst = new CGALCache;
+    return inst;
+  }
   static bool acceptsGeometry(const std::shared_ptr<const Geometry>& geom);
 
-  bool contains(const std::string& id) const { return this->cache.contains(id); }
+  bool contains(const std::string& id) const {
+    return this->cache.contains(id);
+  }
   std::shared_ptr<const Geometry> get(const std::string& id) const;
   bool insert(const std::string& id, const std::shared_ptr<const Geometry>& N);
   size_t size() const;
@@ -24,8 +29,8 @@ public:
   void clear();
   void print();
 
-private:
-  static CGALCache *inst;
+ private:
+  static CGALCache* inst;
 
   struct cache_entry {
     std::shared_ptr<const Geometry> N;
diff --git a/src/geometry/cgal/CGALNefGeometry.cc b/src/geometry/cgal/CGALNefGeometry.cc
index bc0b17c8f..6dab8711a 100644
--- a/src/geometry/cgal/CGALNefGeometry.cc
+++ b/src/geometry/cgal/CGALNefGeometry.cc
@@ -1,81 +1,77 @@
 #include "geometry/cgal/CGALNefGeometry.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 #include "utils/svg.h"
 
 // Copy constructor only performs shallow copies, so all modifying functions
-// must reset p3 with a new CGAL_Nef_polyhedron3 object, to prevent cache corruption.
-// This is also partly enforced by p3 pointing to a const object.
-CGALNefGeometry::CGALNefGeometry(const CGALNefGeometry& src) : Geometry(src)
-{
-  if (src.p3) this->p3 = src.p3;
+// must reset p3 with a new CGAL_Nef_polyhedron3 object, to prevent cache
+// corruption. This is also partly enforced by p3 pointing to a const object.
+CGALNefGeometry::CGALNefGeometry(const CGALNefGeometry& src) : Geometry(src) {
+  if (src.p3)
+    this->p3 = src.p3;
 }
 
-std::unique_ptr<Geometry> CGALNefGeometry::copy() const
-{
+std::unique_ptr<Geometry> CGALNefGeometry::copy() const {
   return std::make_unique<CGALNefGeometry>(*this);
 }
 
-CGALNefGeometry CGALNefGeometry::operator+(const CGALNefGeometry& other) const
-{
+CGALNefGeometry CGALNefGeometry::operator+(const CGALNefGeometry& other) const {
   return {std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) + (*other.p3))};
 }
 
-CGALNefGeometry& CGALNefGeometry::operator+=(const CGALNefGeometry& other)
-{
+CGALNefGeometry& CGALNefGeometry::operator+=(const CGALNefGeometry& other) {
   this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) + (*other.p3));
   return *this;
 }
 
-CGALNefGeometry& CGALNefGeometry::operator*=(const CGALNefGeometry& other)
-{
+CGALNefGeometry& CGALNefGeometry::operator*=(const CGALNefGeometry& other) {
   this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) * (*other.p3));
   return *this;
 }
 
-CGALNefGeometry& CGALNefGeometry::operator-=(const CGALNefGeometry& other)
-{
+CGALNefGeometry& CGALNefGeometry::operator-=(const CGALNefGeometry& other) {
   this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) - (*other.p3));
   return *this;
 }
 
-// Note: this is only the fallback method in case of failure in CGALUtils::applyMinkowski (see: cgalutils-applyops.cc)
-CGALNefGeometry& CGALNefGeometry::minkowski(const CGALNefGeometry& other)
-{
+// Note: this is only the fallback method in case of failure in
+// CGALUtils::applyMinkowski (see: cgalutils-applyops.cc)
+CGALNefGeometry& CGALNefGeometry::minkowski(const CGALNefGeometry& other) {
   // It is required to construct copies of our const input operands here.
-  // "Postcondition: If either of the input polyhedra is non-convex, it is modified during the computation,
+  // "Postcondition: If either of the input polyhedra is non-convex, it is
+  // modified during the computation,
   //  i.e., it is decomposed into convex pieces."
-  // from https://doc.cgal.org/latest/Minkowski_sum_3/group__PkgMinkowskiSum3Ref.html
+  // from
+  // https://doc.cgal.org/latest/Minkowski_sum_3/group__PkgMinkowskiSum3Ref.html
   CGAL_Nef_polyhedron3 op1(*this->p3);
   CGAL_Nef_polyhedron3 op2(*other.p3);
-  this->p3 = std::make_shared<CGAL_Nef_polyhedron3>(CGAL::minkowski_sum_3(op1, op2));
+  this->p3 =
+      std::make_shared<CGAL_Nef_polyhedron3>(CGAL::minkowski_sum_3(op1, op2));
   return *this;
 }
 
-size_t CGALNefGeometry::memsize() const
-{
-  if (this->isEmpty()) return 0;
+size_t CGALNefGeometry::memsize() const {
+  if (this->isEmpty())
+    return 0;
 
   auto memsize = sizeof(CGALNefGeometry);
   memsize += const_cast<CGAL_Nef_polyhedron3&>(*this->p3).bytes();
   return memsize;
 }
 
-bool CGALNefGeometry::isEmpty() const
-{
+bool CGALNefGeometry::isEmpty() const {
   return !this->p3 || this->p3->is_empty();
 }
 
-BoundingBox CGALNefGeometry::getBoundingBox() const
-{
+BoundingBox CGALNefGeometry::getBoundingBox() const {
   if (isEmpty()) {
     return {};
   }
@@ -88,27 +84,24 @@ BoundingBox CGALNefGeometry::getBoundingBox() const
 }
 
 void CGALNefGeometry::resize(const Vector3d& newsize,
-                             const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+                             const Eigen::Matrix<bool, 3, 1>& autosize) {
   // Based on resize() in Giles Bathgate's RapCAD (but not exactly)
-  if (this->isEmpty()) return;
+  if (this->isEmpty())
+    return;
 
-  transform(
-    CGALUtils::computeResizeTransform(
-      CGALUtils::boundingBox(*this->p3),
-      getDimension(), newsize, autosize));
+  transform(CGALUtils::computeResizeTransform(
+      CGALUtils::boundingBox(*this->p3), getDimension(), newsize, autosize));
 }
 
-std::string CGALNefGeometry::dump() const
-{
+std::string CGALNefGeometry::dump() const {
   return OpenSCAD::dump_svg(*this->p3);
 }
 
-void CGALNefGeometry::transform(const Transform3d& matrix)
-{
+void CGALNefGeometry::transform(const Transform3d& matrix) {
   if (!this->isEmpty()) {
     if (matrix.matrix().determinant() == 0) {
-      LOG(message_group::Warning, "Scaling a 3D object with 0 - removing object");
+      LOG(message_group::Warning,
+          "Scaling a 3D object with 0 - removing object");
       this->reset();
     } else {
       auto N = std::make_shared<CGAL_Nef_polyhedron3>(*this->p3);
diff --git a/src/geometry/cgal/CGALNefGeometry.h b/src/geometry/cgal/CGALNefGeometry.h
index cdef9c4b8..0d7090a3c 100644
--- a/src/geometry/cgal/CGALNefGeometry.h
+++ b/src/geometry/cgal/CGALNefGeometry.h
@@ -1,19 +1,19 @@
 #pragma once
 
-#include "geometry/cgal/cgal.h"
-#include "geometry/Geometry.h"
 #include <cstddef>
 #include <memory>
 #include <string>
 #include <utility>
+#include "geometry/Geometry.h"
+#include "geometry/cgal/cgal.h"
 #include "geometry/linalg.h"
 
-class CGALNefGeometry : public Geometry
-{
-public:
+class CGALNefGeometry : public Geometry {
+ public:
   VISITABLE_GEOMETRY();
   CGALNefGeometry() = default;
-  CGALNefGeometry(std::shared_ptr<const CGAL_Nef_polyhedron3> p) : p3(std::move(p)) {}
+  CGALNefGeometry(std::shared_ptr<const CGAL_Nef_polyhedron3> p)
+      : p3(std::move(p)) {}
   CGALNefGeometry(const CGALNefGeometry& src);
   CGALNefGeometry& operator=(const CGALNefGeometry&) = default;
   CGALNefGeometry(CGALNefGeometry&&) = default;
@@ -28,7 +28,9 @@ public:
   // Empty means it is a geometric node which has zero area/volume
   [[nodiscard]] bool isEmpty() const override;
   [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
-  [[nodiscard]] size_t numFacets() const override { return p3->number_of_facets(); }
+  [[nodiscard]] size_t numFacets() const override {
+    return p3->number_of_facets();
+  }
 
   void reset() { p3.reset(); }
   CGALNefGeometry operator+(const CGALNefGeometry& other) const;
@@ -37,7 +39,8 @@ public:
   CGALNefGeometry& operator-=(const CGALNefGeometry& other);
   CGALNefGeometry& minkowski(const CGALNefGeometry& other);
   void transform(const Transform3d& matrix) override;
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
+  void resize(const Vector3d& newsize,
+              const Eigen::Matrix<bool, 3, 1>& autosize) override;
 
   std::shared_ptr<const CGAL_Nef_polyhedron3> p3;
 };
diff --git a/src/geometry/cgal/cgal.h b/src/geometry/cgal/cgal.h
index 6fb0425b1..8a5006103 100644
--- a/src/geometry/cgal/cgal.h
+++ b/src/geometry/cgal/cgal.h
@@ -2,38 +2,40 @@
 
 #ifdef ENABLE_CGAL
 
-// STL Allocator doesn't make any significant difference on my Linux dev machine - Hans
+// STL Allocator doesn't make any significant difference on my Linux dev machine
+// - Hans
 /*
  #ifdef USE_MIMALLOC
  #ifndef MI_OVERRIDE
  #include <mimalloc.h>
-    // If using CGAL_ALLOCATOR to override, then make sure to define it as the first thing
-    // ****** NOTE: THAT MEANS THIS FILE "cgal.h" SHOULD ALWAYS COME BEFORE OTHER CGAL INCLUDES! ******
- #define CGAL_ALLOCATOR(t) mi_stl_allocator<t>
+    // If using CGAL_ALLOCATOR to override, then make sure to define it as the
+ first thing
+    // ****** NOTE: THAT MEANS THIS FILE "cgal.h" SHOULD ALWAYS COME BEFORE
+ OTHER CGAL INCLUDES! ****** #define CGAL_ALLOCATOR(t) mi_stl_allocator<t>
  #endif
  #endif
    //*/
 
 #include <vector>
 
-#include "CGAL/CGAL_workaround_Mark_bounded_volumes.h" // This file must be included prior to CGAL/Nef_polyhedron_3.h
-#include <CGAL/Gmpq.h>
+#include <CGAL/Cartesian.h>
+#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
 #include <CGAL/Extended_cartesian.h>
+#include <CGAL/Gmpq.h>
+#include <CGAL/IO/Nef_polyhedron_iostream_3.h>  // for dumping .nef3
+#include <CGAL/IO/Polyhedron_iostream.h>
 #include <CGAL/Nef_polyhedron_2.h>
-#include <CGAL/Cartesian.h>
-#include <CGAL/Polyhedron_3.h>
 #include <CGAL/Nef_polyhedron_3.h>
-#include <CGAL/Surface_mesh.h>
-#include <CGAL/IO/Polyhedron_iostream.h>
-#include <CGAL/IO/Nef_polyhedron_iostream_3.h> // for dumping .nef3
-#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
 #include <CGAL/Polygon_2.h>
 #include <CGAL/Polygon_with_holes_2.h>
+#include <CGAL/Polyhedron_3.h>
+#include <CGAL/Surface_mesh.h>
+#include <CGAL/bounding_box.h>
 #include <CGAL/minkowski_sum_2.h>
 #include <CGAL/minkowski_sum_3.h>
-#include <CGAL/bounding_box.h>
 #include <CGAL/utils.h>
 #include <CGAL/version.h>
+#include "CGAL/CGAL_workaround_Mark_bounded_volumes.h"  // This file must be included prior to CGAL/Nef_polyhedron_3.h
 
 #include <CGAL/assertions_behaviour.h>
 #include <CGAL/exceptions.h>
@@ -45,7 +47,8 @@ using CGAL_Kernel2 = CGAL::Extended_cartesian<NT2>;
 using CGAL_Nef_polyhedron2 = CGAL::Nef_polyhedron_2<CGAL_Kernel2>;
 
 using CGAL_Point_2e = CGAL_Nef_polyhedron2::Explorer::Point;
-using CGAL_Iso_rectangle_2e = CGAL::Iso_rectangle_2<CGAL::Simple_cartesian<NT2>>;
+using CGAL_Iso_rectangle_2e =
+    CGAL::Iso_rectangle_2<CGAL::Simple_cartesian<NT2>>;
 
 // 3D
 
diff --git a/src/geometry/cgal/cgalutils-applyops-minkowski.cc b/src/geometry/cgal/cgalutils-applyops-minkowski.cc
index 6d73a14d2..99d1aaa83 100644
--- a/src/geometry/cgal/cgalutils-applyops-minkowski.cc
+++ b/src/geometry/cgal/cgalutils-applyops-minkowski.cc
@@ -9,8 +9,8 @@
 
 namespace CGALUtils {
 
-std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& children)
-{
+std::shared_ptr<const Geometry> applyMinkowski3D(
+    const Geometry::Geometries& children) {
   assert(children.size() >= 2);
 
   CGAL::Timer t;
@@ -18,7 +18,8 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
   t_tot.start();
 
   auto it = children.begin();
-  std::shared_ptr<const Geometry> operands[2] = {it->second, std::shared_ptr<const Geometry>()};
+  std::shared_ptr<const Geometry> operands[2] = {
+      it->second, std::shared_ptr<const Geometry>()};
   try {
     while (++it != children.end()) {
       operands[1] = it->second;
@@ -32,27 +33,36 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
         CGAL_Polyhedron poly;
 
         auto ps = std::dynamic_pointer_cast<const PolySet>(operands[i]);
-        auto nef = std::dynamic_pointer_cast<const CGALNefGeometry>(operands[i]);
+        auto nef =
+            std::dynamic_pointer_cast<const CGALNefGeometry>(operands[i]);
 
         if (!nef) {
           nef = CGALUtils::getNefPolyhedronFromGeometry(operands[i]);
         }
 
-        if (ps) CGALUtils::createPolyhedronFromPolySet(*ps, poly);
-        else if (nef && nef->p3->is_simple()) CGALUtils::convertNefToPolyhedron(*nef->p3, poly);
-        else throw 0;
+        if (ps)
+          CGALUtils::createPolyhedronFromPolySet(*ps, poly);
+        else if (nef && nef->p3->is_simple())
+          CGALUtils::convertNefToPolyhedron(*nef->p3, poly);
+        else
+          throw 0;
 
         if ((ps && ps->isConvex()) ||
             (!ps && CGALUtils::is_weakly_convex(poly))) {
-          PRINTDB("Minkowski: child %d is convex and %s", i % (ps?"PolySet":"Nef"));
+          PRINTDB("Minkowski: child %d is convex and %s",
+                  i % (ps ? "PolySet" : "Nef"));
           P[i].push_back(poly);
         } else {
           CGAL_Nef_polyhedron3 decomposed_nef;
 
           if (ps) {
-            PRINTDB("Minkowski: child %d is nonconvex PolySet, transforming to Nef and decomposing...", i);
+            PRINTDB(
+                "Minkowski: child %d is nonconvex PolySet, transforming to Nef "
+                "and decomposing...",
+                i);
             auto p = CGALUtils::getNefPolyhedronFromGeometry(ps);
-            if (p && !p->isEmpty()) decomposed_nef = *p->p3;
+            if (p && !p->isEmpty())
+              decomposed_nef = *p->p3;
           } else {
             PRINTDB("Minkowski: child %d is nonconvex Nef, decomposing...", i);
             decomposed_nef = *nef->p3;
@@ -61,16 +71,18 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
           t.start();
           CGAL::convex_decomposition_3(decomposed_nef);
 
-          // the first volume is the outer volume, which ignored in the decomposition
-          for (auto ci = ++decomposed_nef.volumes_begin(); ci != decomposed_nef.volumes_end(); ++ci) {
+          // the first volume is the outer volume, which ignored in the
+          // decomposition
+          for (auto ci = ++decomposed_nef.volumes_begin();
+               ci != decomposed_nef.volumes_end(); ++ci) {
             if (ci->mark()) {
               CGAL_Polyhedron poly;
-              decomposed_nef.convert_inner_shell_to_polyhedron(ci->shells_begin(), poly);
+              decomposed_nef.convert_inner_shell_to_polyhedron(
+                  ci->shells_begin(), poly);
               P[i].push_back(poly);
             }
           }
 
-
           PRINTDB("Minkowski: decomposed into %d convex parts", P[i].size());
           t.stop();
           PRINTDB("Minkowski: decomposition took %f s", t.time());
@@ -90,12 +102,14 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
 
           for (int k = 0; k < 2; ++k) {
             auto it = P[k].begin();
-            std::advance(it, k == 0?i:j);
+            std::advance(it, k == 0 ? i : j);
 
             CGAL_Polyhedron const& poly = *it;
             points[k].reserve(poly.size_of_vertices());
 
-            for (CGAL_Polyhedron::Vertex_const_iterator pi = poly.vertices_begin(); pi != poly.vertices_end(); ++pi) {
+            for (CGAL_Polyhedron::Vertex_const_iterator pi =
+                     poly.vertices_begin();
+                 pi != poly.vertices_end(); ++pi) {
               CGAL_Polyhedron::Point_3 const& p = pi->point();
               points[k].push_back(conv(p));
             }
@@ -105,7 +119,8 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
           minkowski_points.reserve(points[0].size() * points[1].size());
           for (size_t i = 0; i < points[0].size(); ++i) {
             for (size_t j = 0; j < points[1].size(); ++j) {
-              minkowski_points.push_back(points[0][i] + (points[1][j] - CGAL::ORIGIN));
+              minkowski_points.push_back(points[0][i] +
+                                         (points[1][j] - CGAL::ORIGIN));
             }
           }
 
@@ -116,17 +131,22 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
 
           CGAL::Polyhedron_3<Hull_kernel> result;
           t.stop();
-          PRINTDB("Minkowski: Point cloud creation (%d  %d -> %d) took %f ms", points[0].size() % points[1].size() % minkowski_points.size() % (t.time() * 1000));
+          PRINTDB("Minkowski: Point cloud creation (%d  %d -> %d) took %f ms",
+                  points[0].size() % points[1].size() %
+                      minkowski_points.size() % (t.time() * 1000));
           t.reset();
 
           t.start();
 
-          CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(), result);
+          CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(),
+                              result);
 
           std::vector<Hull_kernel::Point_3> strict_points;
           strict_points.reserve(minkowski_points.size());
 
-          for (CGAL::Polyhedron_3<Hull_kernel>::Vertex_iterator i = result.vertices_begin(); i != result.vertices_end(); ++i) {
+          for (CGAL::Polyhedron_3<Hull_kernel>::Vertex_iterator i =
+                   result.vertices_begin();
+               i != result.vertices_end(); ++i) {
             Hull_kernel::Point_3 const& p = i->point();
 
             CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle h, e;
@@ -137,18 +157,22 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
 
             do {
               Hull_kernel::Point_3 const& q = h->opposite()->vertex()->point();
-              if (coplanar && !CGAL::coplanar(p, q,
-                                              h->next_on_vertex()->opposite()->vertex()->point(),
-                                              h->next_on_vertex()->next_on_vertex()->opposite()->vertex()->point())) {
+              if (coplanar &&
+                  !CGAL::coplanar(
+                      p, q, h->next_on_vertex()->opposite()->vertex()->point(),
+                      h->next_on_vertex()
+                          ->next_on_vertex()
+                          ->opposite()
+                          ->vertex()
+                          ->point())) {
                 coplanar = false;
               }
 
-
-              for (CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle j = h->next_on_vertex();
-                   j != h && !collinear && !coplanar;
-                   j = j->next_on_vertex()) {
-
-                Hull_kernel::Point_3 const& r = j->opposite()->vertex()->point();
+              for (CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle j =
+                       h->next_on_vertex();
+                   j != h && !collinear && !coplanar; j = j->next_on_vertex()) {
+                Hull_kernel::Point_3 const& r =
+                    j->opposite()->vertex()->point();
                 if (CGAL::collinear(p, q, r)) {
                   collinear = true;
                 }
@@ -157,12 +181,13 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
               h = h->next_on_vertex();
             } while (h != e && !collinear);
 
-            if (!collinear && !coplanar) strict_points.push_back(p);
+            if (!collinear && !coplanar)
+              strict_points.push_back(p);
           }
 
           result.clear();
-          CGAL::convex_hull_3(strict_points.begin(), strict_points.end(), result);
-
+          CGAL::convex_hull_3(strict_points.begin(), strict_points.end(),
+                              result);
 
           t.stop();
           PRINTDB("Minkowski: Computing convex hull took %f s", t.time());
@@ -172,11 +197,12 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
         }
       }
 
-      if (it != std::next(children.begin())) operands[0].reset();
+      if (it != std::next(children.begin()))
+        operands[0].reset();
 
       auto partToGeom = [&](auto& poly) -> std::shared_ptr<const Geometry> {
-          return CGALUtils::createPolySetFromPolyhedron(poly);
-        };
+        return CGALUtils::createPolySetFromPolyhedron(poly);
+      };
 
       if (result_parts.size() == 1) {
         operands[0] = partToGeom(*result_parts.begin());
@@ -185,12 +211,15 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
         PRINTDB("Minkowski: Computing union of %d parts", result_parts.size());
         Geometry::Geometries fake_children;
         for (const auto& part : result_parts) {
-          fake_children.emplace_back(std::shared_ptr<const AbstractNode>(), partToGeom(part));
+          fake_children.emplace_back(std::shared_ptr<const AbstractNode>(),
+                                     partToGeom(part));
         }
-        auto N = CGALUtils::applyUnion3D(fake_children.begin(), fake_children.end());
+        auto N =
+            CGALUtils::applyUnion3D(fake_children.begin(), fake_children.end());
         // FIXME: This should really never throw.
         // Assert once we figured out what went wrong with issue #1069?
-        if (!N) throw 0;
+        if (!N)
+          throw 0;
         t.stop();
         PRINTDB("Minkowski: Union done: %f s", t.time());
         t.reset();
@@ -208,7 +237,8 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
     // If anything throws we simply fall back to Nef Minkowski
     PRINTD("Minkowski: Falling back to Nef Minkowski");
 
-    auto N = std::shared_ptr<const Geometry>(CGALUtils::applyOperator3D(children, OpenSCADOperator::MINKOWSKI));
+    auto N = std::shared_ptr<const Geometry>(
+        CGALUtils::applyOperator3D(children, OpenSCADOperator::MINKOWSKI));
     return N;
   }
 }
diff --git a/src/geometry/cgal/cgalutils-applyops.cc b/src/geometry/cgal/cgalutils-applyops.cc
index 67c3aefdd..7ac5df2ae 100644
--- a/src/geometry/cgal/cgalutils-applyops.cc
+++ b/src/geometry/cgal/cgalutils-applyops.cc
@@ -1,32 +1,32 @@
 // this file is split into many separate cgalutils* files
 // in order to workaround gcc 4.9.1 crashing on systems with only 2GB of RAM
-#include "geometry/cgal/cgal.h"
-#include "geometry/Geometry.h"
-#include "geometry/cgal/cgalutils.h"
 #include "Feature.h"
+#include "core/progress.h"
+#include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/cgal/cgalutils.h"
 #include "utils/printutils.h"
-#include "core/progress.h"
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "geometry/manifold/manifoldutils.h"
 #endif
 #include "core/node.h"
 
-#include <cassert>
-#include <utility>
-#include <exception>
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
-#include <CGAL/normal_vector_newell_3.h>
 #include <CGAL/Handle_hash_function.h>
+#include <CGAL/normal_vector_newell_3.h>
+#include <cassert>
+#include <exception>
+#include <utility>
 
 #include <CGAL/config.h>
 #include <CGAL/version.h>
 
 #include <CGAL/convex_hull_3.h>
 
-#include "geometry/Reindexer.h"
 #include "geometry/GeometryUtils.h"
+#include "geometry/Reindexer.h"
 
 #include <cstddef>
 #include <memory>
@@ -36,19 +36,21 @@
 namespace CGALUtils {
 
 std::unique_ptr<const Geometry> applyUnion3D(
-  Geometry::Geometries::iterator chbegin, Geometry::Geometries::iterator chend)
-{
+    Geometry::Geometries::iterator chbegin,
+    Geometry::Geometries::iterator chend) {
   using QueueConstItem = std::pair<std::shared_ptr<const CGALNefGeometry>, int>;
   struct QueueItemGreater {
     // stable sort for priority_queue by facets, then progress mark
-    bool operator()(const QueueConstItem& lhs, const QueueConstItem& rhs) const
-    {
+    bool operator()(const QueueConstItem& lhs,
+                    const QueueConstItem& rhs) const {
       size_t l = lhs.first->p3->number_of_facets();
       size_t r = rhs.first->p3->number_of_facets();
       return (l > r) || (l == r && lhs.second > rhs.second);
     }
   };
-  std::priority_queue<QueueConstItem, std::vector<QueueConstItem>, QueueItemGreater> q;
+  std::priority_queue<QueueConstItem, std::vector<QueueConstItem>,
+                      QueueItemGreater>
+      q;
 
   try {
     // sort children by fewest faces
@@ -69,7 +71,8 @@ std::unique_ptr<const Geometry> applyUnion3D(
       q.pop();
       auto p2 = q.top();
       q.pop();
-      q.emplace(std::make_unique<const CGALNefGeometry>(*p1.first + *p2.first), -1);
+      q.emplace(std::make_unique<const CGALNefGeometry>(*p1.first + *p2.first),
+                -1);
       progress_tick();
     }
 
@@ -79,20 +82,24 @@ std::unique_ptr<const Geometry> applyUnion3D(
       return nullptr;
     }
   } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Error, "CGAL error in CGALUtils::applyUnion3D: %1$s", e.what());
+    LOG(message_group::Error, "CGAL error in CGALUtils::applyUnion3D: %1$s",
+        e.what());
   }
   return nullptr;
 }
 
 /*!
    Applies op to all children and returns the result.
-   The child list should be guaranteed to contain non-NULL 3D or empty Geometry objects
+   The child list should be guaranteed to contain non-NULL 3D or empty Geometry
+   objects
  */
-std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& children, OpenSCADOperator op)
-{
+std::shared_ptr<const Geometry> applyOperator3D(
+    const Geometry::Geometries& children,
+    OpenSCADOperator op) {
   std::shared_ptr<CGALNefGeometry> N;
 
-  assert(op != OpenSCADOperator::UNION && "use applyUnion3D() instead of applyOperator3D()");
+  assert(op != OpenSCADOperator::UNION &&
+         "use applyUnion3D() instead of applyOperator3D()");
   bool foundFirst = false;
 
   try {
@@ -105,7 +112,7 @@ std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& chil
         if (chN) {
           // FIXME: Do we need to make a copy here?
           N = std::make_shared<CGALNefGeometry>(*chN);
-        } else { // first child geometry might be empty/null
+        } else {  // first child geometry might be empty/null
           N = nullptr;
         }
         foundFirst = true;
@@ -121,33 +128,47 @@ std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& chil
       }
 
       // empty op <something> => empty
-      if (!N || N->isEmpty()) continue;
+      if (!N || N->isEmpty())
+        continue;
 
       switch (op) {
-      case OpenSCADOperator::INTERSECTION:
-        *N *= *chN;
-        break;
-      case OpenSCADOperator::DIFFERENCE:
-        *N -= *chN;
-        break;
-      case OpenSCADOperator::MINKOWSKI:
-        N->minkowski(*chN);
-        break;
-      default:
-        LOG(message_group::Error, "Unsupported CGAL operator: %1$d", static_cast<int>(op));
+        case OpenSCADOperator::INTERSECTION:
+          *N *= *chN;
+          break;
+        case OpenSCADOperator::DIFFERENCE:
+          *N -= *chN;
+          break;
+        case OpenSCADOperator::MINKOWSKI:
+          N->minkowski(*chN);
+          break;
+        default:
+          LOG(message_group::Error, "Unsupported CGAL operator: %1$d",
+              static_cast<int>(op));
       }
-      if (item.first) item.first->progress_report();
+      if (item.first)
+        item.first->progress_report();
     }
   }
-  // union && difference assert triggered by tests/data/scad/bugs/rotate-diff-nonmanifold-crash.scad and tests/data/scad/bugs/issue204.scad
+  // union && difference assert triggered by
+  // tests/data/scad/bugs/rotate-diff-nonmanifold-crash.scad and
+  // tests/data/scad/bugs/issue204.scad
   catch (const CGAL::Failure_exception& e) {
-    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection" : op == OpenSCADOperator::DIFFERENCE ? "difference" : op == OpenSCADOperator::UNION ? "union" : "UNKNOWN";
-    LOG(message_group::Error, "CGAL error in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
+    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection"
+                        : op == OpenSCADOperator::DIFFERENCE ? "difference"
+                        : op == OpenSCADOperator::UNION      ? "union"
+                                                             : "UNKNOWN";
+    LOG(message_group::Error,
+        "CGAL error in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
   }
-  // boost any_cast throws exceptions inside CGAL code, ending here https://github.com/openscad/openscad/issues/3756
+  // boost any_cast throws exceptions inside CGAL code, ending here
+  // https://github.com/openscad/openscad/issues/3756
   catch (const std::exception& e) {
-    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection" : op == OpenSCADOperator::DIFFERENCE ? "difference" : op == OpenSCADOperator::UNION ? "union" : "UNKNOWN";
-    LOG(message_group::Error, "exception in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
+    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection"
+                        : op == OpenSCADOperator::DIFFERENCE ? "difference"
+                        : op == OpenSCADOperator::UNION      ? "union"
+                                                             : "UNKNOWN";
+    LOG(message_group::Error,
+        "exception in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
   }
   return N;
 }
diff --git a/src/geometry/cgal/cgalutils-closed.cc b/src/geometry/cgal/cgalutils-closed.cc
index 71a5815c2..01e50ec24 100644
--- a/src/geometry/cgal/cgalutils-closed.cc
+++ b/src/geometry/cgal/cgalutils-closed.cc
@@ -1,18 +1,17 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/cgal/cgalutils.h"
 
-#include <CGAL/boost/graph/helpers.h>
 #include <CGAL/Surface_mesh.h>
+#include <CGAL/boost/graph/helpers.h>
 
 namespace CGALUtils {
 
 template <typename Polyhedron>
-bool isClosed(const Polyhedron& p)
-{
+bool isClosed(const Polyhedron& p) {
   return CGAL::is_closed(p);
 }
 
 template bool isClosed(const CGAL_DoubleMesh& p);
 
-} // namespace CGALUtils
-
+}  // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-convex.cc b/src/geometry/cgal/cgalutils-convex.cc
index 01329daf0..73adcd3ca 100644
--- a/src/geometry/cgal/cgalutils-convex.cc
+++ b/src/geometry/cgal/cgalutils-convex.cc
@@ -1,11 +1,11 @@
 #ifdef ENABLE_CGAL
 
-#include "geometry/cgal/cgal.h"
-#include "geometry/cgal/cgalutils.h"
 #include <CGAL/Plane_3.h>
 #include <CGAL/Surface_mesh.h>
 #include <queue>
 #include <unordered_set>
+#include "geometry/cgal/cgal.h"
+#include "geometry/cgal/cgalutils.h"
 
 namespace CGALUtils {
 
@@ -13,20 +13,26 @@ template <typename K>
 bool is_weakly_convex(const CGAL::Polyhedron_3<K>& p) {
   using Polyhedron = typename CGAL::Polyhedron_3<K>;
 
-  for (typename Polyhedron::Edge_const_iterator i = p.edges_begin(); i != p.edges_end(); ++i) {
-    typename Polyhedron::Plane_3 p(i->opposite()->vertex()->point(), i->vertex()->point(), i->next()->vertex()->point());
+  for (typename Polyhedron::Edge_const_iterator i = p.edges_begin();
+       i != p.edges_end(); ++i) {
+    typename Polyhedron::Plane_3 p(i->opposite()->vertex()->point(),
+                                   i->vertex()->point(),
+                                   i->next()->vertex()->point());
     if (p.has_on_positive_side(i->opposite()->next()->vertex()->point()) &&
-        CGAL::squared_distance(p, i->opposite()->next()->vertex()->point()) > 1e-8) {
+        CGAL::squared_distance(p, i->opposite()->next()->vertex()->point()) >
+            1e-8) {
       return false;
     }
   }
   // Also make sure that there is only one shell:
-  std::unordered_set<typename Polyhedron::Facet_const_handle, typename CGAL::Handle_hash_function> visited;
+  std::unordered_set<typename Polyhedron::Facet_const_handle,
+                     typename CGAL::Handle_hash_function>
+      visited;
   // c++11
   visited.reserve(p.size_of_facets());
 
   std::queue<typename Polyhedron::Facet_const_handle> to_explore;
-  to_explore.push(p.facets_begin()); // One arbitrary facet
+  to_explore.push(p.facets_begin());  // One arbitrary facet
   visited.insert(to_explore.front());
 
   while (!to_explore.empty()) {
@@ -54,10 +60,8 @@ bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m) {
   using Mesh = typename CGAL::Surface_mesh<CGAL::Point_3<K>>;
 
   for (auto i : m.halfedges()) {
-    CGAL::Plane_3<K> p(
-      m.point(m.target(m.opposite(i))),
-      m.point(m.target(i)),
-      m.point(m.target(m.next(i))));
+    CGAL::Plane_3<K> p(m.point(m.target(m.opposite(i))), m.point(m.target(i)),
+                       m.point(m.target(m.next(i))));
     const auto& pt = m.point(m.target(m.next(m.opposite(i))));
     if (p.has_on_positive_side(pt) && CGAL::squared_distance(p, pt) > 1e-8) {
       return false;
@@ -65,11 +69,13 @@ bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m) {
   }
 
   // Also make sure that there is only one shell:
-  std::unordered_set<typename Mesh::Face_index, typename CGAL::Handle_hash_function> visited;
+  std::unordered_set<typename Mesh::Face_index,
+                     typename CGAL::Handle_hash_function>
+      visited;
   visited.reserve(m.number_of_faces());
 
   std::queue<typename Mesh::Face_index> to_explore;
-  to_explore.push(*m.faces().begin()); // One arbitrary facet
+  to_explore.push(*m.faces().begin());  // One arbitrary facet
   visited.insert(to_explore.front());
 
   while (!to_explore.empty()) {
@@ -77,7 +83,8 @@ bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m) {
     to_explore.pop();
 
     CGAL::Halfedge_around_face_iterator<Mesh> he, end;
-    for (boost::tie(he, end) = CGAL::halfedges_around_face(m.halfedge(f), m); he != end; ++he) {
+    for (boost::tie(he, end) = CGAL::halfedges_around_face(m.halfedge(f), m);
+         he != end; ++he) {
       typename Mesh::Face_index o = m.face(m.opposite(*he));
 
       if (!visited.count(o)) {
@@ -94,4 +101,4 @@ template bool is_weakly_convex(const CGAL::Surface_mesh<CGAL_Point_3>& m);
 
 }  // namespace CGALUtils
 
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
diff --git a/src/geometry/cgal/cgalutils-kernel.cc b/src/geometry/cgal/cgalutils-kernel.cc
index cbb46c8c8..d58f602eb 100644
--- a/src/geometry/cgal/cgalutils-kernel.cc
+++ b/src/geometry/cgal/cgalutils-kernel.cc
@@ -1,29 +1,28 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
-#include "geometry/cgal/cgalutils.h"
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include <CGAL/Cartesian_converter.h>
 #include <CGAL/gmpxx.h>
+#include "geometry/cgal/cgalutils.h"
 
 namespace CGALUtils {
 
 template <>
 double KernelConverter<CGAL::Cartesian<CGAL::Gmpq>, CGAL::Epick>::operator()(
-  const CGAL::Gmpq& n) const
-{
+    const CGAL::Gmpq& n) const {
   return CGAL::to_double(n);
 }
 
 template <>
-CGAL::Gmpq KernelConverter<CGAL::Epick, CGAL::Cartesian<CGAL::Gmpq>>::operator()(
-  const double& n) const
-{
+CGAL::Gmpq
+KernelConverter<CGAL::Epick, CGAL::Cartesian<CGAL::Gmpq>>::operator()(
+    const double& n) const {
   return n;
 }
 
 template <>
 double KernelConverter<CGAL::Epick, CGAL_DoubleKernel>::operator()(
-  const double& n) const
-{
+    const double& n) const {
   return n;
 }
 
-} // namespace CGALUtils
+}  // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-mesh-edits.h b/src/geometry/cgal/cgalutils-mesh-edits.h
index f873597db..36227a673 100644
--- a/src/geometry/cgal/cgalutils-mesh-edits.h
+++ b/src/geometry/cgal/cgalutils-mesh-edits.h
@@ -1,4 +1,5 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #pragma once
 
 #include <CGAL/Polygon_mesh_processing/triangulate_faces.h>
@@ -17,10 +18,8 @@ namespace PMP = CGAL::Polygon_mesh_processing;
 
 /*! Buffer of changes to be applied to a triangle mesh. */
 template <typename TriangleMesh>
-class TriangleMeshEdits
-{
-
-private:
+class TriangleMeshEdits {
+ private:
   using GT = boost::graph_traits<TriangleMesh>;
   using face_descriptor = typename GT::face_descriptor;
   using halfedge_descriptor = typename GT::halfedge_descriptor;
@@ -32,42 +31,36 @@ private:
   std::vector<std::vector<vertex_descriptor>> facesToAdd;
   std::unordered_map<vertex_descriptor, vertex_descriptor> vertexReplacements;
 
-public:
-
+ public:
   bool isEmpty() {
-    return facesToRemove.empty() &&
-           verticesToRemove.empty() &&
-           facesToAdd.empty() &&
-           vertexReplacements.empty();
+    return facesToRemove.empty() && verticesToRemove.empty() &&
+           facesToAdd.empty() && vertexReplacements.empty();
   }
 
-  void removeFace(const face_descriptor& f) {
-    facesToRemove.insert(f);
-  }
+  void removeFace(const face_descriptor& f) { facesToRemove.insert(f); }
 
-  void removeVertex(const vertex_descriptor& v) {
-    verticesToRemove.insert(v);
-  }
+  void removeVertex(const vertex_descriptor& v) { verticesToRemove.insert(v); }
 
   void addFace(const std::vector<vertex_descriptor>& vertices) {
     facesToAdd.push_back(vertices);
   }
 
-  void replaceVertex(const vertex_descriptor& original, const vertex_descriptor& replacement) {
+  void replaceVertex(const vertex_descriptor& original,
+                     const vertex_descriptor& replacement) {
     vertexReplacements[original] = replacement;
   }
 
   static bool findCollapsibleVertices(
-    const std::vector<vertex_descriptor>& path,
-    const TriangleMesh& tm,
-    const std::function<void(size_t, vertex_descriptor)>& sinkFn) {
+      const std::vector<vertex_descriptor>& path,
+      const TriangleMesh& tm,
+      const std::function<void(size_t, vertex_descriptor)>& sinkFn) {
     if (path.size() <= 3) {
       return false;
     }
 
-    const auto *p1 = &tm.point(path[0]);
-    const auto *p2 = &tm.point(path[1]);
-    const auto *p3 = &tm.point(path[2]);
+    const auto* p1 = &tm.point(path[0]);
+    const auto* p2 = &tm.point(path[1]);
+    const auto* p3 = &tm.point(path[2]);
 
     for (size_t i = 0, n = path.size(); i < n; i++) {
       if (CGAL::are_ordered_along_line(*p1, *p2, *p3)) {
@@ -85,72 +78,80 @@ public:
 
   /*! Mutating in place is tricky, to say the least, so this creates a new mesh
    * and overwrites the original to it at the end for now. */
-  bool apply(TriangleMesh& src) const
-  {
+  bool apply(TriangleMesh& src) const {
     TriangleMesh copy;
     auto wasValid = CGAL::is_valid_polygon_mesh(src);
     auto wasClosed = CGAL::is_closed(src);
 
     auto edgesAdded = 0;
-    for (auto& vs : facesToAdd) edgesAdded += vs.size();
-
-    auto projectedVertexCount = src.number_of_vertices() - verticesToRemove.size();
-    auto projectedHalfedgeCount = src.number_of_halfedges() + edgesAdded * 2; // This is crude
-    auto projectedFaceCount = src.number_of_faces() - facesToRemove.size() + facesToAdd.size();
+    for (auto& vs : facesToAdd)
+      edgesAdded += vs.size();
+
+    auto projectedVertexCount =
+        src.number_of_vertices() - verticesToRemove.size();
+    auto projectedHalfedgeCount =
+        src.number_of_halfedges() + edgesAdded * 2;  // This is crude
+    auto projectedFaceCount =
+        src.number_of_faces() - facesToRemove.size() + facesToAdd.size();
     copy.reserve(copy.number_of_vertices() + projectedVertexCount,
                  copy.number_of_halfedges() + projectedHalfedgeCount,
                  copy.number_of_faces() + projectedFaceCount);
 
-    // TODO(ochafik): Speed up with a lookup vector : std::vector<vertex_descriptor> vertexMap(src.number_of_vertices());
+    // TODO(ochafik): Speed up with a lookup vector :
+    // std::vector<vertex_descriptor> vertexMap(src.number_of_vertices());
     std::unordered_map<vertex_descriptor, vertex_descriptor> vertexMap;
     vertexMap.reserve(projectedVertexCount);
 
     auto getDestinationVertex = [&](auto srcVertex) {
-        auto repIt = vertexReplacements.find(srcVertex);
-        if (repIt != vertexReplacements.end()) {
-          srcVertex = repIt->second;
-        }
-        auto it = vertexMap.find(srcVertex);
-        if (it == vertexMap.end()) {
-          auto v = copy.add_vertex(src.point(srcVertex));
-          vertexMap[srcVertex] = v;
-          return v;
-        }
-        return it->second;
-      };
+      auto repIt = vertexReplacements.find(srcVertex);
+      if (repIt != vertexReplacements.end()) {
+        srcVertex = repIt->second;
+      }
+      auto it = vertexMap.find(srcVertex);
+      if (it == vertexMap.end()) {
+        auto v = copy.add_vertex(src.point(srcVertex));
+        vertexMap[srcVertex] = v;
+        return v;
+      }
+      return it->second;
+    };
 
     std::vector<vertex_descriptor> polygon;
 
     auto addFace = [&](auto& polygon) {
-        auto face = copy.add_face(polygon);
-        if (face.is_valid()) {
-          if (polygon.size() > 3) {
-            PMP::triangulate_face(face, copy);
-          }
-          return true;
-        } else {
-          LOG(message_group::Warning, "Failed to add face with %1$lu vertices!", polygon.size());
-          return false;
+      auto face = copy.add_face(polygon);
+      if (face.is_valid()) {
+        if (polygon.size() > 3) {
+          PMP::triangulate_face(face, copy);
         }
-      };
+        return true;
+      } else {
+        LOG(message_group::Warning, "Failed to add face with %1$lu vertices!",
+            polygon.size());
+        return false;
+      }
+    };
     auto copyFace = [&](auto& f) {
-        polygon.clear();
-
-        CGAL::Vertex_around_face_iterator<TriangleMesh> vit, vend;
-        for (boost::tie(vit, vend) = vertices_around_face(src.halfedge(f), src); vit != vend; ++vit) {
-          auto v = *vit;
-          if (verticesToRemove.find(v) != verticesToRemove.end()) {
-            continue;
-          }
-          polygon.push_back(getDestinationVertex(v));
-        }
-        if (polygon.size() < 3) {
-          LOG(message_group::Warning, "Attempted to remove too many vertices around this copied face, remesh aborted!");
-          return false;
+      polygon.clear();
+
+      CGAL::Vertex_around_face_iterator<TriangleMesh> vit, vend;
+      for (boost::tie(vit, vend) = vertices_around_face(src.halfedge(f), src);
+           vit != vend; ++vit) {
+        auto v = *vit;
+        if (verticesToRemove.find(v) != verticesToRemove.end()) {
+          continue;
         }
+        polygon.push_back(getDestinationVertex(v));
+      }
+      if (polygon.size() < 3) {
+        LOG(message_group::Warning,
+            "Attempted to remove too many vertices around this copied face, "
+            "remesh aborted!");
+        return false;
+      }
 
-        return addFace(polygon);
-      };
+      return addFace(polygon);
+    };
 
     for (auto f : src.faces()) {
       if (src.is_removed(f)) {
@@ -174,7 +175,9 @@ public:
         polygon.push_back(getDestinationVertex(v));
       }
       if (polygon.size() < 3) {
-        LOG(message_group::Warning, "Attempted to remove too many vertices around this added face, remesh aborted!");
+        LOG(message_group::Warning,
+            "Attempted to remove too many vertices around this added face, "
+            "remesh aborted!");
         return false;
       }
       if (!addFace(polygon)) {
@@ -197,4 +200,4 @@ public:
   }
 };
 
-} // namespace CGALUtils
+}  // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-mesh.cc b/src/geometry/cgal/cgalutils-mesh.cc
index 4a5b208f5..0cfd3739f 100644
--- a/src/geometry/cgal/cgalutils-mesh.cc
+++ b/src/geometry/cgal/cgalutils-mesh.cc
@@ -1,28 +1,27 @@
 #include "geometry/cgal/cgalutils.h"
 
-#include <unordered_map>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <unordered_map>
 #include <vector>
 
-#include <boost/range/adaptor/transformed.hpp>
 #include <CGAL/Point_3.h>
-#include <CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h>
-#include <CGAL/boost/graph/graph_traits_Surface_mesh.h>
-#include <CGAL/Surface_mesh.h>
 #include <CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h>
 #include <CGAL/Polygon_mesh_processing/repair_polygon_soup.h>
+#include <CGAL/Surface_mesh.h>
+#include <CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h>
+#include <CGAL/boost/graph/graph_traits_Surface_mesh.h>
+#include <boost/range/adaptor/transformed.hpp>
 
+#include "geometry/PolySetBuilder.h"
 #include "geometry/cgal/cgal.h"
 #include "geometry/linalg.h"
-#include "geometry/PolySetBuilder.h"
 
 namespace CGALUtils {
 
 namespace PMP = CGAL::Polygon_mesh_processing;
 
-CGAL_DoubleMesh repairPolySet(const PolySet& ps)
-{
+CGAL_DoubleMesh repairPolySet(const PolySet& ps) {
   std::vector<CGAL_DoubleMesh::Point> points;
   std::vector<std::vector<size_t>> polygons;
 
@@ -47,36 +46,37 @@ CGAL_DoubleMesh repairPolySet(const PolySet& ps)
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet& ps)
-{
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet& ps) {
   auto mesh = std::make_shared<SurfaceMesh>();
   mesh->reserve(ps.vertices.size(), ps.indices.size() * 3, ps.indices.size());
   for (const auto& v : ps.vertices) {
     mesh->add_vertex(typename SurfaceMesh::Point(v[0], v[1], v[2]));
   }
   for (const auto& face : ps.indices) {
-    mesh->add_face(face | boost::adaptors::transformed([](uint32_t i){
-        return typename SurfaceMesh::Vertex_index(i);
-      }));
+    mesh->add_face(face | boost::adaptors::transformed([](uint32_t i) {
+                     return typename SurfaceMesh::Vertex_index(i);
+                   }));
   }
   return mesh;
 }
 
-template std::shared_ptr<CGAL_DoubleMesh> createSurfaceMeshFromPolySet<CGAL_DoubleMesh>(const PolySet& ps);
-template std::shared_ptr<CGAL_Kernel3Mesh> createSurfaceMeshFromPolySet(const PolySet& ps);
-
+template std::shared_ptr<CGAL_DoubleMesh>
+createSurfaceMeshFromPolySet<CGAL_DoubleMesh>(const PolySet& ps);
+template std::shared_ptr<CGAL_Kernel3Mesh> createSurfaceMeshFromPolySet(
+    const PolySet& ps);
 
 template <class SurfaceMesh>
-std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh)
-{
-  //  FIXME: We may want to convert directly, without PolySetBuilder here, to maintain manifoldness, if possible.
+std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh) {
+  //  FIXME: We may want to convert directly, without PolySetBuilder here, to
+  //  maintain manifoldness, if possible.
   PolySetBuilder builder(0, mesh.number_of_faces() + mesh.number_of_faces());
   for (const auto& f : mesh.faces()) {
     builder.beginPolygon(mesh.degree(f));
 
     CGAL::Vertex_around_face_iterator<SurfaceMesh> vbegin, vend;
-    for (boost::tie(vbegin, vend) = vertices_around_face(mesh.halfedge(f), mesh); vbegin != vend;
-         ++vbegin) {
+    for (boost::tie(vbegin, vend) =
+             vertices_around_face(mesh.halfedge(f), mesh);
+         vbegin != vend; ++vbegin) {
       auto& v = mesh.point(*vbegin);
       // for (auto &v : f) {
       double x = CGAL::to_double(v.x());
@@ -89,10 +89,8 @@ std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh)
 }
 
 template <class InputKernel, class OutputKernel>
-void copyMesh(
-  const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>& input,
-  CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>& output)
-{
+void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>& input,
+              CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>& output) {
   using InputMesh = CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>;
   using OutputMesh = CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>;
 
@@ -101,14 +99,20 @@ void copyMesh(
                  output.number_of_halfedges() + input.number_of_halfedges(),
                  output.number_of_faces() + input.number_of_faces());
 
-  std::vector<typename CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>::Vertex_index> polygon;
-  std::unordered_map<typename InputMesh::Vertex_index, typename OutputMesh::Vertex_index> reindexer;
+  std::vector<
+      typename CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>::Vertex_index>
+      polygon;
+  std::unordered_map<typename InputMesh::Vertex_index,
+                     typename OutputMesh::Vertex_index>
+      reindexer;
   for (auto face : input.faces()) {
     polygon.clear();
 
-    CGAL::Vertex_around_face_iterator<typename CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>>
-    vbegin, vend;
-    for (boost::tie(vbegin, vend) = vertices_around_face(input.halfedge(face), input);
+    CGAL::Vertex_around_face_iterator<
+        typename CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>>
+        vbegin, vend;
+    for (boost::tie(vbegin, vend) =
+             vertices_around_face(input.halfedge(face), input);
          vbegin != vend; ++vbegin) {
       auto input_vertex = *vbegin;
       auto size_before = reindexer.size();
@@ -122,7 +126,8 @@ void copyMesh(
   }
 }
 
-template void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& input, CGAL_DoubleMesh& output);
-
+template void copyMesh(
+    const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& input,
+    CGAL_DoubleMesh& output);
 
-} // namespace CGALUtils
+}  // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-orient.cc b/src/geometry/cgal/cgalutils-orient.cc
index 92f67421a..8cc56ec7e 100644
--- a/src/geometry/cgal/cgalutils-orient.cc
+++ b/src/geometry/cgal/cgalutils-orient.cc
@@ -1,4 +1,5 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/cgal/cgalutils.h"
 
 #include <CGAL/Polygon_mesh_processing/orientation.h>
@@ -7,12 +8,10 @@
 namespace CGALUtils {
 
 template <typename SurfaceMesh>
-void orientToBoundAVolume(SurfaceMesh& mesh)
-{
+void orientToBoundAVolume(SurfaceMesh& mesh) {
   CGAL::Polygon_mesh_processing::orient_to_bound_a_volume(mesh);
 }
 
 template void orientToBoundAVolume(CGAL_DoubleMesh& polyhedron);
 
-} // namespace CGALUtils
-
+}  // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-polyhedron.cc b/src/geometry/cgal/cgalutils-polyhedron.cc
index 08d1b2704..a742dfcff 100644
--- a/src/geometry/cgal/cgalutils-polyhedron.cc
+++ b/src/geometry/cgal/cgalutils-polyhedron.cc
@@ -2,43 +2,46 @@
 #include "geometry/cgal/cgalutils.h"
 
 #include <algorithm>
+#include <cstddef>
 #include <iterator>
-#include <ostream>
 #include <memory>
-#include <cstddef>
+#include <ostream>
 #include <vector>
 
-#include <boost/range/adaptor/reversed.hpp>
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
 #include <CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h>
+#include <boost/range/adaptor/reversed.hpp>
 
-#include "geometry/linalg.h"
+#include "geometry/Grid.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
-#include "geometry/Grid.h"
 
 #undef GEN_SURFACE_DEBUG
 namespace /* anonymous */ {
 
 template <typename Polyhedron>
-class CGAL_Build_PolySet : public CGAL::Modifier_base<typename Polyhedron::HalfedgeDS>
-{
+class CGAL_Build_PolySet
+    : public CGAL::Modifier_base<typename Polyhedron::HalfedgeDS> {
   using HDS = typename Polyhedron::HalfedgeDS;
-  using CGAL_Polybuilder = CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
-public:
+  using CGAL_Polybuilder =
+      CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
+
+ public:
   using CGALPoint = typename CGAL_Polybuilder::Point_3;
 
   const PolySet& ps;
-  CGAL_Build_PolySet(const PolySet& ps) : ps(ps) { }
+  CGAL_Build_PolySet(const PolySet& ps) : ps(ps) {}
 
 /*
    Using Grid here is important for performance reasons. See following model.
-   If we don't grid the geometry before converting to a Nef Polyhedron, the quads
-   in the cylinders to tessellated into triangles since floating point
-   incertainty causes the faces to not be 100% planar. The incertainty is exaggerated
-   by the transform. This wasn't a problem earlier since we used Nef for everything,
-   but optimizations since then has made us keep it in floating point space longer.
+   If we don't grid the geometry before converting to a Nef Polyhedron, the
+   quads in the cylinders to tessellated into triangles since floating point
+   incertainty causes the faces to not be 100% planar. The incertainty is
+   exaggerated by the transform. This wasn't a problem earlier since we used Nef
+   for everything, but optimizations since then has made us keep it in floating
+   point space longer.
 
    minkowski() {
    cube([200, 50, 7], center = true);
@@ -46,7 +49,7 @@ public:
    rotate([0,90,0]) cylinder($fn = 8, h = 1, r = 8.36, center = true);
    }
  */
-#if 1 // Use Grid
+#if 1  // Use Grid
   void operator()(HDS& hds) override {
     CGAL_Polybuilder B(hds, true);
 
@@ -80,23 +83,28 @@ public:
     }
     for (auto& pindices : indices) {
 #ifdef GEN_SURFACE_DEBUG
-      if (pidx++ > 0) printf(",");
+      if (pidx++ > 0)
+        printf(",");
 #endif
 
       // We remove duplicate indices since there is a bug in CGAL's
-      // Polyhedron_incremental_builder_3::test_facet() which fails to detect this
+      // Polyhedron_incremental_builder_3::test_facet() which fails to detect
+      // this
       auto last = std::unique(pindices.begin(), pindices.end());
       std::advance(last, -1);
-      if (*last != pindices.front()) last++; // In case the first & last are equal
+      if (*last != pindices.front())
+        last++;  // In case the first & last are equal
       pindices.erase(last, pindices.end());
-      if (pindices.size() >= 3 && B.test_facet(pindices.begin(), pindices.end())) {
+      if (pindices.size() >= 3 &&
+          B.test_facet(pindices.begin(), pindices.end())) {
         B.add_facet(pindices.begin(), pindices.end());
       }
 #ifdef GEN_SURFACE_DEBUG
       printf("[");
       int fidx = 0;
       for (auto i : boost::adaptors::reverse(pindices)) {
-        if (fidx++ > 0) printf(",");
+        if (fidx++ > 0)
+          printf(",");
         printf("%ld", i);
       }
       printf("]");
@@ -109,16 +117,17 @@ public:
 #ifdef GEN_SURFACE_DEBUG
     printf("points=[");
     for (std::size_t i = 0; i < vertices.size(); ++i) {
-      if (i > 0) printf(",");
+      if (i > 0)
+        printf(",");
       const CGALPoint& p = vertices[i];
-      printf("[%g,%g,%g]", CGAL::to_double(p.x()), CGAL::to_double(p.y()), CGAL::to_double(p.z()));
+      printf("[%g,%g,%g]", CGAL::to_double(p.x()), CGAL::to_double(p.y()),
+             CGAL::to_double(p.z()));
     }
     printf("]);\n");
 #endif
   }
-#else // Don't use Grid
-  void operator()(HDS& hds)
-  {
+#else  // Don't use Grid
+  void operator()(HDS& hds) {
     CGAL_Polybuilder B(hds, true);
     Reindexer<Vector3d> vertices;
     std::vector<size_t> indices(3);
@@ -131,14 +140,16 @@ public:
 #endif
     for (const auto& p : ps.indices) {
 #ifdef GEN_SURFACE_DEBUG
-      if (pidx++ > 0) printf(",");
+      if (pidx++ > 0)
+        printf(",");
 #endif
       indices.clear();
-      for (const auto& v: boost::adaptors::reverse(p)) {
+      for (const auto& v : boost::adaptors::reverse(p)) {
         size_t s = vertices.size();
         size_t idx = vertices.lookup(v);
         // If we added a vertex, also add it to the CGAL builder
-        if (idx == s) B.add_vertex(CGALPoint(v[0], v[1], v[2]));
+        if (idx == s)
+          B.add_vertex(CGALPoint(v[0], v[1], v[2]));
         indices.push_back(idx);
       }
       // We perform this test since there is a bug in CGAL's
@@ -160,7 +171,8 @@ public:
         printf("[");
         int fidx = 0;
         for (auto i : indices) {
-          if (fidx++ > 0) printf(",");
+          if (fidx++ > 0)
+            printf(",");
           printf("%ld", i);
         }
         printf("]");
@@ -173,41 +185,45 @@ public:
 
     printf("points=[");
     for (std::size_t vidx = 0; vidx < vertices.size(); ++vidx) {
-      if (vidx > 0) printf(",");
+      if (vidx > 0)
+        printf(",");
       const Vector3d& v = vertices.getArray()[vidx];
       printf("[%g,%g,%g]", v[0], v[1], v[2]);
     }
     printf("]);\n");
 #endif
   }
-#endif // if 1
+#endif  // if 1
 };
 
 template <class InputKernel, class OutputKernel>
-struct Copy_polyhedron_to : public CGAL::Modifier_base<typename CGAL::Polyhedron_3<OutputKernel>::HalfedgeDS>
-{
+struct Copy_polyhedron_to
+    : public CGAL::Modifier_base<
+          typename CGAL::Polyhedron_3<OutputKernel>::HalfedgeDS> {
   using Polyhedron_output = CGAL::Polyhedron_3<OutputKernel>;
   using Polyhedron_input = CGAL::Polyhedron_3<InputKernel>;
 
   Copy_polyhedron_to(const Polyhedron_input& in_poly) : in_poly(in_poly) {}
 
-  void operator()(typename Polyhedron_output::HalfedgeDS& out_hds) override
-  {
+  void operator()(typename Polyhedron_output::HalfedgeDS& out_hds) override {
     using Output_HDS = typename Polyhedron_output::HalfedgeDS;
 
     CGAL::Polyhedron_incremental_builder_3<Output_HDS> builder(out_hds);
 
-    using Vertex_const_iterator = typename Polyhedron_input::Vertex_const_iterator;
-    using Facet_const_iterator = typename Polyhedron_input::Facet_const_iterator;
-    using HFCC = typename Polyhedron_input::Halfedge_around_facet_const_circulator;
+    using Vertex_const_iterator =
+        typename Polyhedron_input::Vertex_const_iterator;
+    using Facet_const_iterator =
+        typename Polyhedron_input::Facet_const_iterator;
+    using HFCC =
+        typename Polyhedron_input::Halfedge_around_facet_const_circulator;
 
-    builder.begin_surface(in_poly.size_of_vertices(),
-                          in_poly.size_of_facets(),
+    builder.begin_surface(in_poly.size_of_vertices(), in_poly.size_of_facets(),
                           in_poly.size_of_halfedges());
 
-    auto converter = CGALUtils::getCartesianConverter<InputKernel, OutputKernel>();
-    for (Vertex_const_iterator
-         vi = in_poly.vertices_begin(), end = in_poly.vertices_end();
+    auto converter =
+        CGALUtils::getCartesianConverter<InputKernel, OutputKernel>();
+    for (Vertex_const_iterator vi = in_poly.vertices_begin(),
+                               end = in_poly.vertices_end();
          vi != end; ++vi) {
       typename Polyhedron_output::Point_3 p(converter(vi->point().x()),
                                             converter(vi->point().y()),
@@ -218,8 +234,8 @@ struct Copy_polyhedron_to : public CGAL::Modifier_base<typename CGAL::Polyhedron
     using Index = CGAL::Inverse_index<Vertex_const_iterator>;
     Index index(in_poly.vertices_begin(), in_poly.vertices_end());
 
-    for (Facet_const_iterator
-         fi = in_poly.facets_begin(), end = in_poly.facets_end();
+    for (Facet_const_iterator fi = in_poly.facets_begin(),
+                              end = in_poly.facets_end();
          fi != end; ++fi) {
       HFCC hc = fi->facet_begin();
       HFCC hc_end = hc;
@@ -233,73 +249,76 @@ struct Copy_polyhedron_to : public CGAL::Modifier_base<typename CGAL::Polyhedron
       builder.end_facet();
     }
     builder.end_surface();
-  } // end operator()(..)
-private:
+  }  // end operator()(..)
+ private:
   const Polyhedron_input& in_poly;
-};   // end Copy_polyhedron_to<>
+};  // end Copy_polyhedron_to<>
 
-} // namespace
+}  // namespace
 
 namespace CGALUtils {
 
 template <class InputKernel, class OutputKernel>
-void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel>& poly_a, CGAL::Polyhedron_3<OutputKernel>& poly_b)
-{
+void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel>& poly_a,
+                    CGAL::Polyhedron_3<OutputKernel>& poly_b) {
   // Copy is also used in "append" cases.
-  poly_b.reserve(
-    poly_b.size_of_vertices() + poly_a.size_of_vertices(),
-    poly_b.size_of_halfedges() + poly_a.size_of_halfedges(),
-    poly_b.size_of_facets() + poly_a.size_of_facets());
+  poly_b.reserve(poly_b.size_of_vertices() + poly_a.size_of_vertices(),
+                 poly_b.size_of_halfedges() + poly_a.size_of_halfedges(),
+                 poly_b.size_of_facets() + poly_a.size_of_facets());
 
   Copy_polyhedron_to<InputKernel, OutputKernel> modifier(poly_a);
   poly_b.delegate(modifier);
 }
 
-template void copyPolyhedron<CGAL::Epick, CGAL_Kernel3>(const CGAL::Polyhedron_3<CGAL::Epick>&, CGAL_Polyhedron&);
-template void copyPolyhedron<CGAL_Kernel3, CGAL::Epick>(const CGAL_Polyhedron&, CGAL::Polyhedron_3<CGAL::Epick>&);
+template void copyPolyhedron<CGAL::Epick, CGAL_Kernel3>(
+    const CGAL::Polyhedron_3<CGAL::Epick>&,
+    CGAL_Polyhedron&);
+template void copyPolyhedron<CGAL_Kernel3, CGAL::Epick>(
+    const CGAL_Polyhedron&,
+    CGAL::Polyhedron_3<CGAL::Epick>&);
 
 template <typename K>
-void convertNefToPolyhedron(
-  const CGAL::Nef_polyhedron_3<K>& nef, CGAL::Polyhedron_3<K>& polyhedron)
-{
+void convertNefToPolyhedron(const CGAL::Nef_polyhedron_3<K>& nef,
+                            CGAL::Polyhedron_3<K>& polyhedron) {
   nef.convert_to_polyhedron(polyhedron);
 }
 
-template void convertNefToPolyhedron(const CGAL_Nef_polyhedron3& nef, CGAL_Polyhedron& polyhedron);
+template void convertNefToPolyhedron(const CGAL_Nef_polyhedron3& nef,
+                                     CGAL_Polyhedron& polyhedron);
 
 template <typename SurfaceMesh>
-void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3& nef, SurfaceMesh& mesh)
-{
+void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3& nef,
+                             SurfaceMesh& mesh) {
   constexpr bool triangulate = false;
   CGAL::convert_nef_polyhedron_to_polygon_mesh(nef, mesh, triangulate);
 }
 
-void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh& mesh, CGAL_Nef_polyhedron3& nef)
-{
+void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh& mesh,
+                             CGAL_Nef_polyhedron3& nef) {
   nef = CGAL_Nef_polyhedron3(mesh);
 }
 
-
 template <typename Polyhedron>
-bool createPolyhedronFromPolySet(const PolySet& ps, Polyhedron& p)
-{
+bool createPolyhedronFromPolySet(const PolySet& ps, Polyhedron& p) {
   bool err = false;
   try {
     CGAL_Build_PolySet<Polyhedron> builder(ps);
     p.delegate(builder);
   } catch (const CGAL::Assertion_exception& e) {
-    LOG(message_group::Error, "CGAL error in CGALUtils::createPolyhedronFromPolySet: %1$s", e.what());
+    LOG(message_group::Error,
+        "CGAL error in CGALUtils::createPolyhedronFromPolySet: %1$s", e.what());
     err = true;
   }
   return err;
 }
 
-template bool createPolyhedronFromPolySet(const PolySet& ps, CGAL_Polyhedron& p);
-template bool createPolyhedronFromPolySet(const PolySet& ps, CGAL::Polyhedron_3<CGAL::Epick>& p);
+template bool createPolyhedronFromPolySet(const PolySet& ps,
+                                          CGAL_Polyhedron& p);
+template bool createPolyhedronFromPolySet(const PolySet& ps,
+                                          CGAL::Polyhedron_3<CGAL::Epick>& p);
 
 template <typename Polyhedron>
-std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p)
-{
+std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p) {
   using Vertex = typename Polyhedron::Vertex;
   using FCI = typename Polyhedron::Facet_const_iterator;
   using HFCC = typename Polyhedron::Halfedge_around_facet_const_circulator;
@@ -321,15 +340,17 @@ std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p)
   return builder.build();
 }
 
-template std::unique_ptr<PolySet> createPolySetFromPolyhedron(const CGAL_Polyhedron& p);
-template std::unique_ptr<PolySet> createPolySetFromPolyhedron(const CGAL::Polyhedron_3<CGAL::Epick>& p);
+template std::unique_ptr<PolySet> createPolySetFromPolyhedron(
+    const CGAL_Polyhedron& p);
+template std::unique_ptr<PolySet> createPolySetFromPolyhedron(
+    const CGAL::Polyhedron_3<CGAL::Epick>& p);
 
-class Polyhedron_writer
-{
-  std::ostream *out{nullptr};
+class Polyhedron_writer {
+  std::ostream* out{nullptr};
   bool firstv{true};
   std::vector<int> indices;
-public:
+
+ public:
   Polyhedron_writer() = default;
   void write_header(std::ostream& stream,
                     std::size_t /*vertices*/,
@@ -340,9 +361,7 @@ public:
     *out << "polyhedron(points=[";
     firstv = true;
   }
-  void write_footer() {
-    *out << "]);" << std::endl;
-  }
+  void write_footer() { *out << "]);" << std::endl; }
   void write_vertex(const double& x, const double& y, const double& z) {
     *out << (firstv ? "" : ",") << '[' << x << ',' << y << ',' << z << ']';
     firstv = false;
@@ -356,9 +375,7 @@ public:
     indices.clear();
     firstv = false;
   }
-  void write_facet_vertex_index(std::size_t index) {
-    indices.push_back(index);
-  }
+  void write_facet_vertex_index(std::size_t index) { indices.push_back(index); }
   void write_facet_end() {
     bool firsti = true;
     for (auto i : boost::adaptors::reverse(indices)) {
diff --git a/src/geometry/cgal/cgalutils-project.cc b/src/geometry/cgal/cgalutils-project.cc
index ab31eb4a2..bacf36dc7 100644
--- a/src/geometry/cgal/cgalutils-project.cc
+++ b/src/geometry/cgal/cgalutils-project.cc
@@ -3,17 +3,17 @@
 
 #ifdef ENABLE_CGAL
 
+#include "geometry/PolySet.h"
+#include "geometry/PolySetUtils.h"
+#include "geometry/Polygon2d.h"
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
-#include "geometry/PolySet.h"
 #include "utils/printutils.h"
-#include "geometry/Polygon2d.h"
-#include "geometry/PolySetUtils.h"
 
-#include <memory>
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
-#include <CGAL/normal_vector_newell_3.h>
 #include <CGAL/Handle_hash_function.h>
+#include <CGAL/normal_vector_newell_3.h>
+#include <memory>
 
 #include <CGAL/config.h>
 #include <CGAL/version.h>
@@ -24,18 +24,20 @@
 
 #include <vector>
 
-static void add_outline_to_poly(CGAL_Nef_polyhedron2::Explorer& explorer,
-                                CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator circ,
-                                CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator end,
-                                bool positive,
-                                Polygon2d& poly) {
+static void add_outline_to_poly(
+    CGAL_Nef_polyhedron2::Explorer& explorer,
+    CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator circ,
+    CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator end,
+    bool positive,
+    Polygon2d& poly) {
   Outline2d outline;
 
   CGAL_For_all(circ, end) {
     if (explorer.is_standard(explorer.target(circ))) {
-      CGAL_Nef_polyhedron2::Explorer::Point ep = explorer.point(explorer.target(circ));
-      outline.vertices.push_back(Vector2d(to_double(ep.x()),
-                                          to_double(ep.y())));
+      CGAL_Nef_polyhedron2::Explorer::Point ep =
+          explorer.point(explorer.target(circ));
+      outline.vertices.push_back(
+          Vector2d(to_double(ep.x()), to_double(ep.y())));
     }
   }
 
@@ -45,20 +47,26 @@ static void add_outline_to_poly(CGAL_Nef_polyhedron2::Explorer& explorer,
   }
 }
 
-static std::unique_ptr<Polygon2d> convertToPolygon2d(const CGAL_Nef_polyhedron2& p2)
-{
+static std::unique_ptr<Polygon2d> convertToPolygon2d(
+    const CGAL_Nef_polyhedron2& p2) {
   auto poly = std::make_unique<Polygon2d>();
 
   using Explorer = CGAL_Nef_polyhedron2::Explorer;
   using fci_t = Explorer::Face_const_iterator;
   using heafcc_t = Explorer::Halfedge_around_face_const_circulator;
   Explorer E = p2.explorer();
-  for (fci_t fit = E.faces_begin(), facesend = E.faces_end(); fit != facesend; ++fit) {
-    if (!fit->mark()) continue;
+  for (fci_t fit = E.faces_begin(), facesend = E.faces_end(); fit != facesend;
+       ++fit) {
+    if (!fit->mark())
+      continue;
     heafcc_t fcirc(E.face_cycle(fit)), fend(fcirc);
     add_outline_to_poly(E, fcirc, fend, true, *poly);
-    for (CGAL_Nef_polyhedron2::Explorer::Hole_const_iterator j = E.holes_begin(fit); j != E.holes_end(fit); ++j) {
-      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator hcirc(j), hend(hcirc);
+    for (CGAL_Nef_polyhedron2::Explorer::Hole_const_iterator j =
+             E.holes_begin(fit);
+         j != E.holes_end(fit); ++j) {
+      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator
+          hcirc(j),
+          hend(hcirc);
       add_outline_to_poly(E, hcirc, hend, false, *poly);
     }
   }
@@ -94,15 +102,13 @@ static std::unique_ptr<Polygon2d> convertToPolygon2d(const CGAL_Nef_polyhedron2&
    OGL_helper.h
  */
 
-class ZRemover
-{
-public:
+class ZRemover {
+ public:
   CGAL_Nef_polyhedron2::Boundary boundary;
   std::shared_ptr<CGAL_Nef_polyhedron2> tmpnef2d;
   std::shared_ptr<CGAL_Nef_polyhedron2> output_nefpoly2d;
   CGAL::Direction_3<CGAL_Kernel3> up;
-  ZRemover()
-  {
+  ZRemover() {
     output_nefpoly2d = std::make_shared<CGAL_Nef_polyhedron2>();
     boundary = CGAL_Nef_polyhedron2::INCLUDED;
     up = CGAL::Direction_3<CGAL_Kernel3>(0, 0, 1);
@@ -115,9 +121,7 @@ public:
   void visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet);
 };
 
-
-void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
-{
+void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet) {
   PRINTDB(" <!-- ZRemover Halffacet visit. Mark: %i --> ", hfacet->mark());
   if (hfacet->plane().orthogonal_direction() != this->up) {
     PRINTD("  <!-- ZRemover down-facing half-facet. skipping -->");
@@ -132,25 +136,32 @@ void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
   CGAL_forall_facet_cycles_of(fci, hfacet) {
     if (fci.is_shalfedge()) {
       PRINTD(" <!-- ZRemover Halffacet cycle begin -->");
-      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(fci), cend(c1);
+      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(fci),
+          cend(c1);
       std::vector<CGAL_Nef_polyhedron2::Explorer::Point> contour;
       CGAL_For_all(c1, cend) {
         CGAL_Nef_polyhedron3::Point_3 point3d = c1->source()->target()->point();
-        CGAL_Nef_polyhedron2::Explorer::Point point2d(CGAL::to_double(point3d.x()),
-                                                      CGAL::to_double(point3d.y()));
+        CGAL_Nef_polyhedron2::Explorer::Point point2d(
+            CGAL::to_double(point3d.x()), CGAL::to_double(point3d.y()));
         contour.push_back(point2d);
       }
-      if (contour.size() == 0) continue;
+      if (contour.size() == 0)
+        continue;
 
-      if (OpenSCAD::debug != "") PRINTDB(" <!-- is_simple_2: %i -->", CGAL::is_simple_2(contour.begin(), contour.end()));
+      if (OpenSCAD::debug != "")
+        PRINTDB(" <!-- is_simple_2: %i -->",
+                CGAL::is_simple_2(contour.begin(), contour.end()));
 
-      tmpnef2d = std::make_shared<CGAL_Nef_polyhedron2>(contour.begin(), contour.end(), boundary);
+      tmpnef2d = std::make_shared<CGAL_Nef_polyhedron2>(
+          contour.begin(), contour.end(), boundary);
 
       if (contour_counter == 0) {
-        PRINTDB(" <!-- contour is a body. make union(). %i points -->", contour.size());
+        PRINTDB(" <!-- contour is a body. make union(). %i points -->",
+                contour.size());
         *(output_nefpoly2d) += *(tmpnef2d);
       } else {
-        PRINTDB(" <!-- contour is a hole. make intersection(). %i points -->", contour.size());
+        PRINTDB(" <!-- contour is a hole. make intersection(). %i points -->",
+                contour.size());
         *(output_nefpoly2d) *= *(tmpnef2d);
       }
 
@@ -168,20 +179,20 @@ void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
   PRINTD(" <!-- ZRemover Halffacet visit end -->");
 }
 
-
-
 namespace CGALUtils {
 
-std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
-{
+std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut) {
   std::unique_ptr<Polygon2d> poly;
-  if (N.getDimension() != 3) return poly;
+  if (N.getDimension() != 3)
+    return poly;
 
   CGALNefGeometry newN;
   if (cut) {
     try {
-      CGAL_Nef_polyhedron3::Plane_3 xy_plane = CGAL_Nef_polyhedron3::Plane_3(0, 0, 1, 0);
-      newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(N.p3->intersection(xy_plane, CGAL_Nef_polyhedron3::PLANE_ONLY));
+      CGAL_Nef_polyhedron3::Plane_3 xy_plane =
+          CGAL_Nef_polyhedron3::Plane_3(0, 0, 1, 0);
+      newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(
+          N.p3->intersection(xy_plane, CGAL_Nef_polyhedron3::PLANE_ONLY));
     } catch (const CGAL::Failure_exception& e) {
       PRINTDB("CGALUtils::project during plane intersection: %s", e.what());
       try {
@@ -191,17 +202,21 @@ std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
         double inf = 1e8;
         double eps = 0.001;
         CGAL_Point_3 minpt(-inf, -inf, -eps);
-        CGAL_Point_3 maxpt(inf,  inf,  eps);
+        CGAL_Point_3 maxpt(inf, inf, eps);
         CGAL_Iso_cuboid_3 bigcuboid(minpt, maxpt);
         pts.reserve(8);
-        for (int i = 0; i < 8; ++i) pts.push_back(bigcuboid.vertex(i));
+        for (int i = 0; i < 8; ++i)
+          pts.push_back(bigcuboid.vertex(i));
         CGAL_Polyhedron bigbox;
         CGAL::convex_hull_3(pts.begin(), pts.end(), bigbox);
         CGAL_Nef_polyhedron3 nef_bigbox(bigbox);
-        newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(nef_bigbox.intersection(*N.p3));
+        newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(
+            nef_bigbox.intersection(*N.p3));
       } catch (const CGAL::Failure_exception& e) {
-        LOG(message_group::Error, " CGAL error in CGALUtils::project during bigbox intersection: %1$s", e.what());
-
+        LOG(message_group::Error,
+            " CGAL error in CGALUtils::project during bigbox intersection: "
+            "%1$s",
+            e.what());
       }
     }
 
@@ -228,12 +243,14 @@ std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
       }
       poly = convertToPolygon2d(*zremover.output_nefpoly2d);
     } catch (const CGAL::Failure_exception& e) {
-      LOG(message_group::Error, "CGAL error in CGALUtils::project while flattening: %1$s", e.what());
+      LOG(message_group::Error,
+          "CGAL error in CGALUtils::project while flattening: %1$s", e.what());
     }
     PRINTD("</svg>");
 
   }
-  // In projection mode all the triangles are projected manually into the XY plane
+  // In projection mode all the triangles are projected manually into the XY
+  // plane
   else {
     if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*N.p3)) {
       poly = PolySetUtils::project(*ps);
@@ -245,6 +262,6 @@ std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
   return poly;
 }
 
-} // namespace
+}  // namespace CGALUtils
 
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
diff --git a/src/geometry/cgal/cgalutils-tess.cc b/src/geometry/cgal/cgalutils-tess.cc
index 7761a433c..ea4af0c3a 100644
--- a/src/geometry/cgal/cgalutils-tess.cc
+++ b/src/geometry/cgal/cgalutils-tess.cc
@@ -1,15 +1,16 @@
+#include <cstddef>
+#include <list>
 #include "geometry/cgal/cgalutils.h"
 #include "utils/printutils.h"
-#include <list>
-#include <cstddef>
-//#include "geometry/cgal/cgal.h"
-//#include "libtess2/Source/tess.h"
+// #include "geometry/cgal/cgal.h"
+// #include "libtess2/Source/tess.h"
 
 #include <CGAL/Constrained_Delaunay_triangulation_2.h>
 #if CGAL_VERSION_NR < CGAL_VERSION_NUMBER(5, 4, 0)
 #include <CGAL/Triangulation_2_projection_traits_3.h>
 using Tess_kernel = CGAL::Epick;
-using Projection = CGAL::Triangulation_2_filtered_projection_traits_3<Tess_kernel>;
+using Projection =
+    CGAL::Triangulation_2_filtered_projection_traits_3<Tess_kernel>;
 #else
 #include <CGAL/Projection_traits_3.h>
 using Tess_kernel = CGAL::Epick;
@@ -23,16 +24,20 @@ struct FaceInfo {
 };
 
 using Fbb = CGAL::Triangulation_face_base_with_info_2<FaceInfo, Tess_kernel>;
-using Tds = CGAL::Triangulation_data_structure_2<CGAL::Triangulation_vertex_base_2<Projection>, CGAL::Constrained_triangulation_face_base_2<Projection, Fbb>>;
-using CDT = CGAL::Constrained_Delaunay_triangulation_2<Projection, Tds, CGAL::Exact_predicates_tag>;
-
+using Tds = CGAL::Triangulation_data_structure_2<
+    CGAL::Triangulation_vertex_base_2<Projection>,
+    CGAL::Constrained_triangulation_face_base_2<Projection, Fbb>>;
+using CDT =
+    CGAL::Constrained_Delaunay_triangulation_2<Projection,
+                                               Tds,
+                                               CGAL::Exact_predicates_tag>;
 
 static void mark_domains(CDT& ct,
                          CDT::Face_handle start,
                          int index,
-                         std::list<CDT::Edge>& border)
-{
-  if (start->info().nesting_level != -1) return;
+                         std::list<CDT::Edge>& border) {
+  if (start->info().nesting_level != -1)
+    return;
   std::list<CDT::Face_handle> queue;
   queue.push_back(start);
   while (!queue.empty()) {
@@ -44,24 +49,25 @@ static void mark_domains(CDT& ct,
         CDT::Edge e(fh, i);
         CDT::Face_handle n = fh->neighbor(i);
         if (n->info().nesting_level == -1) {
-          if (ct.is_constrained(e)) border.push_back(e);
-          else queue.push_back(n);
+          if (ct.is_constrained(e))
+            border.push_back(e);
+          else
+            queue.push_back(n);
         }
       }
     }
   }
 }
 
-
-//explore set of facets connected with non constrained edges,
-//and attribute to each such set a nesting level.
-//We start from facets incident to the infinite vertex, with a nesting
-//level of 0. Then we recursively consider the non-explored facets incident
-//to constrained edges bounding the former set and increase the nesting level by 1.
-//Facets in the domain are those with an odd nesting level.
-static void mark_domains(CDT& cdt)
-{
-  for (CDT::All_faces_iterator it = cdt.all_faces_begin(); it != cdt.all_faces_end(); ++it) {
+// explore set of facets connected with non constrained edges,
+// and attribute to each such set a nesting level.
+// We start from facets incident to the infinite vertex, with a nesting
+// level of 0. Then we recursively consider the non-explored facets incident
+// to constrained edges bounding the former set and increase the nesting level
+// by 1. Facets in the domain are those with an odd nesting level.
+static void mark_domains(CDT& cdt) {
+  for (CDT::All_faces_iterator it = cdt.all_faces_begin();
+       it != cdt.all_faces_end(); ++it) {
     it->info().nesting_level = -1;
   }
   std::list<CDT::Edge> border;
@@ -82,30 +88,34 @@ namespace CGALUtils {
    should be added as a separate PolygonK instance.
    The tessellator will handle almost planar polygons.
 
-   If the normal is given, we will assume this as the normal vector of the polygon.
-   Otherwise, we will try to calculate it using Newell's method.
+   If the normal is given, we will assume this as the normal vector of the
+   polygon. Otherwise, we will try to calculate it using Newell's method.
 
    The resulting triangles is added to the given triangles vector.
  */
-bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>>& polygons,
-                                Polygons& triangles,
-                                const CGAL::Vector_3<CGAL::Epick> *normal)
-{
+bool tessellatePolygonWithHoles(
+    const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>>& polygons,
+    Polygons& triangles,
+    const CGAL::Vector_3<CGAL::Epick>* normal) {
   // No polygon. FIXME: Will this ever happen or can we assert here?
-  if (polygons.empty()) return false;
+  if (polygons.empty())
+    return false;
 
   // No hole
-  if (polygons.size() == 1) return tessellatePolygon(polygons.front(), triangles, normal);
+  if (polygons.size() == 1)
+    return tessellatePolygon(polygons.front(), triangles, normal);
 
   CGAL::Vector_3<CGAL::Epick> normalvec;
   if (normal) {
     normalvec = *normal;
   } else {
     // Calculate best guess at face normal using Newell's method
-    CGAL::normal_vector_newell_3(polygons.front().begin(), polygons.front().end(), normalvec);
+    CGAL::normal_vector_newell_3(polygons.front().begin(),
+                                 polygons.front().end(), normalvec);
   }
   double sqrl = normalvec.squared_length();
-  if (sqrl > 0.0) normalvec = normalvec / sqrt(sqrl);
+  if (sqrl > 0.0)
+    normalvec = normalvec / sqrt(sqrl);
 
   // Pass the normal vector to the (undocumented)
   // CGAL::Triangulation_2_filtered_projection_traits_3. This
@@ -120,7 +130,7 @@ bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL
     }
   }
 
-  //Mark facets that are inside the domain bounded by the polygon
+  // Mark facets that are inside the domain bounded by the polygon
   mark_domains(cdt);
 
   // Iterate over the resulting faces
@@ -141,8 +151,7 @@ bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL
 
 bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
                        Polygons& triangles,
-                       const CGAL::Vector_3<CGAL::Epick> *normal)
-{
+                       const CGAL::Vector_3<CGAL::Epick>* normal) {
   if (polygon.size() == 3) {
     PRINTD("input polygon has 3 points. shortcut tessellation.");
     Polygon t;
@@ -161,7 +170,8 @@ bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
     CGAL::normal_vector_newell_3(polygon.begin(), polygon.end(), normalvec);
   }
   double sqrl = normalvec.squared_length();
-  if (sqrl > 0.0) normalvec = normalvec / sqrt(sqrl);
+  if (sqrl > 0.0)
+    normalvec = normalvec / sqrt(sqrl);
 
   // Pass the normal vector to the (undocumented)
   // CGAL::Triangulation_2_filtered_projection_traits_3. This
@@ -174,7 +184,7 @@ bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
     cdt.insert_constraint(polygon[i], polygon[(i + 1) % polygon.size()]);
   }
 
-  //Mark facets that are inside the domain bounded by the polygon
+  // Mark facets that are inside the domain bounded by the polygon
   mark_domains(cdt);
 
   // Iterate over the resulting faces
diff --git a/src/geometry/cgal/cgalutils-triangulate.cc b/src/geometry/cgal/cgalutils-triangulate.cc
index b8ce0bbfe..8d218d23d 100644
--- a/src/geometry/cgal/cgalutils-triangulate.cc
+++ b/src/geometry/cgal/cgalutils-triangulate.cc
@@ -1,4 +1,5 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/cgal/cgalutils.h"
 
 #include <cassert>
@@ -20,8 +21,7 @@ namespace CGALUtils {
 
 namespace Polygon2DCGAL {
 
-struct FaceInfo
-{
+struct FaceInfo {
   FaceInfo() = default;
   int nesting_level{42};
   [[nodiscard]] bool in_domain() const { return nesting_level % 2 == 1; }
@@ -41,13 +41,12 @@ using CDT = CGAL::Constrained_Delaunay_triangulation_2<K, TDS, Itag>;
 using Point = CDT::Point;
 using Polygon_2 = CGAL::Polygon_2<K>;
 
-void
-mark_domains(CDT& ct,
-             CDT::Face_handle start,
-             int index,
-             std::list<CDT::Edge>& border)
-{
-  if (start->info().nesting_level != -1) return;
+void mark_domains(CDT& ct,
+                  CDT::Face_handle start,
+                  int index,
+                  std::list<CDT::Edge>& border) {
+  if (start->info().nesting_level != -1)
+    return;
 
   std::list<CDT::Face_handle> queue;
   queue.push_back(start);
@@ -61,8 +60,10 @@ mark_domains(CDT& ct,
         CDT::Edge e(fh, i);
         auto n = fh->neighbor(i);
         if (n->info().nesting_level == -1) {
-          if (ct.is_constrained(e)) border.push_back(e);
-          else queue.push_back(n);
+          if (ct.is_constrained(e))
+            border.push_back(e);
+          else
+            queue.push_back(n);
         }
       }
     }
@@ -73,12 +74,11 @@ mark_domains(CDT& ct,
 // and attribute to each such set a nesting level.
 // We start from facets incident to the infinite vertex, with a nesting
 // level of 0. Then we recursively consider the non-explored facets incident
-// to constrained edges bounding the former set and increase the nesting level by 1.
-// Facets in the domain are those with an odd nesting level.
-void
-mark_domains(CDT& cdt)
-{
-  for (CDT::All_faces_iterator it = cdt.all_faces_begin(); it != cdt.all_faces_end(); ++it) {
+// to constrained edges bounding the former set and increase the nesting level
+// by 1. Facets in the domain are those with an odd nesting level.
+void mark_domains(CDT& cdt) {
+  for (CDT::All_faces_iterator it = cdt.all_faces_begin();
+       it != cdt.all_faces_end(); ++it) {
     it->info().nesting_level = -1;
   }
 
@@ -95,22 +95,22 @@ mark_domains(CDT& cdt)
   }
 }
 
-} // namespace Polygon2DCGAL
+}  // namespace Polygon2DCGAL
 
 template <typename SurfaceMesh>
-void triangulateFaces(SurfaceMesh& mesh)
-{
+void triangulateFaces(SurfaceMesh& mesh) {
   CGAL::Polygon_mesh_processing::triangulate_faces(mesh);
 }
 
-template void triangulateFaces(CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& polyhedron);
+template void triangulateFaces(
+    CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& polyhedron);
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d)
-{
+std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(
+    const Polygon2d& polygon2d) {
   auto polyset = std::make_unique<PolySet>(2);
   polyset->setTriangular(true);
 
-  Polygon2DCGAL::CDT cdt; // Uses a constrained Delaunay triangulator.
+  Polygon2DCGAL::CDT cdt;  // Uses a constrained Delaunay triangulator.
 
   try {
     // Adds all vertices, and add all contours as constraints.
@@ -120,15 +120,16 @@ std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d&
         const int idx = i % outline.vertices.size();
         const auto& v = outline.vertices[idx];
         auto curr = cdt.insert({v[0], v[1]});
-        // FIXME: We need be make sure that client relying on vertex indices being
-        // maintained also skips coincident vertices the same way.
+        // FIXME: We need be make sure that client relying on vertex indices
+        // being maintained also skips coincident vertices the same way.
         if (curr != prev) {
           // Don't add the first vertex twice
           if (i < outline.vertices.size()) {
             polyset->vertices.emplace_back(v[0], v[1], 0.0);
             curr->info().id = polyset->vertices.size() - 1;
           }
-          if (prev != nullptr) cdt.insert_constraint(prev, curr);
+          if (prev != nullptr)
+            cdt.insert_constraint(prev, curr);
           prev = curr;
         }
       }
@@ -142,25 +143,25 @@ std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d&
   // To extract triangles which is part of our polygon, we need to filter away
   // triangles inside holes.
   mark_domains(cdt);
-  for (auto fit = cdt.finite_faces_begin(); fit != cdt.finite_faces_end(); ++fit) {
+  for (auto fit = cdt.finite_faces_begin(); fit != cdt.finite_faces_end();
+       ++fit) {
     if (fit->info().in_domain()) {
       // If this assert hits, it means that the polygon2d somehow contains
       // self-intersecting or intersecting constraints. This shouldn't happen
       // since Clipper guarantees no overlaps, but could happen if we lose
-      // precision from converting from Clipper's coordinate space (int64) to Polygon2's (double).
-      // One possible workaround is to reduce Clipper's precision further,
-      // see https://github.com/openscad/openscad/issues/5253.
+      // precision from converting from Clipper's coordinate space (int64) to
+      // Polygon2's (double). One possible workaround is to reduce Clipper's
+      // precision further, see
+      // https://github.com/openscad/openscad/issues/5253.
       assert(fit->vertex(0)->info().id != -1);
       assert(fit->vertex(1)->info().id != -1);
       assert(fit->vertex(2)->info().id != -1);
-      polyset->indices.push_back({
-          fit->vertex(0)->info().id,
-          fit->vertex(1)->info().id,
-          fit->vertex(2)->info().id});
+      polyset->indices.push_back({fit->vertex(0)->info().id,
+                                  fit->vertex(1)->info().id,
+                                  fit->vertex(2)->info().id});
     }
   }
   return polyset;
 }
 
-} // namespace CGALUtils
-
+}  // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils.cc b/src/geometry/cgal/cgalutils.cc
index 4d91fb033..0d228d34d 100644
--- a/src/geometry/cgal/cgalutils.cc
+++ b/src/geometry/cgal/cgalutils.cc
@@ -2,32 +2,32 @@
 // in order to workaround gcc 4.9.1 crashing on systems with only 2GB of RAM
 #include "geometry/cgal/cgalutils.h"
 
+#include "core/node.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/cgal/cgal.h"
 #include "geometry/PolySet.h"
-#include "utils/printutils.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySetUtils.h"
-#include "core/node.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/linalg.h"
 #include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
-#include <cassert>
-#include <set>
-#include <utility>
-#include <memory>
 #include <CGAL/Aff_transformation_3.h>
-#include <CGAL/normal_vector_newell_3.h>
 #include <CGAL/Handle_hash_function.h>
 #include <CGAL/Surface_mesh.h>
+#include <CGAL/normal_vector_newell_3.h>
+#include <cassert>
+#include <memory>
+#include <set>
+#include <utility>
 
 #include <CGAL/config.h>
 #include <CGAL/version.h>
 
 #include <CGAL/convex_hull_3.h>
 
-#include "geometry/Reindexer.h"
 #include "geometry/GeometryUtils.h"
+#include "geometry/Reindexer.h"
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
@@ -39,12 +39,13 @@
 
 namespace CGALUtils {
 
-// TODO: We could rewrite this to use PolygonMeshProcessing concepts, similar to how
-// we create Manifold geometries from PolySet; convert via Surface_mesh, check if it's closed,
-// use repair|orient_polygon_soup, etc.
-std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& ps)
-{
-  if (ps.isEmpty()) return std::make_unique<CGALNefGeometry>();
+// TODO: We could rewrite this to use PolygonMeshProcessing concepts, similar to
+// how we create Manifold geometries from PolySet; convert via Surface_mesh,
+// check if it's closed, use repair|orient_polygon_soup, etc.
+std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(
+    const PolySet& ps) {
+  if (ps.isEmpty())
+    return std::make_unique<CGALNefGeometry>();
   assert(ps.getDimension() == 3);
 
   // Since is_convex doesn't work well with non-planar faces,
@@ -61,14 +62,16 @@ std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& p
       points[i] = vector_convert<Hull_kernel::Point_3>(points3d[i]);
     }
 
-    if (points.size() <= 3) return std::make_unique<CGALNefGeometry>();
+    if (points.size() <= 3)
+      return std::make_unique<CGALNefGeometry>();
 
     // Apply hull
     CGAL::Polyhedron_3<Hull_kernel> r;
     CGAL::convex_hull_3(points.begin(), points.end(), r);
     CGAL_Polyhedron r_exact;
     CGALUtils::copyPolyhedron(r, r_exact);
-    return std::make_unique<CGALNefGeometry>(std::make_shared<CGAL_Nef_polyhedron3>(r_exact));
+    return std::make_unique<CGALNefGeometry>(
+        std::make_shared<CGAL_Nef_polyhedron3>(r_exact));
   }
 
   std::shared_ptr<CGAL_Nef_polyhedron3> N;
@@ -78,54 +81,65 @@ std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& p
     auto err = CGALUtils::createPolyhedronFromPolySet(psq, P);
     if (!err) {
       if (!P.is_closed()) {
-        LOG(message_group::Error, "The given mesh is not closed! Unable to convert to CGALNefGeometry.");
+        LOG(message_group::Error,
+            "The given mesh is not closed! Unable to convert to "
+            "CGALNefGeometry.");
       } else if (!P.is_valid(false, 0)) {
-        LOG(message_group::Error, "The given mesh is invalid! Unable to convert to CGALNefGeometry.");
+        LOG(message_group::Error,
+            "The given mesh is invalid! Unable to convert to CGALNefGeometry.");
       } else {
         N = std::make_shared<CGAL_Nef_polyhedron3>(P);
       }
     }
   } catch (const CGAL::Assertion_exception& e) {
-    // First two tests matches against CGAL < 4.10, the last two tests matches against CGAL >= 4.10
+    // First two tests matches against CGAL < 4.10, the last two tests matches
+    // against CGAL >= 4.10
     if ((std::string(e.what()).find("Plane_constructor") != std::string::npos &&
          std::string(e.what()).find("has_on") != std::string::npos) ||
-        std::string(e.what()).find("ss_plane.has_on(sv_prev->point())") != std::string::npos ||
-        std::string(e.what()).find("ss_circle.has_on(sp)") != std::string::npos) {
+        std::string(e.what()).find("ss_plane.has_on(sv_prev->point())") !=
+            std::string::npos ||
+        std::string(e.what()).find("ss_circle.has_on(sp)") !=
+            std::string::npos) {
       LOG("PolySet has nonplanar faces. Attempting alternate construction");
       plane_error = true;
     } else {
-      LOG(message_group::Error, "CGAL error in CGAL_Nef_polyhedron3(): %1$s", e.what());
+      LOG(message_group::Error, "CGAL error in CGAL_Nef_polyhedron3(): %1$s",
+          e.what());
     }
   }
-  if (plane_error) try {
+  if (plane_error)
+    try {
       CGAL_Polyhedron P;
       auto err = CGALUtils::createPolyhedronFromPolySet(*ps_tri, P);
       if (!err) {
         PRINTDB("Polyhedron is closed: %d", P.is_closed());
         PRINTDB("Polyhedron is valid: %d", P.is_valid(false, 0));
       }
-      if (!err) N = std::make_shared<CGAL_Nef_polyhedron3>(P);
+      if (!err)
+        N = std::make_shared<CGAL_Nef_polyhedron3>(P);
     } catch (const CGAL::Assertion_exception& e) {
-      LOG(message_group::Error, "Alternate construction failed. CGAL error in CGAL_Nef_polyhedron3(): %1$s", e.what());
+      LOG(message_group::Error,
+          "Alternate construction failed. CGAL error in "
+          "CGAL_Nef_polyhedron3(): %1$s",
+          e.what());
     }
   return std::make_unique<CGALNefGeometry>(N);
 }
 
 template <typename K>
-CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K>& N)
-{
+CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K>& N) {
   CGAL::Iso_cuboid_3<K> result(0, 0, 0, 0, 0, 0);
   typename CGAL::Nef_polyhedron_3<K>::Vertex_const_iterator vi;
   std::vector<typename CGAL::Point_3<K>> points;
   // can be optimized by rewriting bounding_box to accept vertices
   CGAL_forall_vertices(vi, N) points.push_back(vi->point());
-  if (points.size()) result = CGAL::bounding_box(points.begin(), points.end());
+  if (points.size())
+    result = CGAL::bounding_box(points.begin(), points.end());
   return result;
 }
 template CGAL_Iso_cuboid_3 boundingBox(const CGAL_Nef_polyhedron3& N);
 
-CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox& bbox)
-{
+CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox& bbox) {
   return {vector_convert<CGAL_Point_3>(bbox.min()),
           vector_convert<CGAL_Point_3>(bbox.max())};
 }
@@ -135,13 +149,15 @@ namespace {
 // lexicographic comparison
 bool operator<(Vector3d const& a, Vector3d const& b) {
   for (int i = 0; i < 3; ++i) {
-    if (a[i] < b[i]) return true;
-    else if (a[i] == b[i]) continue;
+    if (a[i] < b[i])
+      return true;
+    else if (a[i] == b[i])
+      continue;
     return false;
   }
   return false;
 }
-}
+}  // namespace
 
 struct VecPairCompare {
   bool operator()(std::pair<Vector3d, Vector3d> const& a,
@@ -150,17 +166,15 @@ struct VecPairCompare {
   }
 };
 
-
 /*!
    Check if all faces of a polyset is within 0.1 degree of being convex.
 
    NB! This function can give false positives if the polyset contains
-   non-planar faces. To be on the safe side, consider passing a tessellated polyset.
-   See issue #1061.
+   non-planar faces. To be on the safe side, consider passing a tessellated
+   polyset. See issue #1061.
  */
 bool is_approximately_convex(const PolySet& ps) {
-
-  const double angle_threshold = cos_degrees(.1); // .1
+  const double angle_threshold = cos_degrees(.1);  // .1
 
   using K = CGAL_DoubleKernel;
   using Vector = K::Vector_3;
@@ -181,8 +195,10 @@ bool is_approximately_convex(const PolySet& ps) {
       std::vector<Point> v(N);
       for (size_t j = 0; j < N; ++j) {
         v[j] = vector_convert<Point>(ps.vertices[ps.indices[i][j]]);
-        Edge edge(ps.vertices[ps.indices[i][j]], ps.vertices[ps.indices[i][(j + 1) % N]]);
-        if (edge_to_facet_map.count(edge)) return false; // edge already exists: nonmanifold
+        Edge edge(ps.vertices[ps.indices[i][j]],
+                  ps.vertices[ps.indices[i][(j + 1) % N]]);
+        if (edge_to_facet_map.count(edge))
+          return false;  // edge already exists: nonmanifold
         edge_to_facet_map[edge] = i;
       }
       Vector normal;
@@ -194,13 +210,16 @@ bool is_approximately_convex(const PolySet& ps) {
 
   for (size_t i = 0; i < ps.indices.size(); ++i) {
     auto N = ps.indices[i].size();
-    if (N < 3) continue;
+    if (N < 3)
+      continue;
     for (size_t j = 0; j < N; ++j) {
-      Edge other_edge(ps.vertices[ps.indices[i][(j + 1) % N]], ps.vertices[ps.indices[i][j]]);
-      if (edge_to_facet_map.count(other_edge) == 0) return false; //
-      //Edge_to_facet_map::const_iterator it = edge_to_facet_map.find(other_edge);
-      //if (it == edge_to_facet_map.end()) return false; // not a closed manifold
-      //int other_facet = it->second;
+      Edge other_edge(ps.vertices[ps.indices[i][(j + 1) % N]],
+                      ps.vertices[ps.indices[i][j]]);
+      if (edge_to_facet_map.count(other_edge) == 0)
+        return false;  //
+      // Edge_to_facet_map::const_iterator it =
+      // edge_to_facet_map.find(other_edge); if (it == edge_to_facet_map.end())
+      // return false; // not a closed manifold int other_facet = it->second;
       int other_facet = edge_to_facet_map[other_edge];
 
       auto p = vector_convert<Point>(ps.vertices[ps.indices[i][(j + 2) % N]]);
@@ -224,12 +243,15 @@ bool is_approximately_convex(const PolySet& ps) {
   explored_facets.insert(0);
 
   while (!facets_to_visit.empty()) {
-    int f = facets_to_visit.front(); facets_to_visit.pop();
+    int f = facets_to_visit.front();
+    facets_to_visit.pop();
 
     for (size_t i = 0; i < ps.indices[f].size(); ++i) {
       int j = (i + 1) % ps.indices[f].size();
-      auto it = edge_to_facet_map.find(Edge(ps.vertices[ps.indices[f][j]], ps.vertices[ps.indices[f][i]]));
-      if (it == edge_to_facet_map.end()) return false; // Nonmanifold
+      auto it = edge_to_facet_map.find(
+          Edge(ps.vertices[ps.indices[f][j]], ps.vertices[ps.indices[f][i]]));
+      if (it == edge_to_facet_map.end())
+        return false;  // Nonmanifold
       if (!explored_facets.count(it->second)) {
         explored_facets.insert(it->second);
         facets_to_visit.push(it->second);
@@ -241,18 +263,23 @@ bool is_approximately_convex(const PolySet& ps) {
   return explored_facets.size() == ps.indices.size();
 }
 
-std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::shared_ptr<const Geometry>& geom)
-{
+std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(
+    const std::shared_ptr<const Geometry>& geom) {
   if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*ps));
+    return std::shared_ptr<CGALNefGeometry>(
+        createNefPolyhedronFromPolySet(*ps));
   } else if (auto poly2d = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     std::shared_ptr<PolySet> ps(poly2d->tessellate());
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*ps));
-  } else if (auto nef = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+    return std::shared_ptr<CGALNefGeometry>(
+        createNefPolyhedronFromPolySet(*ps));
+  } else if (auto nef =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     return nef;
 #if ENABLE_MANIFOLD
-  } else if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*mani->toPolySet()));
+  } else if (auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+    return std::shared_ptr<CGALNefGeometry>(
+        createNefPolyhedronFromPolySet(*mani->toPolySet()));
 #endif
   }
   return nullptr;
@@ -265,8 +292,8 @@ std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::s
    formats) do not allow for holes in their faces. The function documents
    the method used to deal with this
  */
-std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedron3& N)
-{
+std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(
+    const CGAL_Nef_polyhedron3& N) {
   // 1. Build Indexed PolyMesh
   // 2. Validate mesh (manifoldness)
   // 3. Triangulate each face
@@ -283,9 +310,9 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
   typename Nef::Halffacet_const_iterator hfaceti;
   CGAL_forall_halffacets(hfaceti, N) {
     Nef::Plane_3 plane(hfaceti->plane());
-    // Since we're downscaling to float, vertices might merge during this conversion.
-    // To avoid passing equal vertices to the tessellator, we remove consecutively identical
-    // vertices.
+    // Since we're downscaling to float, vertices might merge during this
+    // conversion. To avoid passing equal vertices to the tessellator, we remove
+    // consecutively identical vertices.
     polygons.emplace_back();
     auto& faces = polygons.back();
     // the 0-mark-volume is the 'empty' volume of space. skip it.
@@ -300,25 +327,30 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
           auto p = c1->source()->center_vertex()->point();
           // Create vertex indices and remove consecutive duplicate vertices
           auto idx = allVertices.lookup(vector_convert<Vector3f>(p));
-          if (currface.empty() || idx != currface.back()) currface.push_back(idx);
+          if (currface.empty() || idx != currface.back())
+            currface.push_back(idx);
         }
-        if (!currface.empty() && currface.front() == currface.back()) currface.pop_back();
-        if (currface.size() < 3) faces.pop_back(); // Cull empty triangles
+        if (!currface.empty() && currface.front() == currface.back())
+          currface.pop_back();
+        if (currface.size() < 3)
+          faces.pop_back();  // Cull empty triangles
       }
     }
-    if (faces.empty()) polygons.pop_back(); // Cull empty faces
+    if (faces.empty())
+      polygons.pop_back();  // Cull empty faces
   }
 
   // 2. Validate mesh (manifoldness)
   auto unconnected = GeometryUtils::findUnconnectedEdges(polygons);
   if (unconnected > 0) {
-    LOG(message_group::Error, "Non-manifold mesh encountered: %1$d unconnected edges", unconnected);
+    LOG(message_group::Error,
+        "Non-manifold mesh encountered: %1$d unconnected edges", unconnected);
   }
   // 3. Triangulate each face
   const auto& verts = allVertices.getArray();
   std::vector<IndexedTriangle> allTriangles;
   for (const auto& faces : polygons) {
-#if 0 // For debugging
+#if 0   // For debugging
     std::cerr << "---\n";
     for (const auto& poly : faces) {
       for (auto i : poly) {
@@ -326,7 +358,7 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
       }
       std::cerr << "\n";
     }
-#if 0 // debug
+#if 0   // debug
     std::cerr.precision(20);
     for (const auto& poly : faces) {
       for (auto i : poly) {
@@ -334,15 +366,15 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
       }
       std::cerr << "\n";
     }
-#endif // debug
+#endif  // debug
     std::cerr << "-\n";
-#endif // debug
-#if 0 // For debugging
+#endif  // debug
+#if 0   // For debugging
     std::cerr.precision(20);
     for (size_t i = 0; i < allVertices.size(); ++i) {
       std::cerr << verts[i][0] << ", " << verts[i][1] << ", " << verts[i][2] << "\n";
     }
-#endif // debug
+#endif  // debug
 
     /* at this stage, we have a sequence of polygons. the first
        is the "outside edge' or 'body' or 'border', and the rest of the
@@ -352,12 +384,15 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
        just output the resulting 3d triangles*/
 
     // We cannot trust the plane from Nef polyhedron to be correct.
-    // Passing an incorrect normal vector can cause a crash in the constrained delaunay triangulator
-    // See http://cgal-discuss.949826.n4.nabble.com/Nef3-Wrong-normal-vector-reported-causes-triangulator-crash-tt4660282.html
+    // Passing an incorrect normal vector can cause a crash in the constrained
+    // delaunay triangulator See
+    // http://cgal-discuss.949826.n4.nabble.com/Nef3-Wrong-normal-vector-reported-causes-triangulator-crash-tt4660282.html
     // CGAL::Vector_3<CGAL_Kernel3> nvec = plane.orthogonal_vector();
-    // K::Vector_3 normal(CGAL::to_double(nvec.x()), CGAL::to_double(nvec.y()), CGAL::to_double(nvec.z()));
+    // K::Vector_3 normal(CGAL::to_double(nvec.x()), CGAL::to_double(nvec.y()),
+    // CGAL::to_double(nvec.z()));
     std::vector<IndexedTriangle> triangles;
-    auto err = GeometryUtils::tessellatePolygonWithHoles(verts, faces, triangles, nullptr);
+    auto err = GeometryUtils::tessellatePolygonWithHoles(verts, faces,
+                                                         triangles, nullptr);
     if (!err) {
       for (const auto& t : triangles) {
         assert(t[0] >= 0 && t[0] < static_cast<int>(allVertices.size()));
@@ -368,15 +403,16 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
     }
   }
 
-#if 0 // For debugging
+#if 0   // For debugging
   for (const auto& t : allTriangles) {
     std::cerr << t[0] << " " << t[1] << " " << t[2] << "\n";
   }
-#endif // debug
+#endif  // debug
   // 4. Validate mesh (manifoldness)
   auto unconnected2 = GeometryUtils::findUnconnectedEdges(allTriangles);
   if (unconnected2 > 0) {
-    LOG(message_group::Error, "Non-manifold mesh created: %1$d unconnected edges", unconnected2);
+    LOG(message_group::Error,
+        "Non-manifold mesh created: %1$d unconnected edges", unconnected2);
   }
 
   auto polyset = PolySet::createEmpty();
@@ -390,27 +426,27 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
   }
   polyset->setTriangular(true);
 
-#if 0 // For debugging
+#if 0   // For debugging
   std::cerr.precision(20);
   for (size_t i = 0; i < allVertices.size(); ++i) {
     std::cerr << verts[i][0] << ", " << verts[i][1] << ", " << verts[i][2] << "\n";
   }
-#endif // debug
+#endif  // debug
 
   return polyset;
 }
 
 template <typename K>
-CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix(const Transform3d& matrix) {
+CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix(
+    const Transform3d& matrix) {
   return CGAL::Aff_transformation_3<K>(
-    matrix(0, 0), matrix(0, 1), matrix(0, 2), matrix(0, 3),
-    matrix(1, 0), matrix(1, 1), matrix(1, 2), matrix(1, 3),
-    matrix(2, 0), matrix(2, 1), matrix(2, 2), matrix(2, 3), matrix(3, 3));
+      matrix(0, 0), matrix(0, 1), matrix(0, 2), matrix(0, 3), matrix(1, 0),
+      matrix(1, 1), matrix(1, 2), matrix(1, 3), matrix(2, 0), matrix(2, 1),
+      matrix(2, 2), matrix(2, 3), matrix(3, 3));
 }
 
 template <typename K>
-void transform(CGAL::Nef_polyhedron_3<K>& N, const Transform3d& matrix)
-{
+void transform(CGAL::Nef_polyhedron_3<K>& N, const Transform3d& matrix) {
   assert(matrix.matrix().determinant() != 0);
   N.transform(createAffineTransformFromMatrix<K>(matrix));
 }
@@ -418,8 +454,8 @@ void transform(CGAL::Nef_polyhedron_3<K>& N, const Transform3d& matrix)
 template void transform(CGAL_Nef_polyhedron3& N, const Transform3d& matrix);
 
 template <typename K>
-void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh, const Transform3d& matrix)
-{
+void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh,
+               const Transform3d& matrix) {
   assert(matrix.matrix().determinant() != 0);
   auto t = createAffineTransformFromMatrix<K>(matrix);
 
@@ -430,10 +466,10 @@ void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh, const Transform3d& ma
 }
 
 template <typename K>
-Transform3d computeResizeTransform(
-  const CGAL::Iso_cuboid_3<K>& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+Transform3d computeResizeTransform(const CGAL::Iso_cuboid_3<K>& bb,
+                                   unsigned int dimension,
+                                   const Vector3d& newsize,
+                                   const Eigen::Matrix<bool, 3, 1>& autosize) {
   // Based on resize() in Giles Bathgate's RapCAD (but not exactly)
 
   // The numeric type is our kernel's field type.
@@ -448,12 +484,14 @@ Transform3d computeResizeTransform(
   for (unsigned int i = 0; i < dimension; ++i) {
     if (newsize[i]) {
       if (bbox_size[i] == NT(0)) {
-        LOG(message_group::Warning, "Resize in direction normal to flat object is not implemented");
+        LOG(message_group::Warning,
+            "Resize in direction normal to flat object is not implemented");
         return Transform3d::Identity();
       } else {
         scale[i] = NT(newsize[i]) / bbox_size[i];
       }
-      if (newsize[i] > newsize[newsizemax_index]) newsizemax_index = i;
+      if (newsize[i] > newsize[newsizemax_index])
+        newsizemax_index = i;
     }
   }
 
@@ -462,24 +500,25 @@ Transform3d computeResizeTransform(
     autoscale = NT(newsize[newsizemax_index]) / bbox_size[newsizemax_index];
   }
   for (unsigned int i = 0; i < dimension; ++i) {
-    if (autosize[i] && newsize[i] == 0) scale[i] = autoscale;
+    if (autosize[i] && newsize[i] == 0)
+      scale[i] = autoscale;
   }
 
   Eigen::Matrix4d t;
-  t << CGAL::to_double(scale[0]),           0,        0,        0,
-    0,        CGAL::to_double(scale[1]),           0,        0,
-    0,        0,        CGAL::to_double(scale[2]),           0,
-    0,        0,        0,                                   1;
+  t << CGAL::to_double(scale[0]), 0, 0, 0, 0, CGAL::to_double(scale[1]), 0, 0,
+      0, 0, CGAL::to_double(scale[2]), 0, 0, 0, 0, 1;
 
   return Transform3d(t);
 }
 
 template Transform3d computeResizeTransform(
-  const CGAL_Iso_cuboid_3& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize);
+    const CGAL_Iso_cuboid_3& bb,
+    unsigned int dimension,
+    const Vector3d& newsize,
+    const Eigen::Matrix<bool, 3, 1>& autosize);
 
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const Geometry>& geom)
-{
+std::shared_ptr<const PolySet> getGeometryAsPolySet(
+    const std::shared_ptr<const Geometry>& geom) {
   if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     return ps;
   }
diff --git a/src/geometry/cgal/cgalutils.h b/src/geometry/cgal/cgalutils.h
index 90a454a8a..6ee481e67 100644
--- a/src/geometry/cgal/cgalutils.h
+++ b/src/geometry/cgal/cgalutils.h
@@ -9,37 +9,45 @@
 #include "geometry/cgal/cgal.h"
 #endif
 
+#include "core/enums.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
-#include "core/enums.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
 namespace CGALUtils {
 
 #ifdef ENABLE_CGAL
 template <typename Result, typename V>
 Result vector_convert(V const& v) {
-  return Result(CGAL::to_double(v[0]), CGAL::to_double(v[1]), CGAL::to_double(v[2]));
+  return Result(CGAL::to_double(v[0]), CGAL::to_double(v[1]),
+                CGAL::to_double(v[2]));
 }
 
-std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& ps);
+std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(
+    const PolySet& ps);
 template <typename K>
 bool is_weakly_convex(const CGAL::Polyhedron_3<K>& p);
 
 template <typename K>
 bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m);
 
-std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& children, OpenSCADOperator op);
-std::unique_ptr<const Geometry> applyUnion3D(Geometry::Geometries::iterator chbegin, Geometry::Geometries::iterator chend);
-std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& children);
+std::shared_ptr<const Geometry> applyOperator3D(
+    const Geometry::Geometries& children,
+    OpenSCADOperator op);
+std::unique_ptr<const Geometry> applyUnion3D(
+    Geometry::Geometries::iterator chbegin,
+    Geometry::Geometries::iterator chend);
+std::shared_ptr<const Geometry> applyMinkowski3D(
+    const Geometry::Geometries& children);
 
 std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut);
 template <typename K>
 CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K>& N);
 
 template <typename K>
-CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh);
+CGAL::Iso_cuboid_3<K> boundingBox(
+    const CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh);
 
 CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox& bbox);
 bool is_approximately_convex(const PolySet& ps);
@@ -51,7 +59,8 @@ template <typename Polyhedron>
 bool createPolyhedronFromPolySet(const PolySet& ps, Polyhedron& p);
 
 template <class InputKernel, class OutputKernel>
-void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel>& poly_a, CGAL::Polyhedron_3<OutputKernel>& poly_b);
+void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel>& poly_a,
+                    CGAL::Polyhedron_3<OutputKernel>& poly_b);
 
 template <class InputKernel, class OutputKernel>
 void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>& input,
@@ -64,27 +73,34 @@ std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet& ps);
 template <class SurfaceMesh>
 std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh);
 
-std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedron3& N);
+std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(
+    const CGAL_Nef_polyhedron3& N);
 
-std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::shared_ptr<const Geometry>& geom);
-std::shared_ptr<const CGALNefGeometry> getGeometryAsNefPolyhedron(const std::shared_ptr<const Geometry>&);
+std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(
+    const std::shared_ptr<const Geometry>& geom);
+std::shared_ptr<const CGALNefGeometry> getGeometryAsNefPolyhedron(
+    const std::shared_ptr<const Geometry>&);
 
 template <typename K>
-CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix(const Transform3d& matrix);
+CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix(
+    const Transform3d& matrix);
 template <typename K>
 void transform(CGAL::Nef_polyhedron_3<K>& N, const Transform3d& matrix);
 template <typename K>
-void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh, const Transform3d& matrix);
+void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh,
+               const Transform3d& matrix);
 template <typename K>
-Transform3d computeResizeTransform(
-  const CGAL::Iso_cuboid_3<K>& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize);
+Transform3d computeResizeTransform(const CGAL::Iso_cuboid_3<K>& bb,
+                                   unsigned int dimension,
+                                   const Vector3d& newsize,
+                                   const Eigen::Matrix<bool, 3, 1>& autosize);
 bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
                        Polygons& triangles,
-                       const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
-bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>>& polygons,
-                                Polygons& triangles,
-                                const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
+                       const CGAL::Vector_3<CGAL::Epick>* normal = nullptr);
+bool tessellatePolygonWithHoles(
+    const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>>& polygons,
+    Polygons& triangles,
+    const CGAL::Vector_3<CGAL::Epick>* normal = nullptr);
 bool tessellate3DFaceWithHoles(std::vector<CGAL_Polygon_3>& polygons,
                                std::vector<CGAL_Polygon_3>& triangles,
                                CGAL::Plane_3<CGAL_Kernel3>& plane);
@@ -96,11 +112,12 @@ struct KernelConverter {
   typename ToKernel::FT operator()(const typename FromKernel::FT& n) const;
 };
 template <typename FromKernel, typename ToKernel>
-CGAL::Cartesian_converter<FromKernel, ToKernel, KernelConverter<FromKernel, ToKernel>>
-getCartesianConverter()
-{
-  return CGAL::Cartesian_converter<
-    FromKernel, ToKernel, KernelConverter<FromKernel, ToKernel>>();
+CGAL::Cartesian_converter<FromKernel,
+                          ToKernel,
+                          KernelConverter<FromKernel, ToKernel>>
+getCartesianConverter() {
+  return CGAL::Cartesian_converter<FromKernel, ToKernel,
+                                   KernelConverter<FromKernel, ToKernel>>();
 }
 
 template <typename SurfaceMesh>
@@ -110,12 +127,16 @@ bool isClosed(const Polyhedron& polyhedron);
 template <typename SurfaceMesh>
 void orientToBoundAVolume(SurfaceMesh& mesh);
 template <typename K>
-void convertNefToPolyhedron(const CGAL::Nef_polyhedron_3<K>& nef, CGAL::Polyhedron_3<K>& polyhedron);
+void convertNefToPolyhedron(const CGAL::Nef_polyhedron_3<K>& nef,
+                            CGAL::Polyhedron_3<K>& polyhedron);
 
-void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3& nef, CGAL_Kernel3Mesh& mesh);
-void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh& mesh, CGAL_Nef_polyhedron3& nef);
+void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3& nef,
+                             CGAL_Kernel3Mesh& mesh);
+void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh& mesh,
+                             CGAL_Nef_polyhedron3& nef);
 
-#endif // ifdef ENABLE_CGAL
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d);
+#endif  // ifdef ENABLE_CGAL
+std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(
+    const Polygon2d& polygon2d);
 
-} // namespace CGALUtils
+}  // namespace CGALUtils
diff --git a/src/geometry/linalg.cc b/src/geometry/linalg.cc
index a7f644ee4..2d1dbf1ee 100644
--- a/src/geometry/linalg.cc
+++ b/src/geometry/linalg.cc
@@ -1,6 +1,6 @@
 #include "geometry/linalg.h"
-#include <cstdint>
 #include <cmath>
+#include <cstdint>
 
 // FIXME: We can achieve better pruning by either:
 // o Recalculate the box based on the transformed object
@@ -13,11 +13,11 @@
    Transforms the given bounding box by transforming each of its 8 vertices.
    Returns a new bounding box.
  */
-BoundingBox operator*(const Transform3d& m, const BoundingBox& box)
-{
-  if (box.isEmpty()) return box;
+BoundingBox operator*(const Transform3d& m, const BoundingBox& box) {
+  if (box.isEmpty())
+    return box;
   BoundingBox newbox;
-  Vector3d boxvec[2] = { box.min(), box.max() };
+  Vector3d boxvec[2] = {box.min(), box.max()};
   for (auto& k : boxvec) {
     for (auto& j : boxvec) {
       for (auto& i : boxvec) {
@@ -28,21 +28,21 @@ BoundingBox operator*(const Transform3d& m, const BoundingBox& box)
   return newbox;
 }
 
-bool matrix_contains_infinity(const Transform3d& m)
-{
+bool matrix_contains_infinity(const Transform3d& m) {
   for (int i = 0; i < m.matrix().rows(); ++i) {
     for (int j = 0; j < m.matrix().cols(); ++j) {
-      if ((std::isinf)(m(i, j))) return true;
+      if ((std::isinf)(m(i, j)))
+        return true;
     }
   }
   return false;
 }
 
-bool matrix_contains_nan(const Transform3d& m)
-{
+bool matrix_contains_nan(const Transform3d& m) {
   for (int i = 0; i < m.matrix().rows(); ++i) {
     for (int j = 0; j < m.matrix().cols(); ++j) {
-      if ((std::isnan)(m(i, j))) return true;
+      if ((std::isnan)(m(i, j)))
+        return true;
     }
   }
   return false;
@@ -67,12 +67,12 @@ bool matrix_contains_nan(const Transform3d& m)
 using Py_hash_t = int32_t;
 using Py_uhash_t = uint32_t;
 using Float_t = double;
-Py_hash_t hash_floating_point(Float_t v)
-{
+Py_hash_t hash_floating_point(Float_t v) {
   static constexpr int PyHASH_BITS = 31;
-  //if (sizeof(Py_uhash_t)==8) PyHASH_BITS=61;
+  // if (sizeof(Py_uhash_t)==8) PyHASH_BITS=61;
 
-  static constexpr Py_uhash_t PyHASH_MODULUS = (((Py_uhash_t)1 << PyHASH_BITS) - 1);
+  static constexpr Py_uhash_t PyHASH_MODULUS =
+      (((Py_uhash_t)1 << PyHASH_BITS) - 1);
   static constexpr Py_uhash_t PyHASH_INF = 314159;
   static constexpr Py_uhash_t PyHASH_NAN = 0;
 
@@ -81,8 +81,10 @@ Py_hash_t hash_floating_point(Float_t v)
   Py_uhash_t x, y;
 
   if (!std::isfinite(v)) {
-    if (std::isinf(v)) return v > 0 ? PyHASH_INF : -PyHASH_INF;
-    else return PyHASH_NAN;
+    if (std::isinf(v))
+      return v > 0 ? PyHASH_INF : -PyHASH_INF;
+    else
+      return PyHASH_NAN;
   }
 
   m = frexp(v, &e);
@@ -98,12 +100,13 @@ Py_hash_t hash_floating_point(Float_t v)
   x = 0;
   while (m) {
     x = ((x << 28) & PyHASH_MODULUS) | x >> (PyHASH_BITS - 28);
-    m *= 268435456.0; // 2**28
+    m *= 268435456.0;  // 2**28
     e -= 28;
     y = (Py_uhash_t)m; /* pull out integer part */
     m -= y;
     x += y;
-    if (x >= PyHASH_MODULUS) x -= PyHASH_MODULUS;
+    if (x >= PyHASH_MODULUS)
+      x -= PyHASH_MODULUS;
   }
 
   /* adjust for the exponent;  first reduce it modulo PyHASH_BITS */
diff --git a/src/geometry/linalg.h b/src/geometry/linalg.h
index 3f684c282..237931d7f 100644
--- a/src/geometry/linalg.h
+++ b/src/geometry/linalg.h
@@ -1,31 +1,33 @@
 #pragma once
 
 #include <Eigen/Core>
-#include <Eigen/Geometry>
 #include <Eigen/Dense>
+#include <Eigen/Geometry>
 #include <cstdint>
 #include <vector>
 
 using Eigen::Vector2d;
 using Eigen::Vector3d;
-using Eigen::Vector4d;
 using Eigen::Vector3f;
-using Eigen::Vector4f;
 using Eigen::Vector3i;
+using Eigen::Vector4d;
+using Eigen::Vector4f;
 
 #ifdef _MSC_VER
-  #include <Eigen/StdVector> // https://eigen.tuxfamily.org/dox/group__TopicStlContainers.html
-  #if !EIGEN_HAS_CXX11_CONTAINERS
-    #warning "Eigen has detected no support for CXX11 containers and has redefined std::vector"
-  #endif
-using VectorOfVector2d = std::vector<Vector2d, Eigen::aligned_allocator<Vector2d>>;
+#include <Eigen/StdVector>  // https://eigen.tuxfamily.org/dox/group__TopicStlContainers.html
+#if !EIGEN_HAS_CXX11_CONTAINERS
+#warning \
+    "Eigen has detected no support for CXX11 containers and has redefined std::vector"
+#endif
+using VectorOfVector2d =
+    std::vector<Vector2d, Eigen::aligned_allocator<Vector2d>>;
 #else
 using VectorOfVector2d = std::vector<Vector2d>;
 #endif
 
 using BoundingBox = Eigen::AlignedBox<double, 3>;
-using Eigen::Matrix3f;
 using Eigen::Matrix3d;
+using Eigen::Matrix3f;
 using Eigen::Matrix4d;
 #define Transform3d Eigen::Affine3d
 #define Transform2d Eigen::Affine2d
@@ -34,46 +36,46 @@ bool matrix_contains_infinity(const Transform3d& m);
 bool matrix_contains_nan(const Transform3d& m);
 int32_t hash_floating_point(double v);
 
-template <typename Derived> bool is_finite(const Eigen::MatrixBase<Derived>& x) {
-  //infinity minus infinity is NaN, which never compares equal to itself
-  return ( (x - x).array() == (x - x).array()).all(); // NOLINT(misc-redundant-expression)
+template <typename Derived>
+bool is_finite(const Eigen::MatrixBase<Derived>& x) {
+  // infinity minus infinity is NaN, which never compares equal to itself
+  return ((x - x).array() == (x - x).array())
+      .all();  // NOLINT(misc-redundant-expression)
 }
 
-template <typename Derived> bool is_nan(const Eigen::MatrixBase<Derived>& x) {
+template <typename Derived>
+bool is_nan(const Eigen::MatrixBase<Derived>& x) {
   return !((x.array() == x.array())).all();
 }
 
 BoundingBox operator*(const Transform3d& m, const BoundingBox& box);
 
-class Color4f
-{
-public:
-  Color4f(const Vector4f& v) : color_(v) { }
+class Color4f {
+ public:
+  Color4f(const Vector4f& v) : color_(v) {}
   Color4f(int r, int g, int b, int a = 255) { setRgba(r, g, b, a); }
-  Color4f(float r = -1.0f, float g = -1.0f, float b = -1.0f, float a = -1.0f) : color_(r, g, b, a) { }
+  Color4f(float r = -1.0f, float g = -1.0f, float b = -1.0f, float a = -1.0f)
+      : color_(r, g, b, a) {}
 
   [[nodiscard]] bool isValid() const { return color_.minCoeff() >= 0.0f; }
-  [[nodiscard]] bool hasRgb() const { return color_[0] >= 0.0f && color_[1] >= 0.0f && color_[2] >= 0.0f; }
+  [[nodiscard]] bool hasRgb() const {
+    return color_[0] >= 0.0f && color_[1] >= 0.0f && color_[2] >= 0.0f;
+  }
   [[nodiscard]] bool hasAlpha() const { return color_[3] >= 0.0f; }
 
   void setRgba(int r, int g, int b, int a = 255) {
-    color_ << static_cast<float>(r) / 255.0f,
-      static_cast<float>(g) / 255.0f,
-      static_cast<float>(b) / 255.0f,
-      static_cast<float>(a) / 255.0f;
+    color_ << static_cast<float>(r) / 255.0f, static_cast<float>(g) / 255.0f,
+        static_cast<float>(b) / 255.0f, static_cast<float>(a) / 255.0f;
   }
   void setRgba(float r, float g, float b, float a = 1.0f) {
     color_ << r, g, b, a;
   }
-  void setRgb(float r, float g, float b) {
-    color_.head<3>() << r, g, b;
-  }
-  void setAlpha(float a) {
-    color_[3] = a;
-  }
+  void setRgb(float r, float g, float b) { color_.head<3>() << r, g, b; }
+  void setAlpha(float a) { color_[3] = a; }
 
   bool getRgba(int& r, int& g, int& b, int& a) const {
-    if (!isValid()) return false;
+    if (!isValid())
+      return false;
     r = std::clamp(static_cast<int>(this->r() * 255.0f), 0, 255);
     g = std::clamp(static_cast<int>(this->g() * 255.0f), 0, 255);
     b = std::clamp(static_cast<int>(this->b() * 255.0f), 0, 255);
@@ -82,7 +84,8 @@ public:
   }
 
   bool getRgba(uint8_t& r, uint8_t& g, uint8_t& b, uint8_t& a) const {
-    if (!isValid()) return false;
+    if (!isValid())
+      return false;
     r = static_cast<uint8_t>(std::clamp(this->r(), 0.0f, 1.0f) * 255.0f);
     g = static_cast<uint8_t>(std::clamp(this->g(), 0.0f, 1.0f) * 255.0f);
     b = static_cast<uint8_t>(std::clamp(this->b(), 0.0f, 1.0f) * 255.0f);
@@ -91,7 +94,8 @@ public:
   }
 
   bool getRgba(float& r, float& g, float& b, float& a) const {
-    if (!isValid()) return false;
+    if (!isValid())
+      return false;
     r = this->r();
     g = this->g();
     b = this->b();
@@ -99,9 +103,7 @@ public:
     return true;
   }
 
-  [[nodiscard]] Vector4f toVector4f() const {
-    return color_;
-  }
+  [[nodiscard]] Vector4f toVector4f() const { return color_; }
 
   [[nodiscard]] float r() const { return color_[0]; }
   [[nodiscard]] float g() const { return color_[1]; }
@@ -110,8 +112,10 @@ public:
 
   [[nodiscard]] bool operator<(const Color4f& b) const {
     for (int i = 0; i < 4; i++) {
-      if (color_[i] < b.color_[i]) return true;
-      if (color_[i] > b.color_[i]) return false;
+      if (color_[i] < b.color_[i])
+        return true;
+      if (color_[i] > b.color_[i])
+        return false;
     }
     return false;
   }
@@ -135,16 +139,15 @@ public:
     hash = std::hash<float>{}(a()) ^ (hash << 1);
     return hash;
   }
-private:
+
+ private:
   // Vector4f is fixed-size vectorizable
   // Use Eigen::DontAlign so we can store Color4f in STL containers
   // https://eigen.tuxfamily.org/dox/group__DenseMatrixManipulation__Alignement.html
   Eigen::Matrix<float, 4, 1, Eigen::DontAlign> color_;
 };
 
-template <> struct std::hash<Color4f> {
-  std::size_t operator()(Color4f const& c) const noexcept {
-    return c.hash();
-  }
+template <>
+struct std::hash<Color4f> {
+  std::size_t operator()(Color4f const& c) const noexcept { return c.hash(); }
 };
-
diff --git a/src/geometry/linear_extrude.cc b/src/geometry/linear_extrude.cc
index 9b379b457..d82b53bcb 100644
--- a/src/geometry/linear_extrude.cc
+++ b/src/geometry/linear_extrude.cc
@@ -1,25 +1,25 @@
 #include "geometry/linear_extrude.h"
 
 #include <algorithm>
+#include <cassert>
 #include <cmath>
+#include <cstddef>
 #include <iterator>
-#include <cassert>
-#include <utility>
 #include <memory>
-#include <cstddef>
 #include <queue>
+#include <utility>
 #include <vector>
 
 #include <boost/logic/tribool.hpp>
 
+#include "core/LinearExtrudeNode.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/GeometryUtils.h"
-#include "glview/RenderSettings.h"
-#include "core/LinearExtrudeNode.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
+#include "glview/RenderSettings.h"
 #include "utils/calc.h"
 #include "utils/degree_trig.h"
 
@@ -33,7 +33,7 @@ namespace {
     1 : if v1  > v2
  */
 int sgn_vdiff(const Vector2d& v1, const Vector2d& v2) {
-  constexpr double ratio_threshold = 1e5; // 10ppm difference
+  constexpr double ratio_threshold = 1e5;  // 10ppm difference
   double l1 = v1.norm();
   double l2 = v2.norm();
   // Compare the average and difference, to be independent of geometry scale.
@@ -46,29 +46,37 @@ int sgn_vdiff(const Vector2d& v1, const Vector2d& v2) {
 // Insert vertices for segments interpolated between v0 and v1.
 // The last vertex (t==1) is not added here to avoid duplicate vertices,
 // since it will be the first vertex of the *next* edge.
-void add_segmented_edge(Outline2d& o, const Vector2d& v0, const Vector2d& v1, unsigned int edge_segments) {
+void add_segmented_edge(Outline2d& o,
+                        const Vector2d& v0,
+                        const Vector2d& v1,
+                        unsigned int edge_segments) {
   for (unsigned int j = 0; j < edge_segments; ++j) {
     double t = static_cast<double>(j) / edge_segments;
     o.vertices.push_back((1 - t) * v0 + t * v1);
   }
 }
 
-// While total outline segments < fn, increment segment_count for edge with largest
-// (max_edge_length / segment_count).
-Outline2d splitOutlineByFn(
-  const Outline2d& o,
-  const double twist, const double scale_x, const double scale_y,
-  const double fn, unsigned int slices)
-{
-
+// While total outline segments < fn, increment segment_count for edge with
+// largest (max_edge_length / segment_count).
+Outline2d splitOutlineByFn(const Outline2d& o,
+                           const double twist,
+                           const double scale_x,
+                           const double scale_y,
+                           const double fn,
+                           unsigned int slices) {
   struct segment_tracker {
     size_t edge_index;
     double max_edgelen;
     unsigned int segment_count{1u};
-    segment_tracker(size_t i, double len) : edge_index(i), max_edgelen(len) { }
-    // metric for comparison: average between (max segment length, and max segment length after split)
-    [[nodiscard]] double metric() const { return max_edgelen / (segment_count + 0.5); }
-    bool operator<(const segment_tracker& rhs) const { return this->metric() < rhs.metric();  }
+    segment_tracker(size_t i, double len) : edge_index(i), max_edgelen(len) {}
+    // metric for comparison: average between (max segment length, and max
+    // segment length after split)
+    [[nodiscard]] double metric() const {
+      return max_edgelen / (segment_count + 0.5);
+    }
+    bool operator<(const segment_tracker& rhs) const {
+      return this->metric() < rhs.metric();
+    }
     [[nodiscard]] bool close_match(const segment_tracker& other) const {
       // Edges are grouped when metrics match by at least 99.9%
       constexpr double APPROX_EQ_RATIO = 0.999;
@@ -87,19 +95,21 @@ Outline2d splitOutlineByFn(
   if (scale_x != scale_y) {
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
-      double max_edgelen = 0.0; // max length for single edge over all transformed slices
+      double max_edgelen =
+          0.0;  // max length for single edge over all transformed slices
       for (unsigned int j = 0; j <= slices; j++) {
         double t = static_cast<double>(j) / slices;
         Vector2d scale(Calc::lerp(1, scale_x, t), Calc::lerp(1, scale_y, t));
         double rot = twist * t;
-        Eigen::Affine2d trans(Eigen::Scaling(scale) * Eigen::Affine2d(rotate_degrees(-rot)));
+        Eigen::Affine2d trans(Eigen::Scaling(scale) *
+                              Eigen::Affine2d(rotate_degrees(-rot)));
         double edgelen = (trans * v1 - trans * v0).norm();
         max_edgelen = std::max(max_edgelen, edgelen);
       }
       q.emplace(i - 1, max_edgelen);
       v0 = v1;
     }
-  } else { // uniform scaling
+  } else {  // uniform scaling
     double max_scale = std::max(scale_x, 1.0);
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
@@ -116,7 +126,8 @@ Outline2d splitOutlineByFn(
     auto current = q.top();
 
     // Group similar length segmented edges to keep result roughly symmetrical.
-    while (!q.empty() && (tmp_q.empty() || q.top().close_match(tmp_q.front()))) {
+    while (!q.empty() &&
+           (tmp_q.empty() || q.top().close_match(tmp_q.front()))) {
       tmp_q.push_back(q.top());
       q.pop();
     }
@@ -155,13 +166,14 @@ Outline2d splitOutlineByFn(
   return o2;
 }
 
-// For each edge in original outline, find its max length over all slice transforms,
-// and divide into segments no longer than fs.
-Outline2d splitOutlineByFs(
-  const Outline2d& o,
-  const double twist, const double scale_x, const double scale_y,
-  const double fs, unsigned int slices)
-{
+// For each edge in original outline, find its max length over all slice
+// transforms, and divide into segments no longer than fs.
+Outline2d splitOutlineByFs(const Outline2d& o,
+                           const double twist,
+                           const double scale_x,
+                           const double scale_y,
+                           const double fs,
+                           unsigned int slices) {
   const auto num_vertices = o.vertices.size();
 
   Vector2d v0 = o.vertices[0];
@@ -173,24 +185,28 @@ Outline2d splitOutlineByFs(
   if (scale_x != scale_y) {
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
-      double max_edgelen = 0.0; // max length for single edge over all transformed slices
+      double max_edgelen =
+          0.0;  // max length for single edge over all transformed slices
       for (unsigned int j = 0; j <= slices; j++) {
         double t = static_cast<double>(j) / slices;
         Vector2d scale(Calc::lerp(1, scale_x, t), Calc::lerp(1, scale_y, t));
         double rot = twist * t;
-        Eigen::Affine2d trans(Eigen::Scaling(scale) * Eigen::Affine2d(rotate_degrees(-rot)));
+        Eigen::Affine2d trans(Eigen::Scaling(scale) *
+                              Eigen::Affine2d(rotate_degrees(-rot)));
         double edgelen = (trans * v1 - trans * v0).norm();
         max_edgelen = std::max(max_edgelen, edgelen);
       }
-      auto edge_segments = static_cast<unsigned int>(std::ceil(max_edgelen / fs));
+      auto edge_segments =
+          static_cast<unsigned int>(std::ceil(max_edgelen / fs));
       add_segmented_edge(o2, v0, v1, edge_segments);
       v0 = v1;
     }
-  } else { // uniform scaling
+  } else {  // uniform scaling
     double max_scale = std::max(scale_x, 1.0);
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
-      unsigned int edge_segments = static_cast<unsigned int>(std::ceil((v1 - v0).norm() * max_scale / fs));
+      unsigned int edge_segments = static_cast<unsigned int>(
+          std::ceil((v1 - v0).norm() * max_scale / fs));
       add_segmented_edge(o2, v0, v1, edge_segments);
       v0 = v1;
     }
@@ -199,9 +215,12 @@ Outline2d splitOutlineByFs(
 }
 
 std::unique_ptr<PolySet> assemblePolySetForManifold(
-  const Polygon2d& polyref,
-  std::vector<Vector3d>& vertices, PolygonIndices& indices,
-  int convexity, boost::tribool isConvex, int index_offset) {
+    const Polygon2d& polyref,
+    std::vector<Vector3d>& vertices,
+    PolygonIndices& indices,
+    int convexity,
+    boost::tribool isConvex,
+    int index_offset) {
   auto final_polyset = std::make_unique<PolySet>(3, isConvex);
   final_polyset->setTriangular(true);
   final_polyset->setConvexity(convexity);
@@ -209,7 +228,7 @@ std::unique_ptr<PolySet> assemblePolySetForManifold(
   final_polyset->indices = std::move(indices);
 
   // Create top and bottom face.
-  auto ps_bottom = polyref.tessellate(); // bottom
+  auto ps_bottom = polyref.tessellate();  // bottom
   // Flip vertex ordering for bottom polygon
   for (auto& p : ps_bottom->indices) {
     std::reverse(p.begin(), p.end());
@@ -232,15 +251,19 @@ std::unique_ptr<PolySet> assemblePolySetForManifold(
 }
 
 std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
-                                                std::vector<Vector3d>& vertices, PolygonIndices& indices,
-                                                int convexity, boost::tribool isConvex,
-                                                double scale_x, double scale_y,
-                                                const Vector3d& h1, const Vector3d& h2, double twist) {
-
+                                                std::vector<Vector3d>& vertices,
+                                                PolygonIndices& indices,
+                                                int convexity,
+                                                boost::tribool isConvex,
+                                                double scale_x,
+                                                double scale_y,
+                                                const Vector3d& h1,
+                                                const Vector3d& h2,
+                                                double twist) {
   PolySetBuilder builder(0, 0, 3, isConvex);
   builder.setConvexity(convexity);
 
-  for (const auto& poly: indices) {
+  for (const auto& poly : indices) {
     builder.beginPolygon(poly.size());
     for (const auto idx : poly) {
       builder.addVertex(vertices[idx]);
@@ -248,13 +271,13 @@ std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
   }
 
   auto translatePolySet = [](PolySet& ps, const Vector3d& translation) {
-      for (auto& v : ps.vertices) {
-        v += translation;
-      }
-    };
+    for (auto& v : ps.vertices) {
+      v += translation;
+    }
+  };
 
   // Create bottom face.
-  auto ps_bottom = polyref.tessellate(); // bottom
+  auto ps_bottom = polyref.tessellate();  // bottom
   // Flip vertex ordering for bottom polygon
   for (auto& p : ps_bottom->indices) {
     std::reverse(p.begin(), p.end());
@@ -266,7 +289,8 @@ std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
   // If either scale components are 0, then top will be zero-area, so skip it.
   if (scale_x != 0 && scale_y != 0) {
     Polygon2d top_poly(polyref);
-    Eigen::Affine2d trans(Eigen::Scaling(scale_x, scale_y) * Eigen::Affine2d(rotate_degrees(-twist)));
+    Eigen::Affine2d trans(Eigen::Scaling(scale_x, scale_y) *
+                          Eigen::Affine2d(rotate_degrees(-twist)));
     top_poly.transform(trans);
     auto ps_top = top_poly.tessellate();
     translatePolySet(*ps_top, h2);
@@ -280,18 +304,25 @@ std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
    Attempt to triangulate quads in an ideal way.
    Each quad is composed of two adjacent outline vertices: (prev1, curr1)
    and their corresponding transformed points one step up: (prev2, curr2).
-   Quads are triangulated across the shorter of the two diagonals, which works well in most cases.
-   However, when diagonals are equal length, decision may flip depending on other factors.
+   Quads are triangulated across the shorter of the two diagonals, which works
+   well in most cases. However, when diagonals are equal length, decision may
+   flip depending on other factors.
  */
-void add_slice_indices(PolygonIndices& indices, int slice_idx, int slice_stride, const Polygon2d& poly,
-                       double rot1, double rot2,
-                       const Vector2d& scale1, const Vector2d& scale2)
-{
+void add_slice_indices(PolygonIndices& indices,
+                       int slice_idx,
+                       int slice_stride,
+                       const Polygon2d& poly,
+                       double rot1,
+                       double rot2,
+                       const Vector2d& scale1,
+                       const Vector2d& scale2) {
   int prev_slice = (slice_idx - 1) * slice_stride;
   int curr_slice = slice_idx * slice_stride;
 
-  Eigen::Affine2d trans1(Eigen::Scaling(scale1) * Eigen::Affine2d(rotate_degrees(-rot1)));
-  Eigen::Affine2d trans2(Eigen::Scaling(scale2) * Eigen::Affine2d(rotate_degrees(-rot2)));
+  Eigen::Affine2d trans1(Eigen::Scaling(scale1) *
+                         Eigen::Affine2d(rotate_degrees(-rot1)));
+  Eigen::Affine2d trans2(Eigen::Scaling(scale2) *
+                         Eigen::Affine2d(rotate_degrees(-rot2)));
 
   bool any_zero = scale2[0] == 0 || scale2[1] == 0;
   // setting back_twist true helps keep diagonals same as previous builds.
@@ -304,11 +335,12 @@ void add_slice_indices(PolygonIndices& indices, int slice_idx, int slice_stride,
     Vector2d prev1 = trans1 * o.vertices[0];
     Vector2d prev2 = trans2 * o.vertices[0];
 
-    // For equal length diagonals, flip selected choice depending on direction of twist and
-    // whether the outline is negative (eg circle hole inside a larger circle).
-    // This was tested against circles with a single point touching the origin,
-    // and extruded with twist.  Diagonal choice determined by whichever option
-    // matched the direction of diagonal for neighboring edges (which did not exhibit "equal" diagonals).
+    // For equal length diagonals, flip selected choice depending on direction
+    // of twist and whether the outline is negative (eg circle hole inside a
+    // larger circle). This was tested against circles with a single point
+    // touching the origin, and extruded with twist.  Diagonal choice determined
+    // by whichever option matched the direction of diagonal for neighboring
+    // edges (which did not exhibit "equal" diagonals).
     bool flip = ((!o.positive) xor (back_twist));
 
     for (int i = 1; i <= o.vertices.size(); ++i) {
@@ -329,23 +361,23 @@ void add_slice_indices(PolygonIndices& indices, int slice_idx, int slice_stride,
             prev_slice + curr_idx,
             curr_slice + curr_idx,
             prev_slice + prev_idx,
-          });
+        });
         indices.push_back({
             curr_slice + prev_idx,
             prev_slice + prev_idx,
             curr_slice + curr_idx,
-          });
+        });
       } else {
         indices.push_back({
             prev_slice + curr_idx,
             curr_slice + prev_idx,
             prev_slice + prev_idx,
-          });
+        });
         indices.push_back({
             prev_slice + curr_idx,
             curr_slice + curr_idx,
             curr_slice + prev_idx,
-          });
+        });
       }
       prev1 = curr1;
       prev2 = curr2;
@@ -359,40 +391,50 @@ size_t calc_num_slices(const LinearExtrudeNode& node, const Polygon2d& poly) {
   if (node.has_slices) {
     num_slices = node.slices;
   } else if (node.has_twist) {
-    double max_r1_sqr = 0; // r1 is before scaling
+    double max_r1_sqr = 0;  // r1 is before scaling
     Vector2d scale(node.scale_x, node.scale_y);
     for (const auto& o : poly.outlines())
       for (const auto& v : o.vertices)
         max_r1_sqr = fmax(max_r1_sqr, v.squaredNorm());
     // Calculate Helical curve length for Twist with no Scaling
     if (node.scale_x == 1.0 && node.scale_y == 1.0) {
-      num_slices = (unsigned int)Calc::get_helix_slices(max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
-    } else if (node.scale_x != node.scale_y) {  // non uniform scaling with twist using max slices from twist and non uniform scale
-      double max_delta_sqr = 0; // delta from before/after scaling
+      num_slices = (unsigned int)Calc::get_helix_slices(
+          max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
+    } else if (node.scale_x !=
+               node.scale_y) {   // non uniform scaling with twist using max
+                                 // slices from twist and non uniform scale
+      double max_delta_sqr = 0;  // delta from before/after scaling
       Vector2d scale(node.scale_x, node.scale_y);
       for (const auto& o : poly.outlines()) {
         for (const auto& v : o.vertices) {
-          max_delta_sqr = fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
+          max_delta_sqr =
+              fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
         }
       }
       size_t slicesNonUniScale;
       size_t slicesTwist;
-      slicesNonUniScale = (unsigned int)Calc::get_diagonal_slices(max_delta_sqr, node.height[2], node.fn, node.fs);
-      slicesTwist = (unsigned int)Calc::get_helix_slices(max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
+      slicesNonUniScale = (unsigned int)Calc::get_diagonal_slices(
+          max_delta_sqr, node.height[2], node.fn, node.fs);
+      slicesTwist = (unsigned int)Calc::get_helix_slices(
+          max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
       num_slices = std::max(slicesNonUniScale, slicesTwist);
-    } else { // uniform scaling with twist, use conical helix calculation
-      num_slices = (unsigned int)Calc::get_conical_helix_slices(max_r1_sqr, node.height[2], node.twist, node.scale_x, node.fn, node.fs, node.fa);
+    } else {  // uniform scaling with twist, use conical helix calculation
+      num_slices = (unsigned int)Calc::get_conical_helix_slices(
+          max_r1_sqr, node.height[2], node.twist, node.scale_x, node.fn,
+          node.fs, node.fa);
     }
   } else if (node.scale_x != node.scale_y) {
     // Non uniform scaling, w/o twist
-    double max_delta_sqr = 0; // delta from before/after scaling
+    double max_delta_sqr = 0;  // delta from before/after scaling
     Vector2d scale(node.scale_x, node.scale_y);
     for (const auto& o : poly.outlines()) {
       for (const auto& v : o.vertices) {
-        max_delta_sqr = fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
+        max_delta_sqr =
+            fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
       }
     }
-    num_slices = Calc::get_diagonal_slices(max_delta_sqr, node.height[2], node.fn, node.fs);
+    num_slices = Calc::get_diagonal_slices(max_delta_sqr, node.height[2],
+                                           node.fn, node.fs);
   } else {
     // uniform or [1,1] scaling w/o twist needs only one slice
     num_slices = 1;
@@ -403,18 +445,20 @@ size_t calc_num_slices(const LinearExtrudeNode& node, const Polygon2d& poly) {
 }  // namespace
 
 /*!
-   Input to extrude should be sanitized. This means non-intersecting, correct winding order
-   etc., the input coming from a library like Clipper.
+   Input to extrude should be sanitized. This means non-intersecting, correct
+   winding order etc., the input coming from a library like Clipper.
  */
-std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Polygon2d& poly)
-{
+std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node,
+                                         const Polygon2d& poly) {
   assert(poly.isSanitized());
-  if (node.height[2] <= 0) return PolySet::createEmpty();
+  if (node.height[2] <= 0)
+    return PolySet::createEmpty();
 
   bool non_linear = node.twist != 0 || node.scale_x != node.scale_y;
   boost::tribool isConvex{poly.is_convex()};
   // Twist makes convex polygons into unknown polyhedrons
-  if (isConvex && non_linear) isConvex = unknown;
+  if (isConvex && non_linear)
+    isConvex = unknown;
 
   // num_slices is the number of volumetric segments, minimum 1.
   // The number of rings of vertices will be num_slices+1.
@@ -430,7 +474,9 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
         if (o.vertices.size() >= node.segments) {
           seg_poly.addOutline(o);
         } else {
-          seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, node.segments, num_slices));
+          seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x,
+                                               node.scale_y, node.segments,
+                                               num_slices));
         }
       }
       is_segmented = true;
@@ -441,19 +487,23 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
         if (o.vertices.size() >= node.fn) {
           seg_poly.addOutline(o);
         } else {
-          seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, node.fn, num_slices));
+          seg_poly.addOutline(splitOutlineByFn(
+              o, node.twist, node.scale_x, node.scale_y, node.fn, num_slices));
         }
       }
-    } else { // $fs and $fa based segmentation
+    } else {  // $fs and $fa based segmentation
       auto fa_segs = static_cast<unsigned int>(std::ceil(360.0 / node.fa));
       for (const auto& o : poly.outlines()) {
         if (o.vertices.size() >= fa_segs) {
           seg_poly.addOutline(o);
         } else {
           // try splitting by $fs, then check if $fa results in less segments
-          auto fsOutline = splitOutlineByFs(o, node.twist, node.scale_x, node.scale_y, node.fs, num_slices);
+          auto fsOutline = splitOutlineByFs(o, node.twist, node.scale_x,
+                                            node.scale_y, node.fs, num_slices);
           if (fsOutline.vertices.size() >= fa_segs) {
-            seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, fa_segs, num_slices));
+            seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x,
+                                                 node.scale_y, fa_segs,
+                                                 num_slices));
           } else {
             seg_poly.addOutline(std::move(fsOutline));
           }
@@ -480,7 +530,7 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
   std::vector<Vector3d> vertices;
   vertices.reserve(slice_stride * (num_slices + 1));
   PolygonIndices indices;
-  indices.reserve(slice_stride * (num_slices + 1) * 2); // sides + endcaps
+  indices.reserve(slice_stride * (num_slices + 1) * 2);  // sides + endcaps
 
   // Calculate all vertices
   Vector2d full_scale(1 - node.scale_x, 1 - node.scale_y);
@@ -488,13 +538,14 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
   auto full_height = (h2 - h1);
   for (unsigned int slice_idx = 0; slice_idx <= num_slices; slice_idx++) {
     Eigen::Affine2d trans(
-      Eigen::Scaling(Vector2d(1, 1) - full_scale * slice_idx / num_slices) *
-      Eigen::Affine2d(rotate_degrees(full_rot * slice_idx / num_slices)));
+        Eigen::Scaling(Vector2d(1, 1) - full_scale * slice_idx / num_slices) *
+        Eigen::Affine2d(rotate_degrees(full_rot * slice_idx / num_slices)));
 
     for (const auto& o : polyref.outlines()) {
       for (const auto& v : o.vertices) {
         auto tmp = trans * v;
-        vertices.emplace_back(Vector3d(tmp[0], tmp[1], 0.0) + h1 + full_height * slice_idx / num_slices);
+        vertices.emplace_back(Vector3d(tmp[0], tmp[1], 0.0) + h1 +
+                              full_height * slice_idx / num_slices);
       }
     }
   }
@@ -509,21 +560,23 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
                         1 - (1 - node.scale_y) * (slice_idx - 1) / num_slices);
     Vector2d scale_curr(1 - (1 - node.scale_x) * slice_idx / num_slices,
                         1 - (1 - node.scale_y) * slice_idx / num_slices);
-    add_slice_indices(indices, slice_idx, slice_stride, polyref, rot_prev, rot_curr, scale_prev, scale_curr);
+    add_slice_indices(indices, slice_idx, slice_stride, polyref, rot_prev,
+                      rot_curr, scale_prev, scale_curr);
   }
 
-  // For Manifold, we can tesselate the endcaps using existing vertices to build a manifold mesh.
-  // Without Manifold, however, we don't have such a tessellator available, so we'll have to build
-  // the polyset from vertices using PolySetBuilder
+  // For Manifold, we can tesselate the endcaps using existing vertices to build
+  // a manifold mesh. Without Manifold, however, we don't have such a
+  // tessellator available, so we'll have to build the polyset from vertices
+  // using PolySetBuilder
 
 #ifdef ENABLE_MANIFOLD
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
     return assemblePolySetForManifold(polyref, vertices, indices,
-                                      node.convexity, isConvex, slice_stride * num_slices);
+                                      node.convexity, isConvex,
+                                      slice_stride * num_slices);
   } else
 #endif
-  return assemblePolySetForCGAL(polyref, vertices, indices,
-                                node.convexity, isConvex,
-                                node.scale_x, node.scale_y,
-                                h1, h2, node.twist);
+    return assemblePolySetForCGAL(polyref, vertices, indices, node.convexity,
+                                  isConvex, node.scale_x, node.scale_y, h1, h2,
+                                  node.twist);
 }
diff --git a/src/geometry/linear_extrude.h b/src/geometry/linear_extrude.h
index 68182df6b..8659507a3 100644
--- a/src/geometry/linear_extrude.h
+++ b/src/geometry/linear_extrude.h
@@ -2,8 +2,9 @@
 
 #include <memory>
 
-#include "geometry/Polygon2d.h"
-#include "geometry/Geometry.h"
 #include "core/LinearExtrudeNode.h"
+#include "geometry/Geometry.h"
+#include "geometry/Polygon2d.h"
 
-std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Polygon2d& poly);
+std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node,
+                                         const Polygon2d& poly);
diff --git a/src/geometry/manifold/ManifoldGeometry.cc b/src/geometry/manifold/ManifoldGeometry.cc
index 83f1cd7be..9b5d9358e 100644
--- a/src/geometry/manifold/ManifoldGeometry.cc
+++ b/src/geometry/manifold/ManifoldGeometry.cc
@@ -1,26 +1,27 @@
-// Portions of this file are Copyright 2023 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2023 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/manifold/ManifoldGeometry.h"
-#include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
+#include <manifold/cross_section.h>
+#include <manifold/manifold.h>
+#include <cstddef>
+#include <cstdint>
+#include <exception>
+#include <functional>
 #include <map>
+#include <memory>
 #include <set>
-#include <functional>
-#include <exception>
 #include <sstream>
+#include <string>
 #include <utility>
-#include <cstdint>
-#include <manifold/cross_section.h>
-#include <manifold/manifold.h>
+#include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "geometry/manifold/manifoldutils.h"
 #include "glview/ColorMap.h"
 #include "glview/RenderSettings.h"
-#include <cstddef>
-#include <string>
-#include <memory>
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
@@ -32,24 +33,21 @@ Result vector_convert(V const& v) {
   return Result(v[0], v[1], v[2]);
 }
 
-}
+}  // namespace
 
 ManifoldGeometry::ManifoldGeometry() : manifold_(manifold::Manifold()) {}
 
 ManifoldGeometry::ManifoldGeometry(
-  manifold::Manifold mani,
-  const std::set<uint32_t>& originalIDs,
-  const std::map<uint32_t, Color4f>& originalIDToColor,
-  const std::set<uint32_t>& subtractedIDs)
-  : manifold_(std::move(mani)),
-  originalIDs_(originalIDs),
-  originalIDToColor_(originalIDToColor),
-  subtractedIDs_(subtractedIDs)
-{
-}
-
-std::unique_ptr<Geometry> ManifoldGeometry::copy() const
-{
+    manifold::Manifold mani,
+    const std::set<uint32_t>& originalIDs,
+    const std::map<uint32_t, Color4f>& originalIDToColor,
+    const std::set<uint32_t>& subtractedIDs)
+    : manifold_(std::move(mani)),
+      originalIDs_(originalIDs),
+      originalIDToColor_(originalIDToColor),
+      subtractedIDs_(subtractedIDs) {}
+
+std::unique_ptr<Geometry> ManifoldGeometry::copy() const {
   return std::make_unique<ManifoldGeometry>(*this);
 }
 
@@ -82,7 +80,8 @@ void ManifoldGeometry::clear() {
 }
 
 size_t ManifoldGeometry::memsize() const {
-  // We don't introspect on the manifold here, as this would force it to leaf node (ie. would render it).
+  // We don't introspect on the manifold here, as this would force it to leaf
+  // node (ie. would render it).
   return 0;
 }
 
@@ -94,13 +93,13 @@ std::string ManifoldGeometry::dump() const {
       << "\n status: " << ManifoldUtils::statusToString(manifold.Status())
       << "\n genus: " << manifold.Genus()
       << "\n num vertices: " << meshgl.NumVert()
-      << "\n num polygons: " << meshgl.NumTri()
-      << "\n polygons data:";
+      << "\n num polygons: " << meshgl.NumTri() << "\n polygons data:";
 
   for (size_t faceid = 0; faceid < meshgl.NumTri(); faceid++) {
     out << "\n  polygon begin:";
     for (const int j : {0, 1, 2}) {
-      auto v = vector_convert<Vector3d>(meshgl.GetVertPos(meshgl.GetTriVerts(faceid)[j]));
+      auto v = vector_convert<Vector3d>(
+          meshgl.GetVertPos(meshgl.GetTriVerts(faceid)[j]));
       out << "\n   vertex:" << v;
     }
   }
@@ -118,15 +117,15 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
 
   // first 3 channels are xyz coordinate
   for (size_t i = 0; i < mesh.vertProperties.size(); i += mesh.numProp)
-    ps->vertices.emplace_back(
-      mesh.vertProperties[i],
-      mesh.vertProperties[i + 1],
-      mesh.vertProperties[i + 2]);
+    ps->vertices.emplace_back(mesh.vertProperties[i],
+                              mesh.vertProperties[i + 1],
+                              mesh.vertProperties[i + 2]);
 
   ps->colors.reserve(originalIDToColor_.size());
   ps->color_indices.reserve(ps->indices.size());
 
-  auto colorScheme = ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
+  auto colorScheme =
+      ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
   int32_t faceFrontColorIndex = -1;
   int32_t faceBackColorIndex = -1;
 
@@ -134,42 +133,44 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
   std::map<uint32_t, int32_t> originalIDToColorIndex;
 
   auto getFaceFrontColorIndex = [&]() -> int {
-      if (faceFrontColorIndex < 0) {
-        faceFrontColorIndex = ps->colors.size();
-        ps->colors.push_back(ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR));
-      }
-      return faceFrontColorIndex;
-    };
+    if (faceFrontColorIndex < 0) {
+      faceFrontColorIndex = ps->colors.size();
+      ps->colors.push_back(
+          ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR));
+    }
+    return faceFrontColorIndex;
+  };
   auto getFaceBackColorIndex = [&]() -> int {
-      if (faceBackColorIndex < 0) {
-        faceBackColorIndex = ps->colors.size();
-        ps->colors.push_back(ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_BACK_COLOR));
-      }
-      return faceBackColorIndex;
-    };
+    if (faceBackColorIndex < 0) {
+      faceBackColorIndex = ps->colors.size();
+      ps->colors.push_back(
+          ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_BACK_COLOR));
+    }
+    return faceBackColorIndex;
+  };
 
   auto getColorIndex = [&](uint32_t originalID) -> int32_t {
-      if (subtractedIDs_.find(originalID) != subtractedIDs_.end()) {
-        return getFaceBackColorIndex();
-      }
-      auto colorIndexIt = originalIDToColorIndex.find(originalID);
-      if (colorIndexIt != originalIDToColorIndex.end()) {
-        return colorIndexIt->second;
-      }
-      auto colorIt = originalIDToColor_.find(originalID);
-      if (colorIt == originalIDToColor_.end()) {
-        return getFaceFrontColorIndex();
-      }
-      const auto& color = colorIt->second;
+    if (subtractedIDs_.find(originalID) != subtractedIDs_.end()) {
+      return getFaceBackColorIndex();
+    }
+    auto colorIndexIt = originalIDToColorIndex.find(originalID);
+    if (colorIndexIt != originalIDToColorIndex.end()) {
+      return colorIndexIt->second;
+    }
+    auto colorIt = originalIDToColor_.find(originalID);
+    if (colorIt == originalIDToColor_.end()) {
+      return getFaceFrontColorIndex();
+    }
+    const auto& color = colorIt->second;
 
-      auto pair = colorToIndex.insert({color, ps->colors.size()});
-      if (pair.second) {
-        ps->colors.push_back(color);
-      }
-      int32_t color_index = pair.first->second;
-      originalIDToColorIndex[originalID] = color_index;
-      return color_index;
-    };
+    auto pair = colorToIndex.insert({color, ps->colors.size()});
+    if (pair.second) {
+      ps->colors.push_back(color);
+    }
+    int32_t color_index = pair.first->second;
+    originalIDToColorIndex[originalID] = color_index;
+    return color_index;
+  };
 
   auto start = mesh.runIndex[0];
   for (int run = 0, numRun = mesh.runIndex.size() - 1; run < numRun; ++run) {
@@ -182,10 +183,9 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
 
     auto colorIndex = getColorIndex(id);
     for (size_t i = start; i < end; i += 3) {
-      ps->indices.push_back({
-        static_cast<int>(mesh.triVerts[i]),
-        static_cast<int>(mesh.triVerts[i + 1]),
-        static_cast<int>(mesh.triVerts[i + 2])});
+      ps->indices.push_back({static_cast<int>(mesh.triVerts[i]),
+                             static_cast<int>(mesh.triVerts[i + 1]),
+                             static_cast<int>(mesh.triVerts[i + 2])});
       ps->color_indices.push_back(colorIndex);
     }
     start = end;
@@ -195,22 +195,26 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
 
 #ifdef ENABLE_CGAL
 template <typename Polyhedron>
-class CGALPolyhedronBuilderFromManifold : public CGAL::Modifier_base<typename Polyhedron::HalfedgeDS>
-{
+class CGALPolyhedronBuilderFromManifold
+    : public CGAL::Modifier_base<typename Polyhedron::HalfedgeDS> {
   using HDS = typename Polyhedron::HalfedgeDS;
-  using CGAL_Polybuilder = CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
-public:
+  using CGAL_Polybuilder =
+      CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
+
+ public:
   using CGALPoint = typename CGAL_Polybuilder::Point_3;
 
   const manifold::MeshGL64& meshgl;
-  CGALPolyhedronBuilderFromManifold(const manifold::MeshGL64& mesh) : meshgl(mesh) { }
+  CGALPolyhedronBuilderFromManifold(const manifold::MeshGL64& mesh)
+      : meshgl(mesh) {}
 
   void operator()(HDS& hds) override {
     CGAL_Polybuilder B(hds, true);
 
     B.begin_surface(meshgl.NumVert(), meshgl.NumTri());
     for (size_t vertid = 0; vertid < meshgl.NumVert(); vertid++)
-      B.add_vertex(CGALUtils::vector_convert<CGALPoint>(meshgl.GetVertPos(vertid)));
+      B.add_vertex(
+          CGALUtils::vector_convert<CGALPoint>(meshgl.GetVertPos(vertid)));
 
     for (size_t faceid = 0; faceid < meshgl.NumTri(); faceid++) {
       const auto tv = meshgl.GetTriVerts(faceid);
@@ -225,24 +229,27 @@ public:
 };
 
 template <class Polyhedron>
-std::shared_ptr<Polyhedron> ManifoldGeometry::toPolyhedron() const
-{
+std::shared_ptr<Polyhedron> ManifoldGeometry::toPolyhedron() const {
   auto p = std::make_shared<Polyhedron>();
   try {
     auto meshgl = getManifold().GetMeshGL64();
     CGALPolyhedronBuilderFromManifold<Polyhedron> builder(meshgl);
     p->delegate(builder);
   } catch (const CGAL::Assertion_exception& e) {
-    LOG(message_group::Error, "CGAL error in ManifoldGeometry::toPolyhedron(): %1$s", e.what());
+    LOG(message_group::Error,
+        "CGAL error in ManifoldGeometry::toPolyhedron(): %1$s", e.what());
   }
   return p;
 }
 
-template std::shared_ptr<CGAL::Polyhedron_3<CGAL_Kernel3>> ManifoldGeometry::toPolyhedron() const;
+template std::shared_ptr<CGAL::Polyhedron_3<CGAL_Kernel3>>
+ManifoldGeometry::toPolyhedron() const;
 
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
 
-ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs, manifold::OpType opType) const {
+ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry& lhs,
+                                         const ManifoldGeometry& rhs,
+                                         manifold::OpType opType) const {
   auto mani = lhs.manifold_.Boolean(rhs.manifold_, opType);
   auto originalIDToColor = lhs.originalIDToColor_;
   auto subtractedIDs = lhs.subtractedIDs_;
@@ -251,7 +258,8 @@ ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry& lhs, const Mani
   originalIDs.insert(rhs.originalIDs_.begin(), rhs.originalIDs_.end());
 
   if (opType == manifold::OpType::Subtract) {
-    // Mark all the original ids coming from rhs as subtracted, unless they're mapped to a color.
+    // Mark all the original ids coming from rhs as subtracted, unless they're
+    // mapped to a color.
     for (const auto id : rhs.originalIDs_) {
       auto it = rhs.originalIDToColor_.find(id);
       if (it != rhs.originalIDToColor_.end()) {
@@ -262,17 +270,21 @@ ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry& lhs, const Mani
     }
   } else {
     // Add the id -> color mapping from the rhs.
-    originalIDToColor.insert(rhs.originalIDToColor_.begin(), rhs.originalIDToColor_.end());
+    originalIDToColor.insert(rhs.originalIDToColor_.begin(),
+                             rhs.originalIDToColor_.end());
     subtractedIDs.insert(rhs.subtractedIDs_.begin(), rhs.subtractedIDs_.end());
   }
   return {mani, originalIDs, originalIDToColor, subtractedIDs};
 }
 
-std::shared_ptr<ManifoldGeometry> minkowskiOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs) {
+std::shared_ptr<ManifoldGeometry> minkowskiOp(const ManifoldGeometry& lhs,
+                                              const ManifoldGeometry& rhs) {
 // FIXME: How to deal with operation not supported?
 #ifdef ENABLE_CGAL
-  auto lhs_nef = std::shared_ptr<CGALNefGeometry>(CGALUtils::createNefPolyhedronFromPolySet(*lhs.toPolySet()));
-  auto rhs_nef = std::shared_ptr<CGALNefGeometry>(CGALUtils::createNefPolyhedronFromPolySet(*rhs.toPolySet()));
+  auto lhs_nef = std::shared_ptr<CGALNefGeometry>(
+      CGALUtils::createNefPolyhedronFromPolySet(*lhs.toPolySet()));
+  auto rhs_nef = std::shared_ptr<CGALNefGeometry>(
+      CGALUtils::createNefPolyhedronFromPolySet(*rhs.toPolySet()));
   if (lhs_nef->isEmpty() || rhs_nef->isEmpty()) {
     return {};
   }
@@ -284,32 +296,37 @@ std::shared_ptr<ManifoldGeometry> minkowskiOp(const ManifoldGeometry& lhs, const
       return ManifoldUtils::createManifoldFromPolySet(*ps);
     }
   } catch (const std::exception& e) {
-    LOG(message_group::Error,
-        "Nef minkoswki operation failed: %1$s\n", e.what());
+    LOG(message_group::Error, "Nef minkoswki operation failed: %1$s\n",
+        e.what());
   } catch (...) {
-    LOG(message_group::Warning,
-        "Nef minkowski hard-crashed");
+    LOG(message_group::Warning, "Nef minkowski hard-crashed");
   }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
   return {};
 }
 
-ManifoldGeometry ManifoldGeometry::operator+(const ManifoldGeometry& other) const {
+ManifoldGeometry ManifoldGeometry::operator+(
+    const ManifoldGeometry& other) const {
   return binOp(*this, other, manifold::OpType::Add);
 }
 
-ManifoldGeometry ManifoldGeometry::operator*(const ManifoldGeometry& other) const {
+ManifoldGeometry ManifoldGeometry::operator*(
+    const ManifoldGeometry& other) const {
   return binOp(*this, other, manifold::OpType::Intersect);
 }
 
-ManifoldGeometry ManifoldGeometry::operator-(const ManifoldGeometry& other) const {
+ManifoldGeometry ManifoldGeometry::operator-(
+    const ManifoldGeometry& other) const {
   return binOp(*this, other, manifold::OpType::Subtract);
 }
 
-ManifoldGeometry ManifoldGeometry::minkowski(const ManifoldGeometry& other) const {
+ManifoldGeometry ManifoldGeometry::minkowski(
+    const ManifoldGeometry& other) const {
   std::shared_ptr<ManifoldGeometry> geom = minkowskiOp(*this, other);
-  if (geom) return *geom;
-  else return {};
+  if (geom)
+    return *geom;
+  else
+    return {};
 }
 
 Polygon2d ManifoldGeometry::slice() const {
@@ -324,12 +341,9 @@ Polygon2d ManifoldGeometry::project() const {
 
 void ManifoldGeometry::transform(const Transform3d& mat) {
   manifold::mat3x4 glMat(
-    // Column-major ordering
-    {mat(0, 0), mat(1, 0), mat(2, 0)},
-    {mat(0, 1), mat(1, 1), mat(2, 1)},
-    {mat(0, 2), mat(1, 2), mat(2, 2)},
-    {mat(0, 3), mat(1, 3), mat(2, 3)}
-    );
+      // Column-major ordering
+      {mat(0, 0), mat(1, 0), mat(2, 0)}, {mat(0, 1), mat(1, 1), mat(2, 1)},
+      {mat(0, 2), mat(1, 2), mat(2, 2)}, {mat(0, 3), mat(1, 3), mat(2, 3)});
   manifold_ = getManifold().Transform(glMat);
 }
 
@@ -354,8 +368,7 @@ void ManifoldGeometry::toOriginal() {
   subtractedIDs_.clear();
 }
 
-BoundingBox ManifoldGeometry::getBoundingBox() const
-{
+BoundingBox ManifoldGeometry::getBoundingBox() const {
   BoundingBox result;
   manifold::Box bbox = getManifold().BoundingBox();
   result.extend(vector_convert<Eigen::Vector3d>(bbox.min));
@@ -363,12 +376,16 @@ BoundingBox ManifoldGeometry::getBoundingBox() const
   return result;
 }
 
-void ManifoldGeometry::resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) {
-  transform(GeometryUtils::getResizeTransform(this->getBoundingBox(), newsize, autosize));
+void ManifoldGeometry::resize(const Vector3d& newsize,
+                              const Eigen::Matrix<bool, 3, 1>& autosize) {
+  transform(GeometryUtils::getResizeTransform(this->getBoundingBox(), newsize,
+                                              autosize));
 }
 
-/*! Iterate over all vertices' points until the function returns true (for done). */
-void ManifoldGeometry::foreachVertexUntilTrue(const std::function<bool(const manifold::vec3& pt)>& f) const {
+/*! Iterate over all vertices' points until the function returns true (for
+ * done). */
+void ManifoldGeometry::foreachVertexUntilTrue(
+    const std::function<bool(const manifold::vec3& pt)>& f) const {
   auto mesh = getManifold().GetMeshGL64();
   const auto numVert = mesh.NumVert();
   for (size_t v = 0; v < numVert; ++v) {
diff --git a/src/geometry/manifold/ManifoldGeometry.h b/src/geometry/manifold/ManifoldGeometry.h
index 1bcce76e3..482e111c4 100644
--- a/src/geometry/manifold/ManifoldGeometry.h
+++ b/src/geometry/manifold/ManifoldGeometry.h
@@ -1,16 +1,17 @@
-// Portions of this file are Copyright 2023 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2023 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #pragma once
 
-#include "geometry/Geometry.h"
-#include <functional>
-#include <cstdint>
-#include <memory>
-#include "geometry/linalg.h"
 #include <manifold/manifold.h>
 #include <cstddef>
+#include <cstdint>
+#include <functional>
 #include <map>
+#include <memory>
 #include <set>
 #include <string>
+#include "geometry/Geometry.h"
+#include "geometry/linalg.h"
 
 namespace manifold {
 class Manifold;
@@ -18,17 +19,15 @@ class Manifold;
 
 /*! A mutable polyhedron backed by a manifold::Manifold
  */
-class ManifoldGeometry : public Geometry
-{
-public:
+class ManifoldGeometry : public Geometry {
+ public:
   VISITABLE_GEOMETRY();
 
   ManifoldGeometry();
-  ManifoldGeometry(
-    manifold::Manifold object,
-    const std::set<uint32_t>& originalIDs = {},
-    const std::map<uint32_t, Color4f>& originalIDToColor = {},
-    const std::set<uint32_t>& subtractedIDs = {});
+  ManifoldGeometry(manifold::Manifold object,
+                   const std::set<uint32_t>& originalIDs = {},
+                   const std::map<uint32_t, Color4f>& originalIDToColor = {},
+                   const std::set<uint32_t>& subtractedIDs = {});
   ManifoldGeometry(const ManifoldGeometry& other) = default;
 
   [[nodiscard]] bool isEmpty() const override;
@@ -65,15 +64,20 @@ public:
   void transform(const Transform3d& mat) override;
   void setColor(const Color4f& c) override;
   void toOriginal();
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
+  void resize(const Vector3d& newsize,
+              const Eigen::Matrix<bool, 3, 1>& autosize) override;
 
-  /*! Iterate over all vertices' points until the function returns true (for done). */
-  void foreachVertexUntilTrue(const std::function<bool(const manifold::vec3& pt)>& f) const;
+  /*! Iterate over all vertices' points until the function returns true (for
+   * done). */
+  void foreachVertexUntilTrue(
+      const std::function<bool(const manifold::vec3& pt)>& f) const;
 
   const manifold::Manifold& getManifold() const;
 
-private:
-  ManifoldGeometry binOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs, manifold::OpType opType) const;
+ private:
+  ManifoldGeometry binOp(const ManifoldGeometry& lhs,
+                         const ManifoldGeometry& rhs,
+                         manifold::OpType opType) const;
 
   manifold::Manifold manifold_;
   std::set<uint32_t> originalIDs_;
diff --git a/src/geometry/manifold/Polygon2d-manifold.cc b/src/geometry/manifold/Polygon2d-manifold.cc
index a992c4691..20b247086 100644
--- a/src/geometry/manifold/Polygon2d-manifold.cc
+++ b/src/geometry/manifold/Polygon2d-manifold.cc
@@ -7,8 +7,7 @@
 /*!
    Triangulates this polygon2d and returns a 2D-in-3D PolySet.
  */
-std::unique_ptr<PolySet> Polygon2d::tessellate() const
-{
+std::unique_ptr<PolySet> Polygon2d::tessellate() const {
   PRINTDB("Polygon2d::tessellate(): %d outlines", this->outlines().size());
   return std::make_unique<PolySet>(*this);
 }
diff --git a/src/geometry/manifold/manifold-applyops-minkowski.cc b/src/geometry/manifold/manifold-applyops-minkowski.cc
index 6d7ae9e2c..9ec058929 100644
--- a/src/geometry/manifold/manifold-applyops-minkowski.cc
+++ b/src/geometry/manifold/manifold-applyops-minkowski.cc
@@ -1,224 +1,249 @@
-// Portions of this file are Copyright 2023 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2023 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #ifdef ENABLE_MANIFOLD
 
-#include <iterator>
 #include <cassert>
-#include <list>
 #include <exception>
+#include <iterator>
+#include <list>
 #include <memory>
 #include <utility>
 #include <vector>
 
-#include <CGAL/convex_hull_3.h>
 #include <CGAL/Surface_mesh/Surface_mesh.h>
+#include <CGAL/convex_hull_3.h>
 
-#include "geometry/cgal/cgal.h"
 #include "geometry/Geometry.h"
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/PolySet.h"
-#include "utils/printutils.h"
-#include "geometry/manifold/manifoldutils.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/cgal/cgalutils.h"
 #include "geometry/manifold/ManifoldGeometry.h"
+#include "geometry/manifold/manifoldutils.h"
 #include "utils/parallel.h"
+#include "utils/printutils.h"
 
 namespace ManifoldUtils {
 
 /*!
    children cannot contain nullptr objects
  */
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
+std::shared_ptr<const Geometry> applyMinkowski(
+    const Geometry::Geometries& children) {
   assert(children.size() >= 2);
 
   using Hull_kernel = CGAL::Epick;
   using Hull_Mesh = CGAL::Surface_mesh<CGAL::Point_3<Hull_kernel>>;
   using Hull_Points = std::vector<CGAL::Point_3<Hull_kernel>>;
 
-  auto surfaceMeshFromGeometry = [](const std::shared_ptr<const Geometry>& geom, bool *pIsConvexOut) -> std::shared_ptr<CGAL_Kernel3Mesh>
-    {
-      auto ps = std::dynamic_pointer_cast<const PolySet>(geom);
-      if (ps) {
-        auto mesh = CGALUtils::createSurfaceMeshFromPolySet<CGAL_Kernel3Mesh>(*ps);
-        if (pIsConvexOut) *pIsConvexOut = ps->isConvex();
+  auto surfaceMeshFromGeometry =
+      [](const std::shared_ptr<const Geometry>& geom,
+         bool* pIsConvexOut) -> std::shared_ptr<CGAL_Kernel3Mesh> {
+    auto ps = std::dynamic_pointer_cast<const PolySet>(geom);
+    if (ps) {
+      auto mesh =
+          CGALUtils::createSurfaceMeshFromPolySet<CGAL_Kernel3Mesh>(*ps);
+      if (pIsConvexOut)
+        *pIsConvexOut = ps->isConvex();
+      return mesh;
+    } else {
+      if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+        auto mesh =
+            ManifoldUtils::createSurfaceMeshFromManifold<CGAL_Kernel3Mesh>(
+                mani->getManifold());
+        if (pIsConvexOut)
+          *pIsConvexOut = CGALUtils::is_weakly_convex(*mesh);
         return mesh;
-      } else {
-        if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-          auto mesh = ManifoldUtils::createSurfaceMeshFromManifold<CGAL_Kernel3Mesh>(mani->getManifold());
-          if (pIsConvexOut) *pIsConvexOut = CGALUtils::is_weakly_convex(*mesh);
-          return mesh;
-        } else throw 0;
-      }
-      throw 0;
-    };
+      } else
+        throw 0;
+    }
+    throw 0;
+  };
 
   CGAL::Cartesian_converter<CGAL_Kernel3, Hull_kernel> conv;
   auto getHullPoints = [&](const CGAL_Polyhedron& poly) {
-      std::vector<Hull_kernel::Point_3> out;
-      out.reserve(poly.size_of_vertices());
-      for (auto pi = poly.vertices_begin(); pi != poly.vertices_end(); ++pi) {
-        out.push_back(conv(pi->point()));
-      }
-      return out;
-    };
+    std::vector<Hull_kernel::Point_3> out;
+    out.reserve(poly.size_of_vertices());
+    for (auto pi = poly.vertices_begin(); pi != poly.vertices_end(); ++pi) {
+      out.push_back(conv(pi->point()));
+    }
+    return out;
+  };
   auto getHullPointsFromMesh = [&](const CGAL_Kernel3Mesh& mesh) {
-      std::vector<Hull_kernel::Point_3> out;
-      out.reserve(mesh.number_of_vertices());
-      for (auto idx : mesh.vertices()) {
-        out.push_back(conv(mesh.point(idx)));
-      }
-      return out;
-    };
+    std::vector<Hull_kernel::Point_3> out;
+    out.reserve(mesh.number_of_vertices());
+    for (auto idx : mesh.vertices()) {
+      out.push_back(conv(mesh.point(idx)));
+    }
+    return out;
+  };
 
   CGAL::Timer t_tot;
   t_tot.start();
 
   auto it = children.begin();
-  std::vector<std::shared_ptr<const Geometry>> operands = {it->second, std::shared_ptr<const Geometry>()};
+  std::vector<std::shared_ptr<const Geometry>> operands = {
+      it->second, std::shared_ptr<const Geometry>()};
 
   try {
-    // Note: we could parallelize more, e.g. compute all decompositions ahead of time instead of doing them 2 by 2,
-    // but this could use substantially more memory.
+    // Note: we could parallelize more, e.g. compute all decompositions ahead of
+    // time instead of doing them 2 by 2, but this could use substantially more
+    // memory.
     while (++it != children.end()) {
       operands[1] = it->second;
 
       std::vector<std::list<Hull_Points>> part_points(2);
 
-      parallelizable_transform(operands.begin(), operands.begin() + 2, part_points.begin(),
-                               [&](std::shared_ptr<const Geometry>& operand) {
-          std::list<Hull_Points> part_points;
-
-          bool is_convex;
-          auto mesh = surfaceMeshFromGeometry(operand, &is_convex);
-          if (!mesh) throw 0;
-          if (mesh->is_empty()) {
-            throw 0;
-          }
+      parallelizable_transform(
+          operands.begin(), operands.begin() + 2, part_points.begin(),
+          [&](std::shared_ptr<const Geometry>& operand) {
+            std::list<Hull_Points> part_points;
+
+            bool is_convex;
+            auto mesh = surfaceMeshFromGeometry(operand, &is_convex);
+            if (!mesh)
+              throw 0;
+            if (mesh->is_empty()) {
+              throw 0;
+            }
 
-          if (is_convex) {
-            part_points.emplace_back(getHullPointsFromMesh(*mesh));
-          } else {
-            // The CGAL_Nef_polyhedron3 constructor can crash on bad polyhedron, so don't try
-            if (!mesh->is_valid()) throw 0;
-            CGAL_Nef_polyhedron3 decomposed_nef;
-            CGALUtils::convertSurfaceMeshToNef(*mesh, decomposed_nef);
-            CGAL::Timer t;
-            t.start();
-            CGAL::convex_decomposition_3(decomposed_nef);
-
-            // the first volume is the outer volume, which ignored in the decomposition
-            CGAL_Nef_polyhedron3::Volume_const_iterator ci = ++decomposed_nef.volumes_begin();
-            for (; ci != decomposed_nef.volumes_end(); ++ci) {
-              if (ci->mark()) {
-                CGAL_Polyhedron poly;
-                decomposed_nef.convert_inner_shell_to_polyhedron(ci->shells_begin(), poly);
-                part_points.emplace_back(getHullPoints(poly));
+            if (is_convex) {
+              part_points.emplace_back(getHullPointsFromMesh(*mesh));
+            } else {
+              // The CGAL_Nef_polyhedron3 constructor can crash on bad
+              // polyhedron, so don't try
+              if (!mesh->is_valid())
+                throw 0;
+              CGAL_Nef_polyhedron3 decomposed_nef;
+              CGALUtils::convertSurfaceMeshToNef(*mesh, decomposed_nef);
+              CGAL::Timer t;
+              t.start();
+              CGAL::convex_decomposition_3(decomposed_nef);
+
+              // the first volume is the outer volume, which ignored in the
+              // decomposition
+              CGAL_Nef_polyhedron3::Volume_const_iterator ci =
+                  ++decomposed_nef.volumes_begin();
+              for (; ci != decomposed_nef.volumes_end(); ++ci) {
+                if (ci->mark()) {
+                  CGAL_Polyhedron poly;
+                  decomposed_nef.convert_inner_shell_to_polyhedron(
+                      ci->shells_begin(), poly);
+                  part_points.emplace_back(getHullPoints(poly));
+                }
               }
-            }
 
-            PRINTDB("Minkowski: decomposed into %d convex parts", part_points.size());
-            t.stop();
-            PRINTDB("Minkowski: decomposition took %f s", t.time());
-          }
-          return part_points;
-        });
+              PRINTDB("Minkowski: decomposed into %d convex parts",
+                      part_points.size());
+              t.stop();
+              PRINTDB("Minkowski: decomposition took %f s", t.time());
+            }
+            return part_points;
+          });
 
       std::vector<Hull_kernel::Point_3> minkowski_points;
 
-      auto combineParts = [&](const Hull_Points& points0, const Hull_Points& points1) -> std::shared_ptr<const ManifoldGeometry> {
-          CGAL::Timer t;
+      auto combineParts = [&](const Hull_Points& points0,
+                              const Hull_Points& points1)
+          -> std::shared_ptr<const ManifoldGeometry> {
+        CGAL::Timer t;
 
-          t.start();
-          std::vector<Hull_kernel::Point_3> minkowski_points;
+        t.start();
+        std::vector<Hull_kernel::Point_3> minkowski_points;
 
-          minkowski_points.reserve(points0.size() * points1.size());
-          for (const auto& p0 : points0) {
-            for (const auto p1 : points1) {
-              minkowski_points.push_back(p0 + (p1 - CGAL::ORIGIN));
-            }
-          }
-
-          if (minkowski_points.size() <= 3) {
-            t.stop();
-            return std::make_shared<ManifoldGeometry>();
+        minkowski_points.reserve(points0.size() * points1.size());
+        for (const auto& p0 : points0) {
+          for (const auto p1 : points1) {
+            minkowski_points.push_back(p0 + (p1 - CGAL::ORIGIN));
           }
+        }
 
+        if (minkowski_points.size() <= 3) {
           t.stop();
-          PRINTDB("Minkowski: Point cloud creation (%d  %d -> %d) took %f ms", points0.size() % points1.size() % minkowski_points.size() % (t.time() * 1000));
-          t.reset();
-
-          t.start();
-
-          Hull_Mesh mesh;
-          CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(), mesh);
-
-          std::vector<Hull_kernel::Point_3> strict_points;
-          strict_points.reserve(minkowski_points.size());
-
-          for (auto v : mesh.vertices()) {
-            auto& p = mesh.point(v);
-
-            auto h = mesh.halfedge(v);
-            auto e = h;
-            bool collinear = false;
-            bool coplanar = true;
-
-            do {
-              auto& q = mesh.point(mesh.target(mesh.opposite(h)));
-              if (coplanar && !CGAL::coplanar(p, q,
-                                              mesh.point(mesh.target(mesh.next(h))),
-                                              mesh.point(mesh.target(mesh.next(mesh.opposite(mesh.next(h))))))) {
-                coplanar = false;
-              }
-
-
-              for (auto j = mesh.opposite(mesh.next(h));
-                   j != h && !collinear && !coplanar;
-                   j = mesh.opposite(mesh.next(j))) {
+          return std::make_shared<ManifoldGeometry>();
+        }
+
+        t.stop();
+        PRINTDB("Minkowski: Point cloud creation (%d  %d -> %d) took %f ms",
+                points0.size() % points1.size() % minkowski_points.size() %
+                    (t.time() * 1000));
+        t.reset();
+
+        t.start();
+
+        Hull_Mesh mesh;
+        CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(),
+                            mesh);
+
+        std::vector<Hull_kernel::Point_3> strict_points;
+        strict_points.reserve(minkowski_points.size());
+
+        for (auto v : mesh.vertices()) {
+          auto& p = mesh.point(v);
+
+          auto h = mesh.halfedge(v);
+          auto e = h;
+          bool collinear = false;
+          bool coplanar = true;
+
+          do {
+            auto& q = mesh.point(mesh.target(mesh.opposite(h)));
+            if (coplanar &&
+                !CGAL::coplanar(p, q, mesh.point(mesh.target(mesh.next(h))),
+                                mesh.point(mesh.target(
+                                    mesh.next(mesh.opposite(mesh.next(h))))))) {
+              coplanar = false;
+            }
 
-                auto& r = mesh.point(mesh.target(mesh.opposite(j)));
-                if (CGAL::collinear(p, q, r)) {
-                  collinear = true;
-                }
+            for (auto j = mesh.opposite(mesh.next(h));
+                 j != h && !collinear && !coplanar;
+                 j = mesh.opposite(mesh.next(j))) {
+              auto& r = mesh.point(mesh.target(mesh.opposite(j)));
+              if (CGAL::collinear(p, q, r)) {
+                collinear = true;
               }
+            }
 
-              h = mesh.opposite(mesh.next(h));
-            } while (h != e && !collinear);
+            h = mesh.opposite(mesh.next(h));
+          } while (h != e && !collinear);
 
-            if (!collinear && !coplanar) strict_points.push_back(p);
-          }
+          if (!collinear && !coplanar)
+            strict_points.push_back(p);
+        }
 
-          mesh.clear();
-          CGAL::convex_hull_3(strict_points.begin(), strict_points.end(), mesh);
+        mesh.clear();
+        CGAL::convex_hull_3(strict_points.begin(), strict_points.end(), mesh);
 
-          t.stop();
-          PRINTDB("Minkowski: Computing convex hull took %f s", t.time());
-          t.reset();
+        t.stop();
+        PRINTDB("Minkowski: Computing convex hull took %f s", t.time());
+        t.reset();
 
-          CGALUtils::triangulateFaces(mesh);
-          return ManifoldUtils::createManifoldFromSurfaceMesh(mesh);
-        };
+        CGALUtils::triangulateFaces(mesh);
+        return ManifoldUtils::createManifoldFromSurfaceMesh(mesh);
+      };
 
-      std::vector<std::shared_ptr<const ManifoldGeometry>> result_parts(part_points[0].size() * part_points[1].size());
+      std::vector<std::shared_ptr<const ManifoldGeometry>> result_parts(
+          part_points[0].size() * part_points[1].size());
       parallelizable_cross_product_transform(
-        part_points[0], part_points[1],
-        result_parts.begin(),
-        combineParts);
+          part_points[0], part_points[1], result_parts.begin(), combineParts);
 
-      if (it != std::next(children.begin())) operands[0].reset();
+      if (it != std::next(children.begin()))
+        operands[0].reset();
 
       CGAL::Timer t;
       t.start();
       PRINTDB("Minkowski: Computing union of %d parts", result_parts.size());
       Geometry::Geometries fake_children;
       for (const auto& part : result_parts) {
-        fake_children.push_back(std::make_pair(std::shared_ptr<const AbstractNode>(),
-                                               part));
+        fake_children.push_back(
+            std::make_pair(std::shared_ptr<const AbstractNode>(), part));
       }
-      auto N = ManifoldUtils::applyOperator3DManifold(fake_children, OpenSCADOperator::UNION);
+      auto N = ManifoldUtils::applyOperator3DManifold(fake_children,
+                                                      OpenSCADOperator::UNION);
 
       // FIXME: This should really never throw.
       // Assert once we figured out what went wrong with issue #1069?
-      if (!N) throw 0;
+      if (!N)
+        throw 0;
       t.stop();
       PRINTDB("Minkowski: Union done: %f s", t.time());
       t.reset();
@@ -233,14 +258,17 @@ std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& child
     return operands[0];
   } catch (const std::exception& e) {
     LOG(message_group::Warning,
-        "[manifold] Minkowski failed with error, falling back to Nef operation: %1$s\n", e.what());
+        "[manifold] Minkowski failed with error, falling back to Nef "
+        "operation: %1$s\n",
+        e.what());
   } catch (...) {
     LOG(message_group::Warning,
         "[manifold] Minkowski hard-crashed, falling back to Nef operation.");
   }
-  return ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::MINKOWSKI);
+  return ManifoldUtils::applyOperator3DManifold(children,
+                                                OpenSCADOperator::MINKOWSKI);
 }
 
 }  // namespace ManifoldUtils
 
-#endif // ENABLE_MANIFOLD
+#endif  // ENABLE_MANIFOLD
diff --git a/src/geometry/manifold/manifold-applyops.cc b/src/geometry/manifold/manifold-applyops.cc
index ee67c4f34..23d1dac7b 100644
--- a/src/geometry/manifold/manifold-applyops.cc
+++ b/src/geometry/manifold/manifold-applyops.cc
@@ -4,27 +4,28 @@
 #ifdef ENABLE_MANIFOLD
 
 #include <memory>
-#include "geometry/manifold/manifoldutils.h"
-#include "geometry/Geometry.h"
 #include "core/AST.h"
-#include "geometry/manifold/ManifoldGeometry.h"
 #include "core/node.h"
 #include "core/progress.h"
+#include "geometry/Geometry.h"
+#include "geometry/manifold/ManifoldGeometry.h"
+#include "geometry/manifold/manifoldutils.h"
 #include "utils/printutils.h"
 
 namespace ManifoldUtils {
 
-Location getLocation(const std::shared_ptr<const AbstractNode>& node)
-{
+Location getLocation(const std::shared_ptr<const AbstractNode>& node) {
   return node && node->modinst ? node->modinst->location() : Location::NONE;
 }
 
 /*!
    Applies op to all children and returns the result.
-   The child list should be guaranteed to contain non-NULL 3D or empty Geometry objects
+   The child list should be guaranteed to contain non-NULL 3D or empty Geometry
+   objects
  */
-std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geometries& children, OpenSCADOperator op)
-{
+std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(
+    const Geometry::Geometries& children,
+    OpenSCADOperator op) {
   std::shared_ptr<ManifoldGeometry> geom;
 
   bool foundFirst = false;
@@ -53,26 +54,28 @@ std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geomet
     }
 
     switch (op) {
-    case OpenSCADOperator::UNION:
-      *geom = *geom + *chN;
-      break;
-    case OpenSCADOperator::INTERSECTION:
-      *geom = *geom * *chN;
-      break;
-    case OpenSCADOperator::DIFFERENCE:
-      *geom = *geom - *chN;
-      break;
-    case OpenSCADOperator::MINKOWSKI:
-      *geom = geom->minkowski(*chN);
-      break;
-    default:
-      LOG(message_group::Error, "Unsupported CGAL operator: %1$d", static_cast<int>(op));
+      case OpenSCADOperator::UNION:
+        *geom = *geom + *chN;
+        break;
+      case OpenSCADOperator::INTERSECTION:
+        *geom = *geom * *chN;
+        break;
+      case OpenSCADOperator::DIFFERENCE:
+        *geom = *geom - *chN;
+        break;
+      case OpenSCADOperator::MINKOWSKI:
+        *geom = geom->minkowski(*chN);
+        break;
+      default:
+        LOG(message_group::Error, "Unsupported CGAL operator: %1$d",
+            static_cast<int>(op));
     }
-    if (item.first) item.first->progress_report();
+    if (item.first)
+      item.first->progress_report();
   }
   return geom;
 }
 
-}   // namespace ManifoldUtils
+}  // namespace ManifoldUtils
 
-#endif // ENABLE_MANIFOLD
+#endif  // ENABLE_MANIFOLD
diff --git a/src/geometry/manifold/manifoldutils.cc b/src/geometry/manifold/manifoldutils.cc
index 4ce153fa2..4402ac6c5 100644
--- a/src/geometry/manifold/manifoldutils.cc
+++ b/src/geometry/manifold/manifoldutils.cc
@@ -1,30 +1,31 @@
-// Portions of this file are Copyright 2023 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2023 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/manifold/manifoldutils.h"
 
-#include <cstddef>
-#include <optional>
-#include <vector>
 #include <cassert>
+#include <cstddef>
+#include <cstdint>
+#include <exception>
 #include <map>
+#include <memory>
+#include <optional>
 #include <set>
-#include <exception>
 #include <utility>
-#include <cstdint>
-#include <memory>
+#include <vector>
 
 #include <manifold/polygon.h>
 #ifdef ENABLE_CGAL
-#include <CGAL/convex_hull_3.h>
 #include <CGAL/Surface_mesh.h>
+#include <CGAL/convex_hull_3.h>
 #endif
 
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
+#include "geometry/PolySetBuilder.h"
+#include "geometry/PolySetUtils.h"
 #include "geometry/linalg.h"
 #include "geometry/manifold/ManifoldGeometry.h"
-#include "geometry/PolySetBuilder.h"
 #include "utils/printutils.h"
-#include "geometry/PolySetUtils.h"
-#include "geometry/PolySet.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
@@ -33,8 +34,8 @@ using Error = manifold::Manifold::Error;
 
 namespace {
 
-std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(const PolySet& ps)
-{
+std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(
+    const PolySet& ps) {
   assert(ps.isTriangular());
 
   manifold::MeshGL64 mesh;
@@ -63,7 +64,6 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(const Poly
   }
   auto next_id = manifold::Manifold::ReserveIDs(colorToFaceIndices.size());
   for (const auto& [color, faceIndices] : colorToFaceIndices) {
-
     auto id = next_id++;
     if (color.has_value()) {
       originalIDToColor[id] = color.value();
@@ -100,37 +100,49 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(const Poly
     }
   }
 
-  return std::make_shared<ManifoldGeometry>(mani, originalIDs, originalIDToColor);
+  return std::make_shared<ManifoldGeometry>(mani, originalIDs,
+                                            originalIDToColor);
 }
 
 }  // namespace
 
 namespace ManifoldUtils {
 
-const char *statusToString(Error status) {
+const char* statusToString(Error status) {
   switch (status) {
-  case Error::NoError: return "NoError";
-  case Error::NonFiniteVertex: return "NonFiniteVertex";
-  case Error::NotManifold: return "NotManifold";
-  case Error::VertexOutOfBounds: return "VertexOutOfBounds";
-  case Error::PropertiesWrongLength: return "PropertiesWrongLength";
-  case Error::MissingPositionProperties: return "MissingPositionProperties";
-  case Error::MergeVectorsDifferentLengths: return "MergeVectorsDifferentLengths";
-  case Error::MergeIndexOutOfBounds: return "MergeIndexOutOfBounds";
-  case Error::TransformWrongLength: return "TransformWrongLength";
-  case Error::RunIndexWrongLength: return "RunIndexWrongLength";
-  case Error::FaceIDWrongLength: return "FaceIDWrongLength";
-  default: return "unknown";
+    case Error::NoError:
+      return "NoError";
+    case Error::NonFiniteVertex:
+      return "NonFiniteVertex";
+    case Error::NotManifold:
+      return "NotManifold";
+    case Error::VertexOutOfBounds:
+      return "VertexOutOfBounds";
+    case Error::PropertiesWrongLength:
+      return "PropertiesWrongLength";
+    case Error::MissingPositionProperties:
+      return "MissingPositionProperties";
+    case Error::MergeVectorsDifferentLengths:
+      return "MergeVectorsDifferentLengths";
+    case Error::MergeIndexOutOfBounds:
+      return "MergeIndexOutOfBounds";
+    case Error::TransformWrongLength:
+      return "TransformWrongLength";
+    case Error::RunIndexWrongLength:
+      return "RunIndexWrongLength";
+    case Error::FaceIDWrongLength:
+      return "FaceIDWrongLength";
+    default:
+      return "unknown";
   }
 }
 
-std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
-{
-  // 1. If the PolySet is already manifold, we should be able to build a Manifold object directly
-  // (through using manifold::Mesh).
-  // We need to make sure our PolySet is triangulated before doing that.
-  // Note: We currently don't have a way of directly checking if a PolySet is manifold,
-  // so we just try converting to a Manifold object and check its status.
+std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps) {
+  // 1. If the PolySet is already manifold, we should be able to build a
+  // Manifold object directly (through using manifold::Mesh). We need to make
+  // sure our PolySet is triangulated before doing that. Note: We currently
+  // don't have a way of directly checking if a PolySet is manifold, so we just
+  // try converting to a Manifold object and check its status.
   std::unique_ptr<const PolySet> triangulated;
   if (!ps.isTriangular()) {
     triangulated = PolySetUtils::tessellate_faces(ps);
@@ -143,12 +155,13 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
     return mani;
   }
 
-  LOG(message_group::Warning, "PolySet -> Manifold conversion failed: %1$s\n"
+  LOG(message_group::Warning,
+      "PolySet -> Manifold conversion failed: %1$s\n"
       "Trying to repair and reconstruct mesh..",
       ManifoldUtils::statusToString(mani->getManifold().Status()));
 
-  // 2. If the PolySet couldn't be converted into a Manifold object, let's try to repair it.
-  // We currently have to utilize some CGAL functions to do this.
+  // 2. If the PolySet couldn't be converted into a Manifold object, let's try
+  // to repair it. We currently have to utilize some CGAL functions to do this.
 #ifdef ENABLE_CGAL
   try {
     PolySet psq(ps);
@@ -165,7 +178,8 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
       for (size_t i = 0, n = points3d.size(); i < n; i++) {
         points[i] = CGALUtils::vector_convert<K::Point_3>(points3d[i]);
       }
-      if (points.size() <= 3) return std::make_shared<ManifoldGeometry>();
+      if (points.size() <= 3)
+        return std::make_shared<ManifoldGeometry>();
 
       // Apply hull
       CGAL::Surface_mesh<CGAL::Point_3<K>> r;
@@ -184,16 +198,18 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
     }
 
     auto geom = createManifoldFromSurfaceMesh(m);
-    // TODO: preserve color if polyset is fully monochrome, or maybe pass colors around in surface mesh?
+    // TODO: preserve color if polyset is fully monochrome, or maybe pass colors
+    // around in surface mesh?
     return geom;
   } catch (const std::exception& e) {
     LOG(message_group::Error, "[manifold] CGAL error: %1$s", e.what());
   }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
   return std::make_shared<ManifoldGeometry>();
 }
 
-std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(const std::shared_ptr<const Geometry>& geom) {
+std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(
+    const std::shared_ptr<const Geometry>& geom) {
   if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     return mani;
   }
@@ -215,8 +231,8 @@ Polygon2d polygonsToPolygon2d(const manifold::Polygons& polygons) {
   return poly2d;
 }
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d)
-{
+std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(
+    const Polygon2d& polygon2d) {
   auto polyset = std::make_unique<PolySet>(2);
   polyset->setTriangular(true);
 
@@ -236,19 +252,18 @@ std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d&
     polyset->indices.push_back({triangle[0], triangle[1], triangle[2]});
   }
   return polyset;
-
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMesh& tm)
-{
+std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(
+    const SurfaceMesh& tm) {
   using vertex_descriptor = typename SurfaceMesh::Vertex_index;
 
   manifold::MeshGL64 meshgl;
 
   meshgl.numProp = 3;
   meshgl.vertProperties.resize(tm.number_of_vertices() * 3);
-  for (vertex_descriptor vd : tm.vertices()){
+  for (vertex_descriptor vd : tm.vertices()) {
     const auto& v = tm.point(vd);
     meshgl.vertProperties[3 * vd] = v.x();
     meshgl.vertProperties[3 * vd + 1] = v.y();
@@ -260,15 +275,18 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMes
     size_t idx[3];
     size_t i = 0;
     for (vertex_descriptor vd : vertices_around_face(tm.halfedge(f), tm)) {
-      if (i >= 3) break;
+      if (i >= 3)
+        break;
       idx[i++] = vd;
     }
-    if (i < 3) continue;
+    if (i < 3)
+      continue;
     for (size_t j : {0, 1, 2})
       meshgl.triVerts.emplace_back(idx[j]);
   }
 
-  assert((meshgl.triVerts.size() == tm.number_of_faces() * 3) || !"Mesh was not triangular!");
+  assert((meshgl.triVerts.size() == tm.number_of_faces() * 3) ||
+         !"Mesh was not triangular!");
 
   auto mani = manifold::Manifold(meshgl).AsOriginal();
   if (mani.Status() != Error::NoError) {
@@ -286,8 +304,8 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMes
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(const manifold::Manifold& mani)
-{
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(
+    const manifold::Manifold& mani) {
   const auto meshgl = mani.GetMeshGL64();
   auto mesh = std::make_shared<SurfaceMesh>();
   mesh->reserve(meshgl.NumVert(), meshgl.NumTri() * 3, meshgl.NumTri());
@@ -305,10 +323,16 @@ std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(const manifold::Manif
 }
 
 #ifdef ENABLE_CGAL
-template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& tm);
-template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const CGAL_DoubleMesh& tm);
-template std::shared_ptr<CGAL::Surface_mesh<manifold::vec3>> createSurfaceMeshFromManifold<CGAL::Surface_mesh<manifold::vec3>>(const manifold::Manifold& mani);
-template std::shared_ptr<CGAL::Surface_mesh<CGAL_Point_3>> createSurfaceMeshFromManifold<CGAL::Surface_mesh<CGAL_Point_3>>(const manifold::Manifold& mani);
+template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(
+    const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& tm);
+template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(
+    const CGAL_DoubleMesh& tm);
+template std::shared_ptr<CGAL::Surface_mesh<manifold::vec3>>
+createSurfaceMeshFromManifold<CGAL::Surface_mesh<manifold::vec3>>(
+    const manifold::Manifold& mani);
+template std::shared_ptr<CGAL::Surface_mesh<CGAL_Point_3>>
+createSurfaceMeshFromManifold<CGAL::Surface_mesh<CGAL_Point_3>>(
+    const manifold::Manifold& mani);
 #endif
 
 }  // namespace ManifoldUtils
diff --git a/src/geometry/manifold/manifoldutils.h b/src/geometry/manifold/manifoldutils.h
index 475869f9f..281614b94 100644
--- a/src/geometry/manifold/manifoldutils.h
+++ b/src/geometry/manifold/manifoldutils.h
@@ -4,31 +4,39 @@
 
 #include <CGAL/Surface_mesh/Surface_mesh.h>
 
-#include "geometry/Geometry.h"
 #include "core/enums.h"
+#include "geometry/Geometry.h"
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "manifold/manifold.h"
 
 namespace ManifoldUtils {
 
-const char *statusToString(manifold::Manifold::Error status);
+const char* statusToString(manifold::Manifold::Error status);
 
 std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps);
-std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(const std::shared_ptr<const Geometry>& geom);
+std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(
+    const std::shared_ptr<const Geometry>& geom);
 
 template <class SurfaceMesh>
-std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMesh& mesh);
+std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(
+    const SurfaceMesh& mesh);
 template <typename SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(const manifold::Manifold& mani);
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(
+    const manifold::Manifold& mani);
 
-std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geometries& children, OpenSCADOperator op);
+std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(
+    const Geometry::Geometries& children,
+    OpenSCADOperator op);
 
 Polygon2d polygonsToPolygon2d(const manifold::Polygons& polygons);
 
 #ifdef ENABLE_CGAL
-// FIXME: This shouldn't return const, but it does due to internal implementation details.
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children);
+// FIXME: This shouldn't return const, but it does due to internal
+// implementation details.
+std::shared_ptr<const Geometry> applyMinkowski(
+    const Geometry::Geometries& children);
 #endif
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d);
-}
+std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(
+    const Polygon2d& polygon2d);
+}  // namespace ManifoldUtils
diff --git a/src/geometry/roof_ss.cc b/src/geometry/roof_ss.cc
index 2d781b76b..b5da3a6a3 100644
--- a/src/geometry/roof_ss.cc
+++ b/src/geometry/roof_ss.cc
@@ -3,17 +3,17 @@
 
 #include "geometry/roof_ss.h"
 
-#include <vector>
 #include <clipper2/clipper.engine.h>
-#include <iterator>
 #include <functional>
+#include <iterator>
 #include <memory>
+#include <vector>
 
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
+#include <CGAL/Partition_traits_2.h>
 #include <CGAL/Polygon_with_holes_2.h>
 #include <CGAL/create_straight_skeleton_from_polygon_with_holes_2.h>
 #include <CGAL/partition_2.h>
-#include <CGAL/Partition_traits_2.h>
 #if CGAL_VERSION_NR < CGAL_VERSION_NUMBER(6, 0, 0)
 #include <boost/shared_ptr.hpp>
 #endif
@@ -21,15 +21,17 @@
 #include <algorithm>
 #include <map>
 
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
-#include "geometry/GeometryUtils.h"
-#include "geometry/ClipperUtils.h"
 #include "core/RoofNode.h"
+#include "geometry/ClipperUtils.h"
+#include "geometry/GeometryUtils.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
-#define RAISE_ROOF_EXCEPTION(message) \
-        throw RoofNode::roof_exception((boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message)).str());
+#define RAISE_ROOF_EXCEPTION(message)                                     \
+  throw RoofNode::roof_exception(                                         \
+      (boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message)) \
+          .str());
 
 namespace roof_ss {
 
@@ -50,8 +52,8 @@ using CGAL_SsPtr = boost::shared_ptr<CGAL_Ss>;
 using CGAL_SsPtr = std::shared_ptr<CGAL_Ss>;
 #endif
 
-CGAL_Polygon_2 to_cgal_polygon_2(const Clipper2Lib::Path64& path, int scale_bits)
-{
+CGAL_Polygon_2 to_cgal_polygon_2(const Clipper2Lib::Path64& path,
+                                 int scale_bits) {
   CGAL_Polygon_2 poly;
   const double scale = std::ldexp(1.0, -scale_bits);
   for (auto v : path) {
@@ -61,23 +63,26 @@ CGAL_Polygon_2 to_cgal_polygon_2(const Clipper2Lib::Path64& path, int scale_bits
 }
 
 // break a list of outlines into polygons with holes
-std::vector<CGAL_Polygon_with_holes_2> polygons_with_holes(const Clipper2Lib::PolyTree64& polytree, int scale_bits)
-{
+std::vector<CGAL_Polygon_with_holes_2> polygons_with_holes(
+    const Clipper2Lib::PolyTree64& polytree,
+    int scale_bits) {
   std::vector<CGAL_Polygon_with_holes_2> ret;
 
   // lambda for recursive walk through polytree
-  std::function<void (const Clipper2Lib::PolyPath64&)> walk = [&](const Clipper2Lib::PolyPath64& c) {
-      // outer path
-      CGAL_Polygon_with_holes_2 c_poly(to_cgal_polygon_2(c.Polygon(), scale_bits));
-      // holes
-      for (const auto& cc : c) {
-        c_poly.add_hole(to_cgal_polygon_2(cc->Polygon(), scale_bits));
-        for (const auto& ccc : *cc)
-          walk(*ccc);
-      }
-      ret.push_back(c_poly);
-      return;
-    };
+  std::function<void(const Clipper2Lib::PolyPath64&)> walk =
+      [&](const Clipper2Lib::PolyPath64& c) {
+        // outer path
+        CGAL_Polygon_with_holes_2 c_poly(
+            to_cgal_polygon_2(c.Polygon(), scale_bits));
+        // holes
+        for (const auto& cc : c) {
+          c_poly.add_hole(to_cgal_polygon_2(cc->Polygon(), scale_bits));
+          for (const auto& ccc : *cc)
+            walk(*ccc);
+        }
+        ret.push_back(c_poly);
+        return;
+      };
 
   for (const auto& root_node : polytree)
     walk(*root_node);
@@ -85,34 +90,38 @@ std::vector<CGAL_Polygon_with_holes_2> polygons_with_holes(const Clipper2Lib::Po
   return ret;
 }
 
-std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
-{
+std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly) {
   PolySetBuilder hatbuilder;
 
   const int scale_bits = ClipperUtils::scaleBitsFromPrecision();
-  const Clipper2Lib::Paths64 paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
-  const std::unique_ptr<Clipper2Lib::PolyTree64> polytree = ClipperUtils::sanitize(paths);
+  const Clipper2Lib::Paths64 paths =
+      ClipperUtils::fromPolygon2d(poly, scale_bits);
+  const std::unique_ptr<Clipper2Lib::PolyTree64> polytree =
+      ClipperUtils::sanitize(paths);
   auto poly_sanitized = ClipperUtils::toPolygon2d(*polytree, scale_bits);
 
   try {
     // roof
-    const std::vector<CGAL_Polygon_with_holes_2> shapes = polygons_with_holes(*polytree, scale_bits);
+    const std::vector<CGAL_Polygon_with_holes_2> shapes =
+        polygons_with_holes(*polytree, scale_bits);
     for (const CGAL_Polygon_with_holes_2& shape : shapes) {
       const CGAL_SsPtr ss = CGAL::create_interior_straight_skeleton_2(shape);
       // store heights of vertices
       auto vector2d_comp = [](const Vector2d& a, const Vector2d& b) {
-          return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
-        };
-      std::map<Vector2d, double, decltype(vector2d_comp)> heights(vector2d_comp);
+        return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
+      };
+      std::map<Vector2d, double, decltype(vector2d_comp)> heights(
+          vector2d_comp);
       for (auto v = ss->vertices_begin(); v != ss->vertices_end(); v++) {
         const Vector2d p(v->point().x(), v->point().y());
         heights[p] = v->time();
       }
 
-      for (auto ss_face = ss->faces_begin(); ss_face != ss->faces_end(); ss_face++) {
+      for (auto ss_face = ss->faces_begin(); ss_face != ss->faces_end();
+           ss_face++) {
         // convert ss_face to cgal polygon
         CGAL_Polygon_2 face;
-        for (auto h = ss_face->halfedge(); ;) {
+        for (auto h = ss_face->halfedge();;) {
           const CGAL_Point_2 pp = h->vertex()->point();
           face.push_back(pp);
           h = h->next();
@@ -121,19 +130,24 @@ std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
           }
         }
         if (!face.is_simple()) {
-          RAISE_ROOF_EXCEPTION("A non-simple face in straight skeleton, likely cause is cgal issue #5177");
+          RAISE_ROOF_EXCEPTION(
+              "A non-simple face in straight skeleton, likely cause is cgal "
+              "issue #5177");
         }
 
         // do convex partition if necessary
         std::vector<CGAL_PT::Polygon_2> facets;
-        CGAL::approx_convex_partition_2(face.vertices_begin(), face.vertices_end(),
+        CGAL::approx_convex_partition_2(face.vertices_begin(),
+                                        face.vertices_end(),
                                         std::back_inserter(facets));
 
         for (const auto& facet : facets) {
           std::vector<int> roof;
-          for (auto v = facet.vertices_begin(); v != facet.vertices_end(); v++) {
+          for (auto v = facet.vertices_begin(); v != facet.vertices_end();
+               v++) {
             const Vector2d vv(v->x(), v->y());
-            roof.push_back(hatbuilder.vertexIndex(Vector3d(v->x(), v->y(), heights[vv])));
+            roof.push_back(
+                hatbuilder.vertexIndex(Vector3d(v->x(), v->y(), heights[vv])));
           }
           hatbuilder.appendPolygon(roof);
         }
@@ -162,4 +176,4 @@ std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
   }
 }
 
-} // roof_ss
+}  // namespace roof_ss
diff --git a/src/geometry/roof_ss.h b/src/geometry/roof_ss.h
index 4d1817946..6bd69eafa 100644
--- a/src/geometry/roof_ss.h
+++ b/src/geometry/roof_ss.h
@@ -4,8 +4,8 @@
 #pragma once
 
 #include <memory>
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
 
 namespace roof_ss {
 std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly);
diff --git a/src/geometry/roof_vd.cc b/src/geometry/roof_vd.cc
index de90db677..392142d2f 100644
--- a/src/geometry/roof_vd.cc
+++ b/src/geometry/roof_vd.cc
@@ -3,25 +3,27 @@
 
 #include "geometry/roof_vd.h"
 
-#include <ostream>
-#include <cstdint>
-#include <memory>
+#include <algorithm>
+#include <boost/polygon/voronoi.hpp>
 #include <cmath>
 #include <cstddef>
-#include <algorithm>
+#include <cstdint>
 #include <map>
-#include <boost/polygon/voronoi.hpp>
+#include <memory>
+#include <ostream>
 #include <vector>
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
-#include "geometry/GeometryUtils.h"
-#include "geometry/ClipperUtils.h"
 #include "core/RoofNode.h"
+#include "geometry/ClipperUtils.h"
+#include "geometry/GeometryUtils.h"
 
-#define RAISE_ROOF_EXCEPTION(message) \
-        throw RoofNode::roof_exception((boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message)).str());
+#define RAISE_ROOF_EXCEPTION(message)                                     \
+  throw RoofNode::roof_exception(                                         \
+      (boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message)) \
+          .str());
 
 namespace roof_vd {
 
@@ -41,13 +43,14 @@ struct Point {
 struct Segment {
   Point p0;
   Point p1;
-  Segment(VD_int x1, VD_int y1, VD_int x2, VD_int y2) : p0(x1, y1), p1(x2, y2) {}
+  Segment(VD_int x1, VD_int y1, VD_int x2, VD_int y2)
+      : p0(x1, y1), p1(x2, y2) {}
   friend std::ostream& operator<<(std::ostream& os, const Segment& segment) {
     return os << segment.p0 << " -- " << segment.p1;
   }
 };
 
-} // roof_vd
+}  // namespace roof_vd
 
 // pass our Point and Segment structures to boost::polygon
 namespace boost::polygon {
@@ -59,8 +62,8 @@ template <>
 struct point_traits<roof_vd::Point> {
   using coordinate_type = roof_vd::VD_int;
 
-  static inline coordinate_type get(
-    const roof_vd::Point& point, const orientation_2d& orient) {
+  static inline coordinate_type get(const roof_vd::Point& point,
+                                    const orientation_2d& orient) {
     return (orient == HORIZONTAL) ? point.a : point.b;
   }
 };
@@ -73,23 +76,21 @@ struct segment_traits<roof_vd::Segment> {
   using coordinate_type = roof_vd::VD_int;
   using point_type = roof_vd::Point;
 
-  static inline point_type get(const roof_vd::Segment& segment, const direction_1d& dir) {
+  static inline point_type get(const roof_vd::Segment& segment,
+                               const direction_1d& dir) {
     return dir.to_int() ? segment.p1 : segment.p0;
   }
 };
-}  // boost::polygon
-
+}  // namespace boost::polygon
 
 namespace roof_vd {
 
-bool operator==(const Point& lhs, const Point& rhs)
-{
-  return lhs.a == rhs.a  &&  lhs.b == rhs.b;
+bool operator==(const Point& lhs, const Point& rhs) {
+  return lhs.a == rhs.a && lhs.b == rhs.b;
 }
 
-bool operator==(const Segment& lhs, const Segment& rhs)
-{
-  return lhs.p0 == rhs.p0  &&  lhs.p1 == rhs.p1;
+bool operator==(const Segment& lhs, const Segment& rhs) {
+  return lhs.p0 == rhs.p0 && lhs.p1 == rhs.p1;
 }
 
 bool segment_has_endpoint(const Segment& segment, const Point& point) {
@@ -97,7 +98,8 @@ bool segment_has_endpoint(const Segment& segment, const Point& point) {
 }
 
 double distance_to_segment(const Vector2d& vertex, const Segment& segment) {
-  Vector2d segment_normal(-(segment.p1.b - segment.p0.b), segment.p1.a - segment.p0.a);
+  Vector2d segment_normal(-(segment.p1.b - segment.p0.b),
+                          segment.p1.a - segment.p0.a);
   segment_normal.normalize();
   Vector2d p0_to_vertex(vertex[0] - segment.p0.a, vertex[1] - segment.p0.b);
   return std::abs(segment_normal.dot(p0_to_vertex));
@@ -108,10 +110,12 @@ double distance_to_point(const Vector2d& vertex, const Point& point) {
   return point_to_vertex.norm();
 }
 
-std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
-                                     const Vector2d& v0, const Vector2d& v1,
-                                     double fa, double fs)
-{
+std::vector<Vector2d> discretize_arc(const Point& point,
+                                     const Segment& segment,
+                                     const Vector2d& v0,
+                                     const Vector2d& v1,
+                                     double fa,
+                                     double fs) {
   std::vector<Vector2d> ret;
 
   const double max_angle_deviation = M_PI / 180.0 * fa / 2.0;
@@ -122,7 +126,8 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
   const Vector2d p1(segment.p1.a, segment.p1.b);
   const Vector2d p0_to_p1_norm = (p1 - p0).normalized();
 
-  const Vector2d projected_point = p0 + p0_to_p1_norm * p0_to_p1_norm.dot(p - p0);
+  const Vector2d projected_point =
+      p0 + p0_to_p1_norm * p0_to_p1_norm.dot(p - p0);
 
   const double point_distance = (p - projected_point).norm();
 
@@ -136,7 +141,8 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
   // segment parallel to the x axes on the negative side
   //     a_point -> A(a_point - point)
   Eigen::Matrix2d A, Ai;
-  Ai << point_direction.y(), point_direction.x(), -point_direction.x(), point_direction.y();
+  Ai << point_direction.y(), point_direction.x(), -point_direction.x(),
+      point_direction.y();
   A = Ai.inverse();
 
   // x coordinates of source and target
@@ -146,35 +152,34 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
     RAISE_ROOF_EXCEPTION("error in parabolic arc discretization");
   }
 
-  // in transformed coordinates the parabola has equation y = (x^2 - point_distance^2) / (2 point_distance)
+  // in transformed coordinates the parabola has equation y = (x^2 -
+  // point_distance^2) / (2 point_distance)
   auto y = [point_distance](double x) {
-      return (x * x - point_distance * point_distance) / (2 * point_distance);
-    };
-  auto y_prime = [point_distance](double x) {
-      return x / point_distance;
-    };
+    return (x * x - point_distance * point_distance) / (2 * point_distance);
+  };
+  auto y_prime = [point_distance](double x) { return x / point_distance; };
   // angle between a segment and the parabola
-  auto segment_angle = [y, y_prime](double x1, double x2){
-      double dx = x2 - x1,
-       dy = y(x2) - y(x1);
-      double tx = 1,
-             ty = (std::abs(x1) < std::abs(x2)) ? y_prime(x1) : y_prime(x2);
-      return std::abs(std::atan2(dx * ty - dy * tx, dx * tx + dy * ty));
-    };
+  auto segment_angle = [y, y_prime](double x1, double x2) {
+    double dx = x2 - x1, dy = y(x2) - y(x1);
+    double tx = 1,
+           ty = (std::abs(x1) < std::abs(x2)) ? y_prime(x1) : y_prime(x2);
+    return std::abs(std::atan2(dx * ty - dy * tx, dx * tx + dy * ty));
+  };
   // squared length of segment
-  auto segment_sqr_length = [y](double x1, double x2){
-      double dx = x2 - x1,
-       dy = y(x2) - y(x1);
-      return dx * dx + dy * dy;
-    };
+  auto segment_sqr_length = [y](double x1, double x2) {
+    double dx = x2 - x1, dy = y(x2) - y(x1);
+    return dx * dx + dy * dy;
+  };
 
-  std::vector<double> transformed_points_x = {transformed_v0_x, transformed_v1_x};
+  std::vector<double> transformed_points_x = {transformed_v0_x,
+                                              transformed_v1_x};
 
   for (;;) {
     double x1 = transformed_points_x.end()[-2];
     double x2 = transformed_points_x.end()[-1];
     if (segment_angle(x1, x2) > max_angle_deviation ||
-        (max_segment_sqr_length > 0 && segment_sqr_length(x1, x2) > max_segment_sqr_length)) {
+        (max_segment_sqr_length > 0 &&
+         segment_sqr_length(x1, x2) > max_segment_sqr_length)) {
       transformed_points_x.end()[-1] = 0.5 * x1 + 0.5 * x2;
     } else {
       if (x2 == transformed_v1_x) {
@@ -211,21 +216,24 @@ struct Faces_2_plus_1 {
 
 Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
                               const std::vector<Segment>& segments,
-                              double fa, double fs) {
+                              double fa,
+                              double fs) {
   Faces_2_plus_1 ret;
 
-  auto cell_contains_boundary_point = [&segments](const voronoi_diagram::cell_type *cell,
-                                                  const Point& point) {
-      Segment segment = segments[cell->source_index()];
-      return (cell->contains_segment() && segment_has_endpoint(segment, point) )
-             || (cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT
-                 && segment.p0 == point)
-             || (cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_END_POINT
-                 && segment.p1 == point);
-    };
+  auto cell_contains_boundary_point =
+      [&segments](const voronoi_diagram::cell_type* cell, const Point& point) {
+        Segment segment = segments[cell->source_index()];
+        return (cell->contains_segment() &&
+                segment_has_endpoint(segment, point)) ||
+               (cell->source_category() ==
+                    ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT &&
+                segment.p0 == point) ||
+               (cell->source_category() ==
+                    ::boost::polygon::SOURCE_CATEGORY_SEGMENT_END_POINT &&
+                segment.p1 == point);
+      };
 
   for (const auto& cell : vd.cells()) {
-
     std::size_t cell_index = cell.source_index();
     if (cell.is_degenerate()) {
       RAISE_ROOF_EXCEPTION("Voronoi error");
@@ -233,11 +241,13 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
     const Segment& segment = segments[cell_index];
 
     if (cell.contains_segment()) {
-      // walk around the cell, find edge starting from segment.p1 or passing through it
-      const voronoi_diagram::edge_type *edge = cell.incident_edge();
+      // walk around the cell, find edge starting from segment.p1 or passing
+      // through it
+      const voronoi_diagram::edge_type* edge = cell.incident_edge();
       for (;;) {
-        if (cell_contains_boundary_point(edge->twin()->cell(), segment.p1)
-            && !cell_contains_boundary_point(edge->next()->twin()->cell(), segment.p1)) {
+        if (cell_contains_boundary_point(edge->twin()->cell(), segment.p1) &&
+            !cell_contains_boundary_point(edge->next()->twin()->cell(),
+                                          segment.p1)) {
           break;
         }
         edge = edge->next();
@@ -253,22 +263,25 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
         ret.heights[p] = 0.0;
       }
       do {
-        if (edge->is_linear()) { // linear edge is simple
+        if (edge->is_linear()) {  // linear edge is simple
           Vector2d p(edge->vertex1()->x(), edge->vertex1()->y());
           ret.faces.back().push_back(p);
           ret.heights[p] = distance_to_segment(p, segment);
-        } else { // discretize a parabolic edge
-          const voronoi_diagram::cell_type *twin_cell = edge->twin()->cell();
+        } else {  // discretize a parabolic edge
+          const voronoi_diagram::cell_type* twin_cell = edge->twin()->cell();
           if (!(twin_cell->contains_point())) {
             RAISE_ROOF_EXCEPTION("Voronoi error");
           }
           Segment twin_segment = segments[twin_cell->source_index()];
           Point twin_point =
-            (twin_cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT) ?
-            twin_segment.p0 : twin_segment.p1;
+              (twin_cell->source_category() ==
+               ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT)
+                  ? twin_segment.p0
+                  : twin_segment.p1;
           Vector2d v0(edge->vertex0()->x(), edge->vertex0()->y()),
-          v1(edge->vertex1()->x(), edge->vertex1()->y());
-          std::vector<Vector2d> discr = discretize_arc(twin_point, segment, v1, v0, fa, fs);
+              v1(edge->vertex1()->x(), edge->vertex1()->y());
+          std::vector<Vector2d> discr =
+              discretize_arc(twin_point, segment, v1, v0, fa, fs);
           std::reverse(discr.begin(), discr.end());
           for (std::size_t k = 1; k < discr.size(); k++) {
             ret.faces.back().push_back(discr[k]);
@@ -282,34 +295,38 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
         ret.faces.back().push_back(p);
         ret.heights[p] = 0.0;
       }
-    } else { // point cell
-      const voronoi_diagram::edge_type *edge = cell.incident_edge();
-      const Point point = (cell.source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT) ?
-        segment.p0 : segment.p1;
-      while (!(edge->is_secondary() && edge->prev()->is_secondary() )) {
+    } else {  // point cell
+      const voronoi_diagram::edge_type* edge = cell.incident_edge();
+      const Point point =
+          (cell.source_category() ==
+           ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT)
+              ? segment.p0
+              : segment.p1;
+      while (!(edge->is_secondary() && edge->prev()->is_secondary())) {
         edge = edge->next();
         if (edge == cell.incident_edge()) {
           RAISE_ROOF_EXCEPTION("Voronoi error");
         }
       }
 
-      auto add_triangle = [&ret, &point](const Vector2d& v0, const Vector2d& v1) {
-          ret.faces.emplace_back();
+      auto add_triangle = [&ret, &point](const Vector2d& v0,
+                                         const Vector2d& v1) {
+        ret.faces.emplace_back();
 
-          Vector2d p(point.a, point.b);
-          ret.faces.back().push_back(p);
-          ret.heights[p] = 0.0;
+        Vector2d p(point.a, point.b);
+        ret.faces.back().push_back(p);
+        ret.heights[p] = 0.0;
 
-          ret.faces.back().push_back(v0);
-          ret.heights[v0] = distance_to_point(v0, point);
+        ret.faces.back().push_back(v0);
+        ret.heights[v0] = distance_to_point(v0, point);
 
-          ret.faces.back().push_back(v1);
-          ret.heights[v1] = distance_to_point(v1, point);
-        };
+        ret.faces.back().push_back(v1);
+        ret.heights[v1] = distance_to_point(v1, point);
+      };
 
       if (edge->next()->next() != edge &&
           segments[edge->twin()->cell()->source_index()].p0 ==
-          segments[edge->prev()->twin()->cell()->source_index()].p1) {
+              segments[edge->prev()->twin()->cell()->source_index()].p1) {
         // inner non-degenerate cell
         for (;;) {
           edge = edge->next();
@@ -317,10 +334,12 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
             break;
           } else {
             Vector2d v0(edge->vertex0()->x(), edge->vertex0()->y()),
-            v1(edge->vertex1()->x(), edge->vertex1()->y());
+                v1(edge->vertex1()->x(), edge->vertex1()->y());
             if (edge->is_curved()) {
-              Segment twin_segment = segments[edge->twin()->cell()->source_index()];
-              std::vector<Vector2d> discr = discretize_arc(point, twin_segment, v0, v1, fa, fs);
+              Segment twin_segment =
+                  segments[edge->twin()->cell()->source_index()];
+              std::vector<Vector2d> discr =
+                  discretize_arc(point, twin_segment, v0, v1, fa, fs);
               for (std::size_t k = 1; k < discr.size(); k++) {
                 add_triangle(discr[k - 1], discr[k]);
               }
@@ -335,20 +354,22 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
   return ret;
 }
 
-std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa, double fs)
-{
+std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly,
+                                              double fa,
+                                              double fs) {
   PolySetBuilder hatbuilder = PolySetBuilder();
 
   try {
-
     // input data for voronoi diagram is 32 bit integers
     // FIXME: Why does this need to be 32 bits? The default we use elsewhere is
     // scaleBitsFromPrecision(DEFAULT_PRECISION) which is 10^8.
-    const int scale_bits = ClipperUtils::scaleBitsFromBounds(poly.getBoundingBox(), 32);
+    const int scale_bits =
+        ClipperUtils::scaleBitsFromBounds(poly.getBoundingBox(), 32);
     const double scale = std::ldexp(1.0, scale_bits);
 
     Clipper2Lib::Paths64 paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
-    // sanitize is important e.g. when after converting to 32 bit integers we have double points
+    // sanitize is important e.g. when after converting to 32 bit integers we
+    // have double points
     paths = Clipper2Lib::PolyTreeToPaths64(*ClipperUtils::sanitize(paths));
     std::vector<Segment> segments;
 
@@ -369,7 +390,8 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
       if (!(face.size() >= 3)) {
         RAISE_ROOF_EXCEPTION("Voronoi error");
       }
-      // convex partition (actually a triangulation - maybe do a proper convex partition later)
+      // convex partition (actually a triangulation - maybe do a proper convex
+      // partition later)
       Polygon2d face_poly;
       Outline2d outline;
       outline.vertices = face;
@@ -384,7 +406,8 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
           if (!(inner_faces.heights.find(v) != inner_faces.heights.end())) {
             RAISE_ROOF_EXCEPTION("Voronoi error");
           }
-          roof.push_back(hatbuilder.vertexIndex(Vector3d(v[0] / scale, v[1] / scale, inner_faces.heights[v] / scale)));
+          roof.push_back(hatbuilder.vertexIndex(Vector3d(
+              v[0] / scale, v[1] / scale, inner_faces.heights[v] / scale)));
         }
         hatbuilder.appendPolygon(roof);
       }
@@ -420,4 +443,4 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
   return hatbuilder.build();
 }
 
-} // roof_vd
+}  // namespace roof_vd
diff --git a/src/geometry/roof_vd.h b/src/geometry/roof_vd.h
index 6744bf464..ed1b9da5d 100644
--- a/src/geometry/roof_vd.h
+++ b/src/geometry/roof_vd.h
@@ -4,9 +4,11 @@
 #pragma once
 
 #include <memory>
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
 
 namespace roof_vd {
-std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa, double fs);
+std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly,
+                                              double fa,
+                                              double fs);
 }
diff --git a/src/geometry/rotate_extrude.cc b/src/geometry/rotate_extrude.cc
index 00e565885..ca43851fe 100644
--- a/src/geometry/rotate_extrude.cc
+++ b/src/geometry/rotate_extrude.cc
@@ -2,30 +2,33 @@
 
 #include <algorithm>
 #include <cassert>
-#include <cstddef>
 #include <cmath>
+#include <cstddef>
 #include <iterator>
 #include <memory>
 #include <utility>
 #include <vector>
 
 #include "core/RotateExtrudeNode.h"
-#include "geometry/GeometryUtils.h"
 #include "geometry/Geometry.h"
+#include "geometry/GeometryUtils.h"
+#include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
 #include "geometry/Polygon2d.h"
 #include "geometry/linalg.h"
-#include "geometry/PolySet.h"
 #include "utils/calc.h"
 #include "utils/degree_trig.h"
 #include "utils/printutils.h"
 
-static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& polyref,
-                                                           std::vector<Vector3d>& vertices,
-                                                           PolygonIndices& indices, bool closed, int convexity,
-                                                           int index_offset, bool flip_faces)
-{
+static std::unique_ptr<PolySet> assemblePolySetForManifold(
+    const Polygon2d& polyref,
+    std::vector<Vector3d>& vertices,
+    PolygonIndices& indices,
+    bool closed,
+    int convexity,
+    int index_offset,
+    bool flip_faces) {
   auto final_polyset = std::make_unique<PolySet>(3, false);
   final_polyset->setTriangular(true);
   final_polyset->setConvexity(convexity);
@@ -54,14 +57,14 @@ static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& poly
               std::back_inserter(final_polyset->indices));
   }
 
-//  LOG(PolySetUtils::polySetToPolyhedronSource(*final_polyset));
+  //  LOG(PolySetUtils::polySetToPolyhedronSource(*final_polyset));
 
   return final_polyset;
 }
 
 /*!
-   Input to extrude should be clean. This means non-intersecting, correct winding order
-   etc., the input coming from a library like Clipper.
+   Input to extrude should be clean. This means non-intersecting, correct
+   winding order etc., the input coming from a library like Clipper.
 
    FIXME: We should handle some common corner cases better:
    o 2D polygon having an edge being on the Y axis:
@@ -71,14 +74,16 @@ static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& poly
     This is more complex as the resulting geometry will (may?) be nonmanifold.
     In any case, the previous case is a specialization of this, so the following
     should be handled for both cases:
-    Since the ring associated with this vertex will have a radius of zero, it will
-    collapse to one vertex. Any quad using this ring will be collapsed to a triangle.
+    Since the ring associated with this vertex will have a radius of zero, it
+   will collapse to one vertex. Any quad using this ring will be collapsed to a
+   triangle.
 
    Currently, we generate a lot of zero-area triangles
  */
-std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Polygon2d& poly)
-{
-  if (node.angle == 0) return nullptr;
+std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node,
+                                        const Polygon2d& poly) {
+  if (node.angle == 0)
+    return nullptr;
 
   double min_x = 0;
   double max_x = 0;
@@ -90,23 +95,26 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
   }
 
   if (max_x > 0 && min_x < 0) {
-    LOG(
-      message_group::Error,
-      "all points for rotate_extrude() must have the same X coordinate sign (range is %1$.2f -> %2$.2f)",
-      min_x, max_x);
+    LOG(message_group::Error,
+        "all points for rotate_extrude() must have the same X coordinate sign "
+        "(range is %1$.2f -> %2$.2f)",
+        min_x, max_x);
     return nullptr;
   }
 
-  // # of sections. For closed rotations, # vertices is thus fragments*outline_size. For open
-  // rotations # vertices is (fragments+1)*outline_size.
+  // # of sections. For closed rotations, # vertices is thus
+  // fragments*outline_size. For open rotations # vertices is
+  // (fragments+1)*outline_size.
   const auto num_sections = (unsigned int)std::ceil(fmax(
-                                                      Calc::get_fragments_from_r(max_x - min_x, node.fn, node.fs, node.fa) * std::abs(node.angle) / 360,
-                                                      1));
+      Calc::get_fragments_from_r(max_x - min_x, node.fn, node.fs, node.fa) *
+          std::abs(node.angle) / 360,
+      1));
   const bool closed = node.angle == 360;
   // # of rings of vertices
   const int num_rings = num_sections + (closed ? 0 : 1);
 
-  const bool flip_faces = (min_x >= 0 && node.angle > 0) || (min_x < 0 && node.angle < 0);
+  const bool flip_faces =
+      (min_x >= 0 && node.angle > 0) || (min_x < 0 && node.angle < 0);
 
   // slice_stride is the number of vertices in a single ring
   size_t slice_stride = 0;
@@ -122,9 +130,11 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
   // Calculate all vertices
   for (unsigned int j = 0; j < num_rings; ++j) {
     for (const auto& outline : poly.outlines()) {
-      const double angle = node.start + j * node.angle / num_sections;  // start on the X axis
+      const double angle =
+          node.start + j * node.angle / num_sections;  // start on the X axis
       for (const auto& v : outline.vertices) {
-        vertices.emplace_back(v[0] * cos_degrees(angle), v[0] * sin_degrees(angle), v[1]);
+        vertices.emplace_back(v[0] * cos_degrees(angle),
+                              v[0] * sin_degrees(angle), v[1]);
       }
     }
   }
@@ -141,25 +151,25 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
         const int prev_idx = curr_outline + i - 1;
         if (flip_faces) {
           indices.push_back({
-            (prev_slice + prev_idx) % num_vertices,
-            (curr_slice + curr_idx) % num_vertices,
-            (prev_slice + curr_idx) % num_vertices,
+              (prev_slice + prev_idx) % num_vertices,
+              (curr_slice + curr_idx) % num_vertices,
+              (prev_slice + curr_idx) % num_vertices,
           });
           indices.push_back({
-            (curr_slice + curr_idx) % num_vertices,
-            (prev_slice + prev_idx) % num_vertices,
-            (curr_slice + prev_idx) % num_vertices,
+              (curr_slice + curr_idx) % num_vertices,
+              (prev_slice + prev_idx) % num_vertices,
+              (curr_slice + prev_idx) % num_vertices,
           });
         } else {
           indices.push_back({
-            (prev_slice + curr_idx) % num_vertices,
-            (curr_slice + curr_idx) % num_vertices,
-            (prev_slice + prev_idx) % num_vertices,
+              (prev_slice + curr_idx) % num_vertices,
+              (curr_slice + curr_idx) % num_vertices,
+              (prev_slice + prev_idx) % num_vertices,
           });
           indices.push_back({
-            (curr_slice + prev_idx) % num_vertices,
-            (prev_slice + prev_idx) % num_vertices,
-            (curr_slice + curr_idx) % num_vertices,
+              (curr_slice + prev_idx) % num_vertices,
+              (prev_slice + prev_idx) % num_vertices,
+              (curr_slice + curr_idx) % num_vertices,
           });
         }
       }
@@ -167,10 +177,12 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
     }
   }
 
-  // TODO(kintel): Without Manifold, we don't have such tessellator available which guarantees to not modify vertices, so we technically may end up with
-  // broken end caps if we build OpenSCAD without ENABLE_MANIFOLD. Should be fixed, but it's low priority and it's not
-  // trivial to come up with a test case for this.
-  return assemblePolySetForManifold(poly, vertices, indices, closed, node.convexity,
-                                    slice_stride * num_sections, flip_faces);
-
+  // TODO(kintel): Without Manifold, we don't have such tessellator available
+  // which guarantees to not modify vertices, so we technically may end up with
+  // broken end caps if we build OpenSCAD without ENABLE_MANIFOLD. Should be
+  // fixed, but it's low priority and it's not trivial to come up with a test
+  // case for this.
+  return assemblePolySetForManifold(poly, vertices, indices, closed,
+                                    node.convexity, slice_stride * num_sections,
+                                    flip_faces);
 }
diff --git a/src/geometry/rotate_extrude.h b/src/geometry/rotate_extrude.h
index 380593fbf..874b52f79 100644
--- a/src/geometry/rotate_extrude.h
+++ b/src/geometry/rotate_extrude.h
@@ -6,4 +6,5 @@
 #include "geometry/Geometry.h"
 #include "geometry/Polygon2d.h"
 
-std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Polygon2d& poly);
+std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node,
+                                        const Polygon2d& poly);
diff --git a/src/glview/Camera.cc b/src/glview/Camera.cc
index c631f31bd..b504ed604 100644
--- a/src/glview/Camera.cc
+++ b/src/glview/Camera.cc
@@ -1,8 +1,8 @@
 #include "glview/Camera.h"
 #include "geometry/linalg.h"
 #include "glview/RenderSettings.h"
-#include "utils/printutils.h"
 #include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
 #include <cassert>
 #include <memory>
@@ -17,8 +17,7 @@ constexpr int DEFAULT_HEIGHT = 512;
 
 }  // namespace
 
-Camera::Camera() : fov(DEFAULT_FOV)
-{
+Camera::Camera() : fov(DEFAULT_FOV) {
   PRINTD("Camera()");
 
   // gimbal cam values
@@ -29,8 +28,7 @@ Camera::Camera() : fov(DEFAULT_FOV)
   locked = false;
 }
 
-void Camera::setup(std::vector<double> params)
-{
+void Camera::setup(std::vector<double> params) {
   if (params.size() == 7) {
     setVpt(params[0], params[1], params[2]);
     setVpr(params[3], params[4], params[5]);
@@ -41,9 +39,8 @@ void Camera::setup(std::vector<double> params)
     object_trans = -center;
     auto dir = center - eye;
     viewer_distance = dir.norm();
-    object_rot.z() = (!dir[1] && !dir[0]) ? dir[2] < 0 ? 0
-                                           : 180
-                              : -atan2_degrees(dir[1], dir[0]) + 90;
+    object_rot.z() = (!dir[1] && !dir[0]) ? dir[2] < 0 ? 0 : 180
+                                          : -atan2_degrees(dir[1], dir[0]) + 90;
     object_rot.y() = 0;
     Eigen::Vector3d projection(dir[0], dir[1], 0);
     object_rot.x() = -atan2_degrees(dir[2], projection.norm());
@@ -55,13 +52,11 @@ void Camera::setup(std::vector<double> params)
 /*!
    Moves camera so that the given bbox is fully visible.
  */
-void Camera::viewAll(const BoundingBox& bbox)
-{
+void Camera::viewAll(const BoundingBox& bbox) {
   if (bbox.isEmpty()) {
     setVpt(0, 0, 0);
     setVpd(DEFAULT_DISTANCE);
   } else {
-
     if (this->autocenter) {
       // autocenter = point camera at the center of the bounding box.
       this->object_trans = -bbox.center();
@@ -70,13 +65,14 @@ void Camera::viewAll(const BoundingBox& bbox)
     double bboxRadius = bbox.diagonal().norm() / 2;
     double radius = (bbox.center() + object_trans).norm() + bboxRadius;
     this->viewer_distance = radius / sin_degrees(this->fov / 2);
-    PRINTDB("modified obj trans x y z %f %f %f", object_trans.x() % object_trans.y() % object_trans.z());
-    PRINTDB("modified obj rot   x y z %f %f %f", object_rot.x() % object_rot.y() % object_rot.z());
+    PRINTDB("modified obj trans x y z %f %f %f",
+            object_trans.x() % object_trans.y() % object_trans.z());
+    PRINTDB("modified obj rot   x y z %f %f %f",
+            object_rot.x() % object_rot.y() % object_rot.z());
   }
 }
 
-void Camera::zoom(int zoom, bool relative)
-{
+void Camera::zoom(int zoom, bool relative) {
   if (relative) {
     this->viewer_distance *= pow(0.9, zoom / 120.0);
   } else {
@@ -84,14 +80,12 @@ void Camera::zoom(int zoom, bool relative)
   }
 }
 
-void Camera::setProjection(ProjectionType type)
-{
+void Camera::setProjection(ProjectionType type) {
   this->projection = type;
 }
 
-void Camera::resetView()
-{
-  setVpr(55, 0, 25); // set in user space units
+void Camera::resetView() {
+  setVpr(55, 0, 25);  // set in user space units
   setVpt(0, 0, 0);
   setVpd(DEFAULT_DISTANCE);
   setVpf(DEFAULT_FOV);
@@ -102,9 +96,10 @@ void Camera::resetView()
  * are assigned on top-level, the values are used to change the camera
  * rotation, translation and distance.
  */
-void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool enableWarning)
-{
-  if (locked) return;
+void Camera::updateView(const std::shared_ptr<const FileContext>& context,
+                        bool enableWarning) {
+  if (locked)
+    return;
 
   bool noauto = false;
   double x, y, z;
@@ -114,7 +109,9 @@ void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool
       setVpr(x, y, z);
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpr=%1$s to a vec3 or vec2 of numbers", vpr->toEchoString());
+      LOG(message_group::Warning,
+          "Unable to convert $vpr=%1$s to a vec3 or vec2 of numbers",
+          vpr->toEchoString());
     }
   }
 
@@ -124,7 +121,9 @@ void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool
       setVpt(x, y, z);
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpt=%1$s to a vec3 or vec2 of numbers", vpt->toEchoString());
+      LOG(message_group::Warning,
+          "Unable to convert $vpt=%1$s to a vec3 or vec2 of numbers",
+          vpt->toEchoString());
     }
   }
 
@@ -134,7 +133,8 @@ void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool
       setVpd(vpd->toDouble());
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpd=%1$s to a number", vpd->toEchoString());
+      LOG(message_group::Warning, "Unable to convert $vpd=%1$s to a number",
+          vpd->toEchoString());
     }
   }
 
@@ -144,69 +144,63 @@ void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool
       setVpf(vpf->toDouble());
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpf=%1$s to a number", vpf->toEchoString());
+      LOG(message_group::Warning, "Unable to convert $vpf=%1$s to a number",
+          vpf->toEchoString());
     }
   }
 
   if (enableWarning && (viewall || autocenter) && noauto) {
-    LOG(message_group::UI_Warning, "Viewall and autocenter disabled in favor of $vp*");
+    LOG(message_group::UI_Warning,
+        "Viewall and autocenter disabled in favor of $vp*");
     viewall = false;
     autocenter = false;
   }
 }
 
-Eigen::Vector3d Camera::getVpt() const
-{
+Eigen::Vector3d Camera::getVpt() const {
   return -object_trans;
 }
 
-void Camera::setVpt(double x, double y, double z)
-{
+void Camera::setVpt(double x, double y, double z) {
   object_trans << -x, -y, -z;
 }
 
-static double wrap(double angle)
-{
-  return fmod(360.0 + angle, 360.0); // force angle to be 0-360
+static double wrap(double angle) {
+  return fmod(360.0 + angle, 360.0);  // force angle to be 0-360
 }
 
-Eigen::Vector3d Camera::getVpr() const
-{
-  return {wrap(90 - object_rot.x()), wrap(-object_rot.y()), wrap(-object_rot.z())};
+Eigen::Vector3d Camera::getVpr() const {
+  return {wrap(90 - object_rot.x()), wrap(-object_rot.y()),
+          wrap(-object_rot.z())};
 }
 
-void Camera::setVpr(double x, double y, double z)
-{
+void Camera::setVpr(double x, double y, double z) {
   object_rot << wrap(90 - x), wrap(-y), wrap(-z);
 }
 
-void Camera::setVpd(double d)
-{
+void Camera::setVpd(double d) {
   viewer_distance = d;
 }
 
-double Camera::zoomValue() const
-{
+double Camera::zoomValue() const {
   return viewer_distance;
 }
 
-void Camera::setVpf(double f)
-{
+void Camera::setVpf(double f) {
   fov = f;
 }
 
-double Camera::fovValue() const
-{
+double Camera::fovValue() const {
   return fov;
 }
 
-std::string Camera::statusText() const
-{
+std::string Camera::statusText() const {
   const auto vpt = getVpt();
   const auto vpr = getVpr();
-  boost::format fmt(_("Viewport: translate = [ %.2f %.2f %.2f ], rotate = [ %.2f %.2f %.2f ], distance = %.2f, fov = %.2f"));
-  fmt % vpt.x() % vpt.y() % vpt.z()
-  % vpr.x() % vpr.y() % vpr.z()
-  % viewer_distance % fov;
+  boost::format fmt(
+      _("Viewport: translate = [ %.2f %.2f %.2f ], rotate = [ %.2f %.2f %.2f "
+        "], distance = %.2f, fov = %.2f"));
+  fmt % vpt.x() % vpt.y() % vpt.z() % vpr.x() % vpr.y() % vpr.z() %
+      viewer_distance % fov;
   return fmt.str();
 }
diff --git a/src/glview/Camera.h b/src/glview/Camera.h
index 1d76b53c2..36d347bf2 100644
--- a/src/glview/Camera.h
+++ b/src/glview/Camera.h
@@ -16,17 +16,19 @@
 
  */
 
-#include "geometry/linalg.h"
-#include "core/ScopeContext.h"
+#include <Eigen/Geometry>
 #include <memory>
 #include <string>
 #include <vector>
-#include <Eigen/Geometry>
+#include "core/ScopeContext.h"
+#include "geometry/linalg.h"
 
-class Camera
-{
-public:
-  enum class ProjectionType { ORTHOGONAL, PERSPECTIVE } projection{ProjectionType::PERSPECTIVE};
+class Camera {
+ public:
+  enum class ProjectionType {
+    ORTHOGONAL,
+    PERSPECTIVE
+  } projection{ProjectionType::PERSPECTIVE};
   Camera();
   void setup(std::vector<double> params);
   void gimbalDefaultTranslate();
@@ -35,11 +37,13 @@ public:
   [[nodiscard]] double zoomValue() const;
   [[nodiscard]] double fovValue() const;
   void resetView();
-  void updateView(const std::shared_ptr<const class FileContext>& context, bool enableWarning);
+  void updateView(const std::shared_ptr<const class FileContext>& context,
+                  bool enableWarning);
   void viewAll(const BoundingBox& bbox);
   [[nodiscard]] std::string statusText() const;
 
-  // accessors to get and set camera settings in the user space format (different for historical reasons)
+  // accessors to get and set camera settings in the user space format
+  // (different for historical reasons)
   [[nodiscard]] Eigen::Vector3d getVpt() const;
   void setVpt(double x, double y, double z);
   [[nodiscard]] Eigen::Vector3d getVpr() const;
@@ -52,7 +56,7 @@ public:
   Eigen::Vector3d object_rot;
 
   // Perspective settings
-  double fov; // Field of view
+  double fov;  // Field of view
 
   // true if camera should try to view everything in a given
   // bounding box.
diff --git a/src/glview/ColorMap.cc b/src/glview/ColorMap.cc
index 181ae5bb6..e66b7d2ed 100644
--- a/src/glview/ColorMap.cc
+++ b/src/glview/ColorMap.cc
@@ -1,45 +1,55 @@
 #include "glview/ColorMap.h"
 #include "core/ColorUtil.h"
-#include "utils/printutils.h"
 #include "platform/PlatformUtils.h"
+#include "utils/printutils.h"
 
 #include <algorithm>
+#include <boost/property_tree/json_parser.hpp>
+#include <cmath>
+#include <exception>
+#include <filesystem>
 #include <iomanip>
-#include <stdexcept>
 #include <list>
-#include <utility>
-#include <exception>
 #include <memory>
-#include <boost/property_tree/json_parser.hpp>
-#include <filesystem>
-#include <cmath>
+#include <stdexcept>
+#include <utility>
 
 namespace fs = std::filesystem;
 
-static const char *DEFAULT_COLOR_SCHEME_NAME = "Cornfield";
+static const char* DEFAULT_COLOR_SCHEME_NAME = "Cornfield";
 
-RenderColorScheme::RenderColorScheme() : _path("")
-{
+RenderColorScheme::RenderColorScheme() : _path("") {
   _name = DEFAULT_COLOR_SCHEME_NAME;
   _index = 1000;
   _show_in_gui = true;
 
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::BACKGROUND_COLOR, Color4f(0xff, 0xff, 0xe5)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::BACKGROUND_STOP_COLOR, Color4f(0xff, 0xff, 0xe5)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::AXES_COLOR, Color4f(0x00, 0x00, 0x00)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::OPENCSG_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::OPENCSG_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_2D_COLOR, Color4f(0x00, 0xbf, 0x99)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_FRONT_COLOR, Color4f(0xff, 0xec, 0x5e)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_BACK_COLOR, Color4f(0xab, 0xd8, 0x56)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_2D_COLOR, Color4f(0xff, 0x00, 0x00)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CROSSHAIR_COLOR, Color4f(0x80, 0x00, 0x00)));
-}
-
-RenderColorScheme::RenderColorScheme(const fs::path& path) : _path(path)
-{
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::BACKGROUND_COLOR,
+                                               Color4f(0xff, 0xff, 0xe5)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::BACKGROUND_STOP_COLOR, Color4f(0xff, 0xff, 0xe5)));
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::AXES_COLOR,
+                                               Color4f(0x00, 0x00, 0x00)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::OPENCSG_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::OPENCSG_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::CGAL_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_2D_COLOR,
+                                               Color4f(0x00, 0xbf, 0x99)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::CGAL_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::CGAL_EDGE_FRONT_COLOR, Color4f(0xff, 0xec, 0x5e)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::CGAL_EDGE_BACK_COLOR, Color4f(0xab, 0xd8, 0x56)));
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_2D_COLOR,
+                                               Color4f(0xff, 0x00, 0x00)));
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::CROSSHAIR_COLOR,
+                                               Color4f(0x80, 0x00, 0x00)));
+}
+
+RenderColorScheme::RenderColorScheme(const fs::path& path) : _path(path) {
   try {
     boost::property_tree::read_json(path.generic_string().c_str(), pt);
     _name = pt.get<std::string>("name");
@@ -57,13 +67,14 @@ RenderColorScheme::RenderColorScheme(const fs::path& path) : _path(path)
     addColor(RenderColor::CGAL_EDGE_BACK_COLOR, "cgal-edge-back");
     addColor(RenderColor::CGAL_EDGE_2D_COLOR, "cgal-edge-2d");
     addColor(RenderColor::CROSSHAIR_COLOR, "crosshair");
-    try{
+    try {
       addColor(RenderColor::BACKGROUND_STOP_COLOR, "background-stop");
     } catch (const std::exception& e) {
       addColor(RenderColor::BACKGROUND_STOP_COLOR, "background");
     }
   } catch (const std::exception& e) {
-    LOG("Error reading color scheme file: '%1$s': %2$s", path.generic_string().c_str(), e.what());
+    LOG("Error reading color scheme file: '%1$s': %2$s",
+        path.generic_string().c_str(), e.what());
     _error = e.what();
     _name = "";
     _index = 0;
@@ -71,65 +82,56 @@ RenderColorScheme::RenderColorScheme(const fs::path& path) : _path(path)
   }
 }
 
-bool RenderColorScheme::valid() const
-{
+bool RenderColorScheme::valid() const {
   return !_name.empty();
 }
 
-const std::string& RenderColorScheme::name() const
-{
+const std::string& RenderColorScheme::name() const {
   return _name;
 }
 
-int RenderColorScheme::index() const
-{
+int RenderColorScheme::index() const {
   return _index;
 }
 
-bool RenderColorScheme::showInGui() const
-{
+bool RenderColorScheme::showInGui() const {
   return _show_in_gui;
 }
 
-std::string RenderColorScheme::path() const
-{
+std::string RenderColorScheme::path() const {
   return _path.string();
 }
 
-std::string RenderColorScheme::error() const
-{
+std::string RenderColorScheme::error() const {
   return _error;
 }
 
-ColorScheme& RenderColorScheme::colorScheme()
-{
+ColorScheme& RenderColorScheme::colorScheme() {
   return _color_scheme;
 }
 
-const boost::property_tree::ptree& RenderColorScheme::propertyTree() const
-{
+const boost::property_tree::ptree& RenderColorScheme::propertyTree() const {
   return pt;
 }
 
-void RenderColorScheme::addColor(RenderColor colorKey, const std::string& key)
-{
+void RenderColorScheme::addColor(RenderColor colorKey, const std::string& key) {
   const boost::property_tree::ptree& colors = pt.get_child("colors");
   auto color = colors.get<std::string>(key);
   if ((color.length() == 7) && (color.at(0) == '#')) {
-    char *endptr;
+    char* endptr;
     unsigned int val = strtol(color.substr(1).c_str(), &endptr, 16);
     int r = (val >> 16) & 0xff;
     int g = (val >> 8) & 0xff;
     int b = val & 0xff;
     _color_scheme.insert(ColorScheme::value_type(colorKey, Color4f(r, g, b)));
   } else {
-    throw std::invalid_argument(std::string("invalid color value for key '") + key + "': '" + color + "'");
+    throw std::invalid_argument(std::string("invalid color value for key '") +
+                                key + "': '" + color + "'");
   }
 }
 
-ColorMap *ColorMap::inst(bool erase)
-{
-  static auto *instance = new ColorMap;
+ColorMap* ColorMap::inst(bool erase) {
+  static auto* instance = new ColorMap;
   if (erase) {
     delete instance;
     instance = nullptr;
@@ -137,26 +139,22 @@ ColorMap *ColorMap::inst(bool erase)
   return instance;
 }
 
-ColorMap::ColorMap()
-{
+ColorMap::ColorMap() {
   colorSchemeSet = enumerateColorSchemes();
   dump();
 }
 
-const char *ColorMap::defaultColorSchemeName() const
-{
+const char* ColorMap::defaultColorSchemeName() const {
   return DEFAULT_COLOR_SCHEME_NAME;
 }
 
-const ColorScheme& ColorMap::defaultColorScheme() const
-{
+const ColorScheme& ColorMap::defaultColorScheme() const {
   return *findColorScheme(DEFAULT_COLOR_SCHEME_NAME);
 }
 
-const ColorScheme *ColorMap::findColorScheme(const std::string& name) const
-{
+const ColorScheme* ColorMap::findColorScheme(const std::string& name) const {
   for (const auto& item : colorSchemeSet) {
-    RenderColorScheme *scheme = item.second.get();
+    RenderColorScheme* scheme = item.second.get();
     if (name == scheme->name()) {
       return &scheme->colorScheme();
     }
@@ -164,8 +162,7 @@ const ColorScheme *ColorMap::findColorScheme(const std::string& name) const
   return nullptr;
 }
 
-void ColorMap::dump() const
-{
+void ColorMap::dump() const {
   PRINTD("Listing available color schemes...");
 
   std::list<std::string> names = colorSchemeNames();
@@ -175,22 +172,25 @@ void ColorMap::dump() const
   }
 
   for (const auto& item : colorSchemeSet) {
-    const RenderColorScheme *cs = item.second.get();
+    const RenderColorScheme* cs = item.second.get();
     const char gui = cs->showInGui() ? 'G' : '-';
     if (cs->path().empty()) {
-      PRINTDB("%6d:%c: %s (built-in)", cs->index() % gui % boost::io::group(std::setw(length), cs->name()));
+      PRINTDB(
+          "%6d:%c: %s (built-in)",
+          cs->index() % gui % boost::io::group(std::setw(length), cs->name()));
     } else {
-      PRINTDB("%6d:%c: %s from %s", cs->index() % gui % boost::io::group(std::setw(length), cs->name()) % cs->path());
+      PRINTDB("%6d:%c: %s from %s",
+              cs->index() % gui %
+                  boost::io::group(std::setw(length), cs->name()) % cs->path());
     }
   }
   PRINTD("done.");
 }
 
-std::list<std::string> ColorMap::colorSchemeNames(bool guiOnly) const
-{
+std::list<std::string> ColorMap::colorSchemeNames(bool guiOnly) const {
   std::list<std::string> colorSchemeNames;
   for (const auto& item : colorSchemeSet) {
-    const RenderColorScheme *scheme = item.second.get();
+    const RenderColorScheme* scheme = item.second.get();
     if (guiOnly && !scheme->showInGui()) {
       continue;
     }
@@ -199,23 +199,26 @@ std::list<std::string> ColorMap::colorSchemeNames(bool guiOnly) const
   return colorSchemeNames;
 }
 
-Color4f ColorMap::getColor(const ColorScheme& cs, const RenderColor rc)
-{
-  if (cs.count(rc)) return cs.at(rc);
-  if (ColorMap::inst()->defaultColorScheme().count(rc)) return ColorMap::inst()->defaultColorScheme().at(rc);
+Color4f ColorMap::getColor(const ColorScheme& cs, const RenderColor rc) {
+  if (cs.count(rc))
+    return cs.at(rc);
+  if (ColorMap::inst()->defaultColorScheme().count(rc))
+    return ColorMap::inst()->defaultColorScheme().at(rc);
   return {0, 0, 0, 127};
 }
 
-void ColorMap::enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& basePath)
-{
+void ColorMap::enumerateColorSchemesInPath(colorscheme_set_t& result_set,
+                                           const fs::path& basePath) {
   const fs::path color_schemes = basePath / "color-schemes" / "render";
 
-  PRINTDB("Enumerating color schemes from '%s'", color_schemes.generic_string().c_str());
+  PRINTDB("Enumerating color schemes from '%s'",
+          color_schemes.generic_string().c_str());
 
   fs::directory_iterator end_iter;
 
   if (fs::exists(color_schemes) && fs::is_directory(color_schemes)) {
-    for (fs::directory_iterator dir_iter(color_schemes); dir_iter != end_iter; ++dir_iter) {
+    for (fs::directory_iterator dir_iter(color_schemes); dir_iter != end_iter;
+         ++dir_iter) {
       if (!fs::is_regular_file(dir_iter->status())) {
         continue;
       }
@@ -225,26 +228,31 @@ void ColorMap::enumerateColorSchemesInPath(colorscheme_set_t& result_set, const
         continue;
       }
 
-      auto *colorScheme = new RenderColorScheme(path);
-      if (colorScheme->valid() && (findColorScheme(colorScheme->name()) == nullptr)) {
-        result_set.insert(colorscheme_set_t::value_type(colorScheme->index(), std::shared_ptr<RenderColorScheme>(colorScheme)));
-        PRINTDB("Found file '%s' with color scheme '%s' and index %d",
-                colorScheme->path() % colorScheme->name() % colorScheme->index());
+      auto* colorScheme = new RenderColorScheme(path);
+      if (colorScheme->valid() &&
+          (findColorScheme(colorScheme->name()) == nullptr)) {
+        result_set.insert(colorscheme_set_t::value_type(
+            colorScheme->index(),
+            std::shared_ptr<RenderColorScheme>(colorScheme)));
+        PRINTDB(
+            "Found file '%s' with color scheme '%s' and index %d",
+            colorScheme->path() % colorScheme->name() % colorScheme->index());
       } else {
-        PRINTDB("Invalid file '%s': %s", colorScheme->path() % colorScheme->error());
+        PRINTDB("Invalid file '%s': %s",
+                colorScheme->path() % colorScheme->error());
         delete colorScheme;
       }
     }
   }
 }
 
-ColorMap::colorscheme_set_t ColorMap::enumerateColorSchemes()
-{
+ColorMap::colorscheme_set_t ColorMap::enumerateColorSchemes() {
   colorscheme_set_t result_set;
 
-  auto *defaultColorScheme = new RenderColorScheme();
-  result_set.insert(colorscheme_set_t::value_type(defaultColorScheme->index(),
-                                                  std::shared_ptr<RenderColorScheme>(defaultColorScheme)));
+  auto* defaultColorScheme = new RenderColorScheme();
+  result_set.insert(colorscheme_set_t::value_type(
+      defaultColorScheme->index(),
+      std::shared_ptr<RenderColorScheme>(defaultColorScheme)));
   enumerateColorSchemesInPath(result_set, PlatformUtils::resourceBasePath());
   enumerateColorSchemesInPath(result_set, PlatformUtils::userConfigPath());
 
diff --git a/src/glview/ColorMap.h b/src/glview/ColorMap.h
index 90ed649f0..b1a1047bc 100644
--- a/src/glview/ColorMap.h
+++ b/src/glview/ColorMap.h
@@ -1,16 +1,16 @@
 #pragma once
 
+#include <memory.h>
 #include <functional>
-#include <memory>
+#include <list>
 #include <map>
+#include <memory>
 #include <string>
-#include <list>
-#include <memory.h>
 
 #include "geometry/linalg.h"
 
-#include <filesystem>
 #include <boost/property_tree/ptree.hpp>
+#include <filesystem>
 
 namespace fs = std::filesystem;
 
@@ -31,9 +31,8 @@ enum class RenderColor {
 
 using ColorScheme = std::map<RenderColor, Color4f>;
 
-class RenderColorScheme
-{
-private:
+class RenderColorScheme {
+ private:
   const fs::path _path;
 
   boost::property_tree::ptree pt;
@@ -44,7 +43,7 @@ private:
 
   ColorScheme _color_scheme;
 
-public:
+ public:
   /**
    * Constructor for the default color scheme Cornfield.
    */
@@ -62,7 +61,7 @@ public:
   ColorScheme& colorScheme();
   [[nodiscard]] const boost::property_tree::ptree& propertyTree() const;
 
-private:
+ private:
   [[nodiscard]] std::string path() const;
   [[nodiscard]] std::string error() const;
   void addColor(RenderColor colorKey, const std::string& key);
@@ -70,27 +69,30 @@ private:
   friend class ColorMap;
 };
 
-class ColorMap
-{
-  using colorscheme_set_t = std::multimap<int, std::shared_ptr<RenderColorScheme>, std::less<>>;
+class ColorMap {
+  using colorscheme_set_t =
+      std::multimap<int, std::shared_ptr<RenderColorScheme>, std::less<>>;
 
-public:
-  static ColorMap *inst(bool erase = false);
+ public:
+  static ColorMap* inst(bool erase = false);
 
-  [[nodiscard]] const char *defaultColorSchemeName() const;
+  [[nodiscard]] const char* defaultColorSchemeName() const;
   [[nodiscard]] const ColorScheme& defaultColorScheme() const;
-  [[nodiscard]] const ColorScheme *findColorScheme(const std::string& name) const;
-  [[nodiscard]] std::list<std::string> colorSchemeNames(bool guiOnly = false) const;
+  [[nodiscard]] const ColorScheme* findColorScheme(
+      const std::string& name) const;
+  [[nodiscard]] std::list<std::string> colorSchemeNames(
+      bool guiOnly = false) const;
 
   static Color4f getColor(const ColorScheme& cs, const RenderColor rc);
   static Color4f getContrastColor(const Color4f& col);
   static Color4f getColorHSV(const Color4f& col);
 
-private:
+ private:
   ColorMap();
   virtual ~ColorMap() = default;
   void dump() const;
   colorscheme_set_t enumerateColorSchemes();
-  void enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& path);
+  void enumerateColorSchemesInPath(colorscheme_set_t& result_set,
+                                   const fs::path& path);
   colorscheme_set_t colorSchemeSet;
 };
diff --git a/src/glview/CsgInfo.h b/src/glview/CsgInfo.h
index 6fd180ca1..4b8e3e966 100644
--- a/src/glview/CsgInfo.h
+++ b/src/glview/CsgInfo.h
@@ -7,17 +7,15 @@
 #include "core/CSGTreeEvaluator.h"
 #include "core/Tree.h"
 #include "geometry/GeometryEvaluator.h"
-#include "glview/preview/CSGTreeNormalizer.h"
 #include "glview/RenderSettings.h"
+#include "glview/preview/CSGTreeNormalizer.h"
 #include "utils/printutils.h"
 
-
 /*
    Small helper class for compiling and normalizing node trees into CSG products
  */
-class CsgInfo
-{
-public:
+class CsgInfo {
+ public:
   CsgInfo() = default;
   std::shared_ptr<class CSGProducts> root_products;
   std::shared_ptr<CSGProducts> highlights_products;
@@ -28,20 +26,25 @@ public:
     GeometryEvaluator geomevaluator(tree);
     CSGTreeEvaluator evaluator(tree, &geomevaluator);
     const std::shared_ptr<CSGNode> csgRoot = evaluator.buildCSGTree(*root_node);
-    std::vector<std::shared_ptr<CSGNode>> highlightNodes = evaluator.getHighlightNodes();
-    std::vector<std::shared_ptr<CSGNode>> backgroundNodes = evaluator.getBackgroundNodes();
+    std::vector<std::shared_ptr<CSGNode>> highlightNodes =
+        evaluator.getHighlightNodes();
+    std::vector<std::shared_ptr<CSGNode>> backgroundNodes =
+        evaluator.getBackgroundNodes();
 
     LOG("Compiling design (CSG Products normalization)...");
     CSGTreeNormalizer normalizer(RenderSettings::inst()->openCSGTermLimit);
     if (csgRoot) {
-      const std::shared_ptr<CSGNode> normalizedRoot = normalizer.normalize(csgRoot);
+      const std::shared_ptr<CSGNode> normalizedRoot =
+          normalizer.normalize(csgRoot);
       if (normalizedRoot) {
         this->root_products = std::make_shared<CSGProducts>();
         this->root_products->import(normalizedRoot);
-        LOG("Normalized CSG tree has %1$d elements", int(this->root_products->size()));
+        LOG("Normalized CSG tree has %1$d elements",
+            int(this->root_products->size()));
       } else {
         this->root_products.reset();
-        LOG(message_group::Warning, "CSG normalization resulted in an empty tree");
+        LOG(message_group::Warning,
+            "CSG normalization resulted in an empty tree");
       }
     }
 
diff --git a/src/glview/GLView.cc b/src/glview/GLView.cc
index fb133f138..ca4f3bd08 100644
--- a/src/glview/GLView.cc
+++ b/src/glview/GLView.cc
@@ -1,25 +1,24 @@
 #include "glview/GLView.h"
 #include "geometry/linalg.h"
-#include "glview/system-gl.h"
 #include "glview/ColorMap.h"
 #include "glview/RenderSettings.h"
-#include "utils/printutils.h"
 #include "glview/Renderer.h"
-#include "utils/degree_trig.h"
 #include "glview/hershey.h"
+#include "glview/system-gl.h"
+#include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
-#include <functional>
-#include <memory>
 #include <cmath>
 #include <cstdio>
+#include <functional>
+#include <memory>
 #include <string>
 
 #ifdef ENABLE_OPENCSG
 #include <opencsg.h>
 #endif
 
-GLView::GLView()
-{
+GLView::GLView() {
   aspectratio = 1;
   showedges = false;
   showaxes = false;
@@ -36,30 +35,34 @@ GLView::GLView()
 #endif
 }
 
-GLView::~GLView()
-{
+GLView::~GLView() {
   teardownShader();
 }
 
 void GLView::setupShader() {
-  if (edge_shader) return;
-
-  auto resource = ShaderUtils::compileShaderProgram(ShaderUtils::loadShaderSource("ViewEdges.vert"),
-                                                    ShaderUtils::loadShaderSource("ViewEdges.frag"));
-
-  edge_shader = std::make_unique<ShaderUtils::ShaderInfo>(ShaderUtils::ShaderInfo{
-    .resource = resource,
-    .type = ShaderUtils::ShaderType::EDGE_RENDERING,
-    .uniforms = {
-    },
-    .attributes = {
-      {"barycentric", glGetAttribLocation(resource.shader_program, "barycentric")},
-    },
-  });
+  if (edge_shader)
+    return;
+
+  auto resource = ShaderUtils::compileShaderProgram(
+      ShaderUtils::loadShaderSource("ViewEdges.vert"),
+      ShaderUtils::loadShaderSource("ViewEdges.frag"));
+
+  edge_shader =
+      std::make_unique<ShaderUtils::ShaderInfo>(ShaderUtils::ShaderInfo{
+          .resource = resource,
+          .type = ShaderUtils::ShaderType::EDGE_RENDERING,
+          .uniforms = {},
+          .attributes =
+              {
+                  {"barycentric",
+                   glGetAttribLocation(resource.shader_program, "barycentric")},
+              },
+      });
 }
 
 void GLView::teardownShader() {
-  if (edge_shader == nullptr) return; // if OpenGL context was not initialized
+  if (edge_shader == nullptr)
+    return;  // if OpenGL context was not initialized
   if (edge_shader->resource.shader_program) {
     glDeleteProgram(edge_shader->resource.shader_program);
   }
@@ -71,28 +74,25 @@ void GLView::teardownShader() {
   }
 }
 
-void GLView::setRenderer(std::shared_ptr<Renderer> r)
-{
+void GLView::setRenderer(std::shared_ptr<Renderer> r) {
   this->renderer = r;
 }
 
 /* update the color schemes of the Renderer attached to this GLView
    to match the colorscheme of this GLView.*/
-void GLView::updateColorScheme()
-{
-  if (this->renderer) this->renderer->setColorScheme(*this->colorscheme);
+void GLView::updateColorScheme() {
+  if (this->renderer)
+    this->renderer->setColorScheme(*this->colorscheme);
 }
 
 /* change this GLView's colorscheme to the one given, and update the
    Renderer attached to this GLView as well. */
-void GLView::setColorScheme(const ColorScheme& cs)
-{
+void GLView::setColorScheme(const ColorScheme& cs) {
   this->colorscheme = &cs;
   this->updateColorScheme();
 }
 
-void GLView::setColorScheme(const std::string& cs)
-{
+void GLView::setColorScheme(const std::string& cs) {
   const auto colorscheme = ColorMap::inst()->findColorScheme(cs);
   if (colorscheme) {
     setColorScheme(*colorscheme);
@@ -101,8 +101,7 @@ void GLView::setColorScheme(const std::string& cs)
   }
 }
 
-void GLView::resizeGL(int w, int h)
-{
+void GLView::resizeGL(int w, int h) {
   cam.pixel_width = w;
   cam.pixel_height = h;
   glViewport(0, 0, w, h);
@@ -112,52 +111,55 @@ void GLView::resizeGL(int w, int h)
   setupShader();
 }
 
-void GLView::setCamera(const Camera& cam)
-{
+void GLView::setCamera(const Camera& cam) {
   this->cam = cam;
 }
 
-void GLView::setupCamera()
-{
+void GLView::setupCamera() {
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   auto dist = cam.zoomValue();
   switch (this->cam.projection) {
-  case Camera::ProjectionType::PERSPECTIVE: {
-    gluPerspective(cam.fov, aspectratio, 0.1 * dist, 100 * dist);
-    break;
-  }
-  default:
-  case Camera::ProjectionType::ORTHOGONAL: {
-    auto height = dist * tan_degrees(cam.fov / 2);
-    glOrtho(-height * aspectratio, height * aspectratio,
-            -height, height,
-            -100 * dist, +100 * dist);
-    break;
-  }
+    case Camera::ProjectionType::PERSPECTIVE: {
+      gluPerspective(cam.fov, aspectratio, 0.1 * dist, 100 * dist);
+      break;
+    }
+    default:
+    case Camera::ProjectionType::ORTHOGONAL: {
+      auto height = dist * tan_degrees(cam.fov / 2);
+      glOrtho(-height * aspectratio, height * aspectratio, -height, height,
+              -100 * dist, +100 * dist);
+      break;
+    }
   }
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
-  gluLookAt(0.0, -dist, 0.0, // eye
-            0.0, 0.0,   0.0,// center
-            0.0, 0.0,   1.0);// up
+  gluLookAt(0.0, -dist, 0.0,  // eye
+            0.0, 0.0, 0.0,    // center
+            0.0, 0.0, 1.0);   // up
 
   glRotated(cam.object_rot.x(), 1.0, 0.0, 0.0);
   glRotated(cam.object_rot.y(), 0.0, 1.0, 0.0);
   glRotated(cam.object_rot.z(), 0.0, 0.0, 1.0);
-  glTranslated(cam.object_trans[0], cam.object_trans[1], cam.object_trans[2]); // translation be part of modelview matrix!
+  glTranslated(
+      cam.object_trans[0], cam.object_trans[1],
+      cam.object_trans[2]);  // translation be part of modelview matrix!
   glGetDoublev(GL_MODELVIEW_MATRIX, this->modelview);
-  glTranslated(-cam.object_trans[0], -cam.object_trans[1], -cam.object_trans[2]);
+  glTranslated(-cam.object_trans[0], -cam.object_trans[1],
+               -cam.object_trans[2]);
   glGetDoublev(GL_PROJECTION_MATRIX, this->projection);
 }
 
-void GLView::paintGL()
-{
+void GLView::paintGL() {
   glDisable(GL_LIGHTING);
-  auto bgcol = ColorMap::getColor(*this->colorscheme, RenderColor::BACKGROUND_COLOR);
-  auto bgstopcol = ColorMap::getColor(*this->colorscheme, RenderColor::BACKGROUND_STOP_COLOR);
-  auto axescolor = ColorMap::getColor(*this->colorscheme, RenderColor::AXES_COLOR);
-  auto crosshaircol = ColorMap::getColor(*this->colorscheme, RenderColor::CROSSHAIR_COLOR);
+  auto bgcol =
+      ColorMap::getColor(*this->colorscheme, RenderColor::BACKGROUND_COLOR);
+  auto bgstopcol = ColorMap::getColor(*this->colorscheme,
+                                      RenderColor::BACKGROUND_STOP_COLOR);
+  auto axescolor =
+      ColorMap::getColor(*this->colorscheme, RenderColor::AXES_COLOR);
+  auto crosshaircol =
+      ColorMap::getColor(*this->colorscheme, RenderColor::CROSSHAIR_COLOR);
 
   glClearColor(bgcol.r(), bgcol.g(), bgcol.b(), 1.0);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
@@ -171,7 +173,7 @@ void GLView::paintGL()
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
 
-    //draw screen aligned quad with color gradient
+    // draw screen aligned quad with color gradient
     glBegin(GL_QUADS);
     glColor3f(bgcol.r(), bgcol.g(), bgcol.b());
     glVertex2f(-1.0f, +1.0f);
@@ -187,12 +189,16 @@ void GLView::paintGL()
   setupCamera();
 
   // The crosshair should be fixed at the center of the viewport...
-  if (showcrosshairs) GLView::showCrosshairs(crosshaircol);
-  glTranslated(cam.object_trans.x(), cam.object_trans.y(), cam.object_trans.z());
+  if (showcrosshairs)
+    GLView::showCrosshairs(crosshaircol);
+  glTranslated(cam.object_trans.x(), cam.object_trans.y(),
+               cam.object_trans.z());
   // ...the axis lines need to follow the object translation.
-  if (showaxes) GLView::showAxes(axescolor);
+  if (showaxes)
+    GLView::showAxes(axescolor);
   // mark the scale along the axis lines
-  if (showaxes && showscale) GLView::showScalemarkers(axescolor);
+  if (showaxes && showscale)
+    GLView::showScalemarkers(axescolor);
 
   glEnable(GL_LIGHTING);
   glDepthFunc(GL_LESS);
@@ -203,7 +209,8 @@ void GLView::paintGL()
 
   if (this->renderer) {
 #if defined(ENABLE_OPENCSG)
-    // FIXME: This belongs in the OpenCSG renderer, but it doesn't know about this ID yet
+    // FIXME: This belongs in the OpenCSG renderer, but it doesn't know about
+    // this ID yet
     OpenCSG::setContext(this->opencsg_id);
 #endif
     this->renderer->prepare(edge_shader.get());
@@ -211,27 +218,30 @@ void GLView::paintGL()
   }
   Vector3d eyedir(this->modelview[2], this->modelview[6], this->modelview[10]);
   glColor3f(1, 0, 0);
-  for (const SelectedObject& obj:this->selected_obj) {
+  for (const SelectedObject& obj : this->selected_obj) {
     showObject(obj, eyedir);
   }
   glColor3f(0, 1, 0);
-  for (const SelectedObject& obj: this->shown_obj) {
+  for (const SelectedObject& obj : this->shown_obj) {
     showObject(obj, eyedir);
   }
   glDisable(GL_LIGHTING);
-  if (showaxes) GLView::showSmallaxes(axescolor);
+  if (showaxes)
+    GLView::showSmallaxes(axescolor);
 
-  // Workaround for inconsistent QT behavior related to handling custom OpenGL widgets that
-  // leave non opaque alpha values in final output.
-  // On wayland that can cause window to become transparent or blurry trail effect in the
-  // parts that contain partially transparent objects.
+  // Workaround for inconsistent QT behavior related to handling custom OpenGL
+  // widgets that leave non opaque alpha values in final output. On wayland that
+  // can cause window to become transparent or blurry trail effect in the parts
+  // that contain partially transparent objects.
   //
-  // At the end of rendering clear alpha value, so that it doesn't matter how rest of the
-  // compositing stack at QT and desktop level would interpret transparent pixels.
+  // At the end of rendering clear alpha value, so that it doesn't matter how
+  // rest of the compositing stack at QT and desktop level would interpret
+  // transparent pixels.
   //
   // Solves https://github.com/openscad/openscad/issues/3689.
   //
-  // Originally developed by @karliss for FreeCAD (https://github.com/FreeCAD/FreeCAD/pull/19499).
+  // Originally developed by @karliss for FreeCAD
+  // (https://github.com/FreeCAD/FreeCAD/pull/19499).
   GLboolean mask[4];
   glGetBooleanv(GL_COLOR_WRITEMASK, mask);
   glColorMask(false, false, false, true);
@@ -253,8 +263,7 @@ void glCompileCheck(GLuint shader) {
   }
 }
 
-void GLView::enable_opencsg_shaders()
-{
+void GLView::enable_opencsg_shaders() {
   // All OpenGL 2 contexts are OpenCSG capable
 #ifdef USE_GLEW
   const bool hasOpenGL2_0 = GLEW_VERSION_2_0;
@@ -269,24 +278,22 @@ void GLView::enable_opencsg_shaders()
     display_opencsg_warning();
   }
 }
-#endif // ifdef ENABLE_OPENCSG
-
+#endif  // ifdef ENABLE_OPENCSG
 
 #ifdef DEBUG
 // Requires OpenGL 4.3+
 /*
-   void GLAPIENTRY MessageCallback(GLenum source, GLenum type, GLuint id, GLenum severity,
-                                  GLsizei length, const GLchar* message, const void* userParam)
+   void GLAPIENTRY MessageCallback(GLenum source, GLenum type, GLuint id, GLenum
+   severity, GLsizei length, const GLchar* message, const void* userParam)
    {
-    fprintf(stderr, "GL CALLBACK: %s type = 0x%X, severity = 0x%X, message = %s\n",
-            (type == GL_DEBUG_TYPE_ERROR ? "** GL ERROR **" : "" ),
-            type, severity, message);
+    fprintf(stderr, "GL CALLBACK: %s type = 0x%X, severity = 0x%X, message =
+   %s\n", (type == GL_DEBUG_TYPE_ERROR ? "** GL ERROR **" : "" ), type,
+   severity, message);
    }
    //*/
 #endif
 
-void GLView::initializeGL()
-{
+void GLView::initializeGL() {
 #ifdef DEBUG
 /*
    // Requires OpenGL 4.3+
@@ -325,8 +332,7 @@ void GLView::initializeGL()
 #endif
 }
 
-void GLView::showSmallaxes(const Color4f& col)
-{
+void GLView::showSmallaxes(const Color4f& col) {
   auto dpi = this->getDPI();
   // Small axis cross in the lower left corner
   glDepthFunc(GL_ALWAYS);
@@ -336,12 +342,9 @@ void GLView::showSmallaxes(const Color4f& col)
   glLoadIdentity();
   glTranslatef(-0.8f, -0.8f, 0.0f);
   auto scale = 90.0;
-  glOrtho(-scale * dpi * aspectratio, scale * dpi * aspectratio,
-          -scale * dpi, scale * dpi,
-          -scale * dpi, scale * dpi);
-  gluLookAt(0.0, -1.0, 0.0,
-            0.0, 0.0, 0.0,
-            0.0, 0.0, 1.0);
+  glOrtho(-scale * dpi * aspectratio, scale * dpi * aspectratio, -scale * dpi,
+          scale * dpi, -scale * dpi, scale * dpi);
+  gluLookAt(0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
 
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
@@ -352,11 +355,14 @@ void GLView::showSmallaxes(const Color4f& col)
   glLineWidth(dpi);
   glBegin(GL_LINES);
   glColor3d(1.0, 0.0, 0.0);
-  glVertex3d(0, 0, 0); glVertex3d(10 * dpi, 0, 0);
+  glVertex3d(0, 0, 0);
+  glVertex3d(10 * dpi, 0, 0);
   glColor3d(0.0, 1.0, 0.0);
-  glVertex3d(0, 0, 0); glVertex3d(0, 10 * dpi, 0);
+  glVertex3d(0, 0, 0);
+  glVertex3d(0, 10 * dpi, 0);
   glColor3d(0.0, 0.0, 1.0);
-  glVertex3d(0, 0, 0); glVertex3d(0, 0, 10 * dpi);
+  glVertex3d(0, 0, 0);
+  glVertex3d(0, 0, 10 * dpi);
   glEnd();
 
   GLdouble mat_model[16];
@@ -369,16 +375,22 @@ void GLView::showSmallaxes(const Color4f& col)
   glGetIntegerv(GL_VIEWPORT, viewport);
 
   GLdouble xlabel_x, xlabel_y, xlabel_z;
-  gluProject(12 * dpi, 0, 0, mat_model, mat_proj, viewport, &xlabel_x, &xlabel_y, &xlabel_z);
-  xlabel_x = std::round(xlabel_x); xlabel_y = std::round(xlabel_y);
+  gluProject(12 * dpi, 0, 0, mat_model, mat_proj, viewport, &xlabel_x,
+             &xlabel_y, &xlabel_z);
+  xlabel_x = std::round(xlabel_x);
+  xlabel_y = std::round(xlabel_y);
 
   GLdouble ylabel_x, ylabel_y, ylabel_z;
-  gluProject(0, 12 * dpi, 0, mat_model, mat_proj, viewport, &ylabel_x, &ylabel_y, &ylabel_z);
-  ylabel_x = std::round(ylabel_x); ylabel_y = std::round(ylabel_y);
+  gluProject(0, 12 * dpi, 0, mat_model, mat_proj, viewport, &ylabel_x,
+             &ylabel_y, &ylabel_z);
+  ylabel_x = std::round(ylabel_x);
+  ylabel_y = std::round(ylabel_y);
 
   GLdouble zlabel_x, zlabel_y, zlabel_z;
-  gluProject(0, 0, 12 * dpi, mat_model, mat_proj, viewport, &zlabel_x, &zlabel_y, &zlabel_z);
-  zlabel_x = std::round(zlabel_x); zlabel_y = std::round(zlabel_y);
+  gluProject(0, 0, 12 * dpi, mat_model, mat_proj, viewport, &zlabel_x,
+             &zlabel_y, &zlabel_z);
+  zlabel_x = std::round(zlabel_x);
+  zlabel_y = std::round(zlabel_y);
 
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
@@ -393,27 +405,33 @@ void GLView::showSmallaxes(const Color4f& col)
   float d = 3 * dpi;
   glBegin(GL_LINES);
   // X Label
-  glVertex3d(xlabel_x - d, xlabel_y - d, 0); glVertex3d(xlabel_x + d, xlabel_y + d, 0);
-  glVertex3d(xlabel_x - d, xlabel_y + d, 0); glVertex3d(xlabel_x + d, xlabel_y - d, 0);
+  glVertex3d(xlabel_x - d, xlabel_y - d, 0);
+  glVertex3d(xlabel_x + d, xlabel_y + d, 0);
+  glVertex3d(xlabel_x - d, xlabel_y + d, 0);
+  glVertex3d(xlabel_x + d, xlabel_y - d, 0);
   // Y Label
-  glVertex3d(ylabel_x - d, ylabel_y - d, 0); glVertex3d(ylabel_x + d, ylabel_y + d, 0);
-  glVertex3d(ylabel_x - d, ylabel_y + d, 0); glVertex3d(ylabel_x, ylabel_y, 0);
+  glVertex3d(ylabel_x - d, ylabel_y - d, 0);
+  glVertex3d(ylabel_x + d, ylabel_y + d, 0);
+  glVertex3d(ylabel_x - d, ylabel_y + d, 0);
+  glVertex3d(ylabel_x, ylabel_y, 0);
   // Z Label
-  glVertex3d(zlabel_x - d, zlabel_y - d, 0); glVertex3d(zlabel_x + d, zlabel_y - d, 0);
-  glVertex3d(zlabel_x - d, zlabel_y + d, 0); glVertex3d(zlabel_x + d, zlabel_y + d, 0);
-  glVertex3d(zlabel_x - d, zlabel_y - d, 0); glVertex3d(zlabel_x + d, zlabel_y + d, 0);
+  glVertex3d(zlabel_x - d, zlabel_y - d, 0);
+  glVertex3d(zlabel_x + d, zlabel_y - d, 0);
+  glVertex3d(zlabel_x - d, zlabel_y + d, 0);
+  glVertex3d(zlabel_x + d, zlabel_y + d, 0);
+  glVertex3d(zlabel_x - d, zlabel_y - d, 0);
+  glVertex3d(zlabel_x + d, zlabel_y + d, 0);
   glEnd();
 }
 
-void GLView::showAxes(const Color4f& col)
-{
+void GLView::showAxes(const Color4f& col) {
   // Large gray axis cross inline with the model
   glLineWidth(this->getDPI());
   glColor3f(col.r(), col.g(), col.b());
 
   glBegin(GL_LINES);
   glVertex4d(0, 0, 0, 1);
-  glVertex4d(1, 0, 0, 0); // w = 0 goes to infinity
+  glVertex4d(1, 0, 0, 0);  // w = 0 goes to infinity
   glVertex4d(0, 0, 0, 1);
   glVertex4d(0, 1, 0, 0);
   glVertex4d(0, 0, 0, 1);
@@ -434,8 +452,7 @@ void GLView::showAxes(const Color4f& col)
   glPopAttrib();
 }
 
-void GLView::showCrosshairs(const Color4f& col)
-{
+void GLView::showCrosshairs(const Color4f& col) {
   glLineWidth(this->getDPI());
   glColor3f(col.r(), col.g(), col.b());
   glBegin(GL_LINES);
@@ -448,51 +465,58 @@ void GLView::showCrosshairs(const Color4f& col)
   glEnd();
 }
 
-void GLView::showObject(const SelectedObject& obj, const Vector3d& eyedir)
-{
+void GLView::showObject(const SelectedObject& obj, const Vector3d& eyedir) {
   auto vd = cam.zoomValue() / 200.0;
   switch (obj.type) {
-  case SelectionType::SELECTION_POINT:
-  {
-    double n = 1 / sqrt(3);
-    // create an octaeder
-    //x- x+ y- y+ z- z+
-    int sequence[] = { 2, 0, 4, 1, 2, 4, 0, 3, 4, 3, 1, 4, 0, 2, 5, 2, 1, 5, 3, 0, 5, 1, 3, 5 };
-    glBegin(GL_TRIANGLES);
-    for (int i = 0; i < 8; i++) {
-      glNormal3f((i & 1)?-n:n, (i & 2)?-n:n, (i & 4)?-n:n);
-      for (int j = 0; j < 3; j++) {
-        int code = sequence[i * 3 + j];
-        switch (code) {
-        case 0: glVertex3d(obj.p1[0] - vd, obj.p1[1], obj.p1[2]); break;
-        case 1: glVertex3d(obj.p1[0] + vd, obj.p1[1], obj.p1[2]); break;
-        case 2: glVertex3d(obj.p1[0], obj.p1[1] - vd, obj.p1[2]); break;
-        case 3: glVertex3d(obj.p1[0], obj.p1[1] + vd, obj.p1[2]); break;
-        case 4: glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] - vd); break;
-        case 5: glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] + vd); break;
+    case SelectionType::SELECTION_POINT: {
+      double n = 1 / sqrt(3);
+      // create an octaeder
+      // x- x+ y- y+ z- z+
+      int sequence[] = {2, 0, 4, 1, 2, 4, 0, 3, 4, 3, 1, 4,
+                        0, 2, 5, 2, 1, 5, 3, 0, 5, 1, 3, 5};
+      glBegin(GL_TRIANGLES);
+      for (int i = 0; i < 8; i++) {
+        glNormal3f((i & 1) ? -n : n, (i & 2) ? -n : n, (i & 4) ? -n : n);
+        for (int j = 0; j < 3; j++) {
+          int code = sequence[i * 3 + j];
+          switch (code) {
+            case 0:
+              glVertex3d(obj.p1[0] - vd, obj.p1[1], obj.p1[2]);
+              break;
+            case 1:
+              glVertex3d(obj.p1[0] + vd, obj.p1[1], obj.p1[2]);
+              break;
+            case 2:
+              glVertex3d(obj.p1[0], obj.p1[1] - vd, obj.p1[2]);
+              break;
+            case 3:
+              glVertex3d(obj.p1[0], obj.p1[1] + vd, obj.p1[2]);
+              break;
+            case 4:
+              glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] - vd);
+              break;
+            case 5:
+              glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] + vd);
+              break;
+          }
         }
       }
-    }
-    glEnd();
-  }
-  break;
-  case SelectionType::SELECTION_LINE:
-  {
-    Vector3d diff = obj.p2 - obj.p1;
-    Vector3d wdir = eyedir.cross(diff).normalized() * vd / 2.0;
-    glBegin(GL_QUADS);
-    glVertex3d(obj.p1[0] - wdir[0], obj.p1[1] - wdir[1], obj.p1[2] - wdir[2]);
-    glVertex3d(obj.p2[0] - wdir[0], obj.p2[1] - wdir[1], obj.p2[2] - wdir[2]);
-    glVertex3d(obj.p2[0] + wdir[0], obj.p2[1] + wdir[1], obj.p2[2] + wdir[2]);
-    glVertex3d(obj.p1[0] + wdir[0], obj.p1[1] + wdir[1], obj.p1[2] + wdir[2]);
-    glEnd();
-  }
-  break;
+      glEnd();
+    } break;
+    case SelectionType::SELECTION_LINE: {
+      Vector3d diff = obj.p2 - obj.p1;
+      Vector3d wdir = eyedir.cross(diff).normalized() * vd / 2.0;
+      glBegin(GL_QUADS);
+      glVertex3d(obj.p1[0] - wdir[0], obj.p1[1] - wdir[1], obj.p1[2] - wdir[2]);
+      glVertex3d(obj.p2[0] - wdir[0], obj.p2[1] - wdir[1], obj.p2[2] - wdir[2]);
+      glVertex3d(obj.p2[0] + wdir[0], obj.p2[1] + wdir[1], obj.p2[2] + wdir[2]);
+      glVertex3d(obj.p1[0] + wdir[0], obj.p1[1] + wdir[1], obj.p1[2] + wdir[2]);
+      glEnd();
+    } break;
   }
 }
 
-void GLView::showScalemarkers(const Color4f& col)
-{
+void GLView::showScalemarkers(const Color4f& col) {
   // Add scale ticks on large axes
   auto l = cam.zoomValue();
   glLineWidth(this->getDPI());
@@ -507,33 +531,34 @@ void GLView::showScalemarkers(const Color4f& col)
   // Calculate tick width.
   const double tick_width = l_adjusted / 10.0;
 
-  const int size_div_sm = 60; // divisor for l to determine minor tick size
+  const int size_div_sm = 60;  // divisor for l to determine minor tick size
   int line_cnt = 0;
 
   size_t divs = l / tick_width;
   for (auto div = 0; div < divs; ++div) {
-    double i = div * tick_width; // i represents the position along the axis
+    double i = div * tick_width;  // i represents the position along the axis
     int size_div;
-    if (line_cnt > 0 && line_cnt % 10 == 0) { // major tick
-      size_div = size_div_sm * .5; // resize to a major tick
-      GLView::decodeMarkerValue(i, l, size_div_sm); // print number
-    } else {        // minor tick
-      size_div = size_div_sm; // set the minor tick to the standard size
-
-      // Draw additional labels if there are few major tick labels visible due to
-      // zoom. Because the spacing/units of major tick marks only change when the
-      // viewport changes size by a factor of 10, it can be hard to see the
-      // major tick labels when when the viewport is slightly larger than size at
-      // which the last tick spacing change occurred. When zoom level is such
+    if (line_cnt > 0 && line_cnt % 10 == 0) {        // major tick
+      size_div = size_div_sm * .5;                   // resize to a major tick
+      GLView::decodeMarkerValue(i, l, size_div_sm);  // print number
+    } else {                                         // minor tick
+      size_div = size_div_sm;  // set the minor tick to the standard size
+
+      // Draw additional labels if there are few major tick labels visible due
+      // to zoom. Because the spacing/units of major tick marks only change when
+      // the viewport changes size by a factor of 10, it can be hard to see the
+      // major tick labels when when the viewport is slightly larger than size
+      // at which the last tick spacing change occurred. When zoom level is such
       // that very few major tick marks are visible, additional labels are drawn
-      // every 2 minor ticks. We can detect that very few major ticks are visible
-      // by checking if the viewport size is larger than the adjusted scale by
-      // only a small ratio.
+      // every 2 minor ticks. We can detect that very few major ticks are
+      // visible by checking if the viewport size is larger than the adjusted
+      // scale by only a small ratio.
       const double more_labels_threshold = 3;
       // draw additional labels every 2 minor ticks
       const int more_labels_freq = 2;
-      if (line_cnt > 0 && line_cnt % more_labels_freq == 0 && l / l_adjusted < more_labels_threshold) {
-        GLView::decodeMarkerValue(i, l, size_div_sm); // print number
+      if (line_cnt > 0 && line_cnt % more_labels_freq == 0 &&
+          l / l_adjusted < more_labels_threshold) {
+        GLView::decodeMarkerValue(i, l, size_div_sm);  // print number
       }
     }
     line_cnt++;
@@ -550,19 +575,25 @@ void GLView::showScalemarkers(const Color4f& col)
     // positive axes
     glBegin(GL_LINES);
     // x
-    glVertex3d(i, 0, 0); glVertex3d(i, -l / size_div, 0); // 1 arm
-    //glVertex3d(i,-l/size_div,0); glVertex3d(i,l/size_div,0); // 2 arms
-    //glVertex3d(i,0,-l/size_div); glVertex3d(i,0,l/size_div); // 4 arms (w/ 2 arms line)
+    glVertex3d(i, 0, 0);
+    glVertex3d(i, -l / size_div, 0);  // 1 arm
+    // glVertex3d(i,-l/size_div,0); glVertex3d(i,l/size_div,0); // 2 arms
+    // glVertex3d(i,0,-l/size_div); glVertex3d(i,0,l/size_div); // 4 arms (w/ 2
+    // arms line)
 
     // y
-    glVertex3d(0, i, 0); glVertex3d(-l / size_div, i, 0); // 1 arm
-    //glVertex3d(-l/size_div,i,0); glVertex3d(l/size_div,i,0); // 2 arms
-    //glVertex3d(0,i,-l/size_div); glVertex3d(0,i,l/size_div); // 4 arms (w/ 2 arms line)
+    glVertex3d(0, i, 0);
+    glVertex3d(-l / size_div, i, 0);  // 1 arm
+    // glVertex3d(-l/size_div,i,0); glVertex3d(l/size_div,i,0); // 2 arms
+    // glVertex3d(0,i,-l/size_div); glVertex3d(0,i,l/size_div); // 4 arms (w/ 2
+    // arms line)
 
     // z
-    glVertex3d(0, 0, i); glVertex3d(-l / size_div, 0, i); // 1 arm
-    //glVertex3d(-l/size_div,0,i); glVertex3d(l/size_div,0,i); // 2 arms
-    //glVertex3d(0,-l/size_div,i); glVertex3d(0,l/size_div,i); // 4 arms (w/ 2 arms line)
+    glVertex3d(0, 0, i);
+    glVertex3d(-l / size_div, 0, i);  // 1 arm
+    // glVertex3d(-l/size_div,0,i); glVertex3d(l/size_div,0,i); // 2 arms
+    // glVertex3d(0,-l/size_div,i); glVertex3d(0,l/size_div,i); // 4 arms (w/ 2
+    // arms line)
     glEnd();
 
     // negative axes
@@ -571,26 +602,31 @@ void GLView::showScalemarkers(const Color4f& col)
     glLineStipple(3, 0xAAAA);
     glBegin(GL_LINES);
     // x
-    glVertex3d(-i, 0, 0); glVertex3d(-i, -l / size_div, 0); // 1 arm
-    //glVertex3d(-i,-l/size_div,0); glVertex3d(-i,l/size_div,0); // 2 arms
-    //glVertex3d(-i,0,-l/size_div); glVertex3d(-i,0,l/size_div); // 4 arms (w/ 2 arms line)
+    glVertex3d(-i, 0, 0);
+    glVertex3d(-i, -l / size_div, 0);  // 1 arm
+    // glVertex3d(-i,-l/size_div,0); glVertex3d(-i,l/size_div,0); // 2 arms
+    // glVertex3d(-i,0,-l/size_div); glVertex3d(-i,0,l/size_div); // 4 arms (w/
+    // 2 arms line)
 
     // y
-    glVertex3d(0, -i, 0); glVertex3d(-l / size_div, -i, 0); // 1 arm
-    //glVertex3d(-l/size_div,-i,0); glVertex3d(l/size_div,-i,0); // 2 arms
-    //glVertex3d(0,-i,-l/size_div); glVertex3d(0,-i,l/size_div); // 4 arms (w/ 2 arms line)
+    glVertex3d(0, -i, 0);
+    glVertex3d(-l / size_div, -i, 0);  // 1 arm
+    // glVertex3d(-l/size_div,-i,0); glVertex3d(l/size_div,-i,0); // 2 arms
+    // glVertex3d(0,-i,-l/size_div); glVertex3d(0,-i,l/size_div); // 4 arms (w/
+    // 2 arms line)
 
     // z
-    glVertex3d(0, 0, -i); glVertex3d(-l / size_div, 0, -i); // 1 arm
-    //glVertex3d(-l/size_div,0,-i); glVertex3d(l/size_div,0,-i); // 2 arms
-    //glVertex3d(0,-l/size_div,-i); glVertex3d(0,l/size_div,-i); // 4 arms (w/ 2 arms line)
+    glVertex3d(0, 0, -i);
+    glVertex3d(-l / size_div, 0, -i);  // 1 arm
+    // glVertex3d(-l/size_div,0,-i); glVertex3d(l/size_div,0,-i); // 2 arms
+    // glVertex3d(0,-l/size_div,-i); glVertex3d(0,l/size_div,-i); // 4 arms (w/
+    // 2 arms line)
     glEnd();
     glPopAttrib();
   }
 }
 
-void GLView::decodeMarkerValue(double i, double l, int size_div_sm)
-{
+void GLView::decodeMarkerValue(double i, double l, int size_div_sm) {
   // We draw both at once the positive and corresponding negative number.
   const std::string pos_number_str = STR(i);
   const std::string neg_number_str = "-" + pos_number_str;
@@ -605,39 +641,43 @@ void GLView::decodeMarkerValue(double i, double l, int size_div_sm)
   // Draw functions that help map 2D axis label drawings into their plane.
   // Since we're just on axis, no need for fancy affine transformation,
   // just calling glVertex3d() with coordinates in the right plane.
-  using PlaneVertexDraw = std::function<void (
-                                          float x, float y, float font_height, float baseline_offset)>;
+  using PlaneVertexDraw = std::function<void(
+      float x, float y, float font_height, float baseline_offset)>;
 
   const PlaneVertexDraw axis_draw_planes[3] = {
-    [](float x, float y, float /*fh*/, float bl) {
-      glVertex3d(x, y + bl, 0);  // x-label along x-axis; font drawn above line
-    },
-    [](float x, float y, float fh, float bl) {
-      glVertex3d(-y + (fh + bl), x, 0);  // y-label along y-axis; font below
-    },
-    [](float x, float y, float fh, float bl) {
-      glVertex3d(-y + (fh + bl), 0, x);  // z-label along z-axis; font below
-    },
+      [](float x, float y, float /*fh*/, float bl) {
+        glVertex3d(x, y + bl,
+                   0);  // x-label along x-axis; font drawn above line
+      },
+      [](float x, float y, float fh, float bl) {
+        glVertex3d(-y + (fh + bl), x, 0);  // y-label along y-axis; font below
+      },
+      [](float x, float y, float fh, float bl) {
+        glVertex3d(-y + (fh + bl), 0, x);  // z-label along z-axis; font below
+      },
   };
   bool needs_glend = false;
   for (const PlaneVertexDraw& axis_draw : axis_draw_planes) {
     // We get 'plot instructions', a sequence of vertices. Translate into gl ops
     const auto plot_fun = [&](bool pen_down, float x, float y) {
-        if (!pen_down) { // Start a new line, coordinates just move not draw
-          if (needs_glend) glEnd();
-          glBegin(GL_LINE_STRIP);
-          needs_glend = true;
-        }
-        axis_draw(x, y, font_size, baseline_offset);
-      };
+      if (!pen_down) {  // Start a new line, coordinates just move not draw
+        if (needs_glend)
+          glEnd();
+        glBegin(GL_LINE_STRIP);
+        needs_glend = true;
+      }
+      axis_draw(x, y, font_size, baseline_offset);
+    };
 
-    hershey::DrawText(pos_number_str, i, 0,
-                      hershey::TextAlign::kCenter, font_size, plot_fun);
-    if (needs_glend) glEnd();
+    hershey::DrawText(pos_number_str, i, 0, hershey::TextAlign::kCenter,
+                      font_size, plot_fun);
+    if (needs_glend)
+      glEnd();
     needs_glend = false;
     hershey::DrawText(neg_number_str, -i - prefix_offset, 0,
                       hershey::TextAlign::kCenter, font_size, plot_fun);
-    if (needs_glend) glEnd();
+    if (needs_glend)
+      glEnd();
     needs_glend = false;
   }
 }
diff --git a/src/glview/GLView.h b/src/glview/GLView.h
index 3e32daeb4..afda5cdd6 100644
--- a/src/glview/GLView.h
+++ b/src/glview/GLView.h
@@ -17,21 +17,20 @@
 
  */
 
-#include <memory>
 #include <Eigen/Core>
 #include <Eigen/Geometry>
+#include <memory>
 #include <string>
 #include <vector>
-#include "glview/Camera.h"
+#include "core/Selection.h"
 #include "geometry/linalg.h"
+#include "glview/Camera.h"
 #include "glview/ColorMap.h"
-#include "glview/system-gl.h"
-#include "core/Selection.h"
 #include "glview/Renderer.h"
+#include "glview/system-gl.h"
 
-class GLView
-{
-public:
+class GLView {
+ public:
   GLView();
   virtual ~GLView();
 
@@ -39,7 +38,7 @@ public:
   void teardownShader();
 
   void setRenderer(std::shared_ptr<Renderer> r);
-  [[nodiscard]] Renderer *getRenderer() const { return this->renderer.get(); }
+  [[nodiscard]] Renderer* getRenderer() const { return this->renderer.get(); }
 
   void initializeGL();
   void resizeGL(int w, int h);
@@ -61,13 +60,13 @@ public:
   [[nodiscard]] bool showCrosshairs() const { return this->showcrosshairs; }
   void setShowCrosshairs(bool enabled) { this->showcrosshairs = enabled; }
 
-  virtual bool save(const char *filename) const = 0;
+  virtual bool save(const char* filename) const = 0;
   [[nodiscard]] virtual std::string getRendererInfo() const = 0;
   virtual float getDPI() { return 1.0f; }
 
   std::unique_ptr<ShaderUtils::ShaderInfo> edge_shader;
   std::shared_ptr<Renderer> renderer;
-  const ColorScheme *colorscheme;
+  const ColorScheme* colorscheme;
   Camera cam;
   double far_far_away;
   double aspectratio;
@@ -88,7 +87,8 @@ public:
   int opencsg_id;
 #endif
   void showObject(const SelectedObject& pt, const Vector3d& eyedir);
-private:
+
+ private:
   void showCrosshairs(const Color4f& col);
   void showAxes(const Color4f& col);
   void showSmallaxes(const Color4f& col);
diff --git a/src/glview/NULLGL.cc b/src/glview/NULLGL.cc
index 41e355a86..e22a4e498 100644
--- a/src/glview/NULLGL.cc
+++ b/src/glview/NULLGL.cc
@@ -8,29 +8,47 @@
 #include "geometry/linalg.h"
 #include "glview/Camera.h"
 #include "glview/ColorMap.h"
-#include "glview/Renderer.h"
-#include "glview/fbo.h"
 #include "glview/GLView.h"
 #include "glview/OpenGLContext.h"
+#include "glview/Renderer.h"
+#include "glview/fbo.h"
 #include "glview/system-gl.h"
 
-bool FBO::resize(size_t, size_t) { return false; }
+bool FBO::resize(size_t, size_t) {
+  return false;
+}
 FBO::FBO(int, int, bool) {}
-GLuint FBO::bind() { return 0; }
+GLuint FBO::bind() {
+  return 0;
+}
 GLView::~GLView() = default;
 GLView::GLView() = default;
-std::string gl_dump() { return {"GL Renderer: NULLGL\n"}; }
-std::string gl_extensions_dump() { return {"NULLGL Extensions"}; }
-std::unique_ptr<FBO> createFBO(int, int) {return nullptr;}
-std::vector<uint8_t> OpenGLContext::getFramebuffer() const { return {}; }
+std::string gl_dump() {
+  return {"GL Renderer: NULLGL\n"};
+}
+std::string gl_extensions_dump() {
+  return {"NULLGL Extensions"};
+}
+std::unique_ptr<FBO> createFBO(int, int) {
+  return nullptr;
+}
+std::vector<uint8_t> OpenGLContext::getFramebuffer() const {
+  return {};
+}
 void FBO::destroy() {}
 void FBO::unbind() {}
 void GLView::initializeGL() {}
 void GLView::paintGL() {}
 void GLView::resizeGL(int w, int h) {}
-void GLView::setCamera(const Camera& /*cam*/) {assert(false && "not implemented");}
-void GLView::setColorScheme(const ColorScheme& /*cs*/){assert(false && "not implemented");}
-void GLView::setColorScheme(const std::string& /*cs*/) {assert(false && "not implemented");}
+void GLView::setCamera(const Camera& /*cam*/) {
+  assert(false && "not implemented");
+}
+void GLView::setColorScheme(const ColorScheme& /*cs*/) {
+  assert(false && "not implemented");
+}
+void GLView::setColorScheme(const std::string& /*cs*/) {
+  assert(false && "not implemented");
+}
 void GLView::setRenderer(std::shared_ptr<Renderer>) {}
 void GLView::showAxes(const Color4f& col) {}
 void GLView::showCrosshairs(const Color4f& col) {}
diff --git a/src/glview/OffscreenContext.h b/src/glview/OffscreenContext.h
index 794b8d68b..024c03cfa 100644
--- a/src/glview/OffscreenContext.h
+++ b/src/glview/OffscreenContext.h
@@ -3,8 +3,8 @@
 #include <cstdint>
 #include "glview/OpenGLContext.h"
 
-class OffscreenContext : public OpenGLContext
-{
-public:
-  OffscreenContext(uint32_t width, uint32_t height) : OpenGLContext(width, height) {}
+class OffscreenContext : public OpenGLContext {
+ public:
+  OffscreenContext(uint32_t width, uint32_t height)
+      : OpenGLContext(width, height) {}
 };
diff --git a/src/glview/OffscreenContextCGL.cc b/src/glview/OffscreenContextCGL.cc
index 5d8af174e..f2205ab9a 100644
--- a/src/glview/OffscreenContextCGL.cc
+++ b/src/glview/OffscreenContextCGL.cc
@@ -1,22 +1,19 @@
 #include "glview/OffscreenContextCGL.h"
 
-#include <sstream>
-#include <memory>
 #include <cstddef>
-#include <string>
 #include <iostream>
+#include <memory>
+#include <sstream>
+#include <string>
 
-#include "glview/system-gl.h"
 #include <OpenGL/OpenGL.h>
+#include "glview/system-gl.h"
 
-class OffscreenContextCGL : public OffscreenContext
-{
-
-public:
-  OffscreenContextCGL(int width, int height) : OffscreenContext(width, height) {}
-  ~OffscreenContextCGL() {
-    CGLDestroyContext(cglContext);
-  }
+class OffscreenContextCGL : public OffscreenContext {
+ public:
+  OffscreenContextCGL(int width, int height)
+      : OffscreenContext(width, height) {}
+  ~OffscreenContextCGL() { CGLDestroyContext(cglContext); }
 
   // FIXME: What info are we really interested in here?
   std::string getInfo() const override {
@@ -33,29 +30,33 @@ public:
   CGLContextObj cglContext = nullptr;
 };
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion)
-{
+std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(
+    size_t width,
+    size_t height,
+    size_t majorGLVersion,
+    size_t minorGLVersion) {
   auto ctx = std::make_shared<OffscreenContextCGL>(width, height);
 
   CGLOpenGLProfile glVersion = kCGLOGLPVersion_Legacy;
-  if (majorGLVersion >= 4) glVersion = kCGLOGLPVersion_GL4_Core;
-  else if (majorGLVersion >= 3) glVersion = kCGLOGLPVersion_GL3_Core;
+  if (majorGLVersion >= 4)
+    glVersion = kCGLOGLPVersion_GL4_Core;
+  else if (majorGLVersion >= 3)
+    glVersion = kCGLOGLPVersion_GL3_Core;
 
   CGLPixelFormatAttribute attributes[13] = {
-    kCGLPFAOpenGLProfile, (CGLPixelFormatAttribute)glVersion,
-    kCGLPFAColorSize, (CGLPixelFormatAttribute)24,
-    kCGLPFAAlphaSize, (CGLPixelFormatAttribute)8,
-    kCGLPFADoubleBuffer,
-    kCGLPFASampleBuffers, (CGLPixelFormatAttribute)1,
-    kCGLPFASamples,  (CGLPixelFormatAttribute)4,
-    (CGLPixelFormatAttribute) 0
-  };
+      kCGLPFAOpenGLProfile,       (CGLPixelFormatAttribute)glVersion,
+      kCGLPFAColorSize,           (CGLPixelFormatAttribute)24,
+      kCGLPFAAlphaSize,           (CGLPixelFormatAttribute)8,
+      kCGLPFADoubleBuffer,        kCGLPFASampleBuffers,
+      (CGLPixelFormatAttribute)1, kCGLPFASamples,
+      (CGLPixelFormatAttribute)4, (CGLPixelFormatAttribute)0};
   CGLPixelFormatObj pixelFormat = NULL;
   GLint numPixelFormats = 0;
-  const auto status = CGLChoosePixelFormat(attributes, &pixelFormat, &numPixelFormats);
+  const auto status =
+      CGLChoosePixelFormat(attributes, &pixelFormat, &numPixelFormats);
   if (status != kCGLNoError) {
-    std::cerr << "CGLChoosePixelFormat() failed: " << CGLErrorString(status) << std::endl;
+    std::cerr << "CGLChoosePixelFormat() failed: " << CGLErrorString(status)
+              << std::endl;
     return nullptr;
   }
   CGLCreateContext(pixelFormat, NULL, &ctx->cglContext);
diff --git a/src/glview/OffscreenContextCGL.h b/src/glview/OffscreenContextCGL.h
index 0fc65b545..b42f9ac5e 100644
--- a/src/glview/OffscreenContextCGL.h
+++ b/src/glview/OffscreenContextCGL.h
@@ -5,5 +5,8 @@
 
 #include "glview/OffscreenContext.h"
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion);
+std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(
+    size_t width,
+    size_t height,
+    size_t majorGLVersion,
+    size_t minorGLVersion);
diff --git a/src/glview/OffscreenContextEGL.cc b/src/glview/OffscreenContextEGL.cc
index ea811f883..0f8a90d2d 100644
--- a/src/glview/OffscreenContextEGL.cc
+++ b/src/glview/OffscreenContextEGL.cc
@@ -1,8 +1,8 @@
 #include "glview/OffscreenContextEGL.h"
 
-#include <memory>
 #include <fcntl.h>
 #include <cstddef>
+#include <memory>
 #include <set>
 #include <sstream>
 #include <string>
@@ -10,55 +10,58 @@
 
 #include "utils/printutils.h"
 #define GLAD_EGL_IMPLEMENTATION
-#include "glad/egl.h"
 #include <GL/gl.h>
+#include "glad/egl.h"
 
 namespace {
 
-#define CASE_STR(value) case value: return #value;
-const char *eglGetErrorString(EGLint error)
-{
+#define CASE_STR(value) \
+  case value:           \
+    return #value;
+const char* eglGetErrorString(EGLint error) {
   switch (error) {
-  CASE_STR(EGL_SUCCESS)
-  CASE_STR(EGL_NOT_INITIALIZED)
-  CASE_STR(EGL_BAD_ACCESS)
-  CASE_STR(EGL_BAD_ALLOC)
-  CASE_STR(EGL_BAD_ATTRIBUTE)
-  CASE_STR(EGL_BAD_CONTEXT)
-  CASE_STR(EGL_BAD_CONFIG)
-  CASE_STR(EGL_BAD_CURRENT_SURFACE)
-  CASE_STR(EGL_BAD_DISPLAY)
-  CASE_STR(EGL_BAD_SURFACE)
-  CASE_STR(EGL_BAD_MATCH)
-  CASE_STR(EGL_BAD_PARAMETER)
-  CASE_STR(EGL_BAD_NATIVE_PIXMAP)
-  CASE_STR(EGL_BAD_NATIVE_WINDOW)
-  CASE_STR(EGL_CONTEXT_LOST)
-  default: return "Unknown";
+    CASE_STR(EGL_SUCCESS)
+    CASE_STR(EGL_NOT_INITIALIZED)
+    CASE_STR(EGL_BAD_ACCESS)
+    CASE_STR(EGL_BAD_ALLOC)
+    CASE_STR(EGL_BAD_ATTRIBUTE)
+    CASE_STR(EGL_BAD_CONTEXT)
+    CASE_STR(EGL_BAD_CONFIG)
+    CASE_STR(EGL_BAD_CURRENT_SURFACE)
+    CASE_STR(EGL_BAD_DISPLAY)
+    CASE_STR(EGL_BAD_SURFACE)
+    CASE_STR(EGL_BAD_MATCH)
+    CASE_STR(EGL_BAD_PARAMETER)
+    CASE_STR(EGL_BAD_NATIVE_PIXMAP)
+    CASE_STR(EGL_BAD_NATIVE_WINDOW)
+    CASE_STR(EGL_CONTEXT_LOST)
+    default:
+      return "Unknown";
   }
 }
 #undef CASE_STR
 
-} // namespace
-
-class OffscreenContextEGL : public OffscreenContext
-{
+}  // namespace
 
-public:
+class OffscreenContextEGL : public OffscreenContext {
+ public:
   EGLDisplay eglDisplay;
   EGLSurface eglSurface;
   EGLContext eglContext;
 
-  OffscreenContextEGL(int width, int height) : OffscreenContext(width, height) {}
+  OffscreenContextEGL(int width, int height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextEGL() {
-    if (this->eglSurface) eglDestroySurface(this->eglDisplay, this->eglSurface);
-    if (this->eglDisplay) eglTerminate(this->eglDisplay);
+    if (this->eglSurface)
+      eglDestroySurface(this->eglDisplay, this->eglSurface);
+    if (this->eglDisplay)
+      eglTerminate(this->eglDisplay);
   }
 
   std::string getInfo() const override {
     std::ostringstream result;
 
-    const char *eglVersion = eglQueryString(this->eglDisplay, EGL_VERSION);
+    const char* eglVersion = eglQueryString(this->eglDisplay, EGL_VERSION);
 
     result << "GL context creator: EGL (new)\n"
            << "EGL version: " << eglVersion << "\n"
@@ -68,7 +71,8 @@ public:
   }
 
   bool makeCurrent() const override {
-    return eglMakeCurrent(this->eglDisplay, this->eglSurface, this->eglSurface, this->eglContext);
+    return eglMakeCurrent(this->eglDisplay, this->eglSurface, this->eglSurface,
+                          this->eglContext);
   }
 
   void findPlatformDisplay() {
@@ -81,7 +85,8 @@ public:
       clientExtensions.insert(extension);
     }
 
-    if (clientExtensions.find("EGL_EXT_platform_device") == clientExtensions.end()) {
+    if (clientExtensions.find("EGL_EXT_platform_device") ==
+        clientExtensions.end()) {
       return;
     }
 
@@ -91,18 +96,20 @@ public:
       eglQueryDevicesEXT(1, &eglDevice, &numDevices);
       if (numDevices > 0) {
         // FIXME: Attribs
-        this->eglDisplay = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT, eglDevice, nullptr);
+        this->eglDisplay = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT,
+                                                    eglDevice, nullptr);
       }
     }
   }
 
   void createSurface(const EGLConfig& config, size_t width, size_t height) {
     const EGLint pbufferAttribs[] = {
-      EGL_WIDTH, static_cast<EGLint>(width),
-      EGL_HEIGHT, static_cast<EGLint>(height),
-      EGL_NONE,
+        EGL_WIDTH,  static_cast<EGLint>(width),
+        EGL_HEIGHT, static_cast<EGLint>(height),
+        EGL_NONE,
     };
-    this->eglSurface = eglCreatePbufferSurface(this->eglDisplay, config, pbufferAttribs);
+    this->eglSurface =
+        eglCreatePbufferSurface(this->eglDisplay, config, pbufferAttribs);
   }
 };
 
@@ -110,10 +117,13 @@ public:
 // OpenGL core major.minor
 // OpenGL compatibility major.minor
 // OpenGL ES major.minor
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion,
-                                                            bool gles, bool compatibilityProfile)
-{
+std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
+    size_t width,
+    size_t height,
+    size_t majorGLVersion,
+    size_t minorGLVersion,
+    bool gles,
+    bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextEGL>(width, height);
 
   int initialEglVersion = gladLoaderLoadEGL(nullptr);
@@ -122,26 +132,29 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t
     return nullptr;
   }
   PRINTDB("GLAD: Loaded EGL %d.%d on first load",
-          GLAD_VERSION_MAJOR(initialEglVersion) % GLAD_VERSION_MINOR(initialEglVersion));
+          GLAD_VERSION_MAJOR(initialEglVersion) %
+              GLAD_VERSION_MINOR(initialEglVersion));
 
   EGLint conformant;
-  if (!gles) conformant = EGL_OPENGL_BIT;
-  else if (majorGLVersion >= 3) conformant = EGL_OPENGL_ES3_BIT;
-  else if (majorGLVersion >= 2) conformant = EGL_OPENGL_ES2_BIT;
-  else conformant = EGL_OPENGL_ES_BIT;
-
-  const EGLint configAttribs[] = {
-    EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-    EGL_BLUE_SIZE, 8,
-    EGL_GREEN_SIZE, 8,
-    EGL_RED_SIZE, 8,
-    EGL_ALPHA_SIZE, 8,
-    EGL_DEPTH_SIZE, 24,
-    EGL_STENCIL_SIZE, 8,
-    EGL_CONFORMANT, conformant,
-    EGL_CONFIG_CAVEAT, EGL_NONE,
-    EGL_NONE
-  };
+  if (!gles)
+    conformant = EGL_OPENGL_BIT;
+  else if (majorGLVersion >= 3)
+    conformant = EGL_OPENGL_ES3_BIT;
+  else if (majorGLVersion >= 2)
+    conformant = EGL_OPENGL_ES2_BIT;
+  else
+    conformant = EGL_OPENGL_ES_BIT;
+
+  const EGLint configAttribs[] = {EGL_SURFACE_TYPE,  EGL_PBUFFER_BIT,
+                                  EGL_BLUE_SIZE,     8,
+                                  EGL_GREEN_SIZE,    8,
+                                  EGL_RED_SIZE,      8,
+                                  EGL_ALPHA_SIZE,    8,
+                                  EGL_DEPTH_SIZE,    24,
+                                  EGL_STENCIL_SIZE,  8,
+                                  EGL_CONFORMANT,    conformant,
+                                  EGL_CONFIG_CAVEAT, EGL_NONE,
+                                  EGL_NONE};
 
   // FIXME: Should we try default display first?
   // If so, we also have to try initializing it
@@ -161,18 +174,21 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t
     return nullptr;
   }
 
-  PRINTDB("Initialized EGL version: %d.%d (%s)", major % minor % eglQueryString(ctx->eglDisplay, EGL_VENDOR));
+  PRINTDB("Initialized EGL version: %d.%d (%s)",
+          major % minor % eglQueryString(ctx->eglDisplay, EGL_VENDOR));
 
   const auto eglVersion = gladLoaderLoadEGL(ctx->eglDisplay);
   if (!eglVersion) {
     LOG("gladLoaderLoadEGL(eglDisplay): Unable to reload EGL");
     return nullptr;
   }
-  PRINTDB("GLAD: Loaded EGL %d.%d after reload", GLAD_VERSION_MAJOR(eglVersion) % GLAD_VERSION_MINOR(eglVersion));
+  PRINTDB("GLAD: Loaded EGL %d.%d after reload",
+          GLAD_VERSION_MAJOR(eglVersion) % GLAD_VERSION_MINOR(eglVersion));
 
   EGLint numConfigs;
   EGLConfig config;
-  bool gotConfig = eglChooseConfig(ctx->eglDisplay, configAttribs, &config, 1, &numConfigs);
+  bool gotConfig =
+      eglChooseConfig(ctx->eglDisplay, configAttribs, &config, 1, &numConfigs);
   if (!gotConfig || numConfigs == 0) {
     LOG("Failed to choose config (eglError: %1$x)", eglGetError());
     return nullptr;
@@ -189,15 +205,20 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t
   }
 
   std::vector<EGLint> ctxattr = {
-    EGL_CONTEXT_MAJOR_VERSION, static_cast<EGLint>(majorGLVersion),
-    EGL_CONTEXT_MINOR_VERSION, static_cast<EGLint>(minorGLVersion),
+      EGL_CONTEXT_MAJOR_VERSION,
+      static_cast<EGLint>(majorGLVersion),
+      EGL_CONTEXT_MINOR_VERSION,
+      static_cast<EGLint>(minorGLVersion),
   };
   if (!gles) {
     ctxattr.push_back(EGL_CONTEXT_OPENGL_PROFILE_MASK);
-    ctxattr.push_back(compatibilityProfile ? EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT : EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
+    ctxattr.push_back(compatibilityProfile
+                          ? EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT
+                          : EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
   }
   ctxattr.push_back(EGL_NONE);
-  ctx->eglContext = eglCreateContext(ctx->eglDisplay, config, EGL_NO_CONTEXT, ctxattr.data());
+  ctx->eglContext =
+      eglCreateContext(ctx->eglDisplay, config, EGL_NO_CONTEXT, ctxattr.data());
   if (ctx->eglContext == EGL_NO_CONTEXT) {
     LOG("Unable to create EGL context (eglError: %1$x)", eglGetError());
     return nullptr;
diff --git a/src/glview/OffscreenContextEGL.h b/src/glview/OffscreenContextEGL.h
index d446e9970..b2f32b101 100644
--- a/src/glview/OffscreenContextEGL.h
+++ b/src/glview/OffscreenContextEGL.h
@@ -6,5 +6,9 @@
 #include "glview/OffscreenContext.h"
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
-  size_t width, size_t height, size_t majorGLVersion,
-  size_t minorGLVersion, bool gles, bool compatibilityProfile);
+    size_t width,
+    size_t height,
+    size_t majorGLVersion,
+    size_t minorGLVersion,
+    bool gles,
+    bool compatibilityProfile);
diff --git a/src/glview/OffscreenContextFactory.cc b/src/glview/OffscreenContextFactory.cc
index c0b45b8ad..05fe379bb 100644
--- a/src/glview/OffscreenContextFactory.cc
+++ b/src/glview/OffscreenContextFactory.cc
@@ -6,19 +6,19 @@
 #include "utils/printutils.h"
 
 #ifdef __APPLE__
-#include "glview/offscreen-old/OffscreenContextNSOpenGL.h"
 #include "glview/OffscreenContextCGL.h"
+#include "glview/offscreen-old/OffscreenContextNSOpenGL.h"
 #endif
 #ifdef _WIN32
 #include "glview/offscreen-old/OffscreenContextWGL.h"
 #endif
 #ifdef ENABLE_EGL
-#include "glview/offscreen-old/OffscreenContextEGL.h"
 #include "glview/OffscreenContextEGL.h"
+#include "glview/offscreen-old/OffscreenContextEGL.h"
 #endif
 #ifdef ENABLE_GLX
-#include "glview/offscreen-old/OffscreenContextGLX.h"
 #include "glview/OffscreenContextGLX.h"
+#include "glview/offscreen-old/OffscreenContextGLX.h"
 #endif
 #ifdef NULLGL
 #include "glview/OffscreenContextNULL.h"
@@ -26,7 +26,7 @@
 
 namespace OffscreenContextFactory {
 
-const char *defaultProvider() {
+const char* defaultProvider() {
 #ifdef NULLGL
   return "nullgl";
 #else
@@ -45,13 +45,18 @@ const char *defaultProvider() {
 #endif  // NULLGL
 }
 
-std::shared_ptr<OpenGLContext> create(const std::string& provider, const OffscreenContextFactory::ContextAttributes& attrib)
-{
+std::shared_ptr<OpenGLContext> create(
+    const std::string& provider,
+    const OffscreenContextFactory::ContextAttributes& attrib) {
   PRINTDB("Creating OpenGL context with the %1s provider:", provider);
   PRINTDB("  Size: %d x %d", attrib.width % attrib.height);
-  PRINTDB("  Version: %s %d.%d %s", (attrib.gles ? "OpenGL ES" : "OpenGL") % attrib.majorGLVersion % attrib.minorGLVersion %
-          (attrib.compatibilityProfile ? "(compatibility profile requested)" : ""));
-  // FIXME: We should log an error if the chosen provider doesn't support all our attribs.
+  PRINTDB("  Version: %s %d.%d %s",
+          (attrib.gles ? "OpenGL ES" : "OpenGL") % attrib.majorGLVersion %
+              attrib.minorGLVersion %
+              (attrib.compatibilityProfile ? "(compatibility profile requested)"
+                                           : ""));
+  // FIXME: We should log an error if the chosen provider doesn't support all
+  // our attribs.
 #ifdef NULLGL
   if (provider == "nullgl") {
     return CreateOffscreenContextNULL();
@@ -65,29 +70,35 @@ std::shared_ptr<OpenGLContext> create(const std::string& provider, const Offscre
     if (attrib.compatibilityProfile) {
       LOG("Compatibility context is not available on macOS");
     }
-    return offscreen_old::CreateOffscreenContextNSOpenGL(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion);
+    return offscreen_old::CreateOffscreenContextNSOpenGL(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion);
   } else if (provider == "cgl") {
-    return CreateOffscreenContextCGL(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion);
+    return CreateOffscreenContextCGL(attrib.width, attrib.height,
+                                     attrib.majorGLVersion,
+                                     attrib.minorGLVersion);
   }
-#endif // ifdef __APPLE__
+#endif  // ifdef __APPLE__
 #if ENABLE_EGL
   if (provider == "egl-old") {
-    return offscreen_old::CreateOffscreenContextEGL(attrib.width, attrib.height,
-                                                    attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.gles, attrib.compatibilityProfile);
+    return offscreen_old::CreateOffscreenContextEGL(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.gles, attrib.compatibilityProfile);
   } else if (provider == "egl") {
-    return CreateOffscreenContextEGL(attrib.width, attrib.height,
-                                     attrib.majorGLVersion, attrib.minorGLVersion,
-                                     attrib.gles, attrib.compatibilityProfile);
+    return CreateOffscreenContextEGL(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.gles, attrib.compatibilityProfile);
   } else
 #endif
 #ifdef ENABLE_GLX
-  if (provider == "glx-old") {
-    return offscreen_old::CreateOffscreenContextGLX(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.gles, attrib.compatibilityProfile);
+      if (provider == "glx-old") {
+    return offscreen_old::CreateOffscreenContextGLX(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.gles, attrib.compatibilityProfile);
   } else if (provider == "glx") {
-    return CreateOffscreenContextGLX(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion,
-                                     attrib.gles, attrib.compatibilityProfile);
+    return CreateOffscreenContextGLX(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.gles, attrib.compatibilityProfile);
   }
 #endif
 #ifdef _WIN32
@@ -95,9 +106,9 @@ std::shared_ptr<OpenGLContext> create(const std::string& provider, const Offscre
     if (attrib.gles) {
       LOG("GLES is not supported on Windows");
     }
-    return offscreen_old::CreateOffscreenContextWGL(attrib.width, attrib.height,
-                                                    attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.compatibilityProfile);
+    return offscreen_old::CreateOffscreenContextWGL(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.compatibilityProfile);
   } else
 #endif
 #endif  // NULLGL
diff --git a/src/glview/OffscreenContextFactory.h b/src/glview/OffscreenContextFactory.h
index 9b83e0559..6c78b72ef 100644
--- a/src/glview/OffscreenContextFactory.h
+++ b/src/glview/OffscreenContextFactory.h
@@ -9,15 +9,17 @@
 namespace OffscreenContextFactory {
 
 struct ContextAttributes {
-  uint32_t width;            // Context size in pixels
-  uint32_t height;           //
-  uint32_t majorGLVersion;   // Minimum OpenGL or GLES major version
-  uint32_t minorGLVersion;   // Minimum OpenGL or GLES minor version
-  bool gles;                 // Request a GLES context
-  bool compatibilityProfile; // Request a compatibility context (to support legacy OpenGL calls)
+  uint32_t width;             // Context size in pixels
+  uint32_t height;            //
+  uint32_t majorGLVersion;    // Minimum OpenGL or GLES major version
+  uint32_t minorGLVersion;    // Minimum OpenGL or GLES minor version
+  bool gles;                  // Request a GLES context
+  bool compatibilityProfile;  // Request a compatibility context (to support
+                              // legacy OpenGL calls)
 };
 
-const char *defaultProvider();
-std::shared_ptr<OpenGLContext> create(const std::string& provider, const ContextAttributes& attrib);
+const char* defaultProvider();
+std::shared_ptr<OpenGLContext> create(const std::string& provider,
+                                      const ContextAttributes& attrib);
 
 }  // namespace OffscreenContextFactory
diff --git a/src/glview/OffscreenContextGLX.cc b/src/glview/OffscreenContextGLX.cc
index 06d1604da..45c690212 100644
--- a/src/glview/OffscreenContextGLX.cc
+++ b/src/glview/OffscreenContextGLX.cc
@@ -10,30 +10,32 @@
 #include <sstream>
 #include <string>
 
-#include "utils/scope_guard.hpp"
 #include "utils/printutils.h"
+#include "utils/scope_guard.hpp"
 
 namespace {
 
 int xlibLastError = 0;
-int xlibErrorHandler(Display *dpy, XErrorEvent *event) {
+int xlibErrorHandler(Display* dpy, XErrorEvent* event) {
   xlibLastError = event->error_code;
   return 0;
 }
 
 }  // namespace
 
-class OffscreenContextGLX : public OffscreenContext
-{
-public:
+class OffscreenContextGLX : public OffscreenContext {
+ public:
   GLXContext glxContext = nullptr;
-  Display *display = nullptr;
+  Display* display = nullptr;
   Window xWindow = 0;
-  OffscreenContextGLX(int width, int height) : OffscreenContext(width, height) {}
+  OffscreenContextGLX(int width, int height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextGLX() {
     if (this->display) {
-      if (this->glxContext) glXDestroyContext(this->display, this->glxContext);
-      if (this->xWindow) XDestroyWindow(this->display, this->xWindow);
+      if (this->glxContext)
+        glXDestroyContext(this->display, this->glxContext);
+      if (this->xWindow)
+        XDestroyWindow(this->display, this->xWindow);
       XCloseDisplay(this->display);
     }
   }
@@ -53,36 +55,49 @@ public:
   }
 
   bool makeCurrent() const override {
-    return glXMakeContextCurrent(this->display, this->xWindow, this->xWindow, this->glxContext);
+    return glXMakeContextCurrent(this->display, this->xWindow, this->xWindow,
+                                 this->glxContext);
   }
 
-  // Create an OpenGL context, and a dummy X11 window to draw into, without showing (mapping) it.
-  // This purposely does not use glxCreateWindow, to avoid crashes,
-  // "failed to create drawable" errors, and Mesa "WARNING: Application calling
-  // GLX 1.3 function when GLX 1.3 is not supported! This is an application bug!"
+  // Create an OpenGL context, and a dummy X11 window to draw into, without
+  // showing (mapping) it. This purposely does not use glxCreateWindow, to avoid
+  // crashes, "failed to create drawable" errors, and Mesa "WARNING: Application
+  // calling GLX 1.3 function when GLX 1.3 is not supported! This is an
+  // application bug!"
 
   //  This function will alter ctx.openGLContext and ctx.xwindow if successful
-  bool createGLXContext(size_t majorGLVersion, size_t minorGLVersion, bool compatibilityProfile) {
-    const int attributes[] = {
-      GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT | GLX_PIXMAP_BIT,
-      GLX_RENDER_TYPE, GLX_RGBA_BIT,
-      GLX_RED_SIZE, 8,
-      GLX_GREEN_SIZE, 8,
-      GLX_BLUE_SIZE, 8,
-      GLX_ALPHA_SIZE, 8,
-      GLX_DEPTH_SIZE, 24, // depth-stencil for OpenCSG
-      GLX_STENCIL_SIZE, 8,
-      None
-    };
+  bool createGLXContext(size_t majorGLVersion,
+                        size_t minorGLVersion,
+                        bool compatibilityProfile) {
+    const int attributes[] = {GLX_DRAWABLE_TYPE,
+                              GLX_WINDOW_BIT | GLX_PIXMAP_BIT,
+                              GLX_RENDER_TYPE,
+                              GLX_RGBA_BIT,
+                              GLX_RED_SIZE,
+                              8,
+                              GLX_GREEN_SIZE,
+                              8,
+                              GLX_BLUE_SIZE,
+                              8,
+                              GLX_ALPHA_SIZE,
+                              8,
+                              GLX_DEPTH_SIZE,
+                              24,  // depth-stencil for OpenCSG
+                              GLX_STENCIL_SIZE,
+                              8,
+                              None};
 
     int numConfigs = 0;
-    GLXFBConfig *fbconfigs = nullptr;
-    XVisualInfo *visinfo = nullptr;
+    GLXFBConfig* fbconfigs = nullptr;
+    XVisualInfo* visinfo = nullptr;
     auto guard = sg::make_scope_guard([&fbconfigs, &visinfo]() {
-      if (fbconfigs) XFree(fbconfigs);
-      if (visinfo) XFree(visinfo);
+      if (fbconfigs)
+        XFree(fbconfigs);
+      if (visinfo)
+        XFree(visinfo);
     });
-    fbconfigs = glXChooseFBConfig(this->display, DefaultScreen(this->display), attributes, &numConfigs);
+    fbconfigs = glXChooseFBConfig(this->display, DefaultScreen(this->display),
+                                  attributes, &numConfigs);
     if (fbconfigs == nullptr) {
       LOG("glXChooseFBConfig() failed");
       return false;
@@ -93,22 +108,23 @@ public:
       return false;
     }
 
-    // We can't depend on XCreateWindow() returning 0 on failure, so we use a custom Xlib error handler
+    // We can't depend on XCreateWindow() returning 0 on failure, so we use a
+    // custom Xlib error handler
     XErrorHandler originalErrorHandler = XSetErrorHandler(xlibErrorHandler);
-    auto errorGuard = sg::make_scope_guard([originalErrorHandler]() {
-      XSetErrorHandler(originalErrorHandler);
-    });
+    auto errorGuard = sg::make_scope_guard(
+        [originalErrorHandler]() { XSetErrorHandler(originalErrorHandler); });
 
     const auto root = DefaultRootWindow(this->display);
     XSetWindowAttributes windowAttributes = {
-      .event_mask = StructureNotifyMask | ExposureMask | KeyPressMask,
-      .colormap = XCreateColormap(this->display, root, visinfo->visual, AllocNone),
+        .event_mask = StructureNotifyMask | ExposureMask | KeyPressMask,
+        .colormap =
+            XCreateColormap(this->display, root, visinfo->visual, AllocNone),
     };
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
 
-    this->xWindow =
-      XCreateWindow(this->display, root, 0, 0, this->width(), this->height(), 0,
-                    visinfo->depth, InputOutput, visinfo->visual, mask, &windowAttributes);
+    this->xWindow = XCreateWindow(
+        this->display, root, 0, 0, this->width(), this->height(), 0,
+        visinfo->depth, InputOutput, visinfo->visual, mask, &windowAttributes);
     XSync(this->display, false);
     if (xlibLastError != Success) {
       char description[1024];
@@ -118,20 +134,25 @@ public:
     }
 
     GLint context_attributes[] = {
-      GLX_CONTEXT_MAJOR_VERSION_ARB, static_cast<GLint>(majorGLVersion),
-      GLX_CONTEXT_MINOR_VERSION_ARB, static_cast<GLint>(minorGLVersion),
-      GLX_CONTEXT_PROFILE_MASK_ARB, compatibilityProfile ? GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB : GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
-      None
-    };
+        GLX_CONTEXT_MAJOR_VERSION_ARB,
+        static_cast<GLint>(majorGLVersion),
+        GLX_CONTEXT_MINOR_VERSION_ARB,
+        static_cast<GLint>(minorGLVersion),
+        GLX_CONTEXT_PROFILE_MASK_ARB,
+        compatibilityProfile ? GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB
+                             : GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
+        None};
 
     if (glXCreateContextAttribsARB) {
-      this->glxContext = glXCreateContextAttribsARB(this->display, fbconfigs[0], nullptr, 1, context_attributes);
+      this->glxContext = glXCreateContextAttribsARB(
+          this->display, fbconfigs[0], nullptr, 1, context_attributes);
       if (!this->glxContext) {
         LOG("Unable to create GLX context using glXCreateContextAttribsARB()");
       }
     }
     if (!this->glxContext) {
-      this->glxContext = glXCreateNewContext(this->display, fbconfigs[0], GLX_RGBA_TYPE, nullptr, 1);
+      this->glxContext = glXCreateNewContext(this->display, fbconfigs[0],
+                                             GLX_RGBA_TYPE, nullptr, 1);
       if (!this->glxContext) {
         LOG("Unable to create GLX context using glXCreateNewContext()");
         return false;
@@ -141,7 +162,6 @@ public:
   }
 };
 
-
 /*
    create a dummy X window without showing it. (without 'mapping' it)
    and save information to the ctx.
@@ -152,16 +172,20 @@ public:
 
    This function will alter ctx.openGLContext and ctx.xwindow if successful
  */
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
+std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
+    size_t width,
+    size_t height,
+    size_t majorGLVersion,
+    size_t minorGLVersion,
+    bool gles,
+    bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextGLX>(width, height);
 
   ctx->display = XOpenDisplay(nullptr);
   if (ctx->display == nullptr) {
     LOG("Unable to open a connection to the X server.");
-    char *dpyenv = getenv("DISPLAY");
-    LOG("  DISPLAY=%1$s", (dpyenv?dpyenv:""));
+    char* dpyenv = getenv("DISPLAY");
+    LOG("  DISPLAY=%1$s", (dpyenv ? dpyenv : ""));
     return nullptr;
   }
 
@@ -175,15 +199,19 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(size_t width, size_t
   PRINTDB("GLAD: Loaded GLX %d.%d", glxMajor % glxMinor);
 
   // We require GLX >= 1.3.
-  // However, glxQueryVersion sometimes returns an earlier version than is actually available, so
-  // we also accept GLX < 1.3 as long as glXGetVisualFromFBConfig() exists.
-  // FIXME: Figure out if this is still relevant with GLAD, as we may want to check functions anyway?
+  // However, glxQueryVersion sometimes returns an earlier version than is
+  // actually available, so we also accept GLX < 1.3 as long as
+  // glXGetVisualFromFBConfig() exists.
+  // FIXME: Figure out if this is still relevant with GLAD, as we may want to
+  // check functions anyway?
   if (glxMajor == 1 && glxMinor <= 2 && glXGetVisualFromFBConfig == nullptr) {
-    LOG("Error: GLX version 1.3 functions missing. Your GLX version: %1$d.%2$d", glxMajor, glxMinor);
+    LOG("Error: GLX version 1.3 functions missing. Your GLX version: %1$d.%2$d",
+        glxMajor, glxMinor);
     return nullptr;
   }
 
-  if (!ctx->createGLXContext(majorGLVersion, minorGLVersion, compatibilityProfile)) {
+  if (!ctx->createGLXContext(majorGLVersion, minorGLVersion,
+                             compatibilityProfile)) {
     return nullptr;
   }
 
diff --git a/src/glview/OffscreenContextGLX.h b/src/glview/OffscreenContextGLX.h
index 7cec59866..ffcad6fab 100644
--- a/src/glview/OffscreenContextGLX.h
+++ b/src/glview/OffscreenContextGLX.h
@@ -6,5 +6,9 @@
 #include "glview/OffscreenContext.h"
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
-  size_t width, size_t height, size_t majorGLVersion,
-  size_t minorGLVersion, bool gles, bool compatibilityProfile);
+    size_t width,
+    size_t height,
+    size_t majorGLVersion,
+    size_t minorGLVersion,
+    bool gles,
+    bool compatibilityProfile);
diff --git a/src/glview/OffscreenContextNULL.cc b/src/glview/OffscreenContextNULL.cc
index 16b43449a..e6d772f6d 100644
--- a/src/glview/OffscreenContextNULL.cc
+++ b/src/glview/OffscreenContextNULL.cc
@@ -9,19 +9,15 @@
 
 #include "glview/OffscreenContext.h"
 
-class OffscreenContextNULL : public OffscreenContext
-{
-public:
+class OffscreenContextNULL : public OffscreenContext {
+ public:
   OffscreenContextNULL() : OffscreenContext(0, 0) {}
   ~OffscreenContextNULL() override = default;
 
-  std::string getInfo() const override {
-    return "GL context creator: NULLGL";
-  }
+  std::string getInfo() const override { return "GL context creator: NULLGL"; }
   bool makeCurrent() const override { return true; }
 };
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextNULL()
-{
+std::shared_ptr<OffscreenContext> CreateOffscreenContextNULL() {
   return std::make_shared<OffscreenContextNULL>();
 }
diff --git a/src/glview/OffscreenView.cc b/src/glview/OffscreenView.cc
index 00e6f6e0c..193c97e61 100644
--- a/src/glview/OffscreenView.cc
+++ b/src/glview/OffscreenView.cc
@@ -1,19 +1,19 @@
 #include "glview/OffscreenView.h"
-#include "glview/system-gl.h"
-#include <iostream>
-#include <cstdint>
 #include <cmath>
+#include <cstdint>
 #include <cstdio>
-#include <string>
 #include <cstdlib>
-#include <sstream>
 #include <fstream>
+#include <iostream>
+#include <sstream>
+#include <string>
 #include <vector>
+#include "glview/system-gl.h"
 
-#include "io/imageutils.h"
-#include "utils/printutils.h"
 #include "glview/OffscreenContextFactory.h"
 #include "glview/fbo.h"
+#include "io/imageutils.h"
+#include "utils/printutils.h"
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
 #include "glview/glew-utils.h"
 #endif
@@ -24,36 +24,38 @@ namespace {
    Capture framebuffer from OpenGL and write it to the given ostream.
    Called by save_framebuffer() from platform-specific code.
  */
-bool save_framebuffer(const OpenGLContext *ctx, std::ostream& output)
-{
-  if (!ctx) return false;
+bool save_framebuffer(const OpenGLContext* ctx, std::ostream& output) {
+  if (!ctx)
+    return false;
 
   const auto pixels = ctx->getFramebuffer();
 
-  const size_t samplesPerPixel = 4; // R, G, B and A
+  const size_t samplesPerPixel = 4;  // R, G, B and A
   // Flip it vertically - images read from OpenGL buffers are upside-down
-  std::vector<uint8_t> flippedBuffer(samplesPerPixel * ctx->height() * ctx->width());
-  flip_image(&pixels[0], flippedBuffer.data(), samplesPerPixel, ctx->width(), ctx->height());
+  std::vector<uint8_t> flippedBuffer(samplesPerPixel * ctx->height() *
+                                     ctx->width());
+  flip_image(&pixels[0], flippedBuffer.data(), samplesPerPixel, ctx->width(),
+             ctx->height());
 
   return write_png(output, flippedBuffer.data(), ctx->width(), ctx->height());
 }
 
 }  // namespace
 
-OffscreenView::OffscreenView(uint32_t width, uint32_t height)
-{
+OffscreenView::OffscreenView(uint32_t width, uint32_t height) {
   OffscreenContextFactory::ContextAttributes attrib = {
-    .width = width,
-    .height = height,
-    .majorGLVersion = 2,
-    .minorGLVersion = 0,
+      .width = width,
+      .height = height,
+      .majorGLVersion = 2,
+      .minorGLVersion = 0,
   };
   auto provider = OffscreenContextFactory::defaultProvider();
   // We cannot initialize GLX GLEW with an EGL context:
   // https://github.com/nigels-com/glew/issues/273
   // ..so if we're using GLEW, default to creating a GLX context.
   // FIXME: It's possible that GLEW was built using EGL, in which case this
-  // logic isn't correct, but we don't have a good way of determining how GLEW was built.
+  // logic isn't correct, but we don't have a good way of determining how GLEW
+  // was built.
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
   provider = !strcmp(provider, "egl") ? "glx" : provider;
 #endif
@@ -67,24 +69,26 @@ OffscreenView::OffscreenView(uint32_t width, uint32_t height)
       throw OffscreenViewException("Unable to obtain GL Context");
     }
   }
-  if (!this->ctx->makeCurrent()) throw OffscreenViewException("Unable to make GL context current");
+  if (!this->ctx->makeCurrent())
+    throw OffscreenViewException("Unable to make GL context current");
 
 #ifndef NULLGL
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
   if (!initializeGlew()) {
     throw OffscreenViewException("Unable to initialize Glew");
   }
-#endif // USE_GLEW
+#endif  // USE_GLEW
 #ifdef USE_GLAD
   // We could ask for gladLoadGLES2UserPtr() here if we want to use GLES2+
   const auto version = gladLoaderLoadGL();
   if (version == 0) {
     throw OffscreenViewException("Unable to initialize GLAD");
   }
-  PRINTDB("GLAD: Loaded OpenGL %d.%d", GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
-#endif // USE_GLAD
+  PRINTDB("GLAD: Loaded OpenGL %d.%d",
+          GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
+#endif  // USE_GLAD
 
-#endif // NULLGL
+#endif  // NULLGL
 
   PRINTD(gl_dump());
 
@@ -96,20 +100,17 @@ OffscreenView::OffscreenView(uint32_t width, uint32_t height)
   GLView::resizeGL(width, height);
 }
 
-OffscreenView::~OffscreenView()
-{
+OffscreenView::~OffscreenView() {
   fbo.reset();
 }
 
 #ifdef ENABLE_OPENCSG
-void OffscreenView::display_opencsg_warning()
-{
+void OffscreenView::display_opencsg_warning() {
   LOG("OpenSCAD recommended OpenGL version is 2.0.");
 }
 #endif
 
-bool OffscreenView::save(const char *filename) const
-{
+bool OffscreenView::save(const char* filename) const {
   std::ofstream fstream(filename, std::ios::out | std::ios::binary);
   if (!fstream.is_open()) {
     std::cerr << "Can't open file " << filename << " for writing";
@@ -121,13 +122,11 @@ bool OffscreenView::save(const char *filename) const
   return true;
 }
 
-bool OffscreenView::save(std::ostream& output) const
-{
+bool OffscreenView::save(std::ostream& output) const {
   return save_framebuffer(this->ctx.get(), output);
 }
 
-std::string OffscreenView::getRendererInfo() const
-{
+std::string OffscreenView::getRendererInfo() const {
   std::ostringstream result;
   result << this->ctx->getInfo() << "\n" << gl_dump();
   return result.str();
diff --git a/src/glview/OffscreenView.h b/src/glview/OffscreenView.h
index 6d7d1ce2d..e3ed376b3 100644
--- a/src/glview/OffscreenView.h
+++ b/src/glview/OffscreenView.h
@@ -1,24 +1,23 @@
 #pragma once
 
-#include <stdexcept>
 #include <cstdint>
 #include <memory>
-#include <string>
 #include <ostream>
+#include <stdexcept>
+#include <string>
 
 #include "glview/GLView.h"
 #include "glview/OpenGLContext.h"
 #include "glview/fbo.h"
 
-class OffscreenViewException : public std::runtime_error
-{
-public:
-  OffscreenViewException(const std::string& what_arg) : std::runtime_error(what_arg) {}
+class OffscreenViewException : public std::runtime_error {
+ public:
+  OffscreenViewException(const std::string& what_arg)
+      : std::runtime_error(what_arg) {}
 };
 
-class OffscreenView : public GLView
-{
-public:
+class OffscreenView : public GLView {
+ public:
   OffscreenView(uint32_t width, uint32_t height);
   ~OffscreenView() override;
   bool save(std::ostream& output) const;
@@ -27,7 +26,7 @@ public:
   std::unique_ptr<FBO> fbo;
 
   // overrides
-  bool save(const char *filename) const override;
+  bool save(const char* filename) const override;
   [[nodiscard]] std::string getRendererInfo() const override;
 #ifdef ENABLE_OPENCSG
   void display_opencsg_warning() override;
diff --git a/src/glview/OpenGLContext.cc b/src/glview/OpenGLContext.cc
index fffe784c9..7c2f6cfed 100644
--- a/src/glview/OpenGLContext.cc
+++ b/src/glview/OpenGLContext.cc
@@ -1,15 +1,15 @@
 #include "glview/OpenGLContext.h"
 
-#include <cstdint>
 #include <cstddef>
+#include <cstdint>
 #include <vector>
 
 #include "glview/system-gl.h"
 
-std::vector<uint8_t> OpenGLContext::getFramebuffer() const
-{
-  const size_t samplesPerPixel = 4; // R, G, B and A
+std::vector<uint8_t> OpenGLContext::getFramebuffer() const {
+  const size_t samplesPerPixel = 4;  // R, G, B and A
   std::vector<uint8_t> buffer(samplesPerPixel * this->width_ * this->height_);
-  GL_CHECK(glReadPixels(0, 0, this->width_, this->height_, GL_RGBA, GL_UNSIGNED_BYTE, buffer.data()));
+  GL_CHECK(glReadPixels(0, 0, this->width_, this->height_, GL_RGBA,
+                        GL_UNSIGNED_BYTE, buffer.data()));
   return buffer;
 }
diff --git a/src/glview/OpenGLContext.h b/src/glview/OpenGLContext.h
index d350c1edb..c38849e18 100644
--- a/src/glview/OpenGLContext.h
+++ b/src/glview/OpenGLContext.h
@@ -1,17 +1,17 @@
 #pragma once
 
-#include <vector>
-#include <string>
 #include <cstdint>
+#include <string>
+#include <vector>
 
-class OpenGLContext
-{
-protected:
+class OpenGLContext {
+ protected:
   uint32_t width_;
   uint32_t height_;
 
-public:
-  OpenGLContext(uint32_t width, uint32_t height) : width_(width), height_(height) {}
+ public:
+  OpenGLContext(uint32_t width, uint32_t height)
+      : width_(width), height_(height) {}
   virtual ~OpenGLContext() = default;
   uint32_t width() const { return this->width_; }
   uint32_t height() const { return this->height_; }
diff --git a/src/glview/PolySetRenderer.cc b/src/glview/PolySetRenderer.cc
index ed481c4ac..d333e12d5 100644
--- a/src/glview/PolySetRenderer.cc
+++ b/src/glview/PolySetRenderer.cc
@@ -29,28 +29,28 @@
 #include <cassert>
 #include <cmath>
 #include <cstddef>
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 #ifdef _MSC_VER
 // Boost conflicts with MPFR under MSVC (google it)
 #include <mpfr.h>
 #endif
 
-#include "glview/system-gl.h"
 #include "core/Selection.h"
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/cgal/cgalutils.h"
+#include "geometry/linalg.h"
 #include "glview/ColorMap.h"
-#include "glview/cgal/CGALRenderUtils.h"
-#include "glview/VBORenderer.h"
 #include "glview/Renderer.h"
 #include "glview/ShaderUtils.h"
 #include "glview/VBOBuilder.h"
+#include "glview/VBORenderer.h"
 #include "glview/VertexState.h"
+#include "glview/cgal/CGALRenderUtils.h"
+#include "glview/system-gl.h"
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALNefGeometry.h"
@@ -60,34 +60,38 @@
 #endif
 
 // This renderer is used in Manifold mode (F6 with Manifold as geometry engine)
-PolySetRenderer::PolySetRenderer(const std::shared_ptr<const class Geometry>& geom)
-{
+PolySetRenderer::PolySetRenderer(
+    const std::shared_ptr<const class Geometry>& geom) {
   this->addGeometry(geom);
 }
 
-void PolySetRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom)
-{
+void PolySetRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
   assert(geom != nullptr);
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     for (const auto& item : geomlist->getChildren()) {
       this->addGeometry(item.second);
     }
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     assert(ps->getDimension() == 3);
-    // We need to tessellate here, in case the generated PolySet contains concave polygons
-    // See tests/data/scad/3D/features/polyhedron-concave-test.scad
+    // We need to tessellate here, in case the generated PolySet contains
+    // concave polygons See
+    // tests/data/scad/3D/features/polyhedron-concave-test.scad
     this->polysets_.push_back(PolySetUtils::tessellate_faces(*ps));
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+  } else if (const auto poly =
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     this->polygons_.emplace_back(
-      poly, std::shared_ptr<const PolySet>(poly->tessellate()));
+        poly, std::shared_ptr<const PolySet>(poly->tessellate()));
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     this->polysets_.push_back(mani->toPolySet());
 #endif
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    // Note: It's rare, but possible for Nef polyhedrons to exist among geometries in Manifold mode.
-    // One way is through import("file.nef3")
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+    // Note: It's rare, but possible for Nef polyhedrons to exist among
+    // geometries in Manifold mode. One way is through import("file.nef3")
     assert(N->getDimension() == 3);
     if (!N->isEmpty()) {
       if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*N->p3)) {
@@ -95,7 +99,7 @@ void PolySetRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom)
         this->polysets_.push_back(std::shared_ptr<PolySet>(std::move(ps)));
       }
     }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
   } else {
     const auto& geom_ref = *geom.get();
     LOG("Unsupported geom '%1$s' in PolySetRenderer", typeid(geom_ref).name());
@@ -104,19 +108,22 @@ void PolySetRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom)
 }
 
 // Overridden from Renderer
-void PolySetRenderer::setColorScheme(const ColorScheme& cs)
-{
+void PolySetRenderer::setColorScheme(const ColorScheme& cs) {
   Renderer::setColorScheme(cs);
-  colormap_[ColorMode::CGAL_FACE_2D_COLOR] = ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
-  colormap_[ColorMode::CGAL_EDGE_2D_COLOR] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
+  colormap_[ColorMode::CGAL_FACE_2D_COLOR] =
+      ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
+  colormap_[ColorMode::CGAL_EDGE_2D_COLOR] =
+      ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
 }
 
+void PolySetRenderer::createPolySetStates(
+    const ShaderUtils::ShaderInfo* shaderinfo) {
+  VertexStateContainer& vertex_state_container =
+      polyset_vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
 
-void PolySetRenderer::createPolySetStates(const ShaderUtils::ShaderInfo *shaderinfo) {
-  VertexStateContainer& vertex_state_container = polyset_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
-
-  vbo_builder.addSurfaceData(); // position, normal, color
+  vbo_builder.addSurfaceData();  // position, normal, color
   vbo_builder.addShaderData();
   const bool enable_barycentric = true;
 
@@ -128,12 +135,14 @@ void PolySetRenderer::createPolySetStates(const ShaderUtils::ShaderInfo *shaderi
 
   for (const auto& polyset : this->polysets_) {
     Color4f color;
-    if (!polyset->colors.empty()) color = polyset->colors[0];
+    if (!polyset->colors.empty())
+      color = polyset->colors[0];
     getShaderColor(ColorMode::MATERIAL, color, color);
     add_shader_pointers(vbo_builder, shaderinfo);
 
     vbo_builder.writeSurface();
-    vbo_builder.create_surface(*polyset, Transform3d::Identity(), color, enable_barycentric, false);
+    vbo_builder.create_surface(*polyset, Transform3d::Identity(), color,
+                               enable_barycentric, false);
   }
 
   vbo_builder.createInterleavedVBOs();
@@ -145,12 +154,14 @@ void PolySetRenderer::createPolygonStates() {
 }
 
 void PolySetRenderer::createPolygonSurfaceStates() {
-  VertexStateContainer& vertex_state_container = polygon_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer& vertex_state_container =
+      polygon_vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
   vbo_builder.addSurfaceData();
 
   size_t num_vertices = 0;
-  for (const auto&[_, polyset] : this->polygons_) {
+  for (const auto& [_, polyset] : this->polygons_) {
     num_vertices += calcNumVertices(*polyset);
   }
 
@@ -163,7 +174,7 @@ void PolySetRenderer::createPolygonSurfaceStates() {
   });
   vertex_state_container.states().emplace_back(std::move(init_state));
 
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto& [polygon, polyset] : this->polygons_) {
     Color4f color;
     getColorSchemeColor(ColorMode::CGAL_FACE_2D_COLOR, color);
     vbo_builder.create_polygons(*polyset, Transform3d::Identity(), color);
@@ -173,13 +184,15 @@ void PolySetRenderer::createPolygonSurfaceStates() {
 }
 
 void PolySetRenderer::createPolygonEdgeStates() {
-  VertexStateContainer& vertex_state_container = polygon_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer& vertex_state_container =
+      polygon_vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
 
   vbo_builder.addEdgeData();
 
   size_t num_vertices = 0;
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto& [polygon, _] : this->polygons_) {
     num_vertices += calcNumEdgeVertices(*polygon);
   }
 
@@ -194,7 +207,7 @@ void PolySetRenderer::createPolygonEdgeStates() {
   });
   vertex_state_container.states().emplace_back(std::move(edge_state));
 
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto& [polygon, _] : this->polygons_) {
     Color4f color;
     getColorSchemeColor(ColorMode::CGAL_EDGE_2D_COLOR, color);
     vbo_builder.writeEdge();
@@ -211,12 +224,12 @@ void PolySetRenderer::createPolygonEdgeStates() {
   vbo_builder.createInterleavedVBOs();
 }
 
-
-void PolySetRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo)
-{
-  if (polyset_vertex_state_containers_.empty() && polygon_vertex_state_containers_.empty()) {
+void PolySetRenderer::prepare(const ShaderUtils::ShaderInfo* shaderinfo) {
+  if (polyset_vertex_state_containers_.empty() &&
+      polygon_vertex_state_containers_.empty()) {
     if (!this->polysets_.empty() && !this->polygons_.empty()) {
-      LOG(message_group::Error, "PolySetRenderer::prepare() called with both polysets and polygons");
+      LOG(message_group::Error,
+          "PolySetRenderer::prepare() called with both polysets and polygons");
     } else if (!this->polysets_.empty()) {
       createPolySetStates(shaderinfo);
     } else if (!this->polygons_.empty()) {
@@ -225,19 +238,21 @@ void PolySetRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo)
   }
 }
 
-void PolySetRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
-
+void PolySetRenderer::draw(bool showedges,
+                           const ShaderUtils::ShaderInfo* shaderinfo) const {
   drawPolySets(showedges, shaderinfo);
   drawPolygons();
 }
 
-void PolySetRenderer::drawPolySets(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
+void PolySetRenderer::drawPolySets(
+    bool showedges,
+    const ShaderUtils::ShaderInfo* shaderinfo) const {
   // Only use shader if select rendering or showedges
-  const bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  const bool enable_shader =
+      shaderinfo &&
+      (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING &&
+           showedges ||
+       shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
   if (enable_shader) {
     GL_TRACE("glUseProgram(%d)", shaderinfo->resource.shader_program);
     GL_CHECKD(glUseProgram(shaderinfo->resource.shader_program));
@@ -246,7 +261,8 @@ void PolySetRenderer::drawPolySets(bool showedges, const ShaderUtils::ShaderInfo
 
   for (const auto& container : polyset_vertex_state_containers_) {
     for (const auto& vertex_state : container.states()) {
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+      const auto shader_vs =
+          std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
       if (!shader_vs || (shader_vs && showedges)) {
         vertex_state->draw();
       }
@@ -271,7 +287,8 @@ void PolySetRenderer::drawPolygons() const {
 
   for (const auto& container : polygon_vertex_state_containers_) {
     for (const auto& vertex_state : container.states()) {
-      if (vertex_state)vertex_state->draw();
+      if (vertex_state)
+        vertex_state->draw();
     }
   }
 
@@ -281,33 +298,41 @@ void PolySetRenderer::drawPolygons() const {
   GL_TRACE("glLineWidth(%d)", current_line_width);
   GL_CHECKD(glLineWidth(current_line_width));
 
-  if (!origVBOBuilderState) glDisableClientState(GL_VERTEX_ARRAY);
-  if (!origNormalArrayState) glDisableClientState(GL_NORMAL_ARRAY);
-  if (!origColorArrayState) glDisableClientState(GL_COLOR_ARRAY);
+  if (!origVBOBuilderState)
+    glDisableClientState(GL_VERTEX_ARRAY);
+  if (!origNormalArrayState)
+    glDisableClientState(GL_NORMAL_ARRAY);
+  if (!origColorArrayState)
+    glDisableClientState(GL_COLOR_ARRAY);
 }
 
-BoundingBox PolySetRenderer::getBoundingBox() const
-{
+BoundingBox PolySetRenderer::getBoundingBox() const {
   BoundingBox bbox;
 
   for (const auto& ps : this->polysets_) {
     bbox.extend(ps->getBoundingBox());
   }
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto& [polygon, polyset] : this->polygons_) {
     bbox.extend(polygon->getBoundingBox());
   }
   return bbox;
 }
 
-std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int /*mouse_x*/, int /*mouse_y*/, double tolerance) {
+std::vector<SelectedObject> PolySetRenderer::findModelObject(
+    const Vector3d& near_pt,
+    const Vector3d& far_pt,
+    int /*mouse_x*/,
+    int /*mouse_y*/,
+    double tolerance) {
   std::vector<SelectedObject> results;
   double dist_near;
   double dist_nearest = NAN;
   Vector3d pt1_nearest;
   Vector3d pt2_nearest;
   for (const auto& ps : this->polysets_) {
-    for (const auto& pt: ps->vertices) {
-      const double dist_pt = calculateLinePointDistance(near_pt, far_pt, pt, dist_near);
+    for (const auto& pt : ps->vertices) {
+      const double dist_pt =
+          calculateLinePointDistance(near_pt, far_pt, pt, dist_near);
       if (dist_pt < tolerance) {
         if (isnan(dist_nearest) || dist_near < dist_nearest) {
           dist_nearest = dist_near;
@@ -318,8 +343,8 @@ std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& nea
   }
   if (!isnan(dist_nearest)) {
     const SelectedObject obj = {
-      .type = SelectionType::SELECTION_POINT,
-      .p1 = pt1_nearest,
+        .type = SelectionType::SELECTION_POINT,
+        .p1 = pt1_nearest,
     };
     results.push_back(obj);
     return results;
@@ -331,7 +356,8 @@ std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& nea
         const int ind1 = pol[i];
         const int ind2 = pol[(i + 1) % n];
         double dist_lat;
-        const double dist_norm = std::fabs(calculateLineLineDistance(ps->vertices[ind1], ps->vertices[ind2], near_pt, far_pt, dist_lat));
+        const double dist_norm = std::fabs(calculateLineLineDistance(
+            ps->vertices[ind1], ps->vertices[ind2], near_pt, far_pt, dist_lat));
         if (dist_lat >= 0 && dist_lat <= 1 && dist_norm < tolerance) {
           dist_nearest = dist_lat;
           pt1_nearest = ps->vertices[ind1];
@@ -343,9 +369,9 @@ std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& nea
 
   if (!isnan(dist_nearest)) {
     const SelectedObject obj = {
-      .type = SelectionType::SELECTION_LINE,
-      .p1 = pt1_nearest,
-      .p2 = pt2_nearest,
+        .type = SelectionType::SELECTION_LINE,
+        .p1 = pt1_nearest,
+        .p2 = pt2_nearest,
     };
     results.push_back(obj);
     return results;
diff --git a/src/glview/PolySetRenderer.h b/src/glview/PolySetRenderer.h
index 745dde2bf..3b12b7cb0 100644
--- a/src/glview/PolySetRenderer.h
+++ b/src/glview/PolySetRenderer.h
@@ -6,37 +6,44 @@
 
 #include "core/Selection.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "glview/ColorMap.h"
 #include "glview/ShaderUtils.h"
-#include "glview/VertexState.h"
 #include "glview/VBORenderer.h"
+#include "glview/VertexState.h"
 
-class PolySetRenderer : public VBORenderer
-{
-public:
+class PolySetRenderer : public VBORenderer {
+ public:
   PolySetRenderer(const std::shared_ptr<const class Geometry>& geom);
   ~PolySetRenderer() override = default;
-  void prepare(const ShaderUtils::ShaderInfo *shaderinfo) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const override;
+  void prepare(const ShaderUtils::ShaderInfo* shaderinfo) override;
+  void draw(bool showedges,
+            const ShaderUtils::ShaderInfo* shaderinfo) const override;
   void setColorScheme(const ColorScheme& cs) override;
   BoundingBox getBoundingBox() const override;
-  std::vector<SelectedObject> findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int mouse_x, int mouse_y, double tolerance) override;
+  std::vector<SelectedObject> findModelObject(const Vector3d& near_pt,
+                                              const Vector3d& far_pt,
+                                              int mouse_x,
+                                              int mouse_y,
+                                              double tolerance) override;
 
-private:
+ private:
   void addGeometry(const std::shared_ptr<const class Geometry>& geom);
-  void createPolySetStates(const ShaderUtils::ShaderInfo *shaderinfo);
+  void createPolySetStates(const ShaderUtils::ShaderInfo* shaderinfo);
   void createPolygonStates();
   void createPolygonSurfaceStates();
   void createPolygonEdgeStates();
 
-  void drawPolySets(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const;
+  void drawPolySets(bool showedges,
+                    const ShaderUtils::ShaderInfo* shaderinfo) const;
   void drawPolygons() const;
 
   std::vector<std::shared_ptr<const class PolySet>> polysets_;
-  std::vector<std::pair<std::shared_ptr<const Polygon2d>, std::shared_ptr<const PolySet>>> polygons_;
+  std::vector<std::pair<std::shared_ptr<const Polygon2d>,
+                        std::shared_ptr<const PolySet>>>
+      polygons_;
 
   std::vector<VertexStateContainer> polyset_vertex_state_containers_;
   std::vector<VertexStateContainer> polygon_vertex_state_containers_;
diff --git a/src/glview/RenderSettings.cc b/src/glview/RenderSettings.cc
index b7e5843fe..4f99ec137 100644
--- a/src/glview/RenderSettings.cc
+++ b/src/glview/RenderSettings.cc
@@ -5,12 +5,12 @@
 
 std::string renderBackend3DToString(RenderBackend3D backend) {
   switch (backend) {
-  case RenderBackend3D::CGALBackend:
-    return "CGAL";
-  case RenderBackend3D::ManifoldBackend:
-    return "Manifold";
-  default:
-    throw std::runtime_error("Unknown rendering backend");
+    case RenderBackend3D::CGALBackend:
+      return "CGAL";
+    case RenderBackend3D::ManifoldBackend:
+      return "Manifold";
+    default:
+      throw std::runtime_error("Unknown rendering backend");
   }
 }
 
@@ -31,7 +31,7 @@ RenderBackend3D renderBackend3DFromString(std::string backend) {
   }
 }
 
-RenderSettings *RenderSettings::inst(bool erase) {
+RenderSettings* RenderSettings::inst(bool erase) {
   static auto instance = new RenderSettings;
   if (erase) {
     delete instance;
diff --git a/src/glview/RenderSettings.h b/src/glview/RenderSettings.h
index 915f4fde0..fbbce6e8f 100644
--- a/src/glview/RenderSettings.h
+++ b/src/glview/RenderSettings.h
@@ -8,20 +8,21 @@ enum class RenderBackend3D {
   ManifoldBackend,
 };
 
-inline constexpr RenderBackend3D DEFAULT_RENDERING_BACKEND_3D = RenderBackend3D::CGALBackend; // ManifoldBackend;
+inline constexpr RenderBackend3D DEFAULT_RENDERING_BACKEND_3D =
+    RenderBackend3D::CGALBackend;  // ManifoldBackend;
 
 std::string renderBackend3DToString(RenderBackend3D backend);
 RenderBackend3D renderBackend3DFromString(std::string backend);
 
-class RenderSettings
-{
-public:
-  static RenderSettings *inst(bool erase = false);
+class RenderSettings {
+ public:
+  static RenderSettings* inst(bool erase = false);
 
   RenderBackend3D backend3D;
   unsigned int openCSGTermLimit;
   double far_gl_clip_limit;
   std::string colorscheme;
-private:
+
+ private:
   RenderSettings();
 };
diff --git a/src/glview/Renderer.cc b/src/glview/Renderer.cc
index 43dd3e496..b162d5b31 100644
--- a/src/glview/Renderer.cc
+++ b/src/glview/Renderer.cc
@@ -1,26 +1,25 @@
 #include "glview/Renderer.h"
 #include "geometry/linalg.h"
 #include "glview/ColorMap.h"
-#include "utils/printutils.h"
-#include "platform/PlatformUtils.h"
 #include "glview/system-gl.h"
+#include "platform/PlatformUtils.h"
+#include "utils/printutils.h"
 
-#include <sstream>
 #include <Eigen/LU>
 #include <fstream>
+#include <sstream>
 #include <string>
 #include <vector>
 
 #ifndef NULLGL
 
-
 namespace {
 
 GLuint compileShader(const std::string& name, GLuint shader_type) {
   auto shader_source = ShaderUtils::loadShaderSource(name);
   const GLuint shader = glCreateShader(shader_type);
-  auto *c_source = shader_source.c_str();
-  glShaderSource(shader, 1, (const GLchar **)&c_source, nullptr);
+  auto* c_source = shader_source.c_str();
+  glShaderSource(shader, 1, (const GLchar**)&c_source, nullptr);
   glCompileShader(shader);
   GLint status;
   glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
@@ -38,31 +37,39 @@ GLuint compileShader(const std::string& name, GLuint shader_type) {
 
 namespace RendererUtils {
 
-CSGMode getCsgMode(const bool highlight_mode, const bool background_mode, const OpenSCADOperator type) {
-  int csgmode = highlight_mode ? CSGMODE_HIGHLIGHT : (background_mode ? CSGMODE_BACKGROUND : CSGMODE_NORMAL);
-  if (type == OpenSCADOperator::DIFFERENCE) csgmode |= CSGMODE_DIFFERENCE_FLAG;
+CSGMode getCsgMode(const bool highlight_mode,
+                   const bool background_mode,
+                   const OpenSCADOperator type) {
+  int csgmode = highlight_mode
+                    ? CSGMODE_HIGHLIGHT
+                    : (background_mode ? CSGMODE_BACKGROUND : CSGMODE_NORMAL);
+  if (type == OpenSCADOperator::DIFFERENCE)
+    csgmode |= CSGMODE_DIFFERENCE_FLAG;
   return static_cast<CSGMode>(csgmode);
 }
 
 std::string loadShaderSource(const std::string& name) {
-  std::string shaderPath = (PlatformUtils::resourcePath("shaders") / name).string();
+  std::string shaderPath =
+      (PlatformUtils::resourcePath("shaders") / name).string();
   std::ostringstream buffer;
   const std::ifstream f(shaderPath);
   if (f.is_open()) {
     buffer << f.rdbuf();
   } else {
-    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'", shaderPath);
+    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'",
+        shaderPath);
   }
   return buffer.str();
 }
 
-ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str) {
+ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str,
+                                                 const std::string& fs_str) {
   int shaderstatus;
-  const char *vs_source = vs_str.c_str();
-  const char *fs_source = fs_str.c_str();
+  const char* vs_source = vs_str.c_str();
+  const char* fs_source = fs_str.c_str();
   // Compile the shaders
   GL_CHECKD(auto vertex_shader = glCreateShader(GL_VERTEX_SHADER));
-  glShaderSource(vertex_shader, 1, (const GLchar **)&vs_source, nullptr);
+  glShaderSource(vertex_shader, 1, (const GLchar**)&vs_source, nullptr);
   glCompileShader(vertex_shader);
   glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &shaderstatus);
   if (shaderstatus != GL_TRUE) {
@@ -70,12 +77,13 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
     char logbuffer[1000];
     glGetShaderInfoLog(vertex_shader, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen,
+            logbuffer);
     return {};
   }
 
   GL_CHECKD(auto fragment_shader = glCreateShader(GL_FRAGMENT_SHADER));
-  glShaderSource(fragment_shader, 1, (const GLchar **)&fs_source, nullptr);
+  glShaderSource(fragment_shader, 1, (const GLchar**)&fs_source, nullptr);
   glCompileShader(fragment_shader);
   glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &shaderstatus);
   if (shaderstatus != GL_TRUE) {
@@ -83,7 +91,8 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
     char logbuffer[1000];
     glGetShaderInfoLog(fragment_shader, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n",
+            loglen, logbuffer);
     return {};
   }
 
@@ -100,7 +109,8 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
     char logbuffer[1000];
     glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen,
+            logbuffer);
     return {};
   } else {
     glValidateProgram(shader_prog);
@@ -110,22 +120,22 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
       char logbuffer[1000];
       glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
       // FIXME: Use OpenCAD log to error instead of stderr
-      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n", loglen, logbuffer);
+      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n",
+              loglen, logbuffer);
       return {};
     }
   }
 
   return {
-    .shader_program = shader_prog,
-    .vertex_shader = vertex_shader,
-    .fragment_shader = fragment_shader,
+      .shader_program = shader_prog,
+      .vertex_shader = vertex_shader,
+      .fragment_shader = fragment_shader,
   };
 }
 
 }  // namespace RendererUtils
 
-Renderer::Renderer()
-{
+Renderer::Renderer() {
   PRINTD("Renderer() start");
 
   // Setup default colors
@@ -148,8 +158,8 @@ Renderer::Renderer()
   PRINTD("Renderer() end");
 }
 
-bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode, Color4f& outcolor) const
-{
+bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode,
+                                   Color4f& outcolor) const {
   if (const auto it = colormap_.find(colormode); it != colormap_.end()) {
     outcolor = it->second;
     return true;
@@ -157,52 +167,84 @@ bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode, Color4f& outco
   return false;
 }
 
-bool Renderer::getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color,
-                              Color4f& outcolor) const
-{
-  // If an object was colored, use any set components from that color, except in pure highlight mode
-  if ((colormode == ColorMode::BACKGROUND || colormode != ColorMode::HIGHLIGHT)) {
-    if (object_color.hasRgb()) outcolor.setRgb(object_color.r(), object_color.g(), object_color.b());
-    if (object_color.hasAlpha()) outcolor.setAlpha(object_color.a());
-    if (outcolor.isValid()) return true;
+bool Renderer::getShaderColor(Renderer::ColorMode colormode,
+                              const Color4f& object_color,
+                              Color4f& outcolor) const {
+  // If an object was colored, use any set components from that color, except in
+  // pure highlight mode
+  if ((colormode == ColorMode::BACKGROUND ||
+       colormode != ColorMode::HIGHLIGHT)) {
+    if (object_color.hasRgb())
+      outcolor.setRgb(object_color.r(), object_color.g(), object_color.b());
+    if (object_color.hasAlpha())
+      outcolor.setAlpha(object_color.a());
+    if (outcolor.isValid())
+      return true;
   }
 
   // Fill in missing components with the color from the colorscheme
   Color4f basecol;
   if (Renderer::getColorSchemeColor(colormode, basecol)) {
-    if (!outcolor.hasRgb()) outcolor.setRgb(basecol.r(), basecol.g(), basecol.b());
-    if (!outcolor.hasAlpha()) outcolor.setAlpha(basecol.a());
+    if (!outcolor.hasRgb())
+      outcolor.setRgb(basecol.r(), basecol.g(), basecol.b());
+    if (!outcolor.hasAlpha())
+      outcolor.setAlpha(basecol.a());
     return true;
   }
 
   return false;
 }
 
-
-
 /* fill colormap_ with matching entries from the colorscheme. note
    this does not change Highlight or Background colors as they are not
    represented in the colorscheme (yet). Also edgecolors are currently the
    same for CGAL & OpenCSG */
 void Renderer::setColorScheme(const ColorScheme& cs) {
   PRINTD("setColorScheme");
-  colormap_[ColorMode::MATERIAL] = ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_FRONT_COLOR);
-  colormap_[ColorMode::CUTOUT] = ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_BACK_COLOR);
-  colormap_[ColorMode::MATERIAL_EDGES] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR);
-  colormap_[ColorMode::CUTOUT_EDGES] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR);
-  colormap_[ColorMode::EMPTY_SPACE] = ColorMap::getColor(cs, RenderColor::BACKGROUND_COLOR);
+  colormap_[ColorMode::MATERIAL] =
+      ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_FRONT_COLOR);
+  colormap_[ColorMode::CUTOUT] =
+      ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_BACK_COLOR);
+  colormap_[ColorMode::MATERIAL_EDGES] =
+      ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR);
+  colormap_[ColorMode::CUTOUT_EDGES] =
+      ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR);
+  colormap_[ColorMode::EMPTY_SPACE] =
+      ColorMap::getColor(cs, RenderColor::BACKGROUND_COLOR);
   colorscheme_ = &cs;
 }
 
-
-std::vector<SelectedObject> Renderer::findModelObject(const Vector3d& /*near_pt*/, const Vector3d& /*far_pt*/, int /*mouse_x*/, int /*mouse_y*/, double /*tolerance*/) { return {}; }
-#else //NULLGL
+std::vector<SelectedObject> Renderer::findModelObject(
+    const Vector3d& /*near_pt*/,
+    const Vector3d& /*far_pt*/,
+    int /*mouse_x*/,
+    int /*mouse_y*/,
+    double /*tolerance*/) {
+  return {};
+}
+#else  // NULLGL
 
 Renderer::Renderer() : colorscheme_(nullptr) {}
-bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode, Color4f& outcolor) const {return false; }
-bool Renderer::getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color, Color4f& outcolor) const { return false; }
-std::string ShaderUtils::loadShaderSource(const std::string& name) { return ""; }
+bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode,
+                                   Color4f& outcolor) const {
+  return false;
+}
+bool Renderer::getShaderColor(Renderer::ColorMode colormode,
+                              const Color4f& object_color,
+                              Color4f& outcolor) const {
+  return false;
+}
+std::string ShaderUtils::loadShaderSource(const std::string& name) {
+  return "";
+}
 void Renderer::setColorScheme(const ColorScheme& cs) {}
-std::vector<SelectedObject> Renderer::findModelObject(const Vector3d& /*near_pt*/, const Vector3d& /*far_pt*/, int /*mouse_x*/, int /*mouse_y*/, double /*tolerance*/) { return {}; }
+std::vector<SelectedObject> Renderer::findModelObject(
+    const Vector3d& /*near_pt*/,
+    const Vector3d& /*far_pt*/,
+    int /*mouse_x*/,
+    int /*mouse_y*/,
+    double /*tolerance*/) {
+  return {};
+}
 
-#endif //NULLGL
+#endif  // NULLGL
diff --git a/src/glview/Renderer.h b/src/glview/Renderer.h
index 78d41edd2..01a215c8b 100644
--- a/src/glview/Renderer.h
+++ b/src/glview/Renderer.h
@@ -1,14 +1,14 @@
 #pragma once
 
+#include "core/Selection.h"
+#include "core/enums.h"
 #include "geometry/linalg.h"
-#include "glview/ShaderUtils.h"
 #include "glview/ColorMap.h"
-#include "core/enums.h"
-#include "core/Selection.h"
+#include "glview/ShaderUtils.h"
 
-#ifdef _MSC_VER // NULL
-#include <map>
+#ifdef _MSC_VER  // NULL
 #include <cstdlib>
+#include <map>
 #endif
 
 #include <vector>
@@ -18,30 +18,31 @@ namespace RendererUtils {
 #define CSGMODE_DIFFERENCE_FLAG 0x10
 
 enum CSGMode {
-  CSGMODE_NONE                  = 0x00,
-  CSGMODE_NORMAL                = 0x01,
-  CSGMODE_DIFFERENCE            = CSGMODE_NORMAL | CSGMODE_DIFFERENCE_FLAG,
-  CSGMODE_BACKGROUND            = 0x02,
+  CSGMODE_NONE = 0x00,
+  CSGMODE_NORMAL = 0x01,
+  CSGMODE_DIFFERENCE = CSGMODE_NORMAL | CSGMODE_DIFFERENCE_FLAG,
+  CSGMODE_BACKGROUND = 0x02,
   CSGMODE_BACKGROUND_DIFFERENCE = CSGMODE_BACKGROUND | CSGMODE_DIFFERENCE_FLAG,
-  CSGMODE_HIGHLIGHT             = 0x03,
-  CSGMODE_HIGHLIGHT_DIFFERENCE  = CSGMODE_HIGHLIGHT | CSGMODE_DIFFERENCE_FLAG
+  CSGMODE_HIGHLIGHT = 0x03,
+  CSGMODE_HIGHLIGHT_DIFFERENCE = CSGMODE_HIGHLIGHT | CSGMODE_DIFFERENCE_FLAG
 };
 
-CSGMode getCsgMode(const bool highlight_mode, const bool background_mode, const OpenSCADOperator type = OpenSCADOperator::UNION);
+CSGMode getCsgMode(const bool highlight_mode,
+                   const bool background_mode,
+                   const OpenSCADOperator type = OpenSCADOperator::UNION);
 
-} // namespace RendererUtils
+}  // namespace RendererUtils
 
-class Renderer
-{
-public:
+class Renderer {
+ public:
   Renderer();
   virtual ~Renderer() = default;
 
-  virtual void prepare(const ShaderUtils::ShaderInfo *shaderinfo) = 0;
-  virtual void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const = 0;
+  virtual void prepare(const ShaderUtils::ShaderInfo* shaderinfo) = 0;
+  virtual void draw(bool showedges,
+                    const ShaderUtils::ShaderInfo* shaderinfo) const = 0;
   [[nodiscard]] virtual BoundingBox getBoundingBox() const = 0;
 
-
   enum class ColorMode {
     NONE,
     MATERIAL,
@@ -58,13 +59,19 @@ public:
   };
 
   bool getColorSchemeColor(ColorMode colormode, Color4f& outcolor) const;
-  bool getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color, Color4f& outcolor) const;
+  bool getShaderColor(Renderer::ColorMode colormode,
+                      const Color4f& object_color,
+                      Color4f& outcolor) const;
   virtual void setColorScheme(const ColorScheme& cs);
 
-  virtual std::vector<SelectedObject> findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int mouse_x, int mouse_y, double tolerance);
+  virtual std::vector<SelectedObject> findModelObject(const Vector3d& near_pt,
+                                                      const Vector3d& far_pt,
+                                                      int mouse_x,
+                                                      int mouse_y,
+                                                      double tolerance);
 
-protected:
+ protected:
   std::map<ColorMode, Color4f> colormap_;
-  const ColorScheme *colorscheme_{nullptr};
+  const ColorScheme* colorscheme_{nullptr};
   void setupShader();
 };
diff --git a/src/glview/ShaderUtils.cc b/src/glview/ShaderUtils.cc
index 207462928..f8751f7b1 100644
--- a/src/glview/ShaderUtils.cc
+++ b/src/glview/ShaderUtils.cc
@@ -1,8 +1,8 @@
 #include "glview/ShaderUtils.h"
 
+#include <fstream>
 #include <sstream>
 #include <string>
-#include <fstream>
 
 #include "platform/PlatformUtils.h"
 
@@ -11,8 +11,8 @@ namespace {
 GLuint compileShader(const std::string& name, GLuint shader_type) {
   auto shader_source = ShaderUtils::loadShaderSource(name);
   const GLuint shader = glCreateShader(shader_type);
-  auto *c_source = shader_source.c_str();
-  glShaderSource(shader, 1, (const GLchar **)&c_source, nullptr);
+  auto* c_source = shader_source.c_str();
+  glShaderSource(shader, 1, (const GLchar**)&c_source, nullptr);
   glCompileShader(shader);
   GLint status;
   glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
@@ -31,24 +31,27 @@ GLuint compileShader(const std::string& name, GLuint shader_type) {
 namespace ShaderUtils {
 
 std::string loadShaderSource(const std::string& name) {
-  std::string shaderPath = (PlatformUtils::resourcePath("shaders") / name).string();
+  std::string shaderPath =
+      (PlatformUtils::resourcePath("shaders") / name).string();
   std::ostringstream buffer;
   const std::ifstream f(shaderPath);
   if (f.is_open()) {
     buffer << f.rdbuf();
   } else {
-    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'", shaderPath);
+    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'",
+        shaderPath);
   }
   return buffer.str();
 }
 
-ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str) {
+ShaderResource compileShaderProgram(const std::string& vs_str,
+                                    const std::string& fs_str) {
   int shaderstatus;
-  const char *vs_source = vs_str.c_str();
-  const char *fs_source = fs_str.c_str();
+  const char* vs_source = vs_str.c_str();
+  const char* fs_source = fs_str.c_str();
   // Compile the shaders
   GL_CHECKD(auto vertex_shader = glCreateShader(GL_VERTEX_SHADER));
-  glShaderSource(vertex_shader, 1, (const GLchar **)&vs_source, nullptr);
+  glShaderSource(vertex_shader, 1, (const GLchar**)&vs_source, nullptr);
   glCompileShader(vertex_shader);
   glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &shaderstatus);
   if (shaderstatus != GL_TRUE) {
@@ -56,12 +59,13 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
     char logbuffer[1000];
     glGetShaderInfoLog(vertex_shader, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen,
+            logbuffer);
     return {};
   }
 
   GL_CHECKD(auto fragment_shader = glCreateShader(GL_FRAGMENT_SHADER));
-  glShaderSource(fragment_shader, 1, (const GLchar **)&fs_source, nullptr);
+  glShaderSource(fragment_shader, 1, (const GLchar**)&fs_source, nullptr);
   glCompileShader(fragment_shader);
   glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &shaderstatus);
   if (shaderstatus != GL_TRUE) {
@@ -69,7 +73,8 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
     char logbuffer[1000];
     glGetShaderInfoLog(fragment_shader, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n",
+            loglen, logbuffer);
     return {};
   }
 
@@ -86,7 +91,8 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
     char logbuffer[1000];
     glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen,
+            logbuffer);
     return {};
   } else {
     glValidateProgram(shader_prog);
@@ -96,15 +102,16 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
       char logbuffer[1000];
       glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
       // FIXME: Use OpenCAD log to error instead of stderr
-      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n", loglen, logbuffer);
+      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n",
+              loglen, logbuffer);
       return {};
     }
   }
 
   return {
-    .shader_program = shader_prog,
-    .vertex_shader = vertex_shader,
-    .fragment_shader = fragment_shader,
+      .shader_program = shader_prog,
+      .vertex_shader = vertex_shader,
+      .fragment_shader = fragment_shader,
   };
 }
 
diff --git a/src/glview/ShaderUtils.h b/src/glview/ShaderUtils.h
index 2fcb29d55..8d7ecedc7 100644
--- a/src/glview/ShaderUtils.h
+++ b/src/glview/ShaderUtils.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <unordered_map>
 #include <string>
+#include <unordered_map>
 #include "glview/system-gl.h"
 
 namespace ShaderUtils {
@@ -27,6 +27,7 @@ struct ShaderInfo {
 };
 
 std::string loadShaderSource(const std::string& name);
-ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str);
+ShaderResource compileShaderProgram(const std::string& vs_str,
+                                    const std::string& fs_str);
 
-} // namespace ShaderUtils
+}  // namespace ShaderUtils
diff --git a/src/glview/VBOBuilder.cc b/src/glview/VBOBuilder.cc
index d5831d0b4..54a6c645a 100644
--- a/src/glview/VBOBuilder.cc
+++ b/src/glview/VBOBuilder.cc
@@ -1,26 +1,27 @@
 #include "glview/VBOBuilder.h"
 
-#include <unordered_map>
-#include <cstring>
-#include <cassert>
 #include <array>
+#include <cassert>
+#include <cstdio>
+#include <cstring>
+#include <memory>
+#include <unordered_map>
 #include <utility>
 #include <vector>
-#include <memory>
-#include <cstdio>
 
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
-#include "utils/printutils.h"
+#include "geometry/linalg.h"
 #include "utils/hash.h"  // IWYU pragma: keep
+#include "utils/printutils.h"
 
 namespace {
 
-// Since we transform each verted on the CPU, we cache already transformed vertices in the same PolySet
-// to avoid redundantly transforming the same vertex value twice, while we process non-indexed PolySets.
-Vector3d uniqueMultiply(std::unordered_map<Vector3d, Vector3d>& vert_mult_map, const Vector3d& in_vert,
-                        const Transform3d& m)
-{
+// Since we transform each verted on the CPU, we cache already transformed
+// vertices in the same PolySet to avoid redundantly transforming the same
+// vertex value twice, while we process non-indexed PolySets.
+Vector3d uniqueMultiply(std::unordered_map<Vector3d, Vector3d>& vert_mult_map,
+                        const Vector3d& in_vert,
+                        const Transform3d& m) {
   auto entry = vert_mult_map.find(in_vert);
   if (entry == vert_mult_map.end()) {
     Vector3d out_vert = m * in_vert;
@@ -34,20 +35,19 @@ Vector3d uniqueMultiply(std::unordered_map<Vector3d, Vector3d>& vert_mult_map, c
 
 void addAttributeValues(IAttributeData&) {}
 
-void VertexData::getLastVertex(std::vector<GLbyte>& interleaved_buffer) const
-{
-  GLbyte *dst_start = interleaved_buffer.data();
+void VertexData::getLastVertex(std::vector<GLbyte>& interleaved_buffer) const {
+  GLbyte* dst_start = interleaved_buffer.data();
   for (const auto& data : attributes_) {
     size_t size = data->sizeofAttribute();
-    GLbyte *dst = dst_start;
-    const GLbyte *src = data->toBytes() + data->sizeInBytes() - data->sizeofAttribute();
-    std::memcpy((void *)dst, (void *)src, size);
+    GLbyte* dst = dst_start;
+    const GLbyte* src =
+        data->toBytes() + data->sizeInBytes() - data->sizeofAttribute();
+    std::memcpy((void*)dst, (void*)src, size);
     dst_start += size;
   }
 }
 
-void VertexData::remove(size_t count)
-{
+void VertexData::remove(size_t count) {
   for (const auto& data : attributes_) {
     data->remove(count);
   }
@@ -55,21 +55,24 @@ void VertexData::remove(size_t count)
 
 // Adds attributes needed for regular 3D polygon rendering:
 // position, normal, color
-void VBOBuilder::addSurfaceData()
-{
+void VBOBuilder::addSurfaceData() {
   auto vertex_data = std::make_shared<VertexData>();
-  vertex_data->addPositionData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addNormalData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addColorData(std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
+  vertex_data->addPositionData(
+      std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
+  vertex_data->addNormalData(
+      std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
+  vertex_data->addColorData(
+      std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
   surface_index_ = vertices_.size();
   vertices_.emplace_back(std::move(vertex_data));
 }
 
-void VBOBuilder::addEdgeData()
-{
+void VBOBuilder::addEdgeData() {
   auto vertex_data = std::make_shared<VertexData>();
-  vertex_data->addPositionData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addColorData(std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
+  vertex_data->addPositionData(
+      std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
+  vertex_data->addColorData(
+      std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
   edge_index_ = vertices_.size();
   vertices_.emplace_back(std::move(vertex_data));
 }
@@ -77,15 +80,22 @@ void VBOBuilder::addEdgeData()
 void VBOBuilder::createVertex(const std::array<Vector3d, 3>& points,
                               const std::array<Vector3d, 3>& normals,
                               const Color4f& color,
-                              size_t active_point_index, size_t primitive_index,
-                              size_t shape_size, bool outlines, bool /*mirror*/)
-{
-  addAttributeValues(*(data()->positionData()), points[active_point_index][0], points[active_point_index][1], points[active_point_index][2]);
+                              size_t active_point_index,
+                              size_t primitive_index,
+                              size_t shape_size,
+                              bool outlines,
+                              bool /*mirror*/) {
+  addAttributeValues(*(data()->positionData()), points[active_point_index][0],
+                     points[active_point_index][1],
+                     points[active_point_index][2]);
   if (data()->hasNormalData()) {
-    addAttributeValues(*(data()->normalData()), normals[active_point_index][0], normals[active_point_index][1], normals[active_point_index][2]);
+    addAttributeValues(*(data()->normalData()), normals[active_point_index][0],
+                       normals[active_point_index][1],
+                       normals[active_point_index][2]);
   }
   if (data()->hasColorData()) {
-    addAttributeValues(*(data()->colorData()), color.r(), color.g(), color.b(), color.a());
+    addAttributeValues(*(data()->colorData()), color.r(), color.g(), color.b(),
+                       color.a());
   }
 
   if (useElements()) {
@@ -97,7 +107,8 @@ void VBOBuilder::createVertex(const std::array<Vector3d, 3>& points,
     if (entry.first == elements_map_.end()) {
       // append vertex data if this is a new element
       if (!interleaved_buffer_.empty()) {
-        memcpy(interleaved_buffer_.data() + vertices_offset_, interleaved_vertex.data(), interleaved_vertex.size());
+        memcpy(interleaved_buffer_.data() + vertices_offset_,
+               interleaved_vertex.data(), interleaved_vertex.size());
         data()->clear();
       }
       vertices_offset_ += interleaved_vertex.size();
@@ -120,28 +131,28 @@ void VBOBuilder::createVertex(const std::array<Vector3d, 3>& points,
           i++;
         }
       }
-#endif // 0
+#endif  // 0
     }
 
     // append element data
     addAttributeValues(*elementsData(), entry.first->second);
     elements_offset_ += elementsData()->sizeofAttribute();
-  } else { // !useElements()
+  } else {  // !useElements()
     if (interleaved_buffer_.empty()) {
       vertices_offset_ = sizeInBytes();
     } else {
       std::vector<GLbyte> interleaved_vertex;
       interleaved_vertex.resize(data()->stride());
       data()->getLastVertex(interleaved_vertex);
-      memcpy(interleaved_buffer_.data() + vertices_offset_, interleaved_vertex.data(), interleaved_vertex.size());
+      memcpy(interleaved_buffer_.data() + vertices_offset_,
+             interleaved_vertex.data(), interleaved_vertex.size());
       vertices_offset_ += interleaved_vertex.size();
       data()->clear();
     }
   }
 }
 
-void VBOBuilder::createInterleavedVBOs()
-{
+void VBOBuilder::createInterleavedVBOs() {
   for (const auto& state : vertex_state_container_.states()) {
     state->setDrawOffset(this->indexOffset(state->drawOffset()));
   }
@@ -150,10 +161,14 @@ void VBOBuilder::createInterleavedVBOs()
   size_t total_size = this->sizeInBytes();
   // If VertexArray is not empty, and initial size is zero
   if (interleaved_buffer_.empty() && total_size) {
-    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", total_size % (void *)nullptr);
-    GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, total_size, nullptr, GL_STATIC_DRAW));
+    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)",
+             vertex_state_container_.verticesVBO());
+    GL_CHECKD(
+        glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
+    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+             total_size % (void*)nullptr);
+    GL_CHECKD(
+        glBufferData(GL_ARRAY_BUFFER, total_size, nullptr, GL_STATIC_DRAW));
 
     size_t dst_start = 0;
     for (const auto& vertex_data : vertices_) {
@@ -161,13 +176,15 @@ void VBOBuilder::createInterleavedVBOs()
       size_t idx = 0, last_size = 0, stride = vertex_data->stride();
       for (const auto& data : vertex_data->attributes()) {
         size_t size = data->sizeofAttribute();
-        const GLbyte *src = data->toBytes();
+        const GLbyte* src = data->toBytes();
         size_t dst = dst_start;
 
         if (src) {
           if (idx != 0) {
             if (last_size != data->size() / data->count()) {
-              PRINTDB("attribute data for vertex incorrect size at index %d = %d", idx % (data->size() / data->count()));
+              PRINTDB(
+                  "attribute data for vertex incorrect size at index %d = %d",
+                  idx % (data->size() / data->count()));
               PRINTDB("last_size = %d", last_size);
               assert(false);
             }
@@ -175,7 +192,8 @@ void VBOBuilder::createInterleavedVBOs()
           last_size = data->size() / data->count();
           for (size_t i = 0; i < last_size; ++i) {
             // This path is chosen in vertex-object-renderers non-direct mode
-            GL_TRACE("A glBufferSubData(GL_ARRAY_BUFFER, %p, %d, %p)", (void *)dst % size % (void *)src);
+            GL_TRACE("A glBufferSubData(GL_ARRAY_BUFFER, %p, %d, %p)",
+                     (void*)dst % size % (void*)src);
             GL_CHECKD(glBufferSubData(GL_ARRAY_BUFFER, dst, size, src));
             src += size;
             dst += stride;
@@ -190,26 +208,37 @@ void VBOBuilder::createInterleavedVBOs()
     GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
     GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
   } else if (!interleaved_buffer_.empty()) {
-    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", interleaved_buffer_.size() % (void *)interleaved_buffer_.data());
-    GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, interleaved_buffer_.size(), interleaved_buffer_.data(), GL_STATIC_DRAW));
+    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)",
+             vertex_state_container_.verticesVBO());
+    GL_CHECKD(
+        glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
+    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+             interleaved_buffer_.size() % (void*)interleaved_buffer_.data());
+    GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, interleaved_buffer_.size(),
+                           interleaved_buffer_.data(), GL_STATIC_DRAW));
     GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
     GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
   }
 
-  PRINTDB("useElements() = %d, elements_size_ = %d", useElements() % elements_size_);
+  PRINTDB("useElements() = %d, elements_size_ = %d",
+          useElements() % elements_size_);
   if (useElements()) {
-    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", vertex_state_container_.elementsVBO());
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vertex_state_container_.elementsVBO()));
+    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)",
+             vertex_state_container_.elementsVBO());
+    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
+                           vertex_state_container_.elementsVBO()));
     if (elements_size_ == 0) {
-      GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", elements_.sizeInBytes() % (void *)nullptr);
-      GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_.sizeInBytes(), nullptr, GL_STATIC_DRAW));
+      GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+               elements_.sizeInBytes() % (void*)nullptr);
+      GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_.sizeInBytes(),
+                             nullptr, GL_STATIC_DRAW));
     }
     size_t last_size = 0;
     for (const auto& e : elements_.attributes()) {
-      GL_TRACE("glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, %d, %d, %p)", last_size % e->sizeInBytes() % (void *)e->toBytes());
-      GL_CHECKD(glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, last_size, e->sizeInBytes(), e->toBytes()));
+      GL_TRACE("glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, %d, %d, %p)",
+               last_size % e->sizeInBytes() % (void*)e->toBytes());
+      GL_CHECKD(glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, last_size,
+                                e->sizeInBytes(), e->toBytes()));
       last_size += e->sizeInBytes();
     }
     GL_TRACE0("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
@@ -217,30 +246,35 @@ void VBOBuilder::createInterleavedVBOs()
   }
 }
 
-void VBOBuilder::addAttributePointers(size_t start_offset)
-{
-  if (!this->data()) return;
+void VBOBuilder::addAttributePointers(size_t start_offset) {
+  if (!this->data())
+    return;
 
   std::shared_ptr<VertexData> vertex_data = this->data();
-  std::shared_ptr<VertexState> vertex_state = vertex_state_container_.states().back();
+  std::shared_ptr<VertexState> vertex_state =
+      vertex_state_container_.states().back();
 
   GLsizei count = vertex_data->positionData()->count();
   GLenum type = vertex_data->positionData()->glType();
   GLsizei stride = vertex_data->stride();
-  size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->positionIndex());
-  // Note: Some code, like OpenCSGRenderer::createVBOPrimitive() relies on this order of
-  // glBegin/glEnd functions for unlit/uncolored vertex rendering.
+  size_t offset = start_offset +
+                  vertex_data->interleavedOffset(vertex_data->positionIndex());
+  // Note: Some code, like OpenCSGRenderer::createVBOPrimitive() relies on this
+  // order of glBegin/glEnd functions for unlit/uncolored vertex rendering.
   vertex_state->glBegin().emplace_back([]() {
     GL_TRACE0("glEnableClientState(GL_VERTEX_ARRAY)");
     GL_CHECKD(glEnableClientState(GL_VERTEX_ARRAY));
   });
-  vertex_state->glBegin().emplace_back([count, type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
+  vertex_state->glBegin().emplace_back([count, type, stride, offset,
+                                        vs_ptr = std::weak_ptr<VertexState>(
+                                            vertex_state)]() {
     auto vs = vs_ptr.lock();
     if (vs) {
       // NOLINTBEGIN(performance-no-int-to-ptr)
       GL_TRACE("glVertexPointer(%d, %d, %d, %p)",
-               count % type % stride % (GLvoid *)(vs->drawOffset() + offset));
-      GL_CHECKD(glVertexPointer(count, type, stride, (GLvoid *)(vs->drawOffset() + offset)));
+               count % type % stride % (GLvoid*)(vs->drawOffset() + offset));
+      GL_CHECKD(glVertexPointer(count, type, stride,
+                                (GLvoid*)(vs->drawOffset() + offset)));
       // NOLINTEND(performance-no-int-to-ptr)
     }
   });
@@ -251,20 +285,25 @@ void VBOBuilder::addAttributePointers(size_t start_offset)
 
   if (vertex_data->hasNormalData()) {
     type = vertex_data->normalData()->glType();
-    size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->normalIndex());
+    size_t offset = start_offset +
+                    vertex_data->interleavedOffset(vertex_data->normalIndex());
     vertex_state->glBegin().emplace_back([]() {
       GL_TRACE0("glEnableClientState(GL_NORMAL_ARRAY)");
       GL_CHECKD(glEnableClientState(GL_NORMAL_ARRAY));
     });
-    vertex_state->glBegin().emplace_back([type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
-      auto vs = vs_ptr.lock();
-      if (vs) {
-        // NOLINTBEGIN(performance-no-int-to-ptr)
-        GL_TRACE("glNormalPointer(%d, %d, %p)", type % stride % (GLvoid *)(vs->drawOffset() + offset));
-        GL_CHECKD(glNormalPointer(type, stride, (GLvoid *)(vs->drawOffset() + offset)));
-        // NOLINTEND(performance-no-int-to-ptr)
-      }
-    });
+    vertex_state->glBegin().emplace_back(
+        [type, stride, offset,
+         vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
+          auto vs = vs_ptr.lock();
+          if (vs) {
+            // NOLINTBEGIN(performance-no-int-to-ptr)
+            GL_TRACE("glNormalPointer(%d, %d, %p)",
+                     type % stride % (GLvoid*)(vs->drawOffset() + offset));
+            GL_CHECKD(glNormalPointer(type, stride,
+                                      (GLvoid*)(vs->drawOffset() + offset)));
+            // NOLINTEND(performance-no-int-to-ptr)
+          }
+        });
     vertex_state->glEnd().emplace_back([]() {
       GL_TRACE0("glDisableClientState(GL_NORMAL_ARRAY)");
       GL_CHECKD(glDisableClientState(GL_NORMAL_ARRAY));
@@ -273,17 +312,22 @@ void VBOBuilder::addAttributePointers(size_t start_offset)
   if (vertex_data->hasColorData()) {
     count = vertex_data->colorData()->count();
     type = vertex_data->colorData()->glType();
-    size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->colorIndex());
+    size_t offset = start_offset +
+                    vertex_data->interleavedOffset(vertex_data->colorIndex());
     vertex_state->glBegin().emplace_back([]() {
       GL_TRACE0("glEnableClientState(GL_COLOR_ARRAY)");
       GL_CHECKD(glEnableClientState(GL_COLOR_ARRAY));
     });
-    vertex_state->glBegin().emplace_back([count, type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
+    vertex_state->glBegin().emplace_back([count, type, stride, offset,
+                                          vs_ptr = std::weak_ptr<VertexState>(
+                                              vertex_state)]() {
       auto vs = vs_ptr.lock();
       if (vs) {
         // NOLINTBEGIN(performance-no-int-to-ptr)
-        GL_TRACE("glColorPointer(%d, %d, %d, %p)", count % type % stride % (GLvoid *)(vs->drawOffset() + offset));
-        GL_CHECKD(glColorPointer(count, type, stride, (GLvoid *)(vs->drawOffset() + offset)));
+        GL_TRACE("glColorPointer(%d, %d, %d, %p)",
+                 count % type % stride % (GLvoid*)(vs->drawOffset() + offset));
+        GL_CHECKD(glColorPointer(count, type, stride,
+                                 (GLvoid*)(vs->drawOffset() + offset)));
         // NOLINTEND(performance-no-int-to-ptr)
       }
     });
@@ -299,41 +343,56 @@ void VBOBuilder::addAttributePointers(size_t start_offset)
 void VBOBuilder::allocateBuffers(size_t num_vertices) {
   size_t vbo_buffer_size = num_vertices * stride();
   interleaved_buffer_.resize(vbo_buffer_size);
-  GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-  GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-  GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", vbo_buffer_size % (void *)nullptr);
-  GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, vbo_buffer_size, nullptr, GL_STATIC_DRAW));
+  GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)",
+           vertex_state_container_.verticesVBO());
+  GL_CHECKD(
+      glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
+  GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+           vbo_buffer_size % (void*)nullptr);
+  GL_CHECKD(
+      glBufferData(GL_ARRAY_BUFFER, vbo_buffer_size, nullptr, GL_STATIC_DRAW));
   if (Feature::ExperimentalVxORenderersIndexing.is_enabled()) {
     // Use smallest possible index data type
     if (num_vertices <= 0xff) {
-      addElementsData(std::make_shared<AttributeData<GLubyte, 1, GL_UNSIGNED_BYTE>>());
+      addElementsData(
+          std::make_shared<AttributeData<GLubyte, 1, GL_UNSIGNED_BYTE>>());
     } else if (num_vertices <= 0xffff) {
-      addElementsData(std::make_shared<AttributeData<GLushort, 1, GL_UNSIGNED_SHORT>>());
+      addElementsData(
+          std::make_shared<AttributeData<GLushort, 1, GL_UNSIGNED_SHORT>>());
     } else {
-      addElementsData(std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
+      addElementsData(
+          std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
     }
     // FIXME: How do we know how much to allocate?
-    // FIXME: Should we preallocate so we don't have to make a bunch of glBufferSubData() calls?
+    // FIXME: Should we preallocate so we don't have to make a bunch of
+    // glBufferSubData() calls?
     size_t elements_size = num_vertices * elements_.stride();
     setElementsSize(elements_size);
-    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", vertex_state_container_.elementsVBO());
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vertex_state_container_.elementsVBO()));
-    GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", elements_size % (void *)nullptr);
-    GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_size, nullptr, GL_STATIC_DRAW));
+    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)",
+             vertex_state_container_.elementsVBO());
+    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
+                           vertex_state_container_.elementsVBO()));
+    GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+             elements_size % (void*)nullptr);
+    GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_size, nullptr,
+                           GL_STATIC_DRAW));
   }
 }
 
-// FIXME: This specifically adds barycentric vertex attributes, so document/rename accordingly
-void VBOBuilder::addShaderData()
-{
+// FIXME: This specifically adds barycentric vertex attributes, so
+// document/rename accordingly
+void VBOBuilder::addShaderData() {
   const std::shared_ptr<VertexData> vertex_data = data();
   shader_attributes_index_ = vertex_data->attributes().size();
-  vertex_data->addAttributeData(std::make_shared<AttributeData<GLubyte, 4, GL_UNSIGNED_BYTE>>()); // barycentric
+  vertex_data->addAttributeData(
+      std::make_shared<
+          AttributeData<GLubyte, 4, GL_UNSIGNED_BYTE>>());  // barycentric
 }
 
 void VBOBuilder::add_barycentric_attribute(size_t active_point_index,
-                                           size_t primitive_index, size_t shape_size, bool outlines)
-{
+                                           size_t primitive_index,
+                                           size_t shape_size,
+                                           bool outlines) {
   const std::shared_ptr<VertexData> vertex_data = data();
 
   // Get edge states
@@ -365,14 +424,20 @@ void VBOBuilder::add_barycentric_attribute(size_t active_point_index,
   barycentric_flags[active_point_index] = 1;
 
   addAttributeValues(
-    *(vertex_data->attributes()[shader_attributes_index_ + BARYCENTRIC_ATTRIB]),
-    barycentric_flags[0], barycentric_flags[1], barycentric_flags[2], 0);
+      *(vertex_data
+            ->attributes()[shader_attributes_index_ + BARYCENTRIC_ATTRIB]),
+      barycentric_flags[0], barycentric_flags[1], barycentric_flags[2], 0);
 }
 
-void VBOBuilder::create_triangle(const Color4f& color, const Vector3d& p0,
-                                 const Vector3d& p1, const Vector3d& p2, size_t primitive_index,
-                                 size_t shape_size, bool outlines, bool enable_barycentric, bool mirror)
-{
+void VBOBuilder::create_triangle(const Color4f& color,
+                                 const Vector3d& p0,
+                                 const Vector3d& p1,
+                                 const Vector3d& p2,
+                                 size_t primitive_index,
+                                 size_t shape_size,
+                                 bool outlines,
+                                 bool enable_barycentric,
+                                 bool mirror) {
   const double ax = p1[0] - p0[0], bx = p1[0] - p2[0];
   const double ay = p1[1] - p0[1], by = p1[1] - p2[1];
   const double az = p1[2] - p0[2], bz = p1[2] - p2[2];
@@ -382,7 +447,8 @@ void VBOBuilder::create_triangle(const Color4f& color, const Vector3d& p0,
   const double nl = sqrt(nx * nx + ny * ny + nz * nz);
   const Vector3d n = Vector3d(nx / nl, ny / nl, nz / nl);
 
-  if (!data()) return;
+  if (!data())
+    return;
 
   if (enable_barycentric) {
     add_barycentric_attribute(0, primitive_index, shape_size, outlines);
@@ -394,29 +460,31 @@ void VBOBuilder::create_triangle(const Color4f& color, const Vector3d& p0,
     if (enable_barycentric) {
       add_barycentric_attribute(1, primitive_index, shape_size, outlines);
     }
-    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size, outlines,
-                 mirror);
+    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size,
+                 outlines, mirror);
   }
   if (enable_barycentric) {
     add_barycentric_attribute(2, primitive_index, shape_size, outlines);
   }
-  createVertex({p0, p1, p2}, {n, n, n}, color, 2, primitive_index, shape_size, outlines,
-               mirror);
+  createVertex({p0, p1, p2}, {n, n, n}, color, 2, primitive_index, shape_size,
+               outlines, mirror);
   if (mirror) {
     if (enable_barycentric) {
       add_barycentric_attribute(1, primitive_index, shape_size, outlines);
     }
-    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size, outlines,
-                 mirror);
+    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size,
+                 outlines, mirror);
   }
 }
 
 // Creates a VBO "surface" from the PolySet.
 // This will usually create a new VertexState and append it to our
 // vertex states
-void VBOBuilder::create_surface(const PolySet& ps, const Transform3d& m,
-                                const Color4f& default_color, bool enable_barycentric, bool force_default_color)
-{
+void VBOBuilder::create_surface(const PolySet& ps,
+                                const Transform3d& m,
+                                const Color4f& default_color,
+                                bool enable_barycentric,
+                                bool force_default_color) {
   const std::shared_ptr<VertexData> vertex_data = data();
 
   if (!vertex_data) {
@@ -439,26 +507,38 @@ void VBOBuilder::create_surface(const PolySet& ps, const Transform3d& m,
 
   for (int i = 0, n = ps.indices.size(); i < n; i++) {
     const auto& poly = ps.indices[i];
-    const auto color_index = has_colors && i < ps.color_indices.size() ? ps.color_indices[i] : -1;
-    const auto& color = !force_default_color && color_index >= 0 && color_index < ps.colors.size() &&
-      ps.colors[color_index].isValid()
-                          ? ps.colors[color_index]
-                          : default_color;
+    const auto color_index =
+        has_colors && i < ps.color_indices.size() ? ps.color_indices[i] : -1;
+    const auto& color = !force_default_color && color_index >= 0 &&
+                                color_index < ps.colors.size() &&
+                                ps.colors[color_index].isValid()
+                            ? ps.colors[color_index]
+                            : default_color;
     if (poly.size() == 3) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-
-      create_triangle(color, p0, p1, p2, 0, poly.size(), false, enable_barycentric, mirrored);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
+      const Vector3d p1 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
+      const Vector3d p2 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+
+      create_triangle(color, p0, p1, p2, 0, poly.size(), false,
+                      enable_barycentric, mirrored);
       triangle_count++;
     } else if (poly.size() == 4) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-      const Vector3d p3 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
-
-      create_triangle(color, p0, p1, p3, 0, poly.size(), false, enable_barycentric, mirrored);
-      create_triangle(color, p2, p3, p1, 1, poly.size(), false, enable_barycentric, mirrored);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
+      const Vector3d p1 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
+      const Vector3d p2 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+      const Vector3d p3 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
+
+      create_triangle(color, p0, p1, p3, 0, poly.size(), false,
+                      enable_barycentric, mirrored);
+      create_triangle(color, p2, p3, p1, 1, poly.size(), false,
+                      enable_barycentric, mirrored);
       triangle_count += 2;
     } else {
       Vector3d center = Vector3d::Zero();
@@ -468,30 +548,35 @@ void VBOBuilder::create_surface(const PolySet& ps, const Transform3d& m,
       center /= poly.size();
       for (size_t i = 1; i <= poly.size(); i++) {
         const Vector3d p0 = uniqueMultiply(vert_mult_map, center, m);
-        const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
-        const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
+        const Vector3d p1 = uniqueMultiply(
+            vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
+        const Vector3d p2 =
+            uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
 
-        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false, enable_barycentric, mirrored);
+        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false,
+                        enable_barycentric, mirrored);
         triangle_count++;
       }
     }
   }
 
   GLenum elements_type = 0;
-  if (useElements()) elements_type = elementsData()->glType();
-  std::shared_ptr<VertexState> vertex_state = createVertexState(
-    GL_TRIANGLES, triangle_count * 3, elements_type, writeIndex(), elements_offset);
+  if (useElements())
+    elements_type = elementsData()->glType();
+  std::shared_ptr<VertexState> vertex_state =
+      createVertexState(GL_TRIANGLES, triangle_count * 3, elements_type,
+                        writeIndex(), elements_offset);
   vertex_state_container_.states().emplace_back(std::move(vertex_state));
   addAttributePointers(last_size);
 }
 
 void VBOBuilder::create_edges(const Polygon2d& polygon,
                               const Transform3d& m,
-                              const Color4f& color)
-{
+                              const Color4f& color) {
   const std::shared_ptr<VertexData> vertex_data = data();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
   auto& vertex_states = states();
   std::unordered_map<Vector3d, Vector3d> vert_mult_map;
@@ -505,25 +590,30 @@ void VBOBuilder::create_edges(const Polygon2d& polygon,
       elementsMap().clear();
     }
     for (const Vector2d& v : o.vertices) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, Vector3d(v[0], v[1], 0.0), m);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, Vector3d(v[0], v[1], 0.0), m);
       createVertex({p0}, {}, color, 0, 0, o.vertices.size(), true, false);
     }
 
     GLenum elements_type = 0;
-    if (useElements()) elements_type = elementsData()->glType();
-    std::shared_ptr<VertexState> line_loop = createVertexState(
-      GL_LINE_LOOP, o.vertices.size(), elements_type, writeIndex(), elements_offset);
+    if (useElements())
+      elements_type = elementsData()->glType();
+    std::shared_ptr<VertexState> line_loop =
+        createVertexState(GL_LINE_LOOP, o.vertices.size(), elements_type,
+                          writeIndex(), elements_offset);
     vertex_states.emplace_back(std::move(line_loop));
     addAttributePointers(last_size);
   }
 }
 
-void VBOBuilder::create_polygons(const PolySet& ps, const Transform3d& m, const Color4f& color)
-{
+void VBOBuilder::create_polygons(const PolySet& ps,
+                                 const Transform3d& m,
+                                 const Color4f& color) {
   assert(ps.getDimension() == 2);
   const std::shared_ptr<VertexData> vertex_data = data();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
   auto& vertex_states = states();
   std::unordered_map<Vector3d, Vector3d> vert_mult_map;
@@ -540,20 +630,30 @@ void VBOBuilder::create_polygons(const PolySet& ps, const Transform3d& m, const
 
   for (const auto& poly : ps.indices) {
     if (poly.size() == 3) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-
-      create_triangle(color, p0, p1, p2, 0, poly.size(), false, false, mirrored);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
+      const Vector3d p1 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
+      const Vector3d p2 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+
+      create_triangle(color, p0, p1, p2, 0, poly.size(), false, false,
+                      mirrored);
       triangle_count++;
     } else if (poly.size() == 4) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-      const Vector3d p3 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
-
-      create_triangle(color, p0, p1, p3, 0, poly.size(), false, false, mirrored);
-      create_triangle(color, p2, p3, p1, 1, poly.size(), false, false, mirrored);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
+      const Vector3d p1 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
+      const Vector3d p2 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+      const Vector3d p3 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
+
+      create_triangle(color, p0, p1, p3, 0, poly.size(), false, false,
+                      mirrored);
+      create_triangle(color, p2, p3, p1, 1, poly.size(), false, false,
+                      mirrored);
       triangle_count += 2;
     } else {
       Vector3d center = Vector3d::Zero();
@@ -566,20 +666,24 @@ void VBOBuilder::create_polygons(const PolySet& ps, const Transform3d& m, const
 
       for (size_t i = 1; i <= poly.size(); i++) {
         const Vector3d p0 = uniqueMultiply(vert_mult_map, center, m);
-        const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
-        const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
+        const Vector3d p1 = uniqueMultiply(
+            vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
+        const Vector3d p2 =
+            uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
 
-        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false, false, mirrored);
+        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false, false,
+                        mirrored);
         triangle_count++;
       }
     }
   }
 
   GLenum elements_type = 0;
-  if (useElements()) elements_type = elementsData()->glType();
-  std::shared_ptr<VertexState> vs = createVertexState(
-    GL_TRIANGLES, triangle_count * 3, elements_type, writeIndex(), elements_offset);
+  if (useElements())
+    elements_type = elementsData()->glType();
+  std::shared_ptr<VertexState> vs =
+      createVertexState(GL_TRIANGLES, triangle_count * 3, elements_type,
+                        writeIndex(), elements_offset);
   vertex_states.emplace_back(std::move(vs));
   addAttributePointers(last_size);
 }
-
diff --git a/src/glview/VBOBuilder.h b/src/glview/VBOBuilder.h
index 3a2f30c82..ce9593965 100644
--- a/src/glview/VBOBuilder.h
+++ b/src/glview/VBOBuilder.h
@@ -1,43 +1,43 @@
 #pragma once
 
 #include <array>
+#include <boost/functional/hash.hpp>
+#include <cstddef>
 #include <functional>
 #include <memory>
-#include <cstddef>
 #include <unordered_map>
-#include <boost/functional/hash.hpp>
 #include <utility>
 #include <vector>
 
+#include "Feature.h"
 #include "geometry/PolySet.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "glview/Renderer.h"
+#include "glview/VertexState.h"
 #include "glview/system-gl.h"
 #include "utils/printutils.h"
-#include "geometry/linalg.h"
-#include "Feature.h"
-#include "glview/VertexState.h"
 
-enum ShaderAttribIndex {
-  BARYCENTRIC_ATTRIB
-};
+enum ShaderAttribIndex { BARYCENTRIC_ATTRIB };
 
 // Hash function for opengl vertex data.
 template <typename T>
 struct vertex_hash {
   std::size_t operator()(T const& vertex) const {
     size_t seed = 0;
-    for (size_t i = 0; i < vertex.size(); ++i) boost::hash_combine(seed, vertex.data()[i]);
+    for (size_t i = 0; i < vertex.size(); ++i)
+      boost::hash_combine(seed, vertex.data()[i]);
     return seed;
   }
 };
 
-using ElementsMap = std::unordered_map<std::vector<GLbyte>, GLuint, vertex_hash<std::vector<GLbyte>>>;
+using ElementsMap = std::unordered_map<std::vector<GLbyte>,
+                                       GLuint,
+                                       vertex_hash<std::vector<GLbyte>>>;
 
 // Interface class for basic attribute data that will be loaded into VBO
-class IAttributeData
-{
-public:
+class IAttributeData {
+ public:
   IAttributeData() = default;
   virtual ~IAttributeData() = default;
 
@@ -54,7 +54,7 @@ public:
   // Return the OpenGL type of the element
   [[nodiscard]] virtual GLenum glType() const = 0;
   // Return pointer to the raw bytes of the element vector
-  [[nodiscard]] virtual const GLbyte *toBytes() const = 0;
+  [[nodiscard]] virtual const GLbyte* toBytes() const = 0;
   // Clear the entire attribute
   virtual void clear() = 0;
   // Remove data from the end of the attribute
@@ -73,38 +73,49 @@ public:
 // Helper function to finish recursion in addAttributeValues call
 void addAttributeValues(IAttributeData&);
 // Template helper function to load multiple attribute values in one call
-template <typename T, typename ... Args>
+template <typename T, typename... Args>
 void addAttributeValues(IAttributeData& attrib, T value, Args... values) {
   attrib.addData(value);
-  addAttributeValues(attrib, values ...);
+  addAttributeValues(attrib, values...);
 }
 
-// Template helper function to load multiple copies of the same multiple attribute values in one call.
-// Used to add the same normal and colors to multiple triangle points.
-template <typename T, typename ... Args>
-void addAttributeValues(size_t copies, IAttributeData& attrib, T value, Args... values) {
+// Template helper function to load multiple copies of the same multiple
+// attribute values in one call. Used to add the same normal and colors to
+// multiple triangle points.
+template <typename T, typename... Args>
+void addAttributeValues(size_t copies,
+                        IAttributeData& attrib,
+                        T value,
+                        Args... values) {
   if (copies > 0) {
-    addAttributeValues(attrib, value, values ...);
-    addAttributeValues(copies - 1, attrib, value, values ...);
+    addAttributeValues(attrib, value, values...);
+    addAttributeValues(copies - 1, attrib, value, values...);
   }
 }
 
 // Template class for implementing IAttributeData interface abstract class
 template <typename T, size_t C, GLenum E>
-class AttributeData : public IAttributeData
-{
-public:
+class AttributeData : public IAttributeData {
+ public:
   AttributeData() : data_() {}
 
   [[nodiscard]] inline size_t count() const override { return C; }
   [[nodiscard]] inline size_t size() const override { return data_.size(); }
   [[nodiscard]] inline size_t sizeofType() const override { return sizeof(T); }
-  [[nodiscard]] inline size_t sizeofAttribute() const override { return sizeof(T) * C; }
-  [[nodiscard]] inline size_t sizeInBytes() const override { return data_.size() * sizeof(T); }
+  [[nodiscard]] inline size_t sizeofAttribute() const override {
+    return sizeof(T) * C;
+  }
+  [[nodiscard]] inline size_t sizeInBytes() const override {
+    return data_.size() * sizeof(T);
+  }
   [[nodiscard]] inline GLenum glType() const override { return E; }
   void clear() override { data_.clear(); }
-  void remove(size_t count) override { data_.erase(data_.end() - (count * C), data_.end()); }
-  [[nodiscard]] inline const GLbyte *toBytes() const override { return (GLbyte *)(data_.data()); }
+  void remove(size_t count) override {
+    data_.erase(data_.end() - (count * C), data_.end());
+  }
+  [[nodiscard]] inline const GLbyte* toBytes() const override {
+    return (GLbyte*)(data_.data());
+  }
 
   inline void addData(GLbyte value) override { add_data((T)value); }
   inline void addData(GLshort value) override { add_data((T)value); }
@@ -115,9 +126,11 @@ public:
   inline void addData(GLdouble value) override { add_data((T)value); }
 
   // Return the template type element vector
-  [[nodiscard]] inline std::shared_ptr<std::vector<T>> getData() const { return std::shared_ptr<std::vector<T>>(data_); }
+  [[nodiscard]] inline std::shared_ptr<std::vector<T>> getData() const {
+    return std::shared_ptr<std::vector<T>>(data_);
+  }
 
-private:
+ private:
   // Internal method to add data of template type to element vector
   void add_data(T value) { data_.emplace_back(value); }
 
@@ -125,71 +138,96 @@ private:
 };
 
 // Storage and access class for multiple AttributeData that make up one vertex.
-class VertexData
-{
-public:
-  VertexData() : position_data_(nullptr), normal_data_(nullptr), color_data_(nullptr) {}
+class VertexData {
+ public:
+  VertexData()
+      : position_data_(nullptr), normal_data_(nullptr), color_data_(nullptr) {}
   virtual ~VertexData() = default;
 
   // Add generic attribute data to vertex vector
-  void addAttributeData(std::shared_ptr<IAttributeData> data)
-  {
+  void addAttributeData(std::shared_ptr<IAttributeData> data) {
     stride_ += data->sizeofAttribute();
     attributes_.emplace_back(data);
   }
 
   // Add position attribute data to vertex vector
-  void addPositionData(std::shared_ptr<IAttributeData> data)
-  {
+  void addPositionData(std::shared_ptr<IAttributeData> data) {
     position_index_ = attributes_.size();
     stride_ += data->sizeofAttribute();
     position_data_ = attributes_.emplace_back(std::move(data));
   }
   // Add normal attribute data to vertex vector
-  void addNormalData(std::shared_ptr<IAttributeData> data)
-  {
+  void addNormalData(std::shared_ptr<IAttributeData> data) {
     normal_index_ = attributes_.size();
     stride_ += data->sizeofAttribute();
     normal_data_ = attributes_.emplace_back(std::move(data));
   }
   // Add color attribute data to vertex vector
-  void addColorData(std::shared_ptr<IAttributeData> data)
-  {
+  void addColorData(std::shared_ptr<IAttributeData> data) {
     color_index_ = attributes_.size();
     stride_ += data->sizeofAttribute();
     color_data_ = attributes_.emplace_back(std::move(data));
   }
 
-  void clear() { for (auto& a : attributes_) a->clear(); }
+  void clear() {
+    for (auto& a : attributes_)
+      a->clear();
+  }
   // Remove the last n interleaved vertices
   void remove(size_t count = 1);
 
   // Return reference to internal IAttributeData vector
-  [[nodiscard]] inline const std::vector<std::shared_ptr<IAttributeData>>& attributes() const { return attributes_; }
-  // Return reference to the last added IAttributeData. This is typically where elements data is stored.
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData> attributeData() const { if (attributes_.size()) return attributes_.back(); else return nullptr; }
+  [[nodiscard]] inline const std::vector<std::shared_ptr<IAttributeData>>&
+  attributes() const {
+    return attributes_;
+  }
+  // Return reference to the last added IAttributeData. This is typically where
+  // elements data is stored.
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData> attributeData()
+      const {
+    if (attributes_.size())
+      return attributes_.back();
+    else
+      return nullptr;
+  }
   // Return reference to position attribute data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& positionData() const { return position_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& positionData()
+      const {
+    return position_data_;
+  }
   // Return reference to normal attribute data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& normalData() const { return normal_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& normalData()
+      const {
+    return normal_data_;
+  }
   // Return reference to color data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& colorData() const { return color_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& colorData()
+      const {
+    return color_data_;
+  }
   // Check if VertexData has position data
-  [[nodiscard]] inline bool hasPositionData() const { return (position_data_ != nullptr); }
+  [[nodiscard]] inline bool hasPositionData() const {
+    return (position_data_ != nullptr);
+  }
   // Return position attribute data vector index
   [[nodiscard]] inline size_t positionIndex() const { return position_index_; }
   // Check if VertexData has normal data
-  [[nodiscard]] inline bool hasNormalData() const { return (normal_data_ != nullptr); }
+  [[nodiscard]] inline bool hasNormalData() const {
+    return (normal_data_ != nullptr);
+  }
   // Return normal attribute data vector index
   [[nodiscard]] inline size_t normalIndex() const { return normal_index_; }
   // Check if VertexData has color data
-  [[nodiscard]] inline bool hasColorData() const { return (color_data_ != nullptr); }
+  [[nodiscard]] inline bool hasColorData() const {
+    return (color_data_ != nullptr);
+  }
   // Return color attribute data vector index
   [[nodiscard]] inline size_t colorIndex() const { return color_index_; }
   // Return stride of VertexData
   [[nodiscard]] inline size_t stride() const { return stride_; }
 
-  // Calculate the offset of interleaved attribute data based on VertexData index
+  // Calculate the offset of interleaved attribute data based on VertexData
+  // index
   [[nodiscard]] size_t interleavedOffset(size_t index) const {
     if (index && attributes_.size()) {
       --index;
@@ -198,13 +236,21 @@ public:
     return 0;
   }
   // Calculate the total size of the buffer in bytes
-  [[nodiscard]] size_t sizeInBytes() const { size_t size = 0; for (const auto& data : attributes_) size += data->sizeInBytes(); return size; }
+  [[nodiscard]] size_t sizeInBytes() const {
+    size_t size = 0;
+    for (const auto& data : attributes_)
+      size += data->sizeInBytes();
+    return size;
+  }
   // Calculate the total number of items in buffer
   [[nodiscard]] inline size_t size() const {
     if (stride_) {
       return sizeInBytes() / stride();
     } else {
-      size_t size = 0; for (const auto& data : attributes_) size += data->size(); return size;
+      size_t size = 0;
+      for (const auto& data : attributes_)
+        size += data->size();
+      return size;
     }
   }
   [[nodiscard]] inline bool empty() const { return attributes_.empty(); }
@@ -217,7 +263,7 @@ public:
   // If the vbo does not exist it will be created and returned.
   // void createInterleavedVBO(GLuint& vbo) const;
 
-private:
+ private:
   std::vector<std::shared_ptr<IAttributeData>> attributes_;
   size_t position_index_{0};
   std::shared_ptr<IAttributeData> position_data_;
@@ -229,13 +275,12 @@ private:
 };
 
 // Combine vertex data with vertex states. Creates VBOs.
-class VBOBuilder
-{
-public:
-  VBOBuilder(std::unique_ptr<VertexStateFactory> factory, VertexStateContainer& vertex_state_container)
-    : factory_(std::move(factory)), vertex_state_container_(vertex_state_container)
-  {
-  }
+class VBOBuilder {
+ public:
+  VBOBuilder(std::unique_ptr<VertexStateFactory> factory,
+             VertexStateContainer& vertex_state_container)
+      : factory_(std::move(factory)),
+        vertex_state_container_(vertex_state_container) {}
 
   virtual ~VBOBuilder() {
     if (Feature::ExperimentalVxORenderersIndexing.is_enabled()) {
@@ -256,7 +301,10 @@ public:
   }
 
   // Clear all data from the VertexArray
-  void clear() { for (auto& v : vertices_) v->clear(); }
+  void clear() {
+    for (auto& v : vertices_)
+      v->clear();
+  }
 
   // Create a single vertex in the VertexArray
   // The method parameters provide a common interface to pass all data
@@ -264,22 +312,33 @@ public:
   void createVertex(const std::array<Vector3d, 3>& points,
                     const std::array<Vector3d, 3>& normals,
                     const Color4f& color,
-                    size_t active_point_index = 0, size_t primitive_index = 0,
+                    size_t active_point_index = 0,
+                    size_t primitive_index = 0,
                     size_t shape_size = 0,
-                    bool outlines = false, bool mirror = false);
+                    bool outlines = false,
+                    bool mirror = false);
 
   // Return reference to the VertexStates
-  inline std::vector<std::shared_ptr<VertexState>>& states() { return vertex_state_container_.states(); }
+  inline std::vector<std::shared_ptr<VertexState>>& states() {
+    return vertex_state_container_.states();
+  }
   // Return reference to VertexData at current internal write index
   inline std::shared_ptr<VertexData> data() { return vertices_[write_index_]; }
   // Return reference to elements
   inline VertexData& elements() { return elements_; }
   // Return reference to elements data if it exists
-  inline std::shared_ptr<IAttributeData> elementsData() { return elements_.attributeData(); }
+  inline std::shared_ptr<IAttributeData> elementsData() {
+    return elements_.attributeData();
+  }
   // Return the number of VertexData in the array
   inline size_t size() const { return vertices_.size(); }
   // Calculate the total size of the buffer in bytes
-  inline size_t sizeInBytes() const { size_t size = 0; for (const auto& data : vertices_) size += data->sizeInBytes(); return size; }
+  inline size_t sizeInBytes() const {
+    size_t size = 0;
+    for (const auto& data : vertices_)
+      size += data->sizeInBytes();
+    return size;
+  }
   // Return the current internal write index
   inline size_t writeIndex() const { return write_index_; }
   // Set the internal write index to the surface index
@@ -288,7 +347,8 @@ public:
   inline void writeEdge() { write_index_ = edge_index_; }
   // Return the total stride for all buffers
   inline size_t stride() const {
-    size_t stride = 0; for (const auto& v : vertices_) {
+    size_t stride = 0;
+    for (const auto& v : vertices_) {
       stride += v->stride();
     }
     return stride;
@@ -304,9 +364,15 @@ public:
   }
 
   // Use VertexStateFactory to create a new VertexState object
-  std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset) const {
-    return factory_->createVertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset,
-                                       vertex_state_container_.verticesVBO(), vertex_state_container_.elementsVBO());
+  std::shared_ptr<VertexState> createVertexState(GLenum draw_mode,
+                                                 size_t draw_size,
+                                                 GLenum draw_type,
+                                                 size_t draw_offset,
+                                                 size_t element_offset) const {
+    return factory_->createVertexState(draw_mode, draw_size, draw_type,
+                                       draw_offset, element_offset,
+                                       vertex_state_container_.verticesVBO(),
+                                       vertex_state_container_.elementsVBO());
   }
 
   void allocateBuffers(size_t num_vertices);
@@ -314,15 +380,22 @@ public:
   // Create an interleaved VBO from the VertexData in the array.
   void createInterleavedVBOs();
 
-  // Method adds begin/end states that enable and point to the VertexData in the array
+  // Method adds begin/end states that enable and point to the VertexData in the
+  // array
   void addAttributePointers(size_t start_offset = 0);
 
-  inline GLuint verticesVBO() const { return vertex_state_container_.verticesVBO(); }
+  inline GLuint verticesVBO() const {
+    return vertex_state_container_.verticesVBO();
+  }
   inline size_t verticesOffset() const { return vertices_offset_; }
 
   // Return whether this Vertex Array uses elements (indexed rendering)
-  inline bool useElements() const { return vertex_state_container_.elementsVBO() != 0; }
-  inline GLuint elementsVBO() const { return vertex_state_container_.elementsVBO(); }
+  inline bool useElements() const {
+    return vertex_state_container_.elementsVBO() != 0;
+  }
+  inline GLuint elementsVBO() const {
+    return vertex_state_container_.elementsVBO();
+  }
   inline size_t elementsOffset() const { return elements_offset_; }
   inline void setElementsOffset(size_t offset) { elements_offset_ = offset; }
 
@@ -333,17 +406,34 @@ public:
   void addShaderData();
 
   void add_barycentric_attribute(size_t active_point_index,
-                                 size_t primitive_index, size_t shape_size, bool outlines);
-  void create_triangle(const Color4f& color, const Vector3d& p0,
-                       const Vector3d& p1, const Vector3d& p2, size_t primitive_index,
-                       size_t shape_size, bool outlines, bool enable_barycentric, bool mirror);
-  void create_surface(const PolySet& ps, const Transform3d& m,
-                      const Color4f& default_color, bool enable_barycentric, bool force_default_color = false);
-  void create_edges(const Polygon2d& polygon, const Transform3d& m, const Color4f& color);
-  void create_polygons(const PolySet& ps, const Transform3d& m, const Color4f& color);
-
-private:
-  inline void setElementsSize(size_t elements_size) { elements_size_ = elements_size; }
+                                 size_t primitive_index,
+                                 size_t shape_size,
+                                 bool outlines);
+  void create_triangle(const Color4f& color,
+                       const Vector3d& p0,
+                       const Vector3d& p1,
+                       const Vector3d& p2,
+                       size_t primitive_index,
+                       size_t shape_size,
+                       bool outlines,
+                       bool enable_barycentric,
+                       bool mirror);
+  void create_surface(const PolySet& ps,
+                      const Transform3d& m,
+                      const Color4f& default_color,
+                      bool enable_barycentric,
+                      bool force_default_color = false);
+  void create_edges(const Polygon2d& polygon,
+                    const Transform3d& m,
+                    const Color4f& color);
+  void create_polygons(const PolySet& ps,
+                       const Transform3d& m,
+                       const Color4f& color);
+
+ private:
+  inline void setElementsSize(size_t elements_size) {
+    elements_size_ = elements_size;
+  }
 
   std::unique_ptr<VertexStateFactory> factory_;
   VertexStateContainer& vertex_state_container_;
diff --git a/src/glview/VBORenderer.cc b/src/glview/VBORenderer.cc
index 36c8d8089..f5348a63a 100644
--- a/src/glview/VBORenderer.cc
+++ b/src/glview/VBORenderer.cc
@@ -25,32 +25,30 @@
  */
 
 #include "glview/VBORenderer.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
-#include "geometry/PolySet.h"
 #include "core/CSGNode.h"
-#include "utils/printutils.h"
+#include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "utils/hash.h"  // IWYU pragma: keep
+#include "utils/printutils.h"
 
-#include <cassert>
 #include <array>
+#include <cassert>
+#include <cstddef>
+#include <memory>
 #include <unordered_map>
 #include <utility>
-#include <memory>
-#include <cstddef>
 
 namespace VBOUtils {
 
-void shader_attribs_enable(const ShaderUtils::ShaderInfo& shaderinfo)
-{
+void shader_attribs_enable(const ShaderUtils::ShaderInfo& shaderinfo) {
   for (const auto& [name, location] : shaderinfo.attributes) {
     GL_TRACE("glEnableVertexAttribArray(%d)", location);
     GL_CHECKD(glEnableVertexAttribArray(location));
   }
 }
 
-void shader_attribs_disable(const ShaderUtils::ShaderInfo& shaderinfo)
-{
+void shader_attribs_disable(const ShaderUtils::ShaderInfo& shaderinfo) {
   for (const auto& [name, location] : shaderinfo.attributes) {
     GL_TRACE("glEnableVertexAttribArray(%d)", location);
     GL_CHECKD(glDisableVertexAttribArray(location));
@@ -61,11 +59,12 @@ void shader_attribs_disable(const ShaderUtils::ShaderInfo& shaderinfo)
 
 VBORenderer::VBORenderer() : Renderer() {}
 
-size_t VBORenderer::calcNumVertices(const std::shared_ptr<CSGProducts>& products,
-                                    bool unique_geometry) const
-{
+size_t VBORenderer::calcNumVertices(
+    const std::shared_ptr<CSGProducts>& products,
+    bool unique_geometry) const {
   size_t buffer_size = 0;
-  if (unique_geometry) this->geom_visit_mark_.clear();
+  if (unique_geometry)
+    this->geom_visit_mark_.clear();
 
   for (const auto& product : products->products) {
     for (const auto& csgobj : product.intersections) {
@@ -78,11 +77,13 @@ size_t VBORenderer::calcNumVertices(const std::shared_ptr<CSGProducts>& products
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumVertices(const CSGChainObject& csgobj, bool unique_geometry) const
-{
+size_t VBORenderer::calcNumVertices(const CSGChainObject& csgobj,
+                                    bool unique_geometry) const {
   size_t buffer_size = 0;
   if (unique_geometry &&
-      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(), &csgobj.leaf->matrix)]++ > 0)return 0;
+      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(),
+                                            &csgobj.leaf->matrix)]++ > 0)
+    return 0;
 
   if (csgobj.leaf->polyset) {
     buffer_size += calcNumVertices(*csgobj.leaf->polyset);
@@ -90,8 +91,7 @@ size_t VBORenderer::calcNumVertices(const CSGChainObject& csgobj, bool unique_ge
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumVertices(const PolySet& polyset) const
-{
+size_t VBORenderer::calcNumVertices(const PolySet& polyset) const {
   size_t buffer_size = 0;
   for (const auto& poly : polyset.indices) {
     if (poly.size() == 3) {
@@ -107,8 +107,7 @@ size_t VBORenderer::calcNumVertices(const PolySet& polyset) const
   return buffer_size * 3;
 }
 
-size_t VBORenderer::calcNumEdgeVertices(const PolySet& polyset) const
-{
+size_t VBORenderer::calcNumEdgeVertices(const PolySet& polyset) const {
   size_t buffer_size = 0;
   for (const auto& polygon : polyset.indices) {
     buffer_size += polygon.size();
@@ -116,8 +115,7 @@ size_t VBORenderer::calcNumEdgeVertices(const PolySet& polyset) const
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumEdgeVertices(const Polygon2d& polygon) const
-{
+size_t VBORenderer::calcNumEdgeVertices(const Polygon2d& polygon) const {
   size_t buffer_size = 0;
   // Render only outlines
   for (const Outline2d& o : polygon.outlines()) {
@@ -126,38 +124,48 @@ size_t VBORenderer::calcNumEdgeVertices(const Polygon2d& polygon) const
   return buffer_size;
 }
 
-void VBORenderer::add_shader_pointers(VBOBuilder& vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void VBORenderer::add_shader_pointers(
+    VBOBuilder& vbo_builder,
+    const ShaderUtils::ShaderInfo* shaderinfo) {
   const std::shared_ptr<VertexData> vertex_data = vbo_builder.data();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
   const auto start_offset = vbo_builder.verticesOffset();
 
   std::shared_ptr<VertexState> ss = std::make_shared<VBOShaderVertexState>(
-    vbo_builder.writeIndex(), 0, vbo_builder.verticesVBO(), vbo_builder.elementsVBO());
+      vbo_builder.writeIndex(), 0, vbo_builder.verticesVBO(),
+      vbo_builder.elementsVBO());
   GLsizei count = 0, stride = 0;
   GLenum type = 0;
   size_t offset = 0;
 
   GLuint attribute_index = shaderinfo->attributes.at("barycentric");
   if (attribute_index > 0) {
-    count =
-      vertex_data->attributes()[vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB]->count();
-    type =
-      vertex_data->attributes()[vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB]->glType();
+    count = vertex_data
+                ->attributes()[vbo_builder.shader_attributes_index_ +
+                               BARYCENTRIC_ATTRIB]
+                ->count();
+    type = vertex_data
+               ->attributes()[vbo_builder.shader_attributes_index_ +
+                              BARYCENTRIC_ATTRIB]
+               ->glType();
     stride = vertex_data->stride();
     offset = start_offset +
-      vertex_data->interleavedOffset(vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB);
-    ss->glBegin().emplace_back(
-      [attribute_index, count, type, stride, offset, ss_ptr = std::weak_ptr<VertexState>(ss)]() {
+             vertex_data->interleavedOffset(
+                 vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB);
+    ss->glBegin().emplace_back([attribute_index, count, type, stride, offset,
+                                ss_ptr = std::weak_ptr<VertexState>(ss)]() {
       auto ss = ss_ptr.lock();
       if (ss) {
         // NOLINTBEGIN(performance-no-int-to-ptr)
         GL_TRACE("glVertexAttribPointer(%d, %d, %d, GL_FALSE, %d, %p)",
-                 attribute_index % count % type % stride % (GLvoid *)(ss->drawOffset() + offset));
-        GL_CHECKD(glVertexAttribPointer(attribute_index, count, type, GL_FALSE, stride,
-                                        (GLvoid *)(ss->drawOffset() + offset)));
+                 attribute_index % count % type % stride %
+                     (GLvoid*)(ss->drawOffset() + offset));
+        GL_CHECKD(glVertexAttribPointer(attribute_index, count, type, GL_FALSE,
+                                        stride,
+                                        (GLvoid*)(ss->drawOffset() + offset)));
         // NOLINTEND(performance-no-int-to-ptr)
       }
     });
diff --git a/src/glview/VBORenderer.h b/src/glview/VBORenderer.h
index 4270383ca..86698a9cb 100644
--- a/src/glview/VBORenderer.h
+++ b/src/glview/VBORenderer.h
@@ -1,20 +1,20 @@
 #pragma once
 
 #include <array>
-#include <utility>
-#include <memory>
 #include <cstddef>
-#include "glview/Renderer.h"
-#include "geometry/linalg.h"
+#include <memory>
+#include <utility>
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
+#include "glview/Renderer.h"
 #include "glview/system-gl.h"
 #ifdef ENABLE_OPENCSG
 #include <opencsg.h>
 #endif
+#include <boost/functional/hash.hpp>
+#include <unordered_map>
 #include "core/CSGNode.h"
 #include "glview/VBOBuilder.h"
-#include <unordered_map>
-#include <boost/functional/hash.hpp>
 
 namespace VBOUtils {
 
@@ -23,32 +23,47 @@ void shader_attribs_disable(const ShaderUtils::ShaderInfo& shaderinfo);
 
 }  // namespace VBOUtils
 
-class VBOShaderVertexState : public VertexState
-{
-public:
-  VBOShaderVertexState(size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo)
-    : VertexState(0, 0, 0, draw_offset, element_offset, vertices_vbo, elements_vbo) {}
+class VBOShaderVertexState : public VertexState {
+ public:
+  VBOShaderVertexState(size_t draw_offset,
+                       size_t element_offset,
+                       GLuint vertices_vbo,
+                       GLuint elements_vbo)
+      : VertexState(0,
+                    0,
+                    0,
+                    draw_offset,
+                    element_offset,
+                    vertices_vbo,
+                    elements_vbo) {}
 };
 
-class VBORenderer : public Renderer
-{
-public:
+class VBORenderer : public Renderer {
+ public:
   VBORenderer();
-  virtual size_t calcNumVertices(const std::shared_ptr<CSGProducts>& products, bool unique_geometry = false) const;
-  virtual size_t calcNumVertices(const CSGChainObject& csgobj, bool unique_geometry = false) const;
+  virtual size_t calcNumVertices(const std::shared_ptr<CSGProducts>& products,
+                                 bool unique_geometry = false) const;
+  virtual size_t calcNumVertices(const CSGChainObject& csgobj,
+                                 bool unique_geometry = false) const;
   virtual size_t calcNumVertices(const PolySet& polyset) const;
   virtual size_t calcNumEdgeVertices(const PolySet& polyset) const;
   virtual size_t calcNumEdgeVertices(const Polygon2d& polygon) const;
 
-  void add_shader_pointers(VBOBuilder& vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo); // This could stay protected, were it not for VertexStateManager
+  void add_shader_pointers(VBOBuilder& vbo_builder,
+                           const ShaderUtils::ShaderInfo*
+                               shaderinfo);  // This could stay protected, were
+                                             // it not for VertexStateManager
 
-protected:
+ protected:
   void add_shader_data(VBOBuilder& vbo_builder);
   void shader_attribs_enable(const ShaderUtils::ShaderInfo&) const;
   void shader_attribs_disable(const ShaderUtils::ShaderInfo&) const;
 
-  mutable std::unordered_map<std::pair<const PolySet *, const Transform3d *>, int,
-                             boost::hash<std::pair<const PolySet *, const Transform3d *>>> geom_visit_mark_;
+  mutable std::unordered_map<
+      std::pair<const PolySet*, const Transform3d*>,
+      int,
+      boost::hash<std::pair<const PolySet*, const Transform3d*>>>
+      geom_visit_mark_;
 
-private:
+ private:
 };
diff --git a/src/glview/VertexState.cc b/src/glview/VertexState.cc
index 858ca9f92..6c3e6b287 100644
--- a/src/glview/VertexState.cc
+++ b/src/glview/VertexState.cc
@@ -1,7 +1,6 @@
 #include "glview/VertexState.h"
 
-void VertexState::draw() const
-{
+void VertexState::draw() const {
   if (vertices_vbo_) {
     GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertices_vbo_);
     GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertices_vbo_));
@@ -16,36 +15,40 @@ void VertexState::draw() const
   if (draw_size_ > 0) {
     if (elements_vbo_) {
       GL_TRACE("glDrawElements(%s, %d, %s, %d)",
-               (draw_mode_ == GL_POINTS ? "GL_POINTS" :
-                draw_mode_ == GL_LINES ? "GL_LINES" :
-                draw_mode_ == GL_LINE_LOOP ? "GL_LINE_LOOP" :
-                draw_mode_ == GL_LINE_STRIP ? "GL_LINE_STRIP" :
-                draw_mode_ == GL_TRIANGLES ? "GL_TRIANGLES" :
-                draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP" :
-                draw_mode_ == GL_TRIANGLE_FAN ? "GL_TRIANGLE_FAN" :
-                draw_mode_ == GL_QUADS ? "GL_QUADS" :
-                draw_mode_ == GL_QUAD_STRIP ? "GL_QUAD_STRIP" :
-                draw_mode_ == GL_POLYGON ? "GL_POLYGON" :
-                "UNKNOWN") % draw_size_ %
-               (draw_type_ == GL_UNSIGNED_BYTE ? "GL_UNSIGNED_BYTE" :
-                draw_type_ == GL_UNSIGNED_SHORT ? "GL_UNSIGNED_SHORT" :
-                draw_type_ == GL_UNSIGNED_INT ? "GL_UNSIGNED_INT" :
-                "UNKNOWN") % element_offset_);
+               (draw_mode_ == GL_POINTS           ? "GL_POINTS"
+                : draw_mode_ == GL_LINES          ? "GL_LINES"
+                : draw_mode_ == GL_LINE_LOOP      ? "GL_LINE_LOOP"
+                : draw_mode_ == GL_LINE_STRIP     ? "GL_LINE_STRIP"
+                : draw_mode_ == GL_TRIANGLES      ? "GL_TRIANGLES"
+                : draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP"
+                : draw_mode_ == GL_TRIANGLE_FAN   ? "GL_TRIANGLE_FAN"
+                : draw_mode_ == GL_QUADS          ? "GL_QUADS"
+                : draw_mode_ == GL_QUAD_STRIP     ? "GL_QUAD_STRIP"
+                : draw_mode_ == GL_POLYGON        ? "GL_POLYGON"
+                                                  : "UNKNOWN") %
+                   draw_size_ %
+                   (draw_type_ == GL_UNSIGNED_BYTE    ? "GL_UNSIGNED_BYTE"
+                    : draw_type_ == GL_UNSIGNED_SHORT ? "GL_UNSIGNED_SHORT"
+                    : draw_type_ == GL_UNSIGNED_INT   ? "GL_UNSIGNED_INT"
+                                                      : "UNKNOWN") %
+                   element_offset_);
       // NOLINTNEXTLINE(performance-no-int-to-ptr)
-      glDrawElements(draw_mode_, draw_size_, draw_type_, (GLvoid *)element_offset_);
+      glDrawElements(draw_mode_, draw_size_, draw_type_,
+                     (GLvoid*)element_offset_);
     } else {
       GL_TRACE("glDrawArrays(%s, 0, %d)",
-               (draw_mode_ == GL_POINTS ? "GL_POINTS" :
-                draw_mode_ == GL_LINES ? "GL_LINES" :
-                draw_mode_ == GL_LINE_LOOP ? "GL_LINE_LOOP" :
-                draw_mode_ == GL_LINE_STRIP ? "GL_LINE_STRIP" :
-                draw_mode_ == GL_TRIANGLES ? "GL_TRIANGLES" :
-                draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP" :
-                draw_mode_ == GL_TRIANGLE_FAN ? "GL_TRIANGLE_FAN" :
-                draw_mode_ == GL_QUADS ? "GL_QUADS" :
-                draw_mode_ == GL_QUAD_STRIP ? "GL_QUAD_STRIP" :
-                draw_mode_ == GL_POLYGON ? "GL_POLYGON" :
-                "UNKNOWN") % draw_size_);
+               (draw_mode_ == GL_POINTS           ? "GL_POINTS"
+                : draw_mode_ == GL_LINES          ? "GL_LINES"
+                : draw_mode_ == GL_LINE_LOOP      ? "GL_LINE_LOOP"
+                : draw_mode_ == GL_LINE_STRIP     ? "GL_LINE_STRIP"
+                : draw_mode_ == GL_TRIANGLES      ? "GL_TRIANGLES"
+                : draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP"
+                : draw_mode_ == GL_TRIANGLE_FAN   ? "GL_TRIANGLE_FAN"
+                : draw_mode_ == GL_QUADS          ? "GL_QUADS"
+                : draw_mode_ == GL_QUAD_STRIP     ? "GL_QUAD_STRIP"
+                : draw_mode_ == GL_POLYGON        ? "GL_POLYGON"
+                                                  : "UNKNOWN") %
+                   draw_size_);
       glDrawArrays(draw_mode_, 0, draw_size_);
     }
   }
diff --git a/src/glview/VertexState.h b/src/glview/VertexState.h
index 04549a5da..c66024e68 100644
--- a/src/glview/VertexState.h
+++ b/src/glview/VertexState.h
@@ -1,43 +1,65 @@
 #pragma once
 
-#include <utility>
-#include <memory>
 #include <cstddef>
 #include <functional>
+#include <memory>
+#include <utility>
 #include <vector>
 
-#include "glview/system-gl.h"
 #include "Feature.h"
+#include "glview/system-gl.h"
 
 #define GL_TRACE_ENABLE
 #ifdef GL_TRACE_ENABLE
 // NOLINTBEGIN(bugprone-macro-parentheses)
-#define GL_TRACE(fmt_, args) do { \
-          if (OpenSCAD::debug != "") PRINTDB("%d : " fmt_, __LINE__ % args); \
-} while (0)
+#define GL_TRACE(fmt_, args)                  \
+  do {                                        \
+    if (OpenSCAD::debug != "")                \
+      PRINTDB("%d : " fmt_, __LINE__ % args); \
+  } while (0)
 // NOLINTEND(bugprone-macro-parentheses)
-#define GL_TRACE0(fmt_) do { \
-          if (OpenSCAD::debug != "") PRINTDB("%d : " fmt_, __LINE__); \
-} while (0)
-#else // GL_TRACE_ENABLE
-#define GL_TRACE(fmt_, args) do {} while (0)
-#define GL_TRACE0(fmt_) do {} while (0)
-#endif // GL_TRACE_ENABLE
+#define GL_TRACE0(fmt_)                \
+  do {                                 \
+    if (OpenSCAD::debug != "")         \
+      PRINTDB("%d : " fmt_, __LINE__); \
+  } while (0)
+#else  // GL_TRACE_ENABLE
+#define GL_TRACE(fmt_, args) \
+  do {                       \
+  } while (0)
+#define GL_TRACE0(fmt_) \
+  do {                  \
+  } while (0)
+#endif  // GL_TRACE_ENABLE
 
 // Storage for minimum state information necessary to draw VBO.
 // This class is also used to encapsulate other state;
-// Example: VBOShaderVertexState will not render anything, but will use glBegin() to e.g. manage shader uniforms.
-class VertexState
-{
-public:
+// Example: VBOShaderVertexState will not render anything, but will use
+// glBegin() to e.g. manage shader uniforms.
+class VertexState {
+ public:
   VertexState()
-    : draw_mode_(GL_TRIANGLES), draw_size_(0), draw_type_(0), draw_offset_(0),
-    element_offset_(0), vertices_vbo_(0), elements_vbo_(0)
-  {}
-  VertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo)
-    : draw_mode_(draw_mode), draw_size_(draw_size), draw_type_(draw_type), draw_offset_(draw_offset),
-    element_offset_(element_offset), vertices_vbo_(vertices_vbo), elements_vbo_(elements_vbo)
-  {}
+      : draw_mode_(GL_TRIANGLES),
+        draw_size_(0),
+        draw_type_(0),
+        draw_offset_(0),
+        element_offset_(0),
+        vertices_vbo_(0),
+        elements_vbo_(0) {}
+  VertexState(GLenum draw_mode,
+              GLsizei draw_size,
+              GLenum draw_type,
+              size_t draw_offset,
+              size_t element_offset,
+              GLuint vertices_vbo,
+              GLuint elements_vbo)
+      : draw_mode_(draw_mode),
+        draw_size_(draw_size),
+        draw_type_(draw_type),
+        draw_offset_(draw_offset),
+        element_offset_(element_offset),
+        vertices_vbo_(vertices_vbo),
+        elements_vbo_(elements_vbo) {}
   virtual ~VertexState() = default;
 
   // Return the OpenGL mode for glDrawArrays/glDrawElements call
@@ -59,12 +81,16 @@ public:
   // Return the Element VBO offset for glDrawElements call
   [[nodiscard]] inline size_t elementOffset() const { return element_offset_; }
   // Set the Element VBO offset for glDrawElements call
-  inline void setElementOffset(size_t element_offset) { element_offset_ = element_offset; }
+  inline void setElementOffset(size_t element_offset) {
+    element_offset_ = element_offset;
+  }
 
-  // Wrap glDrawArrays/glDrawElements call and use gl_begin/gl_end state information
+  // Wrap glDrawArrays/glDrawElements call and use gl_begin/gl_end state
+  // information
   virtual void draw() const;
 
-  // Mimic VAO state functionality. Lambda functions used to hold OpenGL state calls.
+  // Mimic VAO state functionality. Lambda functions used to hold OpenGL state
+  // calls.
   inline std::vector<std::function<void()>>& glBegin() { return gl_begin_; }
   inline std::vector<std::function<void()>>& glEnd() { return gl_end_; }
 
@@ -73,7 +99,7 @@ public:
   [[nodiscard]] inline GLuint elementsVBO() const { return elements_vbo_; }
   inline void setElementsVBO(GLuint vbo) { elements_vbo_ = vbo; }
 
-private:
+ private:
   GLenum draw_mode_;
   GLsizei draw_size_;
   GLenum draw_type_;
@@ -88,21 +114,28 @@ private:
 // Allows Renderers to override VertexState objects with their own derived
 // type. VertexArray will create the appropriate type for creating
 // a VertexState object.
-class VertexStateFactory
-{
-public:
+class VertexStateFactory {
+ public:
   VertexStateFactory() = default;
   virtual ~VertexStateFactory() = default;
 
   // Create and return a VertexState object
-  [[nodiscard]] virtual std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo) const {
-    return std::make_shared<VertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] virtual std::shared_ptr<VertexState> createVertexState(
+      GLenum draw_mode,
+      size_t draw_size,
+      GLenum draw_type,
+      size_t draw_offset,
+      size_t element_offset,
+      GLuint vertices_vbo,
+      GLuint elements_vbo) const {
+    return std::make_shared<VertexState>(draw_mode, draw_size, draw_type,
+                                         draw_offset, element_offset,
+                                         vertices_vbo, elements_vbo);
   }
 };
 
-class VertexStateContainer
-{
-public:
+class VertexStateContainer {
+ public:
   VertexStateContainer() {
     GL_TRACE("glGenBuffers(1, %p)", &vertices_vbo_);
     GL_CHECKD(glGenBuffers(1, &vertices_vbo_));
@@ -135,9 +168,11 @@ public:
   GLuint elementsVBO() const { return elements_vbo_; }
 
   std::vector<std::shared_ptr<VertexState>>& states() { return vertex_states_; }
-  const std::vector<std::shared_ptr<VertexState>>& states() const { return vertex_states_; }
+  const std::vector<std::shared_ptr<VertexState>>& states() const {
+    return vertex_states_;
+  }
 
-private:
+ private:
   GLuint vertices_vbo_;
   GLuint elements_vbo_ = 0;
 
diff --git a/src/glview/cgal/CGALRenderUtils.cc b/src/glview/cgal/CGALRenderUtils.cc
index 57e9917e4..d1d7f48a7 100644
--- a/src/glview/cgal/CGALRenderUtils.cc
+++ b/src/glview/cgal/CGALRenderUtils.cc
@@ -1,19 +1,25 @@
-#include "geometry/linalg.h"
 #include "glview/cgal/CGALRenderUtils.h"
+#include "geometry/linalg.h"
 
 #include <algorithm>
 
-
 // this function resolves a 3x3 linear eqauation system
 /*
  * res[0] * v1 + res[1] *v2 + res[2] * vf3 = pt
  */
 
-bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res, double *detptr)
-{
+bool linsystem(Vector3d v1,
+               Vector3d v2,
+               Vector3d v3,
+               Vector3d pt,
+               Vector3d& res,
+               double* detptr) {
   double det, ad11, ad12, ad13, ad21, ad22, ad23, ad31, ad32, ad33;
-  det = v1[0] * (v2[1] * v3[2] - v3[1] * v2[2]) - v1[1] * (v2[0] * v3[2] - v3[0] * v2[2]) + v1[2] * (v2[0] * v3[1] - v3[0] * v2[1]);
-  if (detptr != nullptr) *detptr = det;
+  det = v1[0] * (v2[1] * v3[2] - v3[1] * v2[2]) -
+        v1[1] * (v2[0] * v3[2] - v3[0] * v2[2]) +
+        v1[2] * (v2[0] * v3[1] - v3[0] * v2[1]);
+  if (detptr != nullptr)
+    *detptr = det;
   ad11 = v2[1] * v3[2] - v3[1] * v2[2];
   ad12 = v3[0] * v2[2] - v2[0] * v3[2];
   ad13 = v2[0] * v3[1] - v3[0] * v2[1];
@@ -24,7 +30,8 @@ bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res
   ad32 = v2[0] * v1[2] - v1[0] * v2[2];
   ad33 = v1[0] * v2[1] - v2[0] * v1[1];
 
-  if (fabs(det) < 0.00001)return true;
+  if (fabs(det) < 0.00001)
+    return true;
 
   res[0] = (ad11 * pt[0] + ad12 * pt[1] + ad13 * pt[2]) / det;
   res[1] = (ad21 * pt[0] + ad22 * pt[1] + ad23 * pt[2]) / det;
@@ -32,7 +39,10 @@ bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res
   return false;
 }
 
-double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat) {
+double calculateLinePointDistance(const Vector3d& l1,
+                                  const Vector3d& l2,
+                                  const Vector3d& pt,
+                                  double& dist_lat) {
   Vector3d d = (l2 - l1);
   double l = d.norm();
   d.normalize();
@@ -40,8 +50,11 @@ double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const
   return (l1 + d * dist_lat - pt).norm();
 }
 
-double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat)
-{
+double calculateLineLineDistance(const Vector3d& l1b,
+                                 const Vector3d& l1e,
+                                 const Vector3d& l2b,
+                                 const Vector3d& l2e,
+                                 double& dist_lat) {
   double d;
   Vector3d v1 = l1e - l1b;
   Vector3d v2 = l2e - l2b;
@@ -56,8 +69,11 @@ double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const
   return d;
 }
 
-double calculateSegSegDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat)
-{
+double calculateSegSegDistance(const Vector3d& l1b,
+                               const Vector3d& l1e,
+                               const Vector3d& l2b,
+                               const Vector3d& l2e,
+                               double& dist_lat) {
   double d;
   Vector3d v1 = l1e - l1b;
   Vector3d v2 = l2e - l2b;
@@ -66,7 +82,8 @@ double calculateSegSegDistance(const Vector3d& l1b, const Vector3d& l1e, const V
   if (n.norm() < 1e-6) {
     return calculateLinePointDistance(l1b, l1e, l2b, d);
   }
-  if (linsystem(v1, n, v2, l2e - l1b, res, nullptr))return NAN;
+  if (linsystem(v1, n, v2, l2e - l1b, res, nullptr))
+    return NAN;
   double d1 = std::clamp(res[0], 0.0, 1.0);
   double d2 = std::clamp(res[2], 0.0, 1.0);
   Vector3d dist = (l2e - v2 * d2) - (l1b + v1 * d1);
diff --git a/src/glview/cgal/CGALRenderUtils.h b/src/glview/cgal/CGALRenderUtils.h
index fa651143d..6b9b9a784 100644
--- a/src/glview/cgal/CGALRenderUtils.h
+++ b/src/glview/cgal/CGALRenderUtils.h
@@ -2,5 +2,12 @@
 
 #include "geometry/linalg.h"
 
-double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat);
-double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
+double calculateLinePointDistance(const Vector3d& l1,
+                                  const Vector3d& l2,
+                                  const Vector3d& pt,
+                                  double& dist_lat);
+double calculateLineLineDistance(const Vector3d& l1b,
+                                 const Vector3d& l1e,
+                                 const Vector3d& l2b,
+                                 const Vector3d& l2e,
+                                 double& dist_lat);
diff --git a/src/glview/cgal/CGALRenderer.cc b/src/glview/cgal/CGALRenderer.cc
index 1c169d878..55ea09911 100644
--- a/src/glview/cgal/CGALRenderer.cc
+++ b/src/glview/cgal/CGALRenderer.cc
@@ -27,9 +27,9 @@
 #include "glview/cgal/CGALRenderer.h"
 
 #include <cassert>
-#include <utility>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <utility>
 #include <vector>
 
 #ifdef _MSC_VER
@@ -37,17 +37,17 @@
 #include <mpfr.h>
 #endif
 
-#include "geometry/cgal/cgal.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/linalg.h"
 #include "glview/ColorMap.h"
 #include "glview/Renderer.h"
 #include "glview/ShaderUtils.h"
-#include "glview/system-gl.h"
 #include "glview/VBOBuilder.h"
 #include "glview/VertexState.h"
+#include "glview/system-gl.h"
 #include "utils/printutils.h"
 
 #ifdef ENABLE_CGAL
@@ -59,18 +59,18 @@
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
-
 CGALRenderer::CGALRenderer(const std::shared_ptr<const class Geometry>& geom) {
   this->addGeometry(geom);
   PRINTD("CGALRenderer::CGALRenderer() -> createPolyhedrons()");
 #ifdef ENABLE_CGAL
-  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())createPolyhedrons();
+  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())
+    createPolyhedrons();
 #endif
 }
 
 void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
   if (const auto geomlist =
-        std::dynamic_pointer_cast<const GeometryList>(geom)) {
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     for (const auto& item : geomlist->getChildren()) {
       this->addGeometry(item.second);
     }
@@ -81,12 +81,12 @@ void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
     // tests/data/scad/3D/features/polyhedron-concave-test.scad
     this->polysets_.push_back(PolySetUtils::tessellate_faces(*ps));
   } else if (const auto poly =
-               std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     this->polygons_.emplace_back(
-      poly, std::shared_ptr<const PolySet>(poly->tessellate()));
+        poly, std::shared_ptr<const PolySet>(poly->tessellate()));
 #ifdef ENABLE_CGAL
   } else if (const auto new_N =
-               std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     assert(new_N->getDimension() == 3);
     if (!new_N->isEmpty()) {
       this->nefPolyhedrons_.push_back(new_N);
@@ -94,7 +94,7 @@ void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
 #endif
 #ifdef ENABLE_MANIFOLD
   } else if (const auto mani =
-               std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     this->polysets_.push_back(mani->toPolySet());
 #endif
   } else {
@@ -102,8 +102,7 @@ void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
   }
 }
 
-CGALRenderer::~CGALRenderer() {
-}
+CGALRenderer::~CGALRenderer() {}
 
 #ifdef ENABLE_CGAL
 void CGALRenderer::createPolyhedrons() {
@@ -112,7 +111,7 @@ void CGALRenderer::createPolyhedrons() {
   for (const auto& N : this->nefPolyhedrons_) {
     auto p = std::make_shared<VBOPolyhedron>(*colorscheme_);
     CGAL::OGL::Nef3_Converter<CGAL_Nef_polyhedron3>::convert_to_OGLPolyhedron(
-      *N->p3, p.get());
+        *N->p3, p.get());
     // CGAL_NEF3_MARKED_FACET_COLOR <- CGAL_FACE_BACK_COLOR
     // CGAL_NEF3_UNMARKED_FACET_COLOR <- CGAL_FACE_FRONT_COLOR
     p->init();
@@ -120,31 +119,33 @@ void CGALRenderer::createPolyhedrons() {
   }
   PRINTD("createPolyhedrons() end");
 }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
 
 // Overridden from Renderer
 void CGALRenderer::setColorScheme(const ColorScheme& cs) {
   PRINTD("setColorScheme");
   Renderer::setColorScheme(cs);
   colormap_[ColorMode::CGAL_FACE_2D_COLOR] =
-    ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
+      ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
   colormap_[ColorMode::CGAL_EDGE_2D_COLOR] =
-    ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
+      ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
 #ifdef ENABLE_CGAL
-  this->polyhedrons_.clear(); // Mark as dirty
+  this->polyhedrons_.clear();  // Mark as dirty
 #endif
-  vertex_state_containers_.clear(); // Mark as dirty
+  vertex_state_containers_.clear();  // Mark as dirty
   PRINTD("setColorScheme done");
 }
 
 void CGALRenderer::createPolySetStates() {
   PRINTD("createPolySetStates() polyset");
 
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
+  VertexStateContainer& vertex_state_container =
+      vertex_state_containers_.emplace_back();
 
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
 
-  vbo_builder.addSurfaceData(); // position, normal, color
+  vbo_builder.addSurfaceData();  // position, normal, color
 
   size_t num_vertices = 0;
   for (const auto& polyset : this->polysets_) {
@@ -168,12 +169,14 @@ void CGALRenderer::createPolygonStates() {
 }
 
 void CGALRenderer::createPolygonSurfaceStates() {
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer& vertex_state_container =
+      vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
   vbo_builder.addSurfaceData();
 
   size_t num_vertices = 0;
-  for (const auto&[_, polyset] : this->polygons_) {
+  for (const auto& [_, polyset] : this->polygons_) {
     num_vertices += calcNumVertices(*polyset);
   }
 
@@ -186,7 +189,7 @@ void CGALRenderer::createPolygonSurfaceStates() {
   });
   vertex_state_container.states().emplace_back(std::move(init_state));
 
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto& [polygon, polyset] : this->polygons_) {
     Color4f color;
     getColorSchemeColor(ColorMode::CGAL_FACE_2D_COLOR, color);
     vbo_builder.create_polygons(*polyset, Transform3d::Identity(), color);
@@ -198,13 +201,15 @@ void CGALRenderer::createPolygonSurfaceStates() {
 void CGALRenderer::createPolygonEdgeStates() {
   PRINTD("createPolygonStates()");
 
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer& vertex_state_container =
+      vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
 
   vbo_builder.addEdgeData();
 
   size_t num_vertices = 0;
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto& [polygon, _] : this->polygons_) {
     num_vertices += calcNumEdgeVertices(*polygon);
   }
 
@@ -219,7 +224,7 @@ void CGALRenderer::createPolygonEdgeStates() {
   });
   vertex_state_container.states().emplace_back(std::move(edge_state));
 
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto& [polygon, _] : this->polygons_) {
     Color4f color;
     getColorSchemeColor(ColorMode::CGAL_EDGE_2D_COLOR, color);
     vbo_builder.writeEdge();
@@ -236,11 +241,12 @@ void CGALRenderer::createPolygonEdgeStates() {
   vbo_builder.createInterleavedVBOs();
 }
 
-void CGALRenderer::prepare(const ShaderUtils::ShaderInfo * /*shaderinfo*/) {
+void CGALRenderer::prepare(const ShaderUtils::ShaderInfo* /*shaderinfo*/) {
   PRINTD("prepare()");
   if (!vertex_state_containers_.size()) {
     if (!this->polysets_.empty() && !this->polygons_.empty()) {
-      LOG(message_group::Error, "CGALRenderer::prepare() called with both polysets and polygons");
+      LOG(message_group::Error,
+          "CGALRenderer::prepare() called with both polysets and polygons");
     } else if (!this->polysets_.empty()) {
       createPolySetStates();
     } else if (!this->polygons_.empty()) {
@@ -249,15 +255,17 @@ void CGALRenderer::prepare(const ShaderUtils::ShaderInfo * /*shaderinfo*/) {
   }
 
 #ifdef ENABLE_CGAL
-  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())createPolyhedrons();
+  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())
+    createPolyhedrons();
 #endif
 
   PRINTD("prepare() end");
 }
 
-void CGALRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo * /*shaderinfo*/) const {
+void CGALRenderer::draw(bool showedges,
+                        const ShaderUtils::ShaderInfo* /*shaderinfo*/) const {
   PRINTD("draw()");
-// grab current state to restore after
+  // grab current state to restore after
   GLfloat current_point_size, current_line_width;
   const GLboolean origVertexArrayState = glIsEnabled(GL_VERTEX_ARRAY);
   const GLboolean origNormalArrayState = glIsEnabled(GL_NORMAL_ARRAY);
@@ -268,7 +276,8 @@ void CGALRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo * /*shader
 
   for (const auto& container : vertex_state_containers_) {
     for (const auto& vertex_state : container.states()) {
-      if (vertex_state)vertex_state->draw();
+      if (vertex_state)
+        vertex_state->draw();
     }
   }
 
@@ -278,9 +287,12 @@ void CGALRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo * /*shader
   GL_TRACE("glLineWidth(%d)", current_line_width);
   GL_CHECKD(glLineWidth(current_line_width));
 
-  if (!origVertexArrayState)glDisableClientState(GL_VERTEX_ARRAY);
-  if (!origNormalArrayState)glDisableClientState(GL_NORMAL_ARRAY);
-  if (!origColorArrayState)glDisableClientState(GL_COLOR_ARRAY);
+  if (!origVertexArrayState)
+    glDisableClientState(GL_VERTEX_ARRAY);
+  if (!origNormalArrayState)
+    glDisableClientState(GL_NORMAL_ARRAY);
+  if (!origColorArrayState)
+    glDisableClientState(GL_COLOR_ARRAY);
 
 #ifdef ENABLE_CGAL
   for (const auto& p : this->getPolyhedrons()) {
@@ -298,16 +310,15 @@ BoundingBox CGALRenderer::getBoundingBox() const {
   for (const auto& p : this->getPolyhedrons()) {
     const CGAL::Bbox_3 cgalbbox = p->bbox();
     bbox.extend(BoundingBox(
-                  Vector3d(cgalbbox.xmin(), cgalbbox.ymin(), cgalbbox.zmin()),
-                  Vector3d(cgalbbox.xmax(), cgalbbox.ymax(), cgalbbox.zmax())));
+        Vector3d(cgalbbox.xmin(), cgalbbox.ymin(), cgalbbox.zmin()),
+        Vector3d(cgalbbox.xmax(), cgalbbox.ymax(), cgalbbox.zmax())));
   }
 #endif
   for (const auto& ps : this->polysets_) {
     bbox.extend(ps->getBoundingBox());
   }
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto& [polygon, polyset] : this->polygons_) {
     bbox.extend(polygon->getBoundingBox());
   }
   return bbox;
 }
-
diff --git a/src/glview/cgal/CGALRenderer.h b/src/glview/cgal/CGALRenderer.h
index c7afea62d..154036b93 100644
--- a/src/glview/cgal/CGALRenderer.h
+++ b/src/glview/cgal/CGALRenderer.h
@@ -1,46 +1,52 @@
 #pragma once
 
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 
-#include "glview/VBORenderer.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
-#include "glview/ShaderUtils.h"
+#include "geometry/linalg.h"
 #include "glview/ColorMap.h"
+#include "glview/ShaderUtils.h"
+#include "glview/VBORenderer.h"
 #include "glview/VertexState.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALNefGeometry.h"
 #endif
 
-class CGALRenderer : public VBORenderer
-{
-public:
+class CGALRenderer : public VBORenderer {
+ public:
   CGALRenderer(const std::shared_ptr<const class Geometry>& geom);
   ~CGALRenderer() override;
-  void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  void prepare(const ShaderUtils::ShaderInfo* shaderinfo = nullptr) override;
+  void draw(bool showedges,
+            const ShaderUtils::ShaderInfo* shaderinfo = nullptr) const override;
   void setColorScheme(const ColorScheme& cs) override;
   BoundingBox getBoundingBox() const override;
 
-private:
+ private:
   void addGeometry(const std::shared_ptr<const class Geometry>& geom);
 #ifdef ENABLE_CGAL
-  const std::vector<std::shared_ptr<class VBOPolyhedron>>& getPolyhedrons() const { return this->polyhedrons_; }
+  const std::vector<std::shared_ptr<class VBOPolyhedron>>& getPolyhedrons()
+      const {
+    return this->polyhedrons_;
+  }
   void createPolyhedrons();
 #endif
 
-  // FIXME: PolySet and Polygon2d features are only needed for the lazy-union feature,
-  // when a GeometryList may contain a mixture of CGAL and Polygon2d/PolySet geometries.
+  // FIXME: PolySet and Polygon2d features are only needed for the lazy-union
+  // feature, when a GeometryList may contain a mixture of CGAL and
+  // Polygon2d/PolySet geometries.
   void createPolySetStates();
   void createPolygonStates();
   void createPolygonSurfaceStates();
   void createPolygonEdgeStates();
 
   std::vector<std::shared_ptr<const class PolySet>> polysets_;
-  std::vector<std::pair<std::shared_ptr<const Polygon2d>, std::shared_ptr<const PolySet>>> polygons_;
+  std::vector<std::pair<std::shared_ptr<const Polygon2d>,
+                        std::shared_ptr<const PolySet>>>
+      polygons_;
 #ifdef ENABLE_CGAL
   std::vector<std::shared_ptr<class VBOPolyhedron>> polyhedrons_;
   std::vector<std::shared_ptr<const CGALNefGeometry>> nefPolyhedrons_;
diff --git a/src/glview/cgal/VBOPolyhedron.h b/src/glview/cgal/VBOPolyhedron.h
index aecab992f..bdf332cbb 100644
--- a/src/glview/cgal/VBOPolyhedron.h
+++ b/src/glview/cgal/VBOPolyhedron.h
@@ -27,24 +27,22 @@
 #pragma once
 
 #include <cassert>
-#include <utility>
-#include <memory>
 #include <cstdlib>
+#include <memory>
+#include <utility>
 #include <vector>
 
 #include <CGAL/IO/Color.h>
 
 #include "CGAL/OGL_helper.h"
 #include "glview/ColorMap.h"
+#include "glview/VBOBuilder.h"
 #include "glview/VertexState.h"
 #include "glview/system-gl.h"
-#include "glview/VBOBuilder.h"
-#include "glview/ColorMap.h"
 #include "utils/printutils.h"
 
-class VBOPolyhedron : public CGAL::OGL::Polyhedron
-{
-public:
+class VBOPolyhedron : public CGAL::OGL::Polyhedron {
+ public:
   enum CGALColorIndex {
     MARKED_VERTEX_COLOR = 0,
     MARKED_EDGE_COLOR,
@@ -59,10 +57,14 @@ public:
     // Set default colors.
     setColor(CGALColorIndex::MARKED_VERTEX_COLOR, {0xb7, 0xe8, 0x5c});
     setColor(CGALColorIndex::UNMARKED_VERTEX_COLOR, {0xff, 0xf6, 0x7c});
-    setColor(CGALColorIndex::MARKED_FACET_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_FACE_BACK_COLOR));
-    setColor(CGALColorIndex::UNMARKED_FACET_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_FACE_FRONT_COLOR));
-    setColor(CGALColorIndex::MARKED_EDGE_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR));
-    setColor(CGALColorIndex::UNMARKED_EDGE_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR));
+    setColor(CGALColorIndex::MARKED_FACET_COLOR,
+             ColorMap::getColor(cs, RenderColor::CGAL_FACE_BACK_COLOR));
+    setColor(CGALColorIndex::UNMARKED_FACET_COLOR,
+             ColorMap::getColor(cs, RenderColor::CGAL_FACE_FRONT_COLOR));
+    setColor(CGALColorIndex::MARKED_EDGE_COLOR,
+             ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR));
+    setColor(CGALColorIndex::UNMARKED_EDGE_COLOR,
+             ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR));
   }
 
   ~VBOPolyhedron() override = default;
@@ -71,10 +73,8 @@ public:
     PRINTD("draw(Vertex_iterator)");
 
     CGAL::Color c = getVertexColor(v);
-    vbo_builder.createVertex({Vector3d(v->x(), v->y(), v->z())},
-                             {},
-                             Color4f(c.red(), c.green(), c.blue()),
-                             0, 0, 1);
+    vbo_builder.createVertex({Vector3d(v->x(), v->y(), v->z())}, {},
+                             Color4f(c.red(), c.green(), c.blue()), 0, 0, 1);
   }
 
   void draw(Edge_iterator e, VBOBuilder& vbo_builder) const {
@@ -84,19 +84,15 @@ public:
     const CGAL::Color c = getEdgeColor(e);
     const Color4f color(c.red(), c.green(), c.blue());
 
-    vbo_builder.createVertex({Vector3d(p.x(), p.y(), p.z())},
-                             {},
-                             color,
-                             0, 0, true);
-    vbo_builder.createVertex({Vector3d(q.x(), q.y(), q.z())},
-                             {},
-                             color,
-                             0, 1, true);
+    vbo_builder.createVertex({Vector3d(p.x(), p.y(), p.z())}, {}, color, 0, 0,
+                             true);
+    vbo_builder.createVertex({Vector3d(q.x(), q.y(), q.z())}, {}, color, 0, 1,
+                             true);
   }
 
   struct TessUserData {
     GLenum which;
-    GLdouble *normal;
+    GLdouble* normal;
     CGAL::Color color;
     size_t primitive_index;
     size_t active_point_index;
@@ -106,8 +102,9 @@ public:
     VBOBuilder& vbo_builder;
   };
 
-  static inline void CGAL_GLU_TESS_CALLBACK beginCallback(GLenum which, GLvoid *user) {
-    auto *tess(static_cast<TessUserData *>(user));
+  static inline void CGAL_GLU_TESS_CALLBACK beginCallback(GLenum which,
+                                                          GLvoid* user) {
+    auto* tess(static_cast<TessUserData*>(user));
     // Create separate vertex set since "which" could be different draw type
     tess->which = which;
     tess->draw_size = 0;
@@ -117,60 +114,65 @@ public:
     if (tess->vbo_builder.useElements()) {
       tess->elements_offset = tess->vbo_builder.elements().sizeInBytes();
       // this can vary size if polyset provides triangles
-      tess->vbo_builder.addElementsData(std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
+      tess->vbo_builder.addElementsData(
+          std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
       tess->vbo_builder.elementsMap().clear();
     }
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK endCallback(GLvoid *user) {
-    auto *tess(static_cast<TessUserData *>(user));
+  static inline void CGAL_GLU_TESS_CALLBACK endCallback(GLvoid* user) {
+    auto* tess(static_cast<TessUserData*>(user));
 
     GLenum elements_type = 0;
-    if (tess->vbo_builder.useElements()) elements_type = tess->vbo_builder.elementsData()->glType();
+    if (tess->vbo_builder.useElements())
+      elements_type = tess->vbo_builder.elementsData()->glType();
     std::shared_ptr<VertexState> vs = tess->vbo_builder.createVertexState(
-      tess->which, tess->draw_size, elements_type,
-      tess->vbo_builder.writeIndex(), tess->elements_offset);
+        tess->which, tess->draw_size, elements_type,
+        tess->vbo_builder.writeIndex(), tess->elements_offset);
     tess->vbo_builder.states().emplace_back(std::move(vs));
     tess->vbo_builder.addAttributePointers(tess->last_size);
     tess->primitive_index++;
   }
 
   static inline void CGAL_GLU_TESS_CALLBACK errorCallback(GLenum errorCode) {
-    const GLubyte *estring;
+    const GLubyte* estring;
     estring = gluErrorString(errorCode);
     fprintf(stderr, "Tessellation Error: %s\n", estring);
     std::exit(0);
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK vertexCallback(GLvoid *vertex_arg, GLvoid *user_arg) {
-    auto *vertex(static_cast<GLdouble *>(vertex_arg));
-    auto *tess(static_cast<TessUserData *>(user_arg));
+  static inline void CGAL_GLU_TESS_CALLBACK vertexCallback(GLvoid* vertex_arg,
+                                                           GLvoid* user_arg) {
+    auto* vertex(static_cast<GLdouble*>(vertex_arg));
+    auto* tess(static_cast<TessUserData*>(user_arg));
     size_t shape_size = 0;
 
     switch (tess->which) {
-    case GL_TRIANGLES:
-    case GL_TRIANGLE_FAN:
-    case GL_TRIANGLE_STRIP:
-      shape_size = 3;
-      break;
-    case GL_POINTS:
-      shape_size = 1;
-      break;
-    default:
-      assert(false && "Unsupported primitive type");
-      break;
+      case GL_TRIANGLES:
+      case GL_TRIANGLE_FAN:
+      case GL_TRIANGLE_STRIP:
+        shape_size = 3;
+        break;
+      case GL_POINTS:
+        shape_size = 1;
+        break;
+      default:
+        assert(false && "Unsupported primitive type");
+        break;
     }
 
-
-    tess->vbo_builder.createVertex({Vector3d(vertex)},
-                                   {Vector3d(tess->normal)},
-                                   Color4f(tess->color.red(), tess->color.green(), tess->color.blue()),
-                                   0, 0, shape_size);
+    tess->vbo_builder.createVertex(
+        {Vector3d(vertex)}, {Vector3d(tess->normal)},
+        Color4f(tess->color.red(), tess->color.green(), tess->color.blue()), 0,
+        0, shape_size);
     tess->draw_size++;
     tess->active_point_index++;
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK combineCallback(GLdouble coords[3], GLvoid *[4], GLfloat [4], GLvoid **dataOut) {
+  static inline void CGAL_GLU_TESS_CALLBACK combineCallback(GLdouble coords[3],
+                                                            GLvoid* [4],
+                                                            GLfloat[4],
+                                                            GLvoid** dataOut) {
     static std::vector<std::unique_ptr<Vector3d>> vertexCache;
     if (dataOut) {
       vertexCache.push_back(std::make_unique<Vector3d>(coords));
@@ -183,33 +185,35 @@ public:
   void draw(Halffacet_iterator f, VBOBuilder& vbo_builder) const {
     PRINTD("draw(Halffacet_iterator)");
 
-    GLUtesselator *tess_ = gluNewTess();
-    gluTessCallback(tess_, GLenum(GLU_TESS_VERTEX_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & vertexCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_COMBINE),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & combineCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_BEGIN_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & beginCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_END_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & endCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_ERROR),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & errorCallback);
+    GLUtesselator* tess_ = gluNewTess();
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_VERTEX_DATA),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK*)(CGAL_GLU_TESS_DOTS))&vertexCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_COMBINE),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK*)(CGAL_GLU_TESS_DOTS))&combineCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_BEGIN_DATA),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK*)(CGAL_GLU_TESS_DOTS))&beginCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_END_DATA),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK*)(CGAL_GLU_TESS_DOTS))&endCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_ERROR),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK*)(CGAL_GLU_TESS_DOTS))&errorCallback);
     gluTessProperty(tess_, GLenum(GLU_TESS_WINDING_RULE),
                     GLU_TESS_WINDING_POSITIVE);
 
     CGAL::OGL::DFacet::Coord_const_iterator cit;
-    TessUserData tess_data = {
-      0, f->normal(), getFacetColor(f),
-      0, 0, 0, 0, 0, vbo_builder
-    };
+    TessUserData tess_data = {0, f->normal(), getFacetColor(f), 0, 0, 0,
+                              0, 0,           vbo_builder};
 
     gluTessBeginPolygon(tess_, &tess_data);
     // forall facet cycles of f:
     for (unsigned i = 0; i < f->number_of_facet_cycles(); ++i) {
       gluTessBeginContour(tess_);
       // put all vertices in facet cycle into contour:
-      for (cit = f->facet_cycle_begin(i);
-           cit != f->facet_cycle_end(i); ++cit) {
+      for (cit = f->facet_cycle_begin(i); cit != f->facet_cycle_end(i); ++cit) {
         gluTessVertex(tess_, *cit, *cit);
       }
       gluTessEndContour(tess_);
@@ -224,14 +228,16 @@ public:
 
     points_edges_container_ = std::make_unique<VertexStateContainer>();
 
-    VBOBuilder points_edges_builder(std::make_unique<VertexStateFactory>(), *points_edges_container_.get());
+    VBOBuilder points_edges_builder(std::make_unique<VertexStateFactory>(),
+                                    *points_edges_container_.get());
 
     points_edges_builder.addEdgeData();
     points_edges_builder.writeEdge();
     size_t last_size = 0;
     size_t elements_offset = 0;
 
-    const size_t num_vertices = vertices_.size() + edges_.size() * 2, elements_size = 0;
+    const size_t num_vertices = vertices_.size() + edges_.size() * 2,
+                 elements_size = 0;
     points_edges_builder.allocateBuffers(num_vertices);
 
     // Points
@@ -256,10 +262,11 @@ public:
       draw(v, points_edges_builder);
 
     GLenum elements_type = 0;
-    if (points_edges_builder.useElements()) elements_type = points_edges_builder.elementsData()->glType();
+    if (points_edges_builder.useElements())
+      elements_type = points_edges_builder.elementsData()->glType();
     std::shared_ptr<VertexState> vs = points_edges_builder.createVertexState(
-      GL_POINTS, vertices_.size(), elements_type,
-      points_edges_builder.writeIndex(), elements_offset);
+        GL_POINTS, vertices_.size(), elements_type,
+        points_edges_builder.writeIndex(), elements_offset);
     points_edges_container_->states().emplace_back(std::move(vs));
     points_edges_builder.addAttributePointers(last_size);
 
@@ -286,12 +293,12 @@ public:
     for (e = edges_.begin(); e != edges_.end(); ++e)
       draw(e, points_edges_builder);
 
-
     elements_type = 0;
-    if (points_edges_builder.useElements()) elements_type = points_edges_builder.elementsData()->glType();
+    if (points_edges_builder.useElements())
+      elements_type = points_edges_builder.elementsData()->glType();
     vs = points_edges_builder.createVertexState(
-      GL_LINES, edges_.size() * 2, elements_type,
-      points_edges_builder.writeIndex(), elements_offset);
+        GL_LINES, edges_.size() * 2, elements_type,
+        points_edges_builder.writeIndex(), elements_offset);
     points_edges_container_->states().emplace_back(std::move(vs));
     points_edges_builder.addAttributePointers(last_size);
 
@@ -300,8 +307,11 @@ public:
     // Halffacets
     halffacets_container_ = std::make_unique<VertexStateContainer>();
 
-    // FIXME: We don't know the size of this VertexArray in advanced, so we have to deal with some fallback mechanism for filling in the data. This complicates code quite a bit
-    VBOBuilder halffacets_builder(std::make_unique<VertexStateFactory>(), *halffacets_container_.get());
+    // FIXME: We don't know the size of this VertexArray in advanced, so we have
+    // to deal with some fallback mechanism for filling in the data. This
+    // complicates code quite a bit
+    VBOBuilder halffacets_builder(std::make_unique<VertexStateFactory>(),
+                                  *halffacets_container_.get());
     halffacets_builder.addSurfaceData();
     halffacets_builder.writeSurface();
 
@@ -347,12 +357,14 @@ public:
     GL_CHECKD(glGetFloatv(GL_LINE_WIDTH, &current_line_width));
 
     for (const auto& halffacet : halffacets_container_->states()) {
-      if (halffacet) halffacet->draw();
+      if (halffacet)
+        halffacet->draw();
     }
 
     if (showedges) {
       for (const auto& point_edge : points_edges_container_->states()) {
-        if (point_edge) point_edge->draw();
+        if (point_edge)
+          point_edge->draw();
       }
     }
 
@@ -362,43 +374,50 @@ public:
     GL_TRACE("glLineWidth(%d)", current_line_width);
     GL_CHECKD(glLineWidth(current_line_width));
 
-    if (!origVertexArrayState) glDisableClientState(GL_VERTEX_ARRAY);
-    if (!origNormalArrayState) glDisableClientState(GL_NORMAL_ARRAY);
-    if (!origColorArrayState) glDisableClientState(GL_COLOR_ARRAY);
+    if (!origVertexArrayState)
+      glDisableClientState(GL_VERTEX_ARRAY);
+    if (!origNormalArrayState)
+      glDisableClientState(GL_NORMAL_ARRAY);
+    if (!origColorArrayState)
+      glDisableClientState(GL_COLOR_ARRAY);
 
     PRINTD("VBO draw() end");
   }
 
-
   // overrides function in OGL_helper.h
   [[nodiscard]] CGAL::Color getVertexColor(Vertex_iterator v) const override {
     PRINTD("getVertexColor");
-    CGAL::Color c = v->mark() ? colors[CGALColorIndex::UNMARKED_VERTEX_COLOR] : colors[CGALColorIndex::MARKED_VERTEX_COLOR];
+    CGAL::Color c = v->mark() ? colors[CGALColorIndex::UNMARKED_VERTEX_COLOR]
+                              : colors[CGALColorIndex::MARKED_VERTEX_COLOR];
     return c;
   }
 
   // overrides function in OGL_helper.h
   [[nodiscard]] CGAL::Color getEdgeColor(Edge_iterator e) const override {
     PRINTD("getEdgeColor");
-    CGAL::Color c = e->mark() ? colors[CGALColorIndex::UNMARKED_EDGE_COLOR] : colors[CGALColorIndex::MARKED_EDGE_COLOR];
+    CGAL::Color c = e->mark() ? colors[CGALColorIndex::UNMARKED_EDGE_COLOR]
+                              : colors[CGALColorIndex::MARKED_EDGE_COLOR];
     return c;
   }
 
   // overrides function in OGL_helper.h
   [[nodiscard]] CGAL::Color getFacetColor(Halffacet_iterator f) const override {
-    CGAL::Color c = f->mark() ? colors[CGALColorIndex::UNMARKED_FACET_COLOR] : colors[CGALColorIndex::MARKED_FACET_COLOR];
+    CGAL::Color c = f->mark() ? colors[CGALColorIndex::UNMARKED_FACET_COLOR]
+                              : colors[CGALColorIndex::MARKED_FACET_COLOR];
     return c;
   }
 
   void setColor(CGALColorIndex color_index, const Color4f& c) {
-    // Note: Not setting alpha here as none of our built-in colors currently have an alpha component
-    // This _may_ yield unexpected results for user-defined colors with alpha components.
+    // Note: Not setting alpha here as none of our built-in colors currently
+    // have an alpha component This _may_ yield unexpected results for
+    // user-defined colors with alpha components.
     PRINTDB("setColor %i %f %f %f", color_index % c.r() % c.g() % c.b());
-    this->colors[color_index] = CGAL::Color(c.r() * 255, c.g() * 255, c.b() * 255);
+    this->colors[color_index] =
+        CGAL::Color(c.r() * 255, c.g() * 255, c.b() * 255);
   }
 
-protected:
+ protected:
   CGAL::Color colors[CGALColorIndex::NUM_COLORS];
   std::unique_ptr<VertexStateContainer> points_edges_container_;
   std::unique_ptr<VertexStateContainer> halffacets_container_;
-}; // Polyhedron
+};  // Polyhedron
diff --git a/src/glview/fbo.cc b/src/glview/fbo.cc
index 08c6bc309..251a896dc 100644
--- a/src/glview/fbo.cc
+++ b/src/glview/fbo.cc
@@ -10,37 +10,37 @@ namespace {
 bool checkFBOStatus() {
   const auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
 
-  const char *statusString = nullptr;
+  const char* statusString = nullptr;
   switch (status) {
-  case GL_FRAMEBUFFER_COMPLETE:
-    return true;
-    break;
-  case GL_FRAMEBUFFER_UNDEFINED:
-    statusString = "GL_FRAMEBUFFER_UNDEFINED";
-    break;
-  case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
-    statusString = "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
-    break;
-  case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
-    statusString = "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
-    break;
-  case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
-    statusString = "GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER";
-    break;
-  case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
-    statusString = "GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER";
-    break;
-  case GL_FRAMEBUFFER_UNSUPPORTED:
-    statusString = "GL_FRAMEBUFFER_UNSUPPORTED";
-    break;
-  case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
-    statusString = "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
-    break;
-  case GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:
-    statusString = "GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS";
-    break;
-  default:
-    break;
+    case GL_FRAMEBUFFER_COMPLETE:
+      return true;
+      break;
+    case GL_FRAMEBUFFER_UNDEFINED:
+      statusString = "GL_FRAMEBUFFER_UNDEFINED";
+      break;
+    case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
+      statusString = "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
+      break;
+    case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
+      statusString = "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
+      break;
+    case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
+      statusString = "GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER";
+      break;
+    case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
+      statusString = "GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER";
+      break;
+    case GL_FRAMEBUFFER_UNSUPPORTED:
+      statusString = "GL_FRAMEBUFFER_UNSUPPORTED";
+      break;
+    case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
+      statusString = "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
+      break;
+    case GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:
+      statusString = "GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS";
+      break;
+    default:
+      break;
   }
 
   LOG(message_group::Error, "glCheckFramebufferStatus(): %1$s",
@@ -61,7 +61,8 @@ std::unique_ptr<FBO> createFBO(int width, int height) {
   }
 }
 
-FBO::FBO(int width, int height, bool useEXT) : width_(width), height_(height), use_ext_(useEXT) {
+FBO::FBO(int width, int height, bool useEXT)
+    : width_(width), height_(height), use_ext_(useEXT) {
   // Generate and bind FBO
   GL_CHECKD(glGenFramebuffers(1, &this->fbo_id_));
   this->bind();
@@ -71,14 +72,17 @@ FBO::FBO(int width, int height, bool useEXT) : width_(width), height_(height), u
   GL_CHECKD(glGenRenderbuffers(1, &this->renderbuf_id_));
 
   // Create buffers with correct size
-  if (!this->resize(width, height)) return;
+  if (!this->resize(width, height))
+    return;
 
   // Attach render and depth buffers
   GL_CHECKD(glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                                       GL_RENDERBUFFER, this->renderbuf_id_));
 
   if (!checkFBOStatus()) {
-    LOG(message_group::Error, "Problem with OpenGL framebuffer after specifying color render buffer.");
+    LOG(message_group::Error,
+        "Problem with OpenGL framebuffer after specifying color render "
+        "buffer.");
     return;
   }
 
@@ -90,15 +94,16 @@ FBO::FBO(int width, int height, bool useEXT) : width_(width), height_(height), u
                                       GL_RENDERBUFFER, this->depthbuf_id_));
 
   if (!checkFBOStatus()) {
-    LOG(message_group::Error, "Problem with OpenGL framebuffer after specifying depth render buffer.");
+    LOG(message_group::Error,
+        "Problem with OpenGL framebuffer after specifying depth render "
+        "buffer.");
     return;
   }
 
   this->complete_ = true;
 }
 
-bool FBO::resize(size_t width, size_t height)
-{
+bool FBO::resize(size_t width, size_t height) {
   if (this->use_ext_) {
     GL_CHECKD(glBindRenderbufferEXT(GL_RENDERBUFFER, this->renderbuf_id_));
   } else {
@@ -110,7 +115,8 @@ bool FBO::resize(size_t width, size_t height)
   } else {
     GL_CHECKD(glBindRenderbuffer(GL_RENDERBUFFER, this->depthbuf_id_));
   }
-  GL_CHECKD(glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height));
+  GL_CHECKD(glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width,
+                                  height));
 
   width_ = width;
   height_ = height;
@@ -119,9 +125,9 @@ bool FBO::resize(size_t width, size_t height)
 }
 
 // Bind this VBO. Returs the old FBO id.
-GLuint FBO::bind()
-{
-  glGetIntegerv(GL_FRAMEBUFFER_BINDING, reinterpret_cast<GLint *>(&this->old_fbo_id_));
+GLuint FBO::bind() {
+  glGetIntegerv(GL_FRAMEBUFFER_BINDING,
+                reinterpret_cast<GLint*>(&this->old_fbo_id_));
   if (this->use_ext_) {
     GL_CHECKD(glBindFramebufferEXT(GL_FRAMEBUFFER, this->fbo_id_));
   } else {
@@ -131,8 +137,7 @@ GLuint FBO::bind()
 }
 
 // Unbind this VBO, and bind the previous FBO id.
-void FBO::unbind()
-{
+void FBO::unbind() {
   if (this->use_ext_) {
     GL_CHECKD(glBindFramebufferEXT(GL_FRAMEBUFFER, this->old_fbo_id_));
   } else {
@@ -141,8 +146,7 @@ void FBO::unbind()
   this->old_fbo_id_ = 0;
 }
 
-void FBO::destroy()
-{
+void FBO::destroy() {
   this->unbind();
   if (this->depthbuf_id_ != 0) {
     GL_CHECKD(glDeleteRenderbuffers(1, &this->depthbuf_id_));
diff --git a/src/glview/fbo.h b/src/glview/fbo.h
index 901cf0b48..6d40646a3 100644
--- a/src/glview/fbo.h
+++ b/src/glview/fbo.h
@@ -5,9 +5,8 @@
 
 #include "glview/system-gl.h"
 
-class FBO
-{
-public:
+class FBO {
+ public:
   FBO(int width, int height, bool useEXT);
   ~FBO() { destroy(); }
 
@@ -19,7 +18,7 @@ public:
   GLuint bind();
   void unbind();
 
-private:
+ private:
   void destroy();
 
   bool use_ext_;
diff --git a/src/glview/hershey.cc b/src/glview/hershey.cc
index 56a5e6292..8ef509a0d 100644
--- a/src/glview/hershey.cc
+++ b/src/glview/hershey.cc
@@ -29,19 +29,25 @@ float TextWidth(std::string_view str, float size) {
       longest_line = std::max(longest_line, w);
       w = 0;
     }
-    if (c < 32 || c > 126) continue;
+    if (c < 32 || c > 126)
+      continue;
     const HersheyGlyph& glyph = hershey_simplex[c - 32];
     w += size * glyph.width;
   }
   return std::max(longest_line, w);
 }
 
-void DrawText(std::string_view str, float tx, float ty, TextAlign align,
+void DrawText(std::string_view str,
+              float tx,
+              float ty,
+              TextAlign align,
               float size,
               const std::function<void(bool do_line, float x, float y)>& draw) {
   float dx = 0;
-  if (align == TextAlign::kRight)dx = -TextWidth(str, size);
-  else if (align == TextAlign::kCenter)dx = -TextWidth(str, size) / 2;
+  if (align == TextAlign::kRight)
+    dx = -TextWidth(str, size);
+  else if (align == TextAlign::kCenter)
+    dx = -TextWidth(str, size) / 2;
   size /= 25.0f;  // The actual coordinates are roughly in the range 0..25
   float x = 0, y = 0;
   for (char c : str) {
@@ -49,7 +55,8 @@ void DrawText(std::string_view str, float tx, float ty, TextAlign align,
       y -= 30 * size;
       x = 0;
     }
-    if (c < 32 || c > 126) continue;
+    if (c < 32 || c > 126)
+      continue;
     const HersheyGlyph& glyph = hershey_simplex[c - 32];
     bool pen_up = true;
     for (int op = 0; op < glyph.number_of_ops; ++op) {
@@ -64,7 +71,7 @@ void DrawText(std::string_view str, float tx, float ty, TextAlign align,
     x += size * glyph.width;
   }
 }
-} // namespace hershey
+}  // namespace hershey
 
 /*
  * This is a transcoding of the Simplex Hershey Font glyphys into a C-struct.
diff --git a/src/glview/hershey.h b/src/glview/hershey.h
index d6a24c3d7..1196af6bd 100644
--- a/src/glview/hershey.h
+++ b/src/glview/hershey.h
@@ -20,7 +20,10 @@ enum class TextAlign { kLeft, kCenter, kRight };
 //   "x", "y"   - the position to moveto/lineto
 // The function makes it independent of any output device and easy to
 // adapt in any environment including 3D projection.
-void DrawText(std::string_view str, float tx, float ty, TextAlign align,
+void DrawText(std::string_view str,
+              float tx,
+              float ty,
+              TextAlign align,
               float size,
               const std::function<void(bool pen_down, float x, float y)>& draw);
 }  // namespace hershey
diff --git a/src/glview/offscreen-old/OffscreenContextEGL.cc b/src/glview/offscreen-old/OffscreenContextEGL.cc
index 60b9602ff..b5464ab23 100644
--- a/src/glview/offscreen-old/OffscreenContextEGL.cc
+++ b/src/glview/offscreen-old/OffscreenContextEGL.cc
@@ -25,28 +25,28 @@
  */
 #include "glview/offscreen-old/OffscreenContextEGL.h"
 
-#include <iostream>
+#include <EGL/egl.h>
 #include <cstdint>
+#include <iostream>
 #include <memory>
-#include <EGL/egl.h>
 #define EGL_EGLEXT_PROTOTYPES
 #include <EGL/eglext.h>
 
 #include "glview/system-gl.h"
 
+#include <sys/utsname.h>  // for uname
 #include <cassert>
 #include <sstream>
 #include <string>
-#include <sys/utsname.h> // for uname
 
 #include "glview/OffscreenContext.h"
 
 namespace {
 
-class OffscreenContextEGL : public OffscreenContext
-{
-public:
-  OffscreenContextEGL(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
+class OffscreenContextEGL : public OffscreenContext {
+ public:
+  OffscreenContextEGL(uint32_t width, uint32_t height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextEGL() {
     if (this->display != nullptr) {
       eglTerminate(this->display);
@@ -60,8 +60,8 @@ public:
 
     std::ostringstream result;
 
-    const char *vendor = eglQueryString(display, EGL_VENDOR);
-    const char *version = eglQueryString(display, EGL_VERSION);
+    const char* vendor = eglQueryString(display, EGL_VENDOR);
+    const char* version = eglQueryString(display, EGL_VERSION);
 
     result << "GL context creator: EGL (old)\n"
            << "EGL version: " << version << " (" << vendor << ")\n"
@@ -71,7 +71,8 @@ public:
   }
 
   bool makeCurrent() const override {
-    return eglMakeCurrent(this->display, this->surface, this->surface, this->context);
+    return eglMakeCurrent(this->display, this->surface, this->surface,
+                          this->context);
   }
 
   EGLContext context{nullptr};
@@ -79,27 +80,27 @@ public:
   EGLSurface surface{EGL_NO_SURFACE};
 };
 
-static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
-{
-  static const EGLint configAttribs[] = {
-    EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-    EGL_BLUE_SIZE, 8,
-    EGL_GREEN_SIZE, 8,
-    EGL_RED_SIZE, 8,
-    EGL_ALPHA_SIZE, 8,
-    EGL_DEPTH_SIZE, 24,
-    EGL_CONFORMANT, EGL_OPENGL_BIT,
-    EGL_NONE
-  };
+static bool create_egl_dummy_context(OffscreenContextEGL& ctx) {
+  static const EGLint configAttribs[] = {EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
+                                         EGL_BLUE_SIZE,    8,
+                                         EGL_GREEN_SIZE,   8,
+                                         EGL_RED_SIZE,     8,
+                                         EGL_ALPHA_SIZE,   8,
+                                         EGL_DEPTH_SIZE,   24,
+                                         EGL_CONFORMANT,   EGL_OPENGL_BIT,
+                                         EGL_NONE};
 
   const EGLint pbufferAttribs[] = {
-    EGL_WIDTH, static_cast<EGLint>(ctx.width()),
-    EGL_HEIGHT, static_cast<EGLint>(ctx.height()),
-    EGL_NONE,
+      EGL_WIDTH,  static_cast<EGLint>(ctx.width()),
+      EGL_HEIGHT, static_cast<EGLint>(ctx.height()),
+      EGL_NONE,
   };
 
-  PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT = (PFNEGLQUERYDEVICESEXTPROC) eglGetProcAddress("eglQueryDevicesEXT");
-  PFNEGLGETPLATFORMDISPLAYEXTPROC eglGetPlatformDisplayEXT = (PFNEGLGETPLATFORMDISPLAYEXTPROC) eglGetProcAddress("eglGetPlatformDisplayEXT");
+  PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT =
+      (PFNEGLQUERYDEVICESEXTPROC)eglGetProcAddress("eglQueryDevicesEXT");
+  PFNEGLGETPLATFORMDISPLAYEXTPROC eglGetPlatformDisplayEXT =
+      (PFNEGLGETPLATFORMDISPLAYEXTPROC)eglGetProcAddress(
+          "eglGetPlatformDisplayEXT");
   if (eglQueryDevicesEXT && eglGetPlatformDisplayEXT) {
     const int MAX_DEVICES = 10;
     EGLDeviceEXT eglDevs[MAX_DEVICES];
@@ -108,7 +109,8 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
     eglQueryDevicesEXT(MAX_DEVICES, eglDevs, &numDevices);
     PRINTDB("Found %d EGL devices.", numDevices);
     for (int idx = 0; idx < numDevices; idx++) {
-      EGLDisplay disp = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT, eglDevs[idx], nullptr);
+      EGLDisplay disp = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT,
+                                                 eglDevs[idx], nullptr);
       if (disp != EGL_NO_DISPLAY) {
         ctx.display = disp;
         break;
@@ -124,9 +126,11 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
     return false;
   }
 
-  PFNEGLGETDISPLAYDRIVERNAMEPROC eglGetDisplayDriverName = (PFNEGLGETDISPLAYDRIVERNAMEPROC) eglGetProcAddress("eglGetDisplayDriverName");
+  PFNEGLGETDISPLAYDRIVERNAMEPROC eglGetDisplayDriverName =
+      (PFNEGLGETDISPLAYDRIVERNAMEPROC)eglGetProcAddress(
+          "eglGetDisplayDriverName");
   if (eglGetDisplayDriverName) {
-    const char *name = eglGetDisplayDriverName(ctx.display);
+    const char* name = eglGetDisplayDriverName(ctx.display);
     PRINTDB("Got EGL display with driver name '%s'", name);
   }
 
@@ -136,12 +140,14 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
     return false;
   }
 
-  PRINTDB("EGL Version: %d.%d (%s)", major % minor % eglQueryString(ctx.display, EGL_VENDOR));
+  PRINTDB("EGL Version: %d.%d (%s)",
+          major % minor % eglQueryString(ctx.display, EGL_VENDOR));
 
   EGLint numConfigs;
   EGLConfig config;
   if (!eglChooseConfig(ctx.display, configAttribs, &config, 1, &numConfigs)) {
-    std::cerr << "Failed to choose config (eglError: " << std::hex << eglGetError() << ")" << std::endl;
+    std::cerr << "Failed to choose config (eglError: " << std::hex
+              << eglGetError() << ")" << std::endl;
     return false;
   }
   if (!eglBindAPI(EGL_OPENGL_API)) {
@@ -150,19 +156,22 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
   }
   ctx.surface = eglCreatePbufferSurface(ctx.display, config, pbufferAttribs);
   if (ctx.surface == EGL_NO_SURFACE) {
-    std::cerr << "Unable to create EGL surface (eglError: " << eglGetError() << ")" << std::endl;
+    std::cerr << "Unable to create EGL surface (eglError: " << eglGetError()
+              << ")" << std::endl;
     return false;
   }
 
-  EGLint ctxattr[] = {
-    EGL_CONTEXT_MAJOR_VERSION, 2,
-    EGL_CONTEXT_MINOR_VERSION, 0,
-    EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT,
-    EGL_NONE
-  };
+  EGLint ctxattr[] = {EGL_CONTEXT_MAJOR_VERSION,
+                      2,
+                      EGL_CONTEXT_MINOR_VERSION,
+                      0,
+                      EGL_CONTEXT_OPENGL_PROFILE_MASK,
+                      EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT,
+                      EGL_NONE};
   ctx.context = eglCreateContext(ctx.display, config, EGL_NO_CONTEXT, ctxattr);
   if (ctx.context == EGL_NO_CONTEXT) {
-    std::cerr << "Unable to create EGL context (eglError: " << eglGetError() << ")" << std::endl;
+    std::cerr << "Unable to create EGL context (eglError: " << eglGetError()
+              << ")" << std::endl;
     return false;
   }
 
@@ -174,9 +183,12 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
 namespace offscreen_old {
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
+    uint32_t width,
+    uint32_t height,
+    uint32_t majorGLVersion,
+    uint32_t minorGLVersion,
+    bool gles,
+    bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextEGL>(width, height);
 
   if (!create_egl_dummy_context(*ctx)) {
diff --git a/src/glview/offscreen-old/OffscreenContextEGL.h b/src/glview/offscreen-old/OffscreenContextEGL.h
index 6eb5f60c3..ea6aee636 100644
--- a/src/glview/offscreen-old/OffscreenContextEGL.h
+++ b/src/glview/offscreen-old/OffscreenContextEGL.h
@@ -8,7 +8,11 @@
 namespace offscreen_old {
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile);
+    uint32_t width,
+    uint32_t height,
+    uint32_t majorGLVersion,
+    uint32_t minorGLVersion,
+    bool gles,
+    bool compatibilityProfile);
 
 }  // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextGLX.cc b/src/glview/offscreen-old/OffscreenContextGLX.cc
index 08c74c22b..b4717954b 100644
--- a/src/glview/offscreen-old/OffscreenContextGLX.cc
+++ b/src/glview/offscreen-old/OffscreenContextGLX.cc
@@ -36,31 +36,33 @@
  */
 #include "glview/offscreen-old/OffscreenContextGLX.h"
 
-
-#include "glview/system-gl.h"
-#include <iostream>
-#include <cstdint>
-#include <memory>
 #include <GL/gl.h>
 #include <GL/glx.h>
+#include <cstdint>
+#include <iostream>
+#include <memory>
+#include "glview/system-gl.h"
 
+#include <sys/utsname.h>  // for uname
 #include <cassert>
 #include <sstream>
 #include <string>
-#include <sys/utsname.h> // for uname
 
 #include "utils/printutils.h"
 
 namespace {
 
-class OffscreenContextGLX : public OffscreenContext
-{
-public:
-  OffscreenContextGLX(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
+class OffscreenContextGLX : public OffscreenContext {
+ public:
+  OffscreenContextGLX(uint32_t width, uint32_t height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextGLX() {
-    if (this->xwindow) XDestroyWindow(this->xdisplay, this->xwindow);
-    if (this->openGLContext) glXDestroyContext(this->xdisplay, this->openGLContext);
-    if (this->xdisplay) XCloseDisplay(this->xdisplay);
+    if (this->xwindow)
+      XDestroyWindow(this->xdisplay, this->xwindow);
+    if (this->openGLContext)
+      glXDestroyContext(this->xdisplay, this->openGLContext);
+    if (this->xdisplay)
+      XCloseDisplay(this->xdisplay);
   }
 
   std::string getInfo() const override {
@@ -81,18 +83,18 @@ public:
   }
 
   bool makeCurrent() const override {
-    return glXMakeContextCurrent(this->xdisplay, this->xwindow, this->xwindow, this->openGLContext);
+    return glXMakeContextCurrent(this->xdisplay, this->xwindow, this->xwindow,
+                                 this->openGLContext);
   }
 
   GLXContext openGLContext{nullptr};
-  Display *xdisplay{nullptr};
+  Display* xdisplay{nullptr};
   Window xwindow{0};
 };
 
 static XErrorHandler original_xlib_handler = nullptr;
 static auto XCreateWindow_failed = false;
-static int XCreateWindow_error(Display *dpy, XErrorEvent *event)
-{
+static int XCreateWindow_error(Display* dpy, XErrorEvent* event) {
   std::cerr << "XCreateWindow failed: XID: " << event->resourceid
             << " request: " << static_cast<int>(event->request_code)
             << " minor: " << static_cast<int>(event->minor_code) << "\n";
@@ -113,25 +115,33 @@ static int XCreateWindow_error(Display *dpy, XErrorEvent *event)
 
    This function will alter ctx.openGLContext and ctx.xwindow if successful
  */
-bool create_glx_dummy_window(OffscreenContextGLX& ctx)
-{
-  int attributes[] = {
-    GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT, //support all 3, for OpenCSG
-    GLX_RENDER_TYPE,   GLX_RGBA_BIT,
-    GLX_RED_SIZE, 8,
-    GLX_GREEN_SIZE, 8,
-    GLX_BLUE_SIZE, 8,
-    GLX_ALPHA_SIZE, 8,
-    GLX_DEPTH_SIZE, 24, // depth-stencil for OpenCSG
-    GLX_STENCIL_SIZE, 8,
-    GLX_DOUBLEBUFFER, true,
-    None
-  };
+bool create_glx_dummy_window(OffscreenContextGLX& ctx) {
+  int attributes[] = {GLX_DRAWABLE_TYPE,
+                      GLX_WINDOW_BIT | GLX_PIXMAP_BIT |
+                          GLX_PBUFFER_BIT,  // support all 3, for OpenCSG
+                      GLX_RENDER_TYPE,
+                      GLX_RGBA_BIT,
+                      GLX_RED_SIZE,
+                      8,
+                      GLX_GREEN_SIZE,
+                      8,
+                      GLX_BLUE_SIZE,
+                      8,
+                      GLX_ALPHA_SIZE,
+                      8,
+                      GLX_DEPTH_SIZE,
+                      24,  // depth-stencil for OpenCSG
+                      GLX_STENCIL_SIZE,
+                      8,
+                      GLX_DOUBLEBUFFER,
+                      true,
+                      None};
 
   auto dpy = ctx.xdisplay;
 
   int num_returned = 0;
-  auto fbconfigs = glXChooseFBConfig(dpy, DefaultScreen(dpy), attributes, &num_returned);
+  auto fbconfigs =
+      glXChooseFBConfig(dpy, DefaultScreen(dpy), attributes, &num_returned);
   if (fbconfigs == nullptr) {
     std::cerr << "glXChooseFBConfig failed\n";
     return false;
@@ -144,7 +154,8 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
     return false;
   }
 
-  // can't depend on xWin==nullptr at failure. use a custom Xlib error handler instead.
+  // can't depend on xWin==nullptr at failure. use a custom Xlib error handler
+  // instead.
   original_xlib_handler = XSetErrorHandler(XCreateWindow_error);
 
   auto root = DefaultRootWindow(dpy);
@@ -156,13 +167,14 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
   xwin_attr.border_pixel = 0;
   xwin_attr.colormap = XCreateColormap(dpy, root, visinfo->visual, AllocNone);
   xwin_attr.event_mask = StructureNotifyMask | ExposureMask | KeyPressMask;
-  unsigned long int mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
+  unsigned long int mask =
+      CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
 
-  auto xWin = XCreateWindow(dpy, root, 0, 0, width, height,
-                            0, visinfo->depth, InputOutput,
-                            visinfo->visual, mask, &xwin_attr);
+  auto xWin = XCreateWindow(dpy, root, 0, 0, width, height, 0, visinfo->depth,
+                            InputOutput, visinfo->visual, mask, &xwin_attr);
 
-  // Window xWin = XCreateSimpleWindow( dpy, DefaultRootWindow(dpy), 0,0,42,42, 0,0,0 );
+  // Window xWin = XCreateSimpleWindow( dpy, DefaultRootWindow(dpy), 0,0,42,42,
+  // 0,0,0 );
 
   XSync(dpy, false);
   if (XCreateWindow_failed) {
@@ -172,10 +184,11 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
   }
   XSetErrorHandler(original_xlib_handler);
 
-  // Most programs would call XMapWindow here. But we don't, to keep the window hidden
-  // XMapWindow( dpy, xWin );
+  // Most programs would call XMapWindow here. But we don't, to keep the window
+  // hidden XMapWindow( dpy, xWin );
 
-  auto context = glXCreateNewContext(dpy, fbconfigs[0], GLX_RGBA_TYPE, nullptr, true);
+  auto context =
+      glXCreateNewContext(dpy, fbconfigs[0], GLX_RGBA_TYPE, nullptr, true);
   if (context == nullptr) {
     std::cerr << "glXCreateNewContext failed\n";
     XDestroyWindow(dpy, xWin);
@@ -184,7 +197,7 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
     return false;
   }
 
-  //GLXWindow glxWin = glXCreateWindow( dpy, fbconfigs[0], xWin, nullptr );
+  // GLXWindow glxWin = glXCreateWindow( dpy, fbconfigs[0], xWin, nullptr );
 
   ctx.openGLContext = context;
   ctx.xwindow = xWin;
@@ -195,11 +208,10 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
   return true;
 }
 
-
 #pragma GCC diagnostic ignored "-Waddress"
-bool create_glx_dummy_context(OffscreenContextGLX& ctx)
-{
-  // This will alter ctx.openGLContext and ctx.xdisplay and ctx.xwindow if successful
+bool create_glx_dummy_context(OffscreenContextGLX& ctx) {
+  // This will alter ctx.openGLContext and ctx.xdisplay and ctx.xwindow if
+  // successful
   int major;
   int minor;
   auto result = false;
@@ -208,7 +220,7 @@ bool create_glx_dummy_context(OffscreenContextGLX& ctx)
   if (ctx.xdisplay == nullptr) {
     std::cerr << "Unable to open a connection to the X server.\n";
     auto dpyenv = getenv("DISPLAY");
-    std::cerr << "DISPLAY=" << (dpyenv?dpyenv:"") << "\n";
+    std::cerr << "DISPLAY=" << (dpyenv ? dpyenv : "") << "\n";
     return false;
   }
 
@@ -223,7 +235,8 @@ bool create_glx_dummy_context(OffscreenContextGLX& ctx)
     result = create_glx_dummy_window(ctx);
   }
 
-  if (!result) XCloseDisplay(ctx.xdisplay);
+  if (!result)
+    XCloseDisplay(ctx.xdisplay);
   return result;
 }
 
@@ -232,9 +245,12 @@ bool create_glx_dummy_context(OffscreenContextGLX& ctx)
 namespace offscreen_old {
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
+    uint32_t width,
+    uint32_t height,
+    uint32_t majorGLVersion,
+    uint32_t minorGLVersion,
+    bool gles,
+    bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextGLX>(width, height);
 
   // before an FBO can be setup, a GLX context must be created
diff --git a/src/glview/offscreen-old/OffscreenContextGLX.h b/src/glview/offscreen-old/OffscreenContextGLX.h
index ed36b43a0..7bbe45acd 100644
--- a/src/glview/offscreen-old/OffscreenContextGLX.h
+++ b/src/glview/offscreen-old/OffscreenContextGLX.h
@@ -8,7 +8,11 @@
 namespace offscreen_old {
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile);
+    uint32_t width,
+    uint32_t height,
+    uint32_t majorGLVersion,
+    uint32_t minorGLVersion,
+    bool gles,
+    bool compatibilityProfile);
 
 }  // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextNSOpenGL.h b/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
index bb4d985ba..8cb5428cc 100644
--- a/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
+++ b/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
@@ -8,7 +8,9 @@
 namespace offscreen_old {
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextNSOpenGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion);
+    uint32_t width,
+    uint32_t height,
+    uint32_t majorGLVersion,
+    uint32_t minorGLVersion);
 
 }  // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextWGL.cc b/src/glview/offscreen-old/OffscreenContextWGL.cc
index 7111b0757..7a0048f08 100644
--- a/src/glview/offscreen-old/OffscreenContextWGL.cc
+++ b/src/glview/offscreen-old/OffscreenContextWGL.cc
@@ -13,24 +13,23 @@
 #include "glview/offscreen-old/OffscreenContextWGL.h"
 
 #undef NOGDI
-#include <iostream>
+#include <windows.h>
 #include <cstdint>
+#include <iostream>
 #include <memory>
-#include <windows.h>
 
-#include <string>
+#include <GL/gl.h>  // must be included after glew.h
 #include <sstream>
-#include "utils/printutils.h"
+#include <string>
 #include "glview/system-gl.h"
-#include <GL/gl.h> // must be included after glew.h
-
+#include "utils/printutils.h"
 
 namespace {
 
-class OffscreenContextWGL : public OffscreenContext
-{
-public:
-  OffscreenContextWGL(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
+class OffscreenContextWGL : public OffscreenContext {
+ public:
+  OffscreenContextWGL(uint32_t width, uint32_t height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextWGL() {
     wglMakeCurrent(nullptr, nullptr);
     wglDeleteContext(this->openGLContext);
@@ -55,13 +54,14 @@ public:
   HGLRC openGLContext{nullptr};
 };
 
-LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
-{
+LRESULT CALLBACK WndProc(HWND hwnd,
+                         UINT message,
+                         WPARAM wparam,
+                         LPARAM lparam) {
   return DefWindowProc(hwnd, message, wparam, lparam);
 }
 
-bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
-{
+bool create_wgl_dummy_context(OffscreenContextWGL& ctx) {
   // this function alters ctx->window and ctx->openGLContext
   //  and ctx->dev_context if successful
 
@@ -70,7 +70,7 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
 
   HINSTANCE inst = GetModuleHandleW(0);
   WNDCLASSW wc;
-  ZeroMemory(&wc, sizeof(wc) );
+  ZeroMemory(&wc, sizeof(wc));
   wc.style = CS_OWNDC;
   wc.lpfnWndProc = WndProc;
   wc.hInstance = inst;
@@ -87,7 +87,7 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
   }
 
   LPCWSTR lpWindowName = L"OpenSCAD";
-  DWORD dwStyle = WS_CAPTION | WS_POPUPWINDOW; // | WS_VISIBLE
+  DWORD dwStyle = WS_CAPTION | WS_POPUPWINDOW;  // | WS_VISIBLE
   int x = 0;
   int y = 0;
   int nWidth = ctx.width();
@@ -97,8 +97,8 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
   HINSTANCE hInstance = inst;
   LPVOID lpParam = nullptr;
 
-  HWND window = CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y,
-                              nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
+  HWND window = CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y, nWidth,
+                              nHeight, hWndParent, hMenu, hInstance, lpParam);
 
   if (window == nullptr) {
     std::cerr << "MS GDI - CreateWindow failed\n";
@@ -117,10 +117,11 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
     return false;
   }
 
-  ZeroMemory(&pixformat, sizeof(pixformat) );
+  ZeroMemory(&pixformat, sizeof(pixformat));
   pixformat.nSize = sizeof(pixformat);
   pixformat.nVersion = 1;
-  pixformat.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
+  pixformat.dwFlags =
+      PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
   pixformat.iPixelType = PFD_TYPE_RGBA;
   pixformat.cGreenBits = 8;
   pixformat.cRedBits = 8;
@@ -163,9 +164,11 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
 namespace offscreen_old {
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool compatibilityProfile)
-{
+    uint32_t width,
+    uint32_t height,
+    uint32_t majorGLVersion,
+    uint32_t minorGLVersion,
+    bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextWGL>(width, height);
 
   // Before an FBO can be setup, a WGL context must be created.
diff --git a/src/glview/offscreen-old/OffscreenContextWGL.h b/src/glview/offscreen-old/OffscreenContextWGL.h
index 1b32a31b4..c8115f8aa 100644
--- a/src/glview/offscreen-old/OffscreenContextWGL.h
+++ b/src/glview/offscreen-old/OffscreenContextWGL.h
@@ -8,7 +8,10 @@
 namespace offscreen_old {
 
 std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool compatibilityProfile);
+    uint32_t width,
+    uint32_t height,
+    uint32_t majorGLVersion,
+    uint32_t minorGLVersion,
+    bool compatibilityProfile);
 
 }  // namespace offscreen_old
diff --git a/src/glview/preview/CSGTreeNormalizer.cc b/src/glview/preview/CSGTreeNormalizer.cc
index a7dddaea0..86793118d 100644
--- a/src/glview/preview/CSGTreeNormalizer.cc
+++ b/src/glview/preview/CSGTreeNormalizer.cc
@@ -1,9 +1,9 @@
 #include "glview/preview/CSGTreeNormalizer.h"
 
 #include <cassert>
-#include <utility>
 #include <memory>
 #include <stack>
+#include <utility>
 
 #include "core/CSGNode.h"
 #include "utils/printutils.h"
@@ -21,10 +21,11 @@ static bool validate_tree(const std::shared_ptr<CSGNode>& node)
 #endif
 
 /*!
-   NB! for e.g. empty intersections, this can normalize a tree to nothing and return nullptr.
+   NB! for e.g. empty intersections, this can normalize a tree to nothing and
+   return nullptr.
  */
-std::shared_ptr<CSGNode> CSGTreeNormalizer::normalize(const std::shared_ptr<CSGNode>& root)
-{
+std::shared_ptr<CSGNode> CSGTreeNormalizer::normalize(
+    const std::shared_ptr<CSGNode>& root) {
   this->aborted = false;
   this->nodecount = 0;
   std::shared_ptr<CSGNode> temp = root;
@@ -39,33 +40,40 @@ std::shared_ptr<CSGNode> CSGTreeNormalizer::normalize(const std::shared_ptr<CSGN
    This will search for nullptr children an recursively repair the corresponding
    subtree.
  */
-std::shared_ptr<CSGNode> CSGTreeNormalizer::cleanup_term(std::shared_ptr<CSGNode>& t)
-{
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(t)) {
-    if (op->left()) op->left() = cleanup_term(op->left());
-    if (op->right()) op->right() = cleanup_term(op->right());
+std::shared_ptr<CSGNode> CSGTreeNormalizer::cleanup_term(
+    std::shared_ptr<CSGNode>& t) {
+  if (std::shared_ptr<CSGOperation> op =
+          std::dynamic_pointer_cast<CSGOperation>(t)) {
+    if (op->left())
+      op->left() = cleanup_term(op->left());
+    if (op->right())
+      op->right() = cleanup_term(op->right());
     return collapse_null_terms(op);
   }
   return t;
 }
 
 static bool isUnion(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
   return op && op->getType() == OpenSCADOperator::UNION;
 }
 
 static bool hasRightNonLeaf(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  return op->right() && (std::dynamic_pointer_cast<CSGLeaf>(op->right()) == nullptr);
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
+  return op->right() &&
+         (std::dynamic_pointer_cast<CSGLeaf>(op->right()) == nullptr);
 }
 
 static bool hasLeftUnion(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
   return op && isUnion(op->left());
 }
 
-std::shared_ptr<CSGNode> CSGTreeNormalizer::normalizePass(std::shared_ptr<CSGNode> node)
-{
+std::shared_ptr<CSGNode> CSGTreeNormalizer::normalizePass(
+    std::shared_ptr<CSGNode> node) {
   // This function implements the CSG normalization
   // Reference:
   // Goldfeather, J., Molnar, S., Turk, G., and Fuchs, H. Near
@@ -74,43 +82,51 @@ std::shared_ptr<CSGNode> CSGTreeNormalizer::normalizePass(std::shared_ptr<CSGNod
   // 1989.
   // http://www.cc.gatech.edu/~turk/my_papers/pxpl_csg.pdf
 
-  // Iterative tree traversal used to workaround stack limits for very large inputs.
-  // This uses dreaded goto calls but is easily verifiable to be
+  // Iterative tree traversal used to workaround stack limits for very large
+  // inputs. This uses dreaded goto calls but is easily verifiable to be
   // functionally equivalent to the original recursive function,
   // compared to the previous attempt.
   // See Issue #2883 for problem with previous iterative implementation
-  // See Pull Request #2343 for the initial reasons for making this not recursive.
+  // See Pull Request #2343 for the initial reasons for making this not
+  // recursive.
 
   // stores current node and bool indicating if it was a left or right call;
   using stackframe_t = std::pair<std::shared_ptr<CSGOperation>, bool>;
   std::stack<stackframe_t> callstack;
 
 entrypoint:
-  if (std::dynamic_pointer_cast<CSGLeaf>(node)) goto return_node;
+  if (std::dynamic_pointer_cast<CSGLeaf>(node))
+    goto return_node;
   do {
     while (node && match_and_replace(node)) {
     }
     this->nodecount++;
     if (nodecount > this->limit) {
-      LOG(message_group::Warning, "Normalized tree is growing past %1$d elements. Aborting normalization.\n", this->limit);
+      LOG(message_group::Warning,
+          "Normalized tree is growing past %1$d elements. Aborting "
+          "normalization.\n",
+          this->limit);
       this->aborted = true;
       return {};
     }
-    if (!node || std::dynamic_pointer_cast<CSGLeaf>(node)) goto return_node;
+    if (!node || std::dynamic_pointer_cast<CSGLeaf>(node))
+      goto return_node;
     goto normalize_left_if_op;
-cont_left:;
-  } while (!this->aborted && !isUnion(node) && (hasRightNonLeaf(node) || hasLeftUnion(node)));
+  cont_left:;
+  } while (!this->aborted && !isUnion(node) &&
+           (hasRightNonLeaf(node) || hasLeftUnion(node)));
 
   if (!this->aborted) {
     goto normalize_right;
-cont_right:;
+  cont_right:;
   }
 
   // FIXME: Do we need to take into account any transformation of item here?
   node = collapse_null_terms(node);
 
   if (this->aborted) {
-    if (node) node = cleanup_term(node);
+    if (node)
+      node = cleanup_term(node);
   }
 
 return_node:
@@ -119,108 +135,129 @@ return_node:
   } else {
     stackframe_t frame = callstack.top();
     callstack.pop();
-    if (frame.second) { // came from a left call
+    if (frame.second) {  // came from a left call
       frame.first->left() = node;
       node = frame.first;
       goto cont_left;
-    } else { // came from a right call
+    } else {  // came from a right call
       frame.first->right() = node;
       node = frame.first;
       goto cont_right;
     }
   }
 normalize_left_if_op:
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node)) {
+  if (std::shared_ptr<CSGOperation> op =
+          std::dynamic_pointer_cast<CSGOperation>(node)) {
     callstack.emplace(op, true);
     node = op->left();
     goto entrypoint;
   }
   goto cont_left;
 normalize_right:
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
   assert(op);
   callstack.emplace(op, false);
   node = op->right();
   goto entrypoint;
 }
 
-std::shared_ptr<CSGNode> CSGTreeNormalizer::collapse_null_terms(const std::shared_ptr<CSGNode>& node)
-{
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+std::shared_ptr<CSGNode> CSGTreeNormalizer::collapse_null_terms(
+    const std::shared_ptr<CSGNode>& node) {
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
   if (op) {
     if (!op->right()) {
       this->nodecount--;
-      if (op->getType() == OpenSCADOperator::UNION || op->getType() == OpenSCADOperator::DIFFERENCE) return op->left();
-      else return op->right();
+      if (op->getType() == OpenSCADOperator::UNION ||
+          op->getType() == OpenSCADOperator::DIFFERENCE)
+        return op->left();
+      else
+        return op->right();
     }
     if (!op->left()) {
       this->nodecount--;
-      if (op->getType() == OpenSCADOperator::UNION) return op->right();
-      else return op->left();
+      if (op->getType() == OpenSCADOperator::UNION)
+        return op->right();
+      else
+        return op->left();
     }
   }
   return node;
 }
 
-bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node)
-{
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  if (!op) return false;
-  if (op->getType() == OpenSCADOperator::UNION) return false;
+bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node) {
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
+  if (!op)
+    return false;
+  if (op->getType() == OpenSCADOperator::UNION)
+    return false;
 
   // Part A: The 'x . (y . z)' expressions
 
-  std::shared_ptr<CSGOperation> rightop = std::dynamic_pointer_cast<CSGOperation>(op->right());
+  std::shared_ptr<CSGOperation> rightop =
+      std::dynamic_pointer_cast<CSGOperation>(op->right());
   if (rightop) {
     std::shared_ptr<CSGNode> x = op->left();
     std::shared_ptr<CSGNode> y = rightop->left();
     std::shared_ptr<CSGNode> z = rightop->right();
 
     // 1.  x - (y + z) -> (x - y) - z
-    if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::UNION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         z);
+    if (op->getType() == OpenSCADOperator::DIFFERENCE &&
+        rightop->getType() == OpenSCADOperator::UNION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::DIFFERENCE,
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y), z);
       return true;
     }
     // 2.  x * (y + z) -> (x * y) + (x * z)
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::UNION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
+    else if (op->getType() == OpenSCADOperator::INTERSECTION &&
+             rightop->getType() == OpenSCADOperator::UNION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
       return true;
     }
     // 3.  x - (y * z) -> (x - y) + (x - z)
-    else if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z));
+    else if (op->getType() == OpenSCADOperator::DIFFERENCE &&
+             rightop->getType() == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z));
       return true;
     }
     // 4.  x * (y * z) -> (x * y) * z
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         z);
+    else if (op->getType() == OpenSCADOperator::INTERSECTION &&
+             rightop->getType() == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::INTERSECTION,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y), z);
       return true;
     }
     // 5.  x - (y - z) -> (x - y) + (x * z)
-    else if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
+    else if (op->getType() == OpenSCADOperator::DIFFERENCE &&
+             rightop->getType() == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
       return true;
     }
     // 6.  x * (y - z) -> (x * y) - z
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         z);
+    else if (op->getType() == OpenSCADOperator::INTERSECTION &&
+             rightop->getType() == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::DIFFERENCE,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y), z);
       return true;
     }
   }
 
-  std::shared_ptr<CSGOperation> leftop = std::dynamic_pointer_cast<CSGOperation>(op->left());
+  std::shared_ptr<CSGOperation> leftop =
+      std::dynamic_pointer_cast<CSGOperation>(op->left());
   if (leftop) {
     // Part B: The '(x . y) . z' expressions
     std::shared_ptr<CSGNode> x = leftop->left();
@@ -228,24 +265,29 @@ bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node)
     std::shared_ptr<CSGNode> z = op->right();
 
     // 7. (x - y) * z  -> (x * z) - y
-    if (leftop->getType() == OpenSCADOperator::DIFFERENCE && op->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z),
-                                         y);
+    if (leftop->getType() == OpenSCADOperator::DIFFERENCE &&
+        op->getType() == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::DIFFERENCE,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z), y);
       return true;
     }
     // 8. (x + y) - z  -> (x - z) + (y - z)
-    else if (leftop->getType() == OpenSCADOperator::UNION && op->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, y, z));
+    else if (leftop->getType() == OpenSCADOperator::UNION &&
+             op->getType() == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z),
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, y, z));
       return true;
     }
     // 9. (x + y) * z  -> (x * z) + (y * z)
-    else if (leftop->getType() == OpenSCADOperator::UNION && op->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, y, z));
+    else if (leftop->getType() == OpenSCADOperator::UNION &&
+             op->getType() == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z),
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, y, z));
       return true;
     }
   }
@@ -253,9 +295,10 @@ bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node)
 }
 
 // Counts all non-leaf nodes
-unsigned int CSGTreeNormalizer::count(const std::shared_ptr<CSGNode>& node) const
-{
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node)) {
+unsigned int CSGTreeNormalizer::count(
+    const std::shared_ptr<CSGNode>& node) const {
+  if (std::shared_ptr<CSGOperation> op =
+          std::dynamic_pointer_cast<CSGOperation>(node)) {
     return 1 + count(op->left()) + count(op->right());
   }
   return 0;
diff --git a/src/glview/preview/CSGTreeNormalizer.h b/src/glview/preview/CSGTreeNormalizer.h
index 7fd02b5d1..4ed1a34a7 100644
--- a/src/glview/preview/CSGTreeNormalizer.h
+++ b/src/glview/preview/CSGTreeNormalizer.h
@@ -3,17 +3,18 @@
 #include <cstddef>
 #include <memory>
 
-class CSGTreeNormalizer
-{
-public:
+class CSGTreeNormalizer {
+ public:
   CSGTreeNormalizer(size_t limit) : limit(limit) {}
 
-  std::shared_ptr<class CSGNode> normalize(const std::shared_ptr<CSGNode>& term);
+  std::shared_ptr<class CSGNode> normalize(
+      const std::shared_ptr<CSGNode>& term);
 
-private:
+ private:
   std::shared_ptr<CSGNode> normalizePass(std::shared_ptr<CSGNode> term);
   bool match_and_replace(std::shared_ptr<class CSGNode>& term);
-  std::shared_ptr<CSGNode> collapse_null_terms(const std::shared_ptr<CSGNode>& term);
+  std::shared_ptr<CSGNode> collapse_null_terms(
+      const std::shared_ptr<CSGNode>& term);
   std::shared_ptr<CSGNode> cleanup_term(std::shared_ptr<CSGNode>& t);
   [[nodiscard]] unsigned int count(const std::shared_ptr<CSGNode>& term) const;
 
diff --git a/src/glview/preview/OpenCSGRenderer.cc b/src/glview/preview/OpenCSGRenderer.cc
index a211c28e1..57e7207dd 100644
--- a/src/glview/preview/OpenCSGRenderer.cc
+++ b/src/glview/preview/OpenCSGRenderer.cc
@@ -25,54 +25,56 @@
  */
 
 #include "glview/preview/OpenCSGRenderer.h"
+#include "geometry/linalg.h"
 #include "glview/Renderer.h"
 #include "glview/ShaderUtils.h"
 #include "glview/VertexState.h"
-#include "geometry/linalg.h"
 #include "glview/system-gl.h"
 
-#include "Feature.h"
-#include <cassert>
-#include <memory>
 #include <memory.h>
+#include <cassert>
 #include <cstddef>
+#include <memory>
 #include <utility>
 #include <vector>
+#include "Feature.h"
 
 #ifdef ENABLE_OPENCSG
 
 namespace {
 
-class OpenCSGVBOPrim : public OpenCSG::Primitive
-{
-public:
-  OpenCSGVBOPrim(OpenCSG::Operation operation, unsigned int convexity,
+class OpenCSGVBOPrim : public OpenCSG::Primitive {
+ public:
+  OpenCSGVBOPrim(OpenCSG::Operation operation,
+                 unsigned int convexity,
                  std::unique_ptr<VertexState> vertex_state)
-    : OpenCSG::Primitive(operation, convexity),
-    vertex_state(std::move(vertex_state)) {}
+      : OpenCSG::Primitive(operation, convexity),
+        vertex_state(std::move(vertex_state)) {}
   void render() override {
     if (vertex_state != nullptr) {
       vertex_state->draw();
     } else {
-      if (OpenSCAD::debug != "") PRINTD("OpenCSGVBOPrim vertex_state was null");
+      if (OpenSCAD::debug != "")
+        PRINTD("OpenCSGVBOPrim vertex_state was null");
     }
   }
 
-private:
+ private:
   const std::unique_ptr<VertexState> vertex_state;
 };
 
 // Primitive for drawing using OpenCSG
 // Makes a copy of the given VertexState enabling just unlit/uncolored vertex
 // rendering
-OpenCSGVBOPrim *createVBOPrimitive(
-  const std::shared_ptr<OpenCSGVertexState>& vertex_state,
-  const OpenCSG::Operation operation, const unsigned int convexity) {
+OpenCSGVBOPrim* createVBOPrimitive(
+    const std::shared_ptr<OpenCSGVertexState>& vertex_state,
+    const OpenCSG::Operation operation,
+    const unsigned int convexity) {
   std::unique_ptr<VertexState> opencsg_vs = std::make_unique<VertexState>(
-    vertex_state->drawMode(), vertex_state->drawSize(),
-    vertex_state->drawType(), vertex_state->drawOffset(),
-    vertex_state->elementOffset(), vertex_state->verticesVBO(),
-    vertex_state->elementsVBO());
+      vertex_state->drawMode(), vertex_state->drawSize(),
+      vertex_state->drawType(), vertex_state->drawOffset(),
+      vertex_state->elementOffset(), vertex_state->verticesVBO(),
+      vertex_state->elementsVBO());
   // First two glBegin entries are the vertex position calls
   opencsg_vs->glBegin().insert(opencsg_vs->glBegin().begin(),
                                vertex_state->glBegin().begin(),
@@ -87,19 +89,19 @@ OpenCSGVBOPrim *createVBOPrimitive(
 
 }  // namespace
 
-#endif // ENABLE_OPENCSG
+#endif  // ENABLE_OPENCSG
 
 OpenCSGRenderer::OpenCSGRenderer(
-  std::shared_ptr<CSGProducts> root_products,
-  std::shared_ptr<CSGProducts> highlights_products,
-  std::shared_ptr<CSGProducts> background_products)
-  : root_products_(std::move(root_products)),
-  highlights_products_(std::move(highlights_products)),
-  background_products_(std::move(background_products)) {
+    std::shared_ptr<CSGProducts> root_products,
+    std::shared_ptr<CSGProducts> highlights_products,
+    std::shared_ptr<CSGProducts> background_products)
+    : root_products_(std::move(root_products)),
+      highlights_products_(std::move(highlights_products)),
+      background_products_(std::move(background_products)) {
   opencsg_vertex_shader_code_ = ShaderUtils::loadShaderSource("OpenCSG.vert");
 }
 
-void OpenCSGRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo) {
+void OpenCSGRenderer::prepare(const ShaderUtils::ShaderInfo* shaderinfo) {
   if (vertex_state_containers_.empty()) {
     if (root_products_) {
       createCSGVBOProducts(*root_products_, false, false, shaderinfo);
@@ -113,18 +115,23 @@ void OpenCSGRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo) {
   }
 }
 
-void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
+void OpenCSGRenderer::draw(bool showedges,
+                           const ShaderUtils::ShaderInfo* shaderinfo) const {
 #ifdef ENABLE_OPENCSG
   // Only use shader if select rendering or showedges
-  bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  bool enable_shader =
+      shaderinfo &&
+      (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING &&
+           showedges ||
+       shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
 
   for (const auto& product : vertex_state_containers_) {
     if (product->primitives().size() > 1) {
 #if OPENCSG_VERSION >= 0x0180
-      if (enable_shader)OpenCSG::setVertexShader(opencsg_vertex_shader_code_);
-      else OpenCSG::setVertexShader({});
+      if (enable_shader)
+        OpenCSG::setVertexShader(opencsg_vertex_shader_code_);
+      else
+        OpenCSG::setVertexShader({});
 #endif
       GL_CHECKD(OpenCSG::render(product->primitives()));
       GL_TRACE0("glDepthFunc(GL_EQUAL)");
@@ -139,19 +146,24 @@ void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shader
 
     for (const auto& vertex_state : product->states()) {
       // Specify ID color if we're using select rendering
-      if (shaderinfo && shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
-        if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(vertex_state)) {
-          GL_TRACE("glUniform3f(%d, %f, %f, %f)", shaderinfo->uniforms.at("frag_idcolor") %
-                   (((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
-                   (((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
-                   (((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
-          GL_CHECKD(glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
-                                ((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
-                                ((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
-                                ((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+      if (shaderinfo &&
+          shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
+        if (const auto csg_vs =
+                std::dynamic_pointer_cast<OpenCSGVertexState>(vertex_state)) {
+          GL_TRACE("glUniform3f(%d, %f, %f, %f)",
+                   shaderinfo->uniforms.at("frag_idcolor") %
+                       (((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
+                       (((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
+                       (((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+          GL_CHECKD(
+              glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
+                          ((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
+                          ((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
+                          ((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
         }
       }
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+      const auto shader_vs =
+          std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
       if (!shader_vs || (showedges && shader_vs)) {
         vertex_state->draw();
       }
@@ -165,7 +177,7 @@ void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shader
     GL_TRACE0("glDepthFunc(GL_LEQUAL)");
     GL_CHECKD(glDepthFunc(GL_LEQUAL));
   }
-#endif // ENABLE_OPENCSG
+#endif  // ENABLE_OPENCSG
 }
 
 // Turn the CSGProducts into VBOs
@@ -176,19 +188,25 @@ void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shader
 // Note: This function can be called multiple times for different products.
 // Each call will add to vbo_vertex_products_.
 void OpenCSGRenderer::createCSGVBOProducts(
-  const CSGProducts& products, bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo) {
+    const CSGProducts& products,
+    bool highlight_mode,
+    bool background_mode,
+    const ShaderUtils::ShaderInfo* shaderinfo) {
 #ifdef ENABLE_OPENCSG
   bool enable_barycentric = true;
   for (const auto& product : products.products) {
-    std::unique_ptr<OpenCSGVBOProduct> vertex_state_container = std::make_unique<OpenCSGVBOProduct>();
+    std::unique_ptr<OpenCSGVBOProduct> vertex_state_container =
+        std::make_unique<OpenCSGVBOProduct>();
 
     Color4f last_color;
-    std::vector<OpenCSG::Primitive *>& primitives = vertex_state_container->primitives();
+    std::vector<OpenCSG::Primitive*>& primitives =
+        vertex_state_container->primitives();
     auto& vertex_states = vertex_state_container->states();
-    VBOBuilder vbo_builder(std::make_unique<OpenCSGVertexStateFactory>(), *vertex_state_container.get());
+    VBOBuilder vbo_builder(std::make_unique<OpenCSGVertexStateFactory>(),
+                           *vertex_state_container.get());
     vbo_builder.addSurfaceData();
     vbo_builder.writeSurface();
-    vbo_builder.addShaderData(); // Always enable barycentric coordinates
+    vbo_builder.addShaderData();  // Always enable barycentric coordinates
 
     size_t num_vertices = 0;
     for (const auto& csgobj : product.intersections) {
@@ -207,7 +225,8 @@ void OpenCSGRenderer::createCSGVBOProducts(
     for (const auto& csgobj : product.intersections) {
       if (csgobj.leaf->polyset) {
         const Color4f& c = csgobj.leaf->color;
-        const auto csgmode = RendererUtils::getCsgMode(highlight_mode, background_mode);
+        const auto csgmode =
+            RendererUtils::getCsgMode(highlight_mode, background_mode);
 
         ColorMode colormode = ColorMode::NONE;
         bool override_color;
@@ -231,33 +250,37 @@ void OpenCSGRenderer::createCSGVBOProducts(
 
         if (color.a() == 1.0f) {
           // object is opaque, draw normally
-          vbo_builder.create_surface(*csgobj.leaf->polyset,
-                                     csgobj.leaf->matrix, last_color, enable_barycentric, override_color);
+          vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix,
+                                     last_color, enable_barycentric,
+                                     override_color);
           if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-                vertex_states.back())) {
+                  vertex_states.back())) {
             csg_vs->setCsgObjectIndex(csgobj.leaf->index);
             primitives.emplace_back(
-              createVBOPrimitive(csg_vs, OpenCSG::Intersection,
-                                 csgobj.leaf->polyset->getConvexity()));
+                createVBOPrimitive(csg_vs, OpenCSG::Intersection,
+                                   csgobj.leaf->polyset->getConvexity()));
           }
         } else {
           // object is transparent, so draw rear faces first.  Issue #1496
           std::shared_ptr<VertexState> cull = std::make_shared<VertexState>();
           cull->glBegin().emplace_back([]() {
-            GL_TRACE0("glEnable(GL_CULL_FACE)"); glEnable(GL_CULL_FACE);
-            GL_TRACE0("glCullFace(GL_FRONT)"); glCullFace(GL_FRONT);
+            GL_TRACE0("glEnable(GL_CULL_FACE)");
+            glEnable(GL_CULL_FACE);
+            GL_TRACE0("glCullFace(GL_FRONT)");
+            glCullFace(GL_FRONT);
           });
           vertex_states.emplace_back(std::move(cull));
 
-          vbo_builder.create_surface(*csgobj.leaf->polyset,
-                                     csgobj.leaf->matrix, last_color, enable_barycentric, override_color);
+          vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix,
+                                     last_color, enable_barycentric,
+                                     override_color);
           if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-                vertex_states.back())) {
+                  vertex_states.back())) {
             csg_vs->setCsgObjectIndex(csgobj.leaf->index);
 
             primitives.emplace_back(
-              createVBOPrimitive(csg_vs, OpenCSG::Intersection,
-                                 csgobj.leaf->polyset->getConvexity()));
+                createVBOPrimitive(csg_vs, OpenCSG::Intersection,
+                                   csgobj.leaf->polyset->getConvexity()));
 
             cull = std::make_shared<VertexState>();
             cull->glBegin().emplace_back([]() {
@@ -284,8 +307,8 @@ void OpenCSGRenderer::createCSGVBOProducts(
     for (const auto& csgobj : product.subtractions) {
       if (csgobj.leaf->polyset) {
         const Color4f& c = csgobj.leaf->color;
-        const auto csgmode = RendererUtils::getCsgMode(highlight_mode, background_mode,
-                                                       OpenSCADOperator::DIFFERENCE);
+        const auto csgmode = RendererUtils::getCsgMode(
+            highlight_mode, background_mode, OpenSCADOperator::DIFFERENCE);
 
         ColorMode colormode = ColorMode::NONE;
         bool override_color;
@@ -320,17 +343,18 @@ void OpenCSGRenderer::createCSGVBOProducts(
         vertex_states.emplace_back(std::move(cull));
         Transform3d tmp = csgobj.leaf->matrix;
         if (csgobj.leaf->polyset->getDimension() == 2) {
-          // Scale 2D negative objects 10% in the Z direction to avoid z fighting
+          // Scale 2D negative objects 10% in the Z direction to avoid z
+          // fighting
           tmp *= Eigen::Scaling(1.0, 1.0, 1.1);
         }
-        vbo_builder.create_surface(*csgobj.leaf->polyset, tmp,
-                                   last_color, enable_barycentric, override_color);
+        vbo_builder.create_surface(*csgobj.leaf->polyset, tmp, last_color,
+                                   enable_barycentric, override_color);
         if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-              vertex_states.back())) {
+                vertex_states.back())) {
           csg_vs->setCsgObjectIndex(csgobj.leaf->index);
           primitives.emplace_back(
-            createVBOPrimitive(csg_vs, OpenCSG::Subtraction,
-                               csgobj.leaf->polyset->getConvexity()));
+              createVBOPrimitive(csg_vs, OpenCSG::Subtraction,
+                                 csgobj.leaf->polyset->getConvexity()));
         } else {
           assert(false && "Subtraction surface state was nullptr");
         }
@@ -353,9 +377,8 @@ void OpenCSGRenderer::createCSGVBOProducts(
 
     vbo_builder.createInterleavedVBOs();
     vertex_state_containers_.push_back(std::move(vertex_state_container));
-
   }
-#endif // ENABLE_OPENCSG
+#endif  // ENABLE_OPENCSG
 }
 
 BoundingBox OpenCSGRenderer::getBoundingBox() const {
diff --git a/src/glview/preview/OpenCSGRenderer.h b/src/glview/preview/OpenCSGRenderer.h
index 5584089b2..a99790b86 100644
--- a/src/glview/preview/OpenCSGRenderer.h
+++ b/src/glview/preview/OpenCSGRenderer.h
@@ -1,10 +1,10 @@
 #pragma once
 
-#include "glview/VertexState.h"
+#include <memory>
 #include "geometry/linalg.h"
 #include "glview/Renderer.h"
+#include "glview/VertexState.h"
 #include "glview/system-gl.h"
-#include <memory>
 #ifdef ENABLE_OPENCSG
 #include <opencsg.h>
 #endif
@@ -16,66 +16,89 @@
 #include <string>
 #include <vector>
 
-class OpenCSGVertexState : public VertexState
-{
-public:
+class OpenCSGVertexState : public VertexState {
+ public:
   OpenCSGVertexState(size_t csg_object_index = 0)
-    : csg_object_index_(csg_object_index) {}
-  OpenCSGVertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
-                     size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo,
+      : csg_object_index_(csg_object_index) {}
+  OpenCSGVertexState(GLenum draw_mode,
+                     GLsizei draw_size,
+                     GLenum draw_type,
+                     size_t draw_offset,
+                     size_t element_offset,
+                     GLuint vertices_vbo,
+                     GLuint elements_vbo,
                      size_t csg_object_index = 0)
-    : VertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo),
-    csg_object_index_(csg_object_index) {}
+      : VertexState(draw_mode,
+                    draw_size,
+                    draw_type,
+                    draw_offset,
+                    element_offset,
+                    vertices_vbo,
+                    elements_vbo),
+        csg_object_index_(csg_object_index) {}
 
   [[nodiscard]] size_t csgObjectIndex() const { return csg_object_index_; }
-  void setCsgObjectIndex(size_t csg_object_index) { csg_object_index_ = csg_object_index; }
+  void setCsgObjectIndex(size_t csg_object_index) {
+    csg_object_index_ = csg_object_index;
+  }
 
-private:
+ private:
   size_t csg_object_index_;
 };
 
-class OpenCSGVertexStateFactory : public VertexStateFactory
-{
-public:
+class OpenCSGVertexStateFactory : public VertexStateFactory {
+ public:
   OpenCSGVertexStateFactory() = default;
 
-  [[nodiscard]] std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
-                                                               size_t draw_offset, size_t element_offset,
-                                                               GLuint vertices_vbo, GLuint elements_vbo) const override {
-    return std::make_shared<OpenCSGVertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] std::shared_ptr<VertexState> createVertexState(
+      GLenum draw_mode,
+      size_t draw_size,
+      GLenum draw_type,
+      size_t draw_offset,
+      size_t element_offset,
+      GLuint vertices_vbo,
+      GLuint elements_vbo) const override {
+    return std::make_shared<OpenCSGVertexState>(draw_mode, draw_size, draw_type,
+                                                draw_offset, element_offset,
+                                                vertices_vbo, elements_vbo);
   }
 };
 
-class OpenCSGVBOProduct : public VertexStateContainer
-{
-public:
+class OpenCSGVBOProduct : public VertexStateContainer {
+ public:
   OpenCSGVBOProduct() = default;
   OpenCSGVBOProduct(const OpenCSGVBOProduct& o) = delete;
   OpenCSGVBOProduct(OpenCSGVBOProduct&& o) = delete;
   virtual ~OpenCSGVBOProduct() = default;
 
-  [[nodiscard]] std::vector<OpenCSG::Primitive *>& primitives() { return primitives_; }
+  [[nodiscard]] std::vector<OpenCSG::Primitive*>& primitives() {
+    return primitives_;
+  }
 
-private:
+ private:
   // primitives_ is used to create the OpenCSG depth buffer (unlit rendering).
   // states_ is used for color rendering (using GL_EQUAL).
   // Both may use the same underlying VBOs
-  std::vector<OpenCSG::Primitive *> primitives_;
+  std::vector<OpenCSG::Primitive*> primitives_;
 };
 
-class OpenCSGRenderer : public VBORenderer
-{
-public:
+class OpenCSGRenderer : public VBORenderer {
+ public:
   OpenCSGRenderer(std::shared_ptr<CSGProducts> root_products,
                   std::shared_ptr<CSGProducts> highlights_products,
                   std::shared_ptr<CSGProducts> background_products);
   ~OpenCSGRenderer() override = default;
-  void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  void prepare(const ShaderUtils::ShaderInfo* shaderinfo = nullptr) override;
+  void draw(bool showedges,
+            const ShaderUtils::ShaderInfo* shaderinfo = nullptr) const override;
 
   BoundingBox getBoundingBox() const override;
-private:
-  void createCSGVBOProducts(const CSGProducts& products, bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo);
+
+ private:
+  void createCSGVBOProducts(const CSGProducts& products,
+                            bool highlight_mode,
+                            bool background_mode,
+                            const ShaderUtils::ShaderInfo* shaderinfo);
 
   std::vector<std::unique_ptr<OpenCSGVBOProduct>> vertex_state_containers_;
   std::shared_ptr<CSGProducts> root_products_;
diff --git a/src/glview/preview/ThrownTogetherRenderer.cc b/src/glview/preview/ThrownTogetherRenderer.cc
index 82d69633f..988bca337 100644
--- a/src/glview/preview/ThrownTogetherRenderer.cc
+++ b/src/glview/preview/ThrownTogetherRenderer.cc
@@ -32,21 +32,24 @@
 
 #include <Eigen/Geometry>
 
+#include "core/CSGNode.h"
 #include "core/enums.h"
 #include "geometry/linalg.h"
-#include "glview/system-gl.h"
-#include "glview/VertexState.h"
 #include "glview/Renderer.h"
-#include "utils/printutils.h"
-#include "core/CSGNode.h"
 #include "glview/ShaderUtils.h"
 #include "glview/VBOBuilder.h"
 #include "glview/VBORenderer.h"
+#include "glview/VertexState.h"
+#include "glview/system-gl.h"
+#include "utils/printutils.h"
 
 namespace {
 
-Renderer::ColorMode getColorMode(const CSGNode::Flag& flags, bool highlight_mode,
-                                 bool background_mode, bool fberror, OpenSCADOperator type) {
+Renderer::ColorMode getColorMode(const CSGNode::Flag& flags,
+                                 bool highlight_mode,
+                                 bool background_mode,
+                                 bool fberror,
+                                 OpenSCADOperator type) {
   Renderer::ColorMode colormode = Renderer::ColorMode::NONE;
 
   if (highlight_mode) {
@@ -76,45 +79,59 @@ Renderer::ColorMode getColorMode(const CSGNode::Flag& flags, bool highlight_mode
 
 }  // namespace
 
-ThrownTogetherRenderer::ThrownTogetherRenderer(std::shared_ptr<CSGProducts> root_products,
-                                               std::shared_ptr<CSGProducts> highlight_products,
-                                               std::shared_ptr<CSGProducts> background_products)
-  : root_products_(std::move(root_products)), highlight_products_(std::move(highlight_products)), background_products_(std::move(background_products))
-{
-}
+ThrownTogetherRenderer::ThrownTogetherRenderer(
+    std::shared_ptr<CSGProducts> root_products,
+    std::shared_ptr<CSGProducts> highlight_products,
+    std::shared_ptr<CSGProducts> background_products)
+    : root_products_(std::move(root_products)),
+      highlight_products_(std::move(highlight_products)),
+      background_products_(std::move(background_products)) {}
 
-void ThrownTogetherRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void ThrownTogetherRenderer::prepare(
+    const ShaderUtils::ShaderInfo* shaderinfo) {
   PRINTD("Thrown prepare");
   if (vertex_state_containers_.empty()) {
-    VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
+    VertexStateContainer& vertex_state_container =
+        vertex_state_containers_.emplace_back();
 
-    VBOBuilder vbo_builder(std::make_unique<TTRVertexStateFactory>(), vertex_state_container);
+    VBOBuilder vbo_builder(std::make_unique<TTRVertexStateFactory>(),
+                           vertex_state_container);
     vbo_builder.addSurfaceData();
-    vbo_builder.addShaderData(); // Always enable barycentric coordinates
+    vbo_builder.addShaderData();  // Always enable barycentric coordinates
 
     size_t num_vertices = 0;
-    if (this->root_products_) num_vertices += (calcNumVertices(this->root_products_, true) * 2);
-    if (this->background_products_) num_vertices += calcNumVertices(this->background_products_, true);
-    if (this->highlight_products_) num_vertices += calcNumVertices(this->highlight_products_, true);
+    if (this->root_products_)
+      num_vertices += (calcNumVertices(this->root_products_, true) * 2);
+    if (this->background_products_)
+      num_vertices += calcNumVertices(this->background_products_, true);
+    if (this->highlight_products_)
+      num_vertices += calcNumVertices(this->highlight_products_, true);
 
     vbo_builder.allocateBuffers(num_vertices);
 
-    if (this->root_products_) createCSGProducts(*this->root_products_, vertex_state_container, vbo_builder, false, false, shaderinfo);
-    if (this->background_products_) createCSGProducts(*this->background_products_, vertex_state_container, vbo_builder, false, true, shaderinfo);
-    if (this->highlight_products_) createCSGProducts(*this->highlight_products_, vertex_state_container, vbo_builder, true, false, shaderinfo);
+    if (this->root_products_)
+      createCSGProducts(*this->root_products_, vertex_state_container,
+                        vbo_builder, false, false, shaderinfo);
+    if (this->background_products_)
+      createCSGProducts(*this->background_products_, vertex_state_container,
+                        vbo_builder, false, true, shaderinfo);
+    if (this->highlight_products_)
+      createCSGProducts(*this->highlight_products_, vertex_state_container,
+                        vbo_builder, true, false, shaderinfo);
 
     vbo_builder.createInterleavedVBOs();
   }
 }
 
-
-void ThrownTogetherRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
+void ThrownTogetherRenderer::draw(
+    bool showedges,
+    const ShaderUtils::ShaderInfo* shaderinfo) const {
   // Only use shader if select rendering or showedges
-  const bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  const bool enable_shader =
+      shaderinfo &&
+      (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING &&
+           showedges ||
+       shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
   if (enable_shader) {
     GL_TRACE("glUseProgram(%d)", shaderinfo->resource.shader_program);
     GL_CHECKD(glUseProgram(shaderinfo->resource.shader_program));
@@ -126,20 +143,24 @@ void ThrownTogetherRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo
   for (const auto& container : vertex_state_containers_) {
     for (const auto& vertex_state : container.states()) {
       // Specify ID color if we're using select rendering
-      if (shaderinfo && shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
-        if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vertex_state)) {
+      if (shaderinfo &&
+          shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
+        if (const auto ttr_vs =
+                std::dynamic_pointer_cast<TTRVertexState>(vertex_state)) {
           GL_TRACE("glUniform3f(%d, %f, %f, %f)",
                    shaderinfo->uniforms.at("frag_idcolor") %
-                   (((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
-                   (((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
-                   (((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
-          GL_CHECKD(glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
-                                ((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
-                                ((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
-                                ((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+                       (((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
+                       (((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
+                       (((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+          GL_CHECKD(
+              glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
+                          ((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
+                          ((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
+                          ((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
         }
       }
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+      const auto shader_vs =
+          std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
       if (!shader_vs || (shader_vs && showedges)) {
         vertex_state->draw();
       }
@@ -152,12 +173,17 @@ void ThrownTogetherRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo
   }
 }
 
-void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container, VBOBuilder& vbo_builder,
-                                               const CSGChainObject& csgobj, bool highlight_mode,
-                                               bool background_mode, OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void ThrownTogetherRenderer::createChainObject(
+    VertexStateContainer& container,
+    VBOBuilder& vbo_builder,
+    const CSGChainObject& csgobj,
+    bool highlight_mode,
+    bool background_mode,
+    OpenSCADOperator type,
+    const ShaderUtils::ShaderInfo* shaderinfo) {
   if (!csgobj.leaf->polyset ||
-      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(), &csgobj.leaf->matrix)]++ > 0) {
+      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(),
+                                            &csgobj.leaf->matrix)]++ > 0) {
     return;
   }
 
@@ -169,17 +195,21 @@ void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container,
 
   Color4f color;
   if (highlight_mode || background_mode) {
-    const ColorMode colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, false, type);
+    const ColorMode colormode = getColorMode(csgobj.flags, highlight_mode,
+                                             background_mode, false, type);
     getShaderColor(colormode, leaf_color, color);
 
     add_shader_pointers(vbo_builder, shaderinfo);
 
-    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix, color, enable_barycentric);
-    if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
+    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix,
+                               color, enable_barycentric);
+    if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(
+            vbo_builder.states().back())) {
       ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
     }
-  } else { // root mode
-    ColorMode colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, false, type);
+  } else {  // root mode
+    ColorMode colormode = getColorMode(csgobj.flags, highlight_mode,
+                                       background_mode, false, type);
     getShaderColor(colormode, leaf_color, color);
 
     add_shader_pointers(vbo_builder, shaderinfo);
@@ -194,18 +224,22 @@ void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container,
     container.states().emplace_back(std::move(cull));
 
     Transform3d mat = csgobj.leaf->matrix;
-    if (csgobj.leaf->polyset->getDimension() == 2 && type == OpenSCADOperator::DIFFERENCE) {
+    if (csgobj.leaf->polyset->getDimension() == 2 &&
+        type == OpenSCADOperator::DIFFERENCE) {
       // Scale 2D negative objects 10% in the Z direction to avoid z fighting
       mat *= Eigen::Scaling(1.0, 1.0, 1.1);
     }
-    vbo_builder.create_surface(*csgobj.leaf->polyset, mat, color, enable_barycentric);
-    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
+    vbo_builder.create_surface(*csgobj.leaf->polyset, mat, color,
+                               enable_barycentric);
+    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(
+            vbo_builder.states().back())) {
       ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
     }
 
-    color.setRgb(1.0f, 0.0f, 1.0f); // override leaf color on front/back error
+    color.setRgb(1.0f, 0.0f, 1.0f);  // override leaf color on front/back error
 
-    colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, true, type);
+    colormode =
+        getColorMode(csgobj.flags, highlight_mode, background_mode, true, type);
     getShaderColor(colormode, leaf_color, color);
 
     add_shader_pointers(vbo_builder, shaderinfo);
@@ -217,8 +251,10 @@ void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container,
     });
     container.states().emplace_back(std::move(cull));
 
-    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix, color, enable_barycentric);
-    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
+    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix,
+                               color, enable_barycentric);
+    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(
+            vbo_builder.states().back())) {
       ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
     }
 
@@ -229,24 +265,31 @@ void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container,
   }
 }
 
-void ThrownTogetherRenderer::createCSGProducts(const CSGProducts& products, VertexStateContainer& container, VBOBuilder& vbo_builder,
-                                               bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void ThrownTogetherRenderer::createCSGProducts(
+    const CSGProducts& products,
+    VertexStateContainer& container,
+    VBOBuilder& vbo_builder,
+    bool highlight_mode,
+    bool background_mode,
+    const ShaderUtils::ShaderInfo* shaderinfo) {
   PRINTD("Thrown renderCSGProducts");
   this->geom_visit_mark_.clear();
 
   for (const auto& product : products.products) {
     for (const auto& csgobj : product.intersections) {
-      createChainObject(container, vbo_builder, csgobj, highlight_mode, background_mode, OpenSCADOperator::INTERSECTION, shaderinfo);
+      createChainObject(container, vbo_builder, csgobj, highlight_mode,
+                        background_mode, OpenSCADOperator::INTERSECTION,
+                        shaderinfo);
     }
     for (const auto& csgobj : product.subtractions) {
-      createChainObject(container, vbo_builder, csgobj, highlight_mode, background_mode, OpenSCADOperator::DIFFERENCE, shaderinfo);
+      createChainObject(container, vbo_builder, csgobj, highlight_mode,
+                        background_mode, OpenSCADOperator::DIFFERENCE,
+                        shaderinfo);
     }
   }
 }
 
-BoundingBox ThrownTogetherRenderer::getBoundingBox() const
-{
+BoundingBox ThrownTogetherRenderer::getBoundingBox() const {
   BoundingBox bbox;
   if (this->root_products_) {
     bbox = this->root_products_->getBoundingBox(true);
diff --git a/src/glview/preview/ThrownTogetherRenderer.h b/src/glview/preview/ThrownTogetherRenderer.h
index dbe881493..e82072394 100644
--- a/src/glview/preview/ThrownTogetherRenderer.h
+++ b/src/glview/preview/ThrownTogetherRenderer.h
@@ -7,66 +7,96 @@
 #include "core/CSGNode.h"
 #include "core/enums.h"
 #include "geometry/linalg.h"
-#include "glview/system-gl.h"
-#include "glview/VBORenderer.h"
-#include "glview/VertexState.h"
 #include "glview/ShaderUtils.h"
 #include "glview/VBOBuilder.h"
+#include "glview/VBORenderer.h"
+#include "glview/VertexState.h"
+#include "glview/system-gl.h"
 
 class CSGProducts;
 class CSGChainObject;
 
-class TTRVertexState : public VertexState
-{
-public:
+class TTRVertexState : public VertexState {
+ public:
   TTRVertexState(size_t csg_object_index = 0)
-    : csg_object_index_(csg_object_index) {}
-  TTRVertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
-                 size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo,
+      : csg_object_index_(csg_object_index) {}
+  TTRVertexState(GLenum draw_mode,
+                 GLsizei draw_size,
+                 GLenum draw_type,
+                 size_t draw_offset,
+                 size_t element_offset,
+                 GLuint vertices_vbo,
+                 GLuint elements_vbo,
                  size_t csg_object_index = 0)
-    : VertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo), csg_object_index_(csg_object_index)
-  {}
+      : VertexState(draw_mode,
+                    draw_size,
+                    draw_type,
+                    draw_offset,
+                    element_offset,
+                    vertices_vbo,
+                    elements_vbo),
+        csg_object_index_(csg_object_index) {}
 
   [[nodiscard]] size_t csgObjectIndex() const { return csg_object_index_; }
-  void setCsgObjectIndex(size_t csg_object_index) { csg_object_index_ = csg_object_index; }
+  void setCsgObjectIndex(size_t csg_object_index) {
+    csg_object_index_ = csg_object_index;
+  }
 
-private:
+ private:
   size_t csg_object_index_;
 };
 
-class TTRVertexStateFactory : public VertexStateFactory
-{
-public:
+class TTRVertexStateFactory : public VertexStateFactory {
+ public:
   TTRVertexStateFactory() = default;
 
-  [[nodiscard]] std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
-                                                               size_t draw_offset, size_t element_offset,
-                                                               GLuint vertices_vbo, GLuint elements_vbo) const override {
-    return std::make_shared<TTRVertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] std::shared_ptr<VertexState> createVertexState(
+      GLenum draw_mode,
+      size_t draw_size,
+      GLenum draw_type,
+      size_t draw_offset,
+      size_t element_offset,
+      GLuint vertices_vbo,
+      GLuint elements_vbo) const override {
+    return std::make_shared<TTRVertexState>(draw_mode, draw_size, draw_type,
+                                            draw_offset, element_offset,
+                                            vertices_vbo, elements_vbo);
   }
 };
 
-class ThrownTogetherRenderer : public VBORenderer
-{
-public:
+class ThrownTogetherRenderer : public VBORenderer {
+ public:
   ThrownTogetherRenderer(std::shared_ptr<CSGProducts> root_products,
                          std::shared_ptr<CSGProducts> highlight_products,
                          std::shared_ptr<CSGProducts> background_products);
   ~ThrownTogetherRenderer() override = default;
-  void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  void prepare(const ShaderUtils::ShaderInfo* shaderinfo = nullptr) override;
+  void draw(bool showedges,
+            const ShaderUtils::ShaderInfo* shaderinfo = nullptr) const override;
 
   BoundingBox getBoundingBox() const override;
-private:
-  void renderCSGProducts(const std::shared_ptr<CSGProducts>& products, bool showedges = false,
-                         const ShaderUtils::ShaderInfo *shaderinfo = nullptr,
-                         bool highlight_mode = false, bool background_mode = false,
+
+ private:
+  void renderCSGProducts(const std::shared_ptr<CSGProducts>& products,
+                         bool showedges = false,
+                         const ShaderUtils::ShaderInfo* shaderinfo = nullptr,
+                         bool highlight_mode = false,
+                         bool background_mode = false,
                          bool fberror = false) const;
 
-  void createCSGProducts(const CSGProducts& products, VertexStateContainer& container, VBOBuilder& vbo_builder,
-                         bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo);
-  void createChainObject(VertexStateContainer& container, VBOBuilder& vbo_builder, const CSGChainObject& csgobj,
-                         bool highlight_mode, bool background_mode, OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo);
+  void createCSGProducts(const CSGProducts& products,
+                         VertexStateContainer& container,
+                         VBOBuilder& vbo_builder,
+                         bool highlight_mode,
+                         bool background_mode,
+                         const ShaderUtils::ShaderInfo* shaderinfo);
+  void createChainObject(VertexStateContainer& container,
+                         VBOBuilder& vbo_builder,
+                         const CSGChainObject& csgobj,
+                         bool highlight_mode,
+                         bool background_mode,
+                         OpenSCADOperator type,
+                         const ShaderUtils::ShaderInfo* shaderinfo);
 
   std::shared_ptr<CSGProducts> root_products_;
   std::shared_ptr<CSGProducts> highlight_products_;
diff --git a/src/glview/system-gl.cc b/src/glview/system-gl.cc
index fddc5f0fb..c72f07a4e 100644
--- a/src/glview/system-gl.cc
+++ b/src/glview/system-gl.cc
@@ -13,16 +13,15 @@
 
 #include <algorithm>
 #include <iostream>
-#include <vector>
 #include <sstream>
 #include <string>
+#include <vector>
 
 #include <boost/algorithm/string.hpp>
 #include <boost/format.hpp>
 
-static double gl_version()
-{
-  std::string tmp((const char *)glGetString(GL_VERSION));
+static double gl_version() {
+  std::string tmp((const char*)glGetString(GL_VERSION));
   std::vector<std::string> strs;
   boost::split(strs, tmp, boost::is_any_of("."));
   std::stringstream out;
@@ -36,18 +35,17 @@ static double gl_version()
   return d;
 }
 
-std::string gl_extensions_dump()
-{
+std::string gl_extensions_dump() {
   std::string tmp;
   if (gl_version() >= 3.0) {
     GLint numexts = 0;
     glGetIntegerv(GL_NUM_EXTENSIONS, &numexts);
     for (int i = 0; i < numexts; ++i) {
-      tmp += (const char *) glGetStringi(GL_EXTENSIONS, i);
+      tmp += (const char*)glGetStringi(GL_EXTENSIONS, i);
       tmp += " ";
     }
   } else {
-    tmp = (const char *) glGetString(GL_EXTENSIONS);
+    tmp = (const char*)glGetString(GL_EXTENSIONS);
   }
   std::vector<std::string> extensions;
   boost::split(extensions, tmp, boost::is_any_of(" "));
@@ -60,8 +58,7 @@ std::string gl_extensions_dump()
   return out.str();
 }
 
-std::string gl_dump()
-{
+std::string gl_dump() {
   GLint rbits, gbits, bbits, abits, dbits, sbits;
   glGetIntegerv(GL_RED_BITS, &rbits);
   glGetIntegerv(GL_GREEN_BITS, &gbits);
@@ -77,17 +74,16 @@ std::string gl_dump()
 #ifdef USE_GLAD
   out << "GLAD version: " << GLAD_GENERATOR_VERSION;
 #endif
-  out << "\nOpenGL Version: " << (const char *)glGetString(GL_VERSION)
-      << "\nGL Renderer: " << (const char *)glGetString(GL_RENDERER)
-      << "\nGL Vendor: " << (const char *)glGetString(GL_VENDOR)
-      << boost::format("\nRGBA(%d%d%d%d), depth(%d), stencil(%d)") %
-    rbits % gbits % bbits % abits % dbits % sbits;
+  out << "\nOpenGL Version: " << (const char*)glGetString(GL_VERSION)
+      << "\nGL Renderer: " << (const char*)glGetString(GL_RENDERER)
+      << "\nGL Vendor: " << (const char*)glGetString(GL_VENDOR)
+      << boost::format("\nRGBA(%d%d%d%d), depth(%d), stencil(%d)") % rbits %
+             gbits % bbits % abits % dbits % sbits;
   out << "\nGL_ARB_framebuffer_object: "
       << (hasGLExtension(ARB_framebuffer_object) ? "yes" : "no")
       << "\nGL_EXT_framebuffer_object: "
       << (hasGLExtension(EXT_framebuffer_object) ? "yes" : "no")
       << "\nGL_EXT_packed_depth_stencil: "
-      << (hasGLExtension(EXT_packed_depth_stencil) ? "yes" : "no")
-      << "\n";
+      << (hasGLExtension(EXT_packed_depth_stencil) ? "yes" : "no") << "\n";
   return out.str();
 }
diff --git a/src/glview/system-gl.h b/src/glview/system-gl.h
index 07aecfd38..10145a6c5 100644
--- a/src/glview/system-gl.h
+++ b/src/glview/system-gl.h
@@ -6,17 +6,18 @@
 #include <GL/glew.h>
 #endif
 #ifdef USE_GLAD
-  #ifdef _WIN32
-  #define NORESOURCE // To avoid picking up DIFFERENCE from winuser.h, conflicting with OpenSCADOperator::DIFFERENCE
-  #include <windows.h>
-  #endif
+#ifdef _WIN32
+#define NORESOURCE  // To avoid picking up DIFFERENCE from winuser.h,
+                    // conflicting with OpenSCADOperator::DIFFERENCE
+#include <windows.h>
+#endif
 #include "glad/gl.h"
 #endif
 
 #ifdef __APPLE__
- #include <OpenGL/glu.h>  // IWYU pragma: export
+#include <OpenGL/glu.h>  // IWYU pragma: export
 #else
- #include <GL/glu.h>
+#include <GL/glu.h>
 #endif
 
 #include <string>
@@ -25,29 +26,30 @@
 namespace {
 
 // Returns true on OK, false on error
-[[maybe_unused]] bool glCheck(const char *stmt, const char *file, int line)
-{
+[[maybe_unused]] bool glCheck(const char* stmt, const char* file, int line) {
   if (const auto err = glGetError(); err != GL_NO_ERROR) {
     LOG(message_group::Error, Location::NONE, "",
         "OpenGL error: %1$s (0x%2$04x) in %3$s:%4$d\n"
-        "              %5$s\n", gluErrorString(err), err, file, line, stmt);
+        "              %5$s\n",
+        gluErrorString(err), err, file, line, stmt);
     return false;
   }
   return true;
 }
 
 // Returns true on OK, false on error
-[[maybe_unused]] bool glCheckd(const char *stmt, const char *file, int line)
-{
+[[maybe_unused]] bool glCheckd(const char* stmt, const char* file, int line) {
   if (const auto err = glGetError(); err != GL_NO_ERROR) {
-    PRINTDB("OpenGL error: %s (0x%04x) in %s:%d\n"
-            "              %s\n", gluErrorString(err) % err % file % line % stmt);
+    PRINTDB(
+        "OpenGL error: %s (0x%04x) in %s:%d\n"
+        "              %s\n",
+        gluErrorString(err) % err % file % line % stmt);
     return false;
   }
   return true;
 }
 
-} // namespace
+}  // namespace
 
 // We have 4 different GL checks:
 // GL_CHECK(statement);
@@ -65,54 +67,65 @@ namespace {
 //   This is fast in release mode (executes statement only).
 
 // GL_CHECK(statement);
-// Use this for important error output causes output on error, also in release mode.
+// Use this for important error output causes output on error, also in release
+// mode.
 //
 // This example will print an error if glClear() fails:
 // GL_CHECK(glClear());
-#define GL_CHECK(stmt) stmt; glCheck(#stmt, __FILE__, __LINE__)
+#define GL_CHECK(stmt) \
+  stmt;                \
+  glCheck(#stmt, __FILE__, __LINE__)
 
 // IF_GL_CHECK(statement) then_statement;
-// Use this for important error handling which always causes an error, also in release mode
+// Use this for important error handling which always causes an error, also in
+// release mode
 //
 // This example will print an error and return false if glClear() fails:
 // IF_GL_CHECK(glClear()) return false;
-#define IF_GL_CHECK(stmt) stmt; if (!glCheck(#stmt, __FILE__, __LINE__))
+#define IF_GL_CHECK(stmt) \
+  stmt;                   \
+  if (!glCheck(#stmt, __FILE__, __LINE__))
 
 // GL_CHECKD(statement);
-// Use this for OpenGL debug error output which should make it into the release build
-// Enable debug output at runtime using --enable=
-// Note: This always checks glGetError(), so it will have performance implications.
+// Use this for OpenGL debug error output which should make it into the release
+// build Enable debug output at runtime using --enable= Note: This always checks
+// glGetError(), so it will have performance implications.
 //
-// This example will print an error if glClear() fails, and if --debug is specified:
-// GL_CHECKD(glClear());
-#define GL_CHECKD(stmt) stmt; glCheckd(#stmt, __FILE__, __LINE__)
+// This example will print an error if glClear() fails, and if --debug is
+// specified: GL_CHECKD(glClear());
+#define GL_CHECKD(stmt) \
+  stmt;                 \
+  glCheckd(#stmt, __FILE__, __LINE__)
 
 // GL_DEBUG_CHECKD(statement)
 // Use this for OpenGL debug output which needs to be fast in release mode
-// Debug output is only available for debug build and only when using --enable= at runtime
+// Debug output is only available for debug build and only when using --enable=
+// at runtime
 //
-// This example will print an error if glClear() fails if --debug is specified, but yields just glClear in release mode.
-// GL_DEBUG_CHECKD(glClear());
+// This example will print an error if glClear() fails if --debug is specified,
+// but yields just glClear in release mode. GL_DEBUG_CHECKD(glClear());
 #ifdef DEBUG
-#define GL_DEBUG_CHECKD(stmt) stmt; glCheckd(#stmt, __FILE__, __LINE__)
+#define GL_DEBUG_CHECKD(stmt) \
+  stmt;                       \
+  glCheckd(#stmt, __FILE__, __LINE__)
 #else
 #define GL_DEBUG_CHECKD(stmt) stmt
 #endif
 
-#else // NULLGL
+#else  // NULLGL
 
 #define GLint int
 #define GLuint unsigned int
 #define GLdouble unsigned int
-inline void glColor4fv(float *c) {}
+inline void glColor4fv(float* c) {}
 
-#endif // NULLGL
+#endif  // NULLGL
 
 #ifdef USE_GLEW
 #define hasGLExtension(ext) glewIsSupported("GL_" #ext)
 #endif
 #ifdef USE_GLAD
-#define hasGLExtension(ext) GLAD_GL_ ## ext
+#define hasGLExtension(ext) GLAD_GL_##ext
 #endif
 
 std::string gl_dump();
diff --git a/src/gui/AboutDialog.h b/src/gui/AboutDialog.h
index 3f61029da..d7eae28b6 100644
--- a/src/gui/AboutDialog.h
+++ b/src/gui/AboutDialog.h
@@ -1,23 +1,24 @@
 #pragma once
 
-#include "version.h"
 #include <QDialog>
 #include <QWidget>
 #include "gui/qtgettext.h"
 #include "ui_AboutDialog.h"
+#include "version.h"
 
-class AboutDialog : public QDialog, public Ui::AboutDialog
-{
+class AboutDialog : public QDialog, public Ui::AboutDialog {
   Q_OBJECT;
-public:
-  AboutDialog(QWidget *) {
+
+ public:
+  AboutDialog(QWidget*) {
     setupUi(this);
-    this->setWindowTitle(QString(_("About OpenSCAD")) + " " + openscad_shortversionnumber.c_str());
+    this->setWindowTitle(QString(_("About OpenSCAD")) + " " +
+                         openscad_shortversionnumber.c_str());
     QString tmp = this->aboutText->toHtml();
     tmp.replace("__VERSION__", openscad_detailedversionnumber.c_str());
     this->aboutText->setHtml(tmp);
   }
 
-public slots:
+ public slots:
   void on_okPushButton_clicked() { accept(); }
 };
diff --git a/src/gui/Animate.cc b/src/gui/Animate.cc
index 44b18e069..53d2cc01e 100644
--- a/src/gui/Animate.cc
+++ b/src/gui/Animate.cc
@@ -1,38 +1,38 @@
 #include "gui/Animate.h"
 
-#include <string>
 #include <QAction>
 #include <QBoxLayout>
+#include <QFormLayout>
 #include <QIcon>
 #include <QList>
 #include <QPushButton>
 #include <QResizeEvent>
 #include <QTimer>
 #include <QWidget>
-#include <iostream>
 #include <filesystem>
-#include <QFormLayout>
+#include <iostream>
+#include <string>
 
-#include "utils/printutils.h"
 #include "gui/MainWindow.h"
 #include "gui/UIUtils.h"
 #include "openscad_gui.h"
+#include "utils/printutils.h"
 
-Animate::Animate(QWidget *parent) : QWidget(parent)
-{
+Animate::Animate(QWidget* parent) : QWidget(parent) {
   setupUi(this);
   initGUI();
 
   const auto width = groupBoxParameter->minimumSizeHint().width();
   const auto margins = layout()->contentsMargins();
-  const auto scrollMargins = scrollAreaWidgetContents->layout()->contentsMargins();
+  const auto scrollMargins =
+      scrollAreaWidgetContents->layout()->contentsMargins();
   const auto parameterMargins = groupBoxParameter->layout()->contentsMargins();
-  initMinWidth = width + margins.left() + margins.right() + scrollMargins.left() + scrollMargins.right()
-    + parameterMargins.left() + parameterMargins.right();
+  initMinWidth = width + margins.left() + margins.right() +
+                 scrollMargins.left() + scrollMargins.right() +
+                 parameterMargins.left() + parameterMargins.right();
 }
 
-void Animate::initGUI()
-{
+void Animate::initGUI() {
   this->animStep = 0;
   this->animNumSteps = 0;
   this->animTVal = 0.0;
@@ -46,14 +46,16 @@ void Animate::initGUI()
   animateTimer = new QTimer(this);
   connect(animateTimer, &QTimer::timeout, this, &Animate::incrementTVal);
 
-  connect(this->e_tval, &QLineEdit::textChanged, this, &Animate::updatedAnimTval);
-  connect(this->e_fps, &QLineEdit::textChanged, this, &Animate::updatedAnimFpsAndAnimSteps);
-  connect(this->e_fsteps, &QLineEdit::textChanged, this, &Animate::updatedAnimFpsAndAnimSteps);
+  connect(this->e_tval, &QLineEdit::textChanged, this,
+          &Animate::updatedAnimTval);
+  connect(this->e_fps, &QLineEdit::textChanged, this,
+          &Animate::updatedAnimFpsAndAnimSteps);
+  connect(this->e_fsteps, &QLineEdit::textChanged, this,
+          &Animate::updatedAnimFpsAndAnimSteps);
   connect(this->e_dump, &QCheckBox::toggled, this, &Animate::updatedAnimDump);
 }
 
-void Animate::setMainWindow(MainWindow *mainWindow)
-{
+void Animate::setMainWindow(MainWindow* mainWindow) {
   this->mainWindow = mainWindow;
 
   connectAction(this->actionAnimationPauseUnpause, pauseButton);
@@ -64,14 +66,12 @@ void Animate::setMainWindow(MainWindow *mainWindow)
   updatePauseButtonIcon();
 }
 
-void Animate::connectAction(QAction *action, QPushButton *button)
-{
+void Animate::connectAction(QAction* action, QPushButton* button) {
   connect(action, &QAction::triggered, button, &QPushButton::click);
   this->actionList.append(action);
 }
 
-void Animate::updatedAnimTval()
-{
+void Animate::updatedAnimTval() {
   double t = this->e_tval->text().toDouble(&this->tOK);
   // Clamp t to 0-1
   if (this->tOK) {
@@ -86,8 +86,7 @@ void Animate::updatedAnimTval()
   updatePauseButtonIcon();
 }
 
-void Animate::updatedAnimFpsAndAnimSteps()
-{
+void Animate::updatedAnimFpsAndAnimSteps() {
   animateTimer->stop();
 
   int numsteps = this->e_fsteps->text().toInt(&this->steps_ok);
@@ -101,7 +100,8 @@ void Animate::updatedAnimFpsAndAnimSteps()
   double fps = this->e_fps->text().toDouble(&this->fpsOK);
   animateTimer->stop();
   if (this->fpsOK && fps > 0 && this->animNumSteps > 0) {
-    this->animStep = int(this->animTVal * this->animNumSteps) % this->animNumSteps;
+    this->animStep =
+        int(this->animTVal * this->animNumSteps) % this->animNumSteps;
     animateTimer->setSingleShot(false);
     animateTimer->setInterval(int(1000 / fps));
     animateTimer->start();
@@ -109,7 +109,8 @@ void Animate::updatedAnimFpsAndAnimSteps()
 
   QPalette defaultPalette;
   const auto bgColor = defaultPalette.base().color().toRgb();
-  QString redStyleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
+  QString redStyleSheet =
+      UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
 
   if (this->steps_ok || this->e_fsteps->text() == "") {
     this->e_fsteps->setStyleSheet("");
@@ -126,21 +127,21 @@ void Animate::updatedAnimFpsAndAnimSteps()
   updatePauseButtonIcon();
 }
 
-
-void Animate::updatedAnimDump(bool checked)
-{
-  if (!checked) this->animDumping = false;
+void Animate::updatedAnimDump(bool checked) {
+  if (!checked)
+    this->animDumping = false;
 
   updatePauseButtonIcon();
 }
 
 // Only called from animate_timer
-void Animate::incrementTVal()
-{
-  if (this->animNumSteps == 0) return;
+void Animate::incrementTVal() {
+  if (this->animNumSteps == 0)
+    return;
 
   if (mainWindow->parameterDock->isVisible()) {
-    if (mainWindow->activeEditor->parameterWidget->childHasFocus()) return;
+    if (mainWindow->activeEditor->parameterWidget->childHasFocus())
+      return;
   }
 
   if (this->animNumSteps > 1) {
@@ -157,9 +158,9 @@ void Animate::incrementTVal()
   updatePauseButtonIcon();
 }
 
-void Animate::updateTVal()
-{
-  if (this->animNumSteps == 0) return;
+void Animate::updateTVal() {
+  if (this->animNumSteps == 0)
+    return;
 
   if (this->animStep < 0) {
     this->animStep = this->animNumSteps - this->animStep - 2;
@@ -179,13 +180,12 @@ void Animate::updateTVal()
   updatePauseButtonIcon();
 }
 
-void Animate::pauseAnimation(){
+void Animate::pauseAnimation() {
   animateTimer->stop();
   updatePauseButtonIcon();
 }
 
-void Animate::on_pauseButton_pressed()
-{
+void Animate::on_pauseButton_pressed() {
   if (animateTimer->isActive()) {
     animateTimer->stop();
     updatePauseButtonIcon();
@@ -194,32 +194,30 @@ void Animate::on_pauseButton_pressed()
   }
 }
 
-void Animate::updatePauseButtonIcon()
-{
+void Animate::updatePauseButtonIcon() {
   if (animateTimer->isActive()) {
     pauseButton->setIcon(this->iconPause);
-    pauseButton->setToolTip(_("press to pause animation") );
+    pauseButton->setToolTip(_("press to pause animation"));
   } else {
     if (this->fpsOK && this->steps_ok) {
       pauseButton->setIcon(this->iconRun);
-      pauseButton->setToolTip(_("press to start animation") );
+      pauseButton->setToolTip(_("press to start animation"));
     } else {
       pauseButton->setIcon(this->iconDisabled);
-      pauseButton->setToolTip(_("incorrect values") );
+      pauseButton->setToolTip(_("incorrect values"));
     }
   }
 }
 
-void Animate::cameraChanged(){
-  this->animateUpdate(); //for now so that we do not change the behavior
+void Animate::cameraChanged() {
+  this->animateUpdate();  // for now so that we do not change the behavior
 }
 
-void Animate::editorContentChanged(){
-  this->animateUpdate(); //for now so that we do not change the behavior
+void Animate::editorContentChanged() {
+  this->animateUpdate();  // for now so that we do not change the behavior
 }
 
-void Animate::animateUpdate()
-{
+void Animate::animateUpdate() {
   if (mainWindow->animateDockContents->isVisible()) {
     double fps = this->e_fps->text().toDouble(&this->fpsOK);
     if (this->fpsOK && fps <= 0 && !animateTimer->isActive()) {
@@ -231,11 +229,11 @@ void Animate::animateUpdate()
   }
 }
 
-bool Animate::dumpPictures(){
+bool Animate::dumpPictures() {
   return this->e_dump->isChecked() && this->animateTimer->isActive();
 }
 
-int Animate::nextFrame(){
+int Animate::nextFrame() {
   if (animDumping && animDumpStartStep == animStep) {
     animDumping = false;
     e_dump->setChecked(false);
@@ -248,10 +246,10 @@ int Animate::nextFrame(){
   return animStep;
 }
 
-void Animate::resizeEvent(QResizeEvent *event)
-{
-  auto layoutParameters = dynamic_cast<QBoxLayout *>(groupBoxParameter->layout());
-  auto layoutButtons = dynamic_cast<QBoxLayout *>(groupBoxButtons->layout());
+void Animate::resizeEvent(QResizeEvent* event) {
+  auto layoutParameters =
+      dynamic_cast<QBoxLayout*>(groupBoxParameter->layout());
+  auto layoutButtons = dynamic_cast<QBoxLayout*>(groupBoxButtons->layout());
 
   if (layoutParameters && layoutButtons) {
     if (layoutParameters->direction() == QBoxLayout::LeftToRight) {
@@ -272,14 +270,14 @@ void Animate::resizeEvent(QResizeEvent *event)
   QWidget::resizeEvent(event);
 }
 
-const QList<QAction *>& Animate::actions(){
+const QList<QAction*>& Animate::actions() {
   return actionList;
 }
 
-void Animate::onActionEvent(InputEventAction *event)
-{
+void Animate::onActionEvent(InputEventAction* event) {
   const std::string actionString = event->action;
-  const std::string actionName = actionString.substr(actionString.find("::") + 2, std::string::npos);
+  const std::string actionName =
+      actionString.substr(actionString.find("::") + 2, std::string::npos);
   for (auto action : actionList) {
     if (actionName == action->objectName().toStdString()) {
       action->trigger();
@@ -287,29 +285,29 @@ void Animate::onActionEvent(InputEventAction *event)
   }
 }
 
-double Animate::getAnimTval(){
+double Animate::getAnimTval() {
   return animTVal;
 }
 
-void Animate::on_pushButton_MoveToBeginning_clicked(){
+void Animate::on_pushButton_MoveToBeginning_clicked() {
   pauseAnimation();
   this->animStep = 0;
   this->updateTVal();
 }
 
-void Animate::on_pushButton_StepBack_clicked(){
+void Animate::on_pushButton_StepBack_clicked() {
   pauseAnimation();
   this->animStep -= 1;
   this->updateTVal();
 }
 
-void Animate::on_pushButton_StepForward_clicked(){
+void Animate::on_pushButton_StepForward_clicked() {
   pauseAnimation();
   this->animStep += 1;
   this->updateTVal();
 }
 
-void Animate::on_pushButton_MoveToEnd_clicked(){
+void Animate::on_pushButton_MoveToEnd_clicked() {
   pauseAnimation();
   this->animStep = this->animNumSteps - 1;
   this->updateTVal();
diff --git a/src/gui/Animate.h b/src/gui/Animate.h
index ea2a29094..eb8efd697 100644
--- a/src/gui/Animate.h
+++ b/src/gui/Animate.h
@@ -8,19 +8,18 @@
 #include <QWidget>
 #include <string>
 
-#include "gui/qtgettext.h"
-#include "ui_Animate.h"
 #include <QIcon>
 #include "gui/input/InputDriverEvent.h"
+#include "gui/qtgettext.h"
+#include "ui_Animate.h"
 
 class MainWindow;
 
-class Animate : public QWidget, public Ui::AnimateWidget
-{
+class Animate : public QWidget, public Ui::AnimateWidget {
   Q_OBJECT
 
-public:
-  Animate(QWidget *parent = nullptr);
+ public:
+  Animate(QWidget* parent = nullptr);
   Animate(const Animate& source) = delete;
   Animate(Animate&& source) = delete;
   Animate& operator=(const Animate& source) = delete;
@@ -31,18 +30,18 @@ public:
   bool dumpPictures();
   int nextFrame();
 
-  QTimer *animateTimer;
+  QTimer* animateTimer;
 
-  void setMainWindow(MainWindow *mainWindow);
+  void setMainWindow(MainWindow* mainWindow);
 
-  const QList<QAction *>& actions();
+  const QList<QAction*>& actions();
   double getAnimTval();
 
-public slots:
+ public slots:
   void animateUpdate();
   void cameraChanged();
   void editorContentChanged();
-  void onActionEvent(InputEventAction *event);
+  void onActionEvent(InputEventAction* event);
   void pauseAnimation();
 
   void on_pushButton_MoveToBeginning_clicked();
@@ -50,15 +49,14 @@ public slots:
   void on_pushButton_StepForward_clicked();
   void on_pushButton_MoveToEnd_clicked();
 
-protected:
-  void resizeEvent(QResizeEvent *event) override;
-
+ protected:
+  void resizeEvent(QResizeEvent* event) override;
 
-private:
-  MainWindow *mainWindow;
+ private:
+  MainWindow* mainWindow;
 
   void updatePauseButtonIcon();
-  void connectAction(QAction *, QPushButton *);
+  void connectAction(QAction*, QPushButton*);
 
   double animTVal;
   bool animDumping;
@@ -75,12 +73,12 @@ private:
   QIcon iconRun;
   QIcon iconPause;
   QIcon iconDisabled;
-  QList<QAction *> actionList;
+  QList<QAction*> actionList;
   QColor errorBlendColor{"red"};
 
-signals:
+ signals:
 
-private slots:
+ private slots:
   void updatedAnimTval();
   void updatedAnimFpsAndAnimSteps();
   void updatedAnimDump(bool checked);
diff --git a/src/gui/AppleEvents.cc b/src/gui/AppleEvents.cc
index c5c0205e1..6323350f2 100644
--- a/src/gui/AppleEvents.cc
+++ b/src/gui/AppleEvents.cc
@@ -1,21 +1,21 @@
 #include "gui/AppleEvents.h"
-#include <MacTypes.h>
 #include <AssertMacros.h>
 #include <CoreServices/CoreServices.h>
+#include <MacTypes.h>
 #include <QApplication>
 #include "gui/MainWindow.h"
 
 extern "C" {
-OSErr eventHandler(const AppleEvent *ev, AppleEvent *reply, SRefCon refcon);
+OSErr eventHandler(const AppleEvent* ev, AppleEvent* reply, SRefCon refcon);
 }
 
-OSErr eventHandler(const AppleEvent *, AppleEvent *, SRefCon)
-{
-// FIXME: Ugly hack; just using the first MainWindow we can find
-  MainWindow *mainwin = nullptr;
+OSErr eventHandler(const AppleEvent*, AppleEvent*, SRefCon) {
+  // FIXME: Ugly hack; just using the first MainWindow we can find
+  MainWindow* mainwin = nullptr;
   for (auto& w : QApplication::topLevelWidgets()) {
-    mainwin = qobject_cast<MainWindow *>(w);
-    if (mainwin) break;
+    mainwin = qobject_cast<MainWindow*>(w);
+    if (mainwin)
+      break;
   }
   if (mainwin) {
     mainwin->actionReloadRenderPreview();
@@ -23,10 +23,10 @@ OSErr eventHandler(const AppleEvent *, AppleEvent *, SRefCon)
   return noErr;
 }
 
-void installAppleEventHandlers()
-{
+void installAppleEventHandlers() {
   // Reload handler
-  auto err = AEInstallEventHandler('SCAD', 'relo', NewAEEventHandlerUPP(eventHandler), nullptr, true);
+  auto err = AEInstallEventHandler(
+      'SCAD', 'relo', NewAEEventHandlerUPP(eventHandler), nullptr, true);
   __Require_noErr(err, CantInstallAppleEventHandler);
   return;
 
diff --git a/src/gui/AutoUpdater.cc b/src/gui/AutoUpdater.cc
index 92279e24c..12ecd45f4 100644
--- a/src/gui/AutoUpdater.cc
+++ b/src/gui/AutoUpdater.cc
@@ -2,10 +2,9 @@
 #include <QAction>
 #include <QMenuBar>
 
-AutoUpdater *AutoUpdater::updater_instance = nullptr;
+AutoUpdater* AutoUpdater::updater_instance = nullptr;
 
-void AutoUpdater::init()
-{
+void AutoUpdater::init() {
 #ifdef OPENSCAD_UPDATER
   if (!this->updateAction) {
     auto mb = new QMenuBar();
@@ -14,10 +13,10 @@ void AutoUpdater::init()
     // Add to application menu
     this->updateAction->setMenuRole(QAction::ApplicationSpecificRole);
     this->updateAction->setEnabled(true);
-    this->connect(this->updateAction, &AutoUpdater::triggered, this, &AutoUpdater::checkForUpdates);
+    this->connect(this->updateAction, &AutoUpdater::triggered, this,
+                  &AutoUpdater::checkForUpdates);
 
     this->updateMenu->addAction(this->updateAction);
-
   }
-#endif // ifdef OPENSCAD_UPDATER
+#endif  // ifdef OPENSCAD_UPDATER
 }
diff --git a/src/gui/AutoUpdater.h b/src/gui/AutoUpdater.h
index 8df135493..19485a577 100644
--- a/src/gui/AutoUpdater.h
+++ b/src/gui/AutoUpdater.h
@@ -1,16 +1,15 @@
 #pragma once
 
-#include <QString>
 #include <QObject>
+#include <QString>
 
 class QAction;
 class QMenu;
 
-class AutoUpdater : public QObject
-{
+class AutoUpdater : public QObject {
   Q_OBJECT;
 
-public:
+ public:
   AutoUpdater() = default;
 
   virtual void setAutomaticallyChecksForUpdates(bool on) = 0;
@@ -20,17 +19,16 @@ public:
   virtual QString lastUpdateCheckDate() = 0;
   virtual void init();
 
-  static AutoUpdater *updater() { return updater_instance; }
-  static void setUpdater(AutoUpdater *updater) { updater_instance = updater; }
+  static AutoUpdater* updater() { return updater_instance; }
+  static void setUpdater(AutoUpdater* updater) { updater_instance = updater; }
 
-public slots:
+ public slots:
   virtual void checkForUpdates() = 0;
 
+ public:
+  QAction* updateAction{nullptr};
+  QMenu* updateMenu{nullptr};
 
-public:
-  QAction *updateAction{nullptr};
-  QMenu *updateMenu{nullptr};
-
-protected:
-  static AutoUpdater *updater_instance;
+ protected:
+  static AutoUpdater* updater_instance;
 };
diff --git a/src/gui/CGALWorker.cc b/src/gui/CGALWorker.cc
index c229e46dc..604394148 100644
--- a/src/gui/CGALWorker.cc
+++ b/src/gui/CGALWorker.cc
@@ -1,38 +1,36 @@
 #include "gui/CGALWorker.h"
+#include <QThread>
 #include <exception>
 #include <memory>
-#include <QThread>
 
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
 #include "core/Tree.h"
-#include "geometry/GeometryEvaluator.h"
 #include "core/progress.h"
-#include "utils/printutils.h"
+#include "geometry/GeometryEvaluator.h"
 #include "utils/exceptions.h"
+#include "utils/printutils.h"
 
 #ifdef ENABLE_PYTHON
 #include "python/python_public.h"
 #endif
 
-CGALWorker::CGALWorker()
-{
+CGALWorker::CGALWorker() {
   this->tree = nullptr;
   this->thread = new QThread();
-  if (this->thread->stackSize() < 1024 * 1024) this->thread->setStackSize(1024 * 1024);
+  if (this->thread->stackSize() < 1024 * 1024)
+    this->thread->setStackSize(1024 * 1024);
   connect(this->thread, &QThread::started, this, &CGALWorker::work);
   moveToThread(this->thread);
 }
 
-CGALWorker::~CGALWorker()
-{
+CGALWorker::~CGALWorker() {
   delete this->thread;
 }
 
-void CGALWorker::start(const Tree& tree)
-{
+void CGALWorker::start(const Tree& tree) {
 #ifdef ENABLE_PYTHON
   python_unlock();
 #endif
@@ -40,9 +38,9 @@ void CGALWorker::start(const Tree& tree)
   this->thread->start();
 }
 
-void CGALWorker::work()
-{
-  // this is a worker thread: we don't want any exceptions escaping and crashing the app.
+void CGALWorker::work() {
+  // this is a worker thread: we don't want any exceptions escaping and crashing
+  // the app.
 #ifdef ENABLE_PYTHON
   python_lock();
 #endif
@@ -52,11 +50,15 @@ void CGALWorker::work()
     root_geom = evaluator.evaluateGeometry(*this->tree->root(), true);
 
 #ifdef ENABLE_MANIFOLD
-    if (auto manifold = std::dynamic_pointer_cast<const ManifoldGeometry>(root_geom)) {
+    if (auto manifold =
+            std::dynamic_pointer_cast<const ManifoldGeometry>(root_geom)) {
       // calling status forces evaluation
       // we should complete evaluation within the worker thread, so computation
       // will not block the GUI.
-      if (manifold->getManifold().Status() != manifold::Manifold::Error::NoError)LOG(message_group::Error, "Rendering cancelled due to unknown manifold error.");
+      if (manifold->getManifold().Status() !=
+          manifold::Manifold::Error::NoError)
+        LOG(message_group::Error,
+            "Rendering cancelled due to unknown manifold error.");
     }
 #endif
   } catch (const ProgressCancelException& e) {
@@ -64,13 +66,14 @@ void CGALWorker::work()
   } catch (const HardWarningException& e) {
     LOG("Rendering cancelled on first warning.");
   } catch (const std::exception& e) {
-    LOG(message_group::Error, "Rendering cancelled by exception %1$s", e.what());
+    LOG(message_group::Error, "Rendering cancelled by exception %1$s",
+        e.what());
   } catch (...) {
     LOG(message_group::Error, "Rendering cancelled by unknown exception.");
   }
- #ifdef ENABLE_PYTHON
+#ifdef ENABLE_PYTHON
   python_unlock();
- #endif
+#endif
   emit done(root_geom);
   thread->quit();
 }
diff --git a/src/gui/CGALWorker.h b/src/gui/CGALWorker.h
index 7bb4f85fc..5d3468a9a 100644
--- a/src/gui/CGALWorker.h
+++ b/src/gui/CGALWorker.h
@@ -5,24 +5,23 @@
 
 class Tree;
 
-class CGALWorker : public QObject
-{
+class CGALWorker : public QObject {
   Q_OBJECT;
-public:
+
+ public:
   CGALWorker();
   ~CGALWorker() override;
 
-public slots:
+ public slots:
   void start(const Tree& tree);
 
-protected slots:
+ protected slots:
   void work();
 
-signals:
+ signals:
   void done(std::shared_ptr<const class Geometry>);
 
-protected:
-
-  class QThread *thread;
-  const class Tree *tree;
+ protected:
+  class QThread* thread;
+  const class Tree* tree;
 };
diff --git a/src/gui/Console.cc b/src/gui/Console.cc
index d69cee757..32d751ed2 100644
--- a/src/gui/Console.cc
+++ b/src/gui/Console.cc
@@ -29,72 +29,74 @@
 #include <QBrush>
 #include <QColor>
 #include <QContextMenuEvent>
+#include <QFileDialog>
+#include <QFileInfo>
 #include <QFocusEvent>
+#include <QMenu>
 #include <QPlainTextEdit>
+#include <QRegularExpression>
+#include <QString>
 #include <QStringLiteral>
 #include <QTextCharFormat>
+#include <QTextStream>
 #include <QWidget>
 #include <cassert>
-#include <QMenu>
-#include <QFileInfo>
-#include <QFileDialog>
-#include <QTextStream>
-#include <QRegularExpression>
-#include <QString>
 #include "gui/MainWindow.h"
-#include "utils/printutils.h"
 #include "gui/Preferences.h"
 #include "gui/UIUtils.h"
+#include "utils/printutils.h"
 
-Console::Console(QWidget *parent) : QPlainTextEdit(parent)
-{
+Console::Console(QWidget* parent) : QPlainTextEdit(parent) {
   setupUi(this);
-  connect(this->actionClear, &QAction::triggered, this, &Console::actionClearConsole_triggered);
-  connect(this->actionSaveAs, &QAction::triggered, this, &Console::actionSaveAs_triggered);
+  connect(this->actionClear, &QAction::triggered, this,
+          &Console::actionClearConsole_triggered);
+  connect(this->actionSaveAs, &QAction::triggered, this,
+          &Console::actionSaveAs_triggered);
   connect(this, &Console::linkActivated, this, &Console::hyperlinkClicked);
   this->setUndoRedoEnabled(false);
   this->appendCursor = this->textCursor();
 }
 
-void Console::focusInEvent(QFocusEvent * /*event*/)
-{
-  QWidget *current = this;
-  MainWindow *mw;
-  while (current && !(mw = dynamic_cast<MainWindow *>(current->window()))) {
+void Console::focusInEvent(QFocusEvent* /*event*/) {
+  QWidget* current = this;
+  MainWindow* mw;
+  while (current && !(mw = dynamic_cast<MainWindow*>(current->window()))) {
     current = current->parentWidget();
   }
   assert(mw);
-  if (mw) mw->setLastFocus(this);
+  if (mw)
+    mw->setLastFocus(this);
 }
 
-void Console::addMessage(const Message& msg)
-{
+void Console::addMessage(const Message& msg) {
   // Messages with links to source must be inserted separately,
   // since anchor href is set via the "format" argument of:
-  //    QTextCursor::insertText(const QString &text, const QTextCharFormat &format)
-  // But if no link, and matching colors, then concat message strings with newline in between.
-  // This results in less calls to insertText in Console::update(), and much better performance.
-  if (!this->msgBuffer.empty() && msg.loc.isNone() && this->msgBuffer.back().link.isEmpty() &&
-      (getGroupColor(msg.group) == getGroupColor(this->msgBuffer.back().group)) ) {
+  //    QTextCursor::insertText(const QString &text, const QTextCharFormat
+  //    &format)
+  // But if no link, and matching colors, then concat message strings with
+  // newline in between. This results in less calls to insertText in
+  // Console::update(), and much better performance.
+  if (!this->msgBuffer.empty() && msg.loc.isNone() &&
+      this->msgBuffer.back().link.isEmpty() &&
+      (getGroupColor(msg.group) ==
+       getGroupColor(this->msgBuffer.back().group))) {
     auto& lastmsg = this->msgBuffer.back().message;
     lastmsg += QChar('\n');
     lastmsg += QString::fromStdString(msg.str());
   } else {
     this->msgBuffer.push_back(
-    {
-      QString::fromStdString(msg.str()),
-      (getGroupTextPlain(msg.group) || msg.loc.isNone()) ?
-      QString() :
-      QString("%1,%2").arg(msg.loc.firstLine()).arg(QString::fromStdString(msg.loc.fileName())),
-      msg.group
-    }
-      );
+        {QString::fromStdString(msg.str()),
+         (getGroupTextPlain(msg.group) || msg.loc.isNone())
+             ? QString()
+             : QString("%1,%2")
+                   .arg(msg.loc.firstLine())
+                   .arg(QString::fromStdString(msg.loc.fileName())),
+         msg.group});
   }
 }
 
 // Slow due to HTML parsing required, only used for initial Console header.
-void Console::addHtml(const QString& html)
-{
+void Console::addHtml(const QString& html) {
   this->appendHtml(html + QStringLiteral("&nbsp;"));
   this->appendCursor.movePosition(QTextCursor::End);
   this->setTextCursor(this->appendCursor);
@@ -104,13 +106,13 @@ void Console::setFont(const QString& fontFamily, uint ptSize) {
   this->document()->setDefaultFont(QFont(fontFamily, ptSize));
 }
 
-void Console::update()
-{
+void Console::update() {
   // Faster to ignore block count until group of messages are done inserting.
   this->setMaximumBlockCount(0);
   for (const auto& line : this->msgBuffer) {
     QTextCharFormat charFormat;
-    if (line.group != message_group::NONE && line.group != message_group::Echo) charFormat.setForeground(QBrush(QColor("#000000")));
+    if (line.group != message_group::NONE && line.group != message_group::Echo)
+      charFormat.setForeground(QBrush(QColor("#000000")));
     charFormat.setBackground(QBrush(QColor(getGroupColor(line.group).c_str())));
     if (!line.link.isEmpty()) {
       charFormat.setAnchor(true);
@@ -120,27 +122,27 @@ void Console::update()
     // TODO insert timestamp as tooltip? (see #3570)
     //   may have to get rid of concatenation feature of Console::addMessage,
     //   or just live with grouped messages using the same timestamp
-    //charFormat.setToolTip(timestr);
+    // charFormat.setToolTip(timestr);
 
     appendCursor.insertBlock();
     appendCursor.insertText(line.message, charFormat);
   }
   msgBuffer.clear();
   this->setTextCursor(appendCursor);
-  this->setMaximumBlockCount(GlobalPreferences::inst()->getValue("advanced/consoleMaxLines").toUInt());
+  this->setMaximumBlockCount(
+      GlobalPreferences::inst()->getValue("advanced/consoleMaxLines").toUInt());
 }
 
-void Console::actionClearConsole_triggered()
-{
+void Console::actionClearConsole_triggered() {
   this->msgBuffer.clear();
   this->document()->clear();
   this->appendCursor = this->textCursor();
 }
 
-void Console::actionSaveAs_triggered()
-{
+void Console::actionSaveAs_triggered() {
   const auto& text = this->document()->toPlainText();
-  const auto fileName = QFileDialog::getSaveFileName(this, _("Save console content"));
+  const auto fileName =
+      QFileDialog::getSaveFileName(this, _("Save console content"));
   QFile file(fileName);
   if (file.open(QIODevice::ReadWrite)) {
     QTextStream stream(&file);
@@ -150,13 +152,12 @@ void Console::actionSaveAs_triggered()
   }
 }
 
-void Console::contextMenuEvent(QContextMenuEvent *event)
-{
+void Console::contextMenuEvent(QContextMenuEvent* event) {
   // Clear leaves characterCount() at 1, not 0
   const bool hasContent = this->document()->characterCount() > 1;
   this->actionClear->setEnabled(hasContent);
   this->actionSaveAs->setEnabled(hasContent);
-  QMenu *menu = createStandardContextMenu();
+  QMenu* menu = createStandardContextMenu();
   menu->insertAction(menu->actions().at(0), this->actionClear);
   menu->addSeparator();
   menu->addAction(this->actionSaveAs);
@@ -164,8 +165,7 @@ void Console::contextMenuEvent(QContextMenuEvent *event)
   delete menu;
 }
 
-void Console::hyperlinkClicked(const QString& url)
-{
+void Console::hyperlinkClicked(const QString& url) {
   if (url.startsWith("http://") || url.startsWith("https://")) {
     UIUtils::openURL(url);
     return;
diff --git a/src/gui/Console.h b/src/gui/Console.h
index d822b154e..652111971 100644
--- a/src/gui/Console.h
+++ b/src/gui/Console.h
@@ -26,15 +26,15 @@
 
 #pragma once
 
-#include <QTextCursor>
-#include <QWidget>
-#include <QPlainTextEdit>
 #include <QMouseEvent>
+#include <QPlainTextEdit>
 #include <QString>
+#include <QTextCursor>
+#include <QWidget>
 #include <vector>
-#include "utils/printutils.h"
-#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "gui/qtgettext.h"  // IWYU pragma: keep
 #include "ui_Console.h"
+#include "utils/printutils.h"
 
 struct ConsoleMessageBlock {
   QString message;
@@ -42,28 +42,26 @@ struct ConsoleMessageBlock {
   message_group group;
 };
 
-class Console : public QPlainTextEdit, public Ui::Console
-{
+class Console : public QPlainTextEdit, public Ui::Console {
   Q_OBJECT
 
-private:
+ private:
   static constexpr int MAX_LINES = 5000;
   std::vector<ConsoleMessageBlock> msgBuffer;
-  QTextCursor appendCursor; // keep a cursor always at the end of document.
+  QTextCursor appendCursor;  // keep a cursor always at the end of document.
 
-public:
-  Console(QWidget *parent = nullptr);
+ public:
+  Console(QWidget* parent = nullptr);
   QString clickedAnchor;
-  void contextMenuEvent(QContextMenuEvent *event) override;
+  void contextMenuEvent(QContextMenuEvent* event) override;
 
-  void mousePressEvent(QMouseEvent *e) override
-  {
-    clickedAnchor = (e->button() & Qt::LeftButton) ? anchorAt(e->pos()) : QString();
+  void mousePressEvent(QMouseEvent* e) override {
+    clickedAnchor =
+        (e->button() & Qt::LeftButton) ? anchorAt(e->pos()) : QString();
     QPlainTextEdit::mousePressEvent(e);
   }
 
-  void mouseReleaseEvent(QMouseEvent *e) override
-  {
+  void mouseReleaseEvent(QMouseEvent* e) override {
     if (e->button() & Qt::LeftButton && !clickedAnchor.isEmpty() &&
         anchorAt(e->pos()) == clickedAnchor) {
       emit linkActivated(clickedAnchor);
@@ -72,15 +70,15 @@ public:
     QPlainTextEdit::mouseReleaseEvent(e);
   }
 
-  void focusInEvent(QFocusEvent *event) override;
+  void focusInEvent(QFocusEvent* event) override;
   void addMessage(const Message& msg);
   void addHtml(const QString& html);
 
-signals:
+ signals:
   void linkActivated(QString);
   void openFile(QString, int);
 
-public slots:
+ public slots:
   void actionClearConsole_triggered();
   void actionSaveAs_triggered();
   void hyperlinkClicked(const QString& loc);
diff --git a/src/gui/Dock.cc b/src/gui/Dock.cc
index f05847beb..f99bab376 100644
--- a/src/gui/Dock.cc
+++ b/src/gui/Dock.cc
@@ -4,44 +4,39 @@
 #include <QWidget>
 #include "gui/QSettingsCached.h"
 
-
-Dock::Dock(QWidget *parent) : QDockWidget(parent)
-{
-  connect(this, &QDockWidget::topLevelChanged, this, &Dock::onTopLevelStatusChanged);
-  connect(this, &QDockWidget::visibilityChanged, this, &Dock::onVisibilityChanged);
+Dock::Dock(QWidget* parent) : QDockWidget(parent) {
+  connect(this, &QDockWidget::topLevelChanged, this,
+          &Dock::onTopLevelStatusChanged);
+  connect(this, &QDockWidget::visibilityChanged, this,
+          &Dock::onVisibilityChanged);
 
   dockTitleWidget = new QWidget();
 }
 
-Dock::~Dock()
-{
+Dock::~Dock() {
   delete dockTitleWidget;
 }
 
-void Dock::disableSettingsUpdate()
-{
+void Dock::disableSettingsUpdate() {
   updateSettings = false;
 }
 
-void Dock::onVisibilityChanged(bool isDockVisible)
-{
+void Dock::onVisibilityChanged(bool isDockVisible) {
   if (updateSettings) {
     QSettingsCached settings;
     settings.setValue(configKey, !isVisible());
   }
 }
 
-void Dock::setTitleBarVisibility(bool isVisible)
-{
-  setTitleBarWidget(isVisible? dockTitleWidget : nullptr);
+void Dock::setTitleBarVisibility(bool isVisible) {
+  setTitleBarWidget(isVisible ? dockTitleWidget : nullptr);
 }
 
-void Dock::setConfigKey(const QString& configKey)
-{
+void Dock::setConfigKey(const QString& configKey) {
   this->configKey = configKey;
 }
 
-void Dock::updateTitle(){
+void Dock::updateTitle() {
   QString title(name);
   if (isFloating() && !namesuffix.isEmpty()) {
     title += " (" + namesuffix + ")";
@@ -63,13 +58,13 @@ void Dock::setNameSuffix(const QString& namesuffix_) {
   updateTitle();
 }
 
-void Dock::onTopLevelStatusChanged(bool isTopLevel)
-{
-  // update the title of the window so it contains the title suffix (in general filename)
-  // also update the flags and visibility to provide interactive feedback on the user action
-  // while it is moving the dock in topLevel=true state. The purpose of such setting
-  // on Qt::Window flag is to allow the dock to be floating behind the main window,
-  // something which isn't supported for regular QDockWidgets.
+void Dock::onTopLevelStatusChanged(bool isTopLevel) {
+  // update the title of the window so it contains the title suffix (in general
+  // filename) also update the flags and visibility to provide interactive
+  // feedback on the user action while it is moving the dock in topLevel=true
+  // state. The purpose of such setting on Qt::Window flag is to allow the dock
+  // to be floating behind the main window, something which isn't supported for
+  // regular QDockWidgets.
   Qt::WindowFlags flags = (windowFlags() & ~Qt::WindowType_Mask) | Qt::Window;
   if (isTopLevel) {
     setWindowFlags(flags);
diff --git a/src/gui/Dock.h b/src/gui/Dock.h
index 37d14df49..a745a79e0 100644
--- a/src/gui/Dock.h
+++ b/src/gui/Dock.h
@@ -1,15 +1,14 @@
 #pragma once
 
-#include <QString>
 #include <QAction>
 #include <QDockWidget>
+#include <QString>
 
-class Dock : public QDockWidget
-{
+class Dock : public QDockWidget {
   Q_OBJECT
 
-public:
-  Dock(QWidget *parent = nullptr);
+ public:
+  Dock(QWidget* parent = nullptr);
   virtual ~Dock();
 
   void setConfigKey(const QString& configKey);
@@ -22,14 +21,14 @@ public:
   void setTitleBarVisibility(bool isVisible);
   void updateTitle();
 
-public slots:
+ public slots:
   void onVisibilityChanged(bool visible);
   void onTopLevelStatusChanged(bool);
 
-private:
+ private:
   QString name;
   QString namesuffix;
   QString configKey;
   bool updateSettings{true};
-  QWidget *dockTitleWidget;
+  QWidget* dockTitleWidget;
 };
diff --git a/src/gui/Editor.cc b/src/gui/Editor.cc
index 20e73ad38..babef43d9 100644
--- a/src/gui/Editor.cc
+++ b/src/gui/Editor.cc
@@ -4,13 +4,15 @@
 #include "gui/Preferences.h"
 #include "gui/QSettingsCached.h"
 
-void EditorInterface::wheelEvent(QWheelEvent *event)
-{
+void EditorInterface::wheelEvent(QWheelEvent* event) {
   QSettingsCached settings;
-  bool wheelzoom_enabled = GlobalPreferences::inst()->getValue("editor/ctrlmousewheelzoom").toBool();
+  bool wheelzoom_enabled =
+      GlobalPreferences::inst()->getValue("editor/ctrlmousewheelzoom").toBool();
   if ((event->modifiers() == Qt::ControlModifier) && wheelzoom_enabled) {
-    if (event->angleDelta().y() > 0) zoomIn();
-    else if (event->angleDelta().y() < 0) zoomOut();
+    if (event->angleDelta().y() > 0)
+      zoomIn();
+    else if (event->angleDelta().y() < 0)
+      zoomOut();
   } else {
     QWidget::wheelEvent(event);
   }
diff --git a/src/gui/Editor.h b/src/gui/Editor.h
index f91937df3..15dffe948 100644
--- a/src/gui/Editor.h
+++ b/src/gui/Editor.h
@@ -1,57 +1,63 @@
 #pragma once
 
-#include <QStringList>
 #include <QObject>
-#include <QString>
-#include <QWidget>
-#include <QWheelEvent>
 #include <QScrollBar>
+#include <QString>
+#include <QStringList>
 #include <QTextEdit>
+#include <QWheelEvent>
+#include <QWidget>
 #include "core/IndicatorData.h"
 #include "gui/parameter/ParameterWidget.h"
 
 #include <string>
 #include <vector>
 
-enum class EditorSelectionIndicatorStatus
-{
-  SELECTED,
-  IMPACTED
-};
+enum class EditorSelectionIndicatorStatus { SELECTED, IMPACTED };
 
-class EditorInterface : public QWidget
-{
+class EditorInterface : public QWidget {
   Q_OBJECT
-public:
-  EditorInterface(QWidget *parent) : QWidget(parent) {}
-  QSize sizeHint() const override { QSize size; return size;}
-  virtual void setInitialSizeHint(const QSize&) { }
-  void wheelEvent(QWheelEvent *) override;
+ public:
+  EditorInterface(QWidget* parent) : QWidget(parent) {}
+  QSize sizeHint() const override {
+    QSize size;
+    return size;
+  }
+  virtual void setInitialSizeHint(const QSize&) {}
+  void wheelEvent(QWheelEvent*) override;
   virtual QString toPlainText() = 0;
-  virtual QTextDocument *document(){auto *t = new QTextDocument; return t;}
+  virtual QTextDocument* document() {
+    auto* t = new QTextDocument;
+    return t;
+  }
   virtual QString selectedText() = 0;
-  virtual int updateFindIndicators(const QString& findText, bool visibility = true) = 0;
-  virtual bool find(const QString&, bool findNext = false, bool findBackwards = false) = 0;
+  virtual int updateFindIndicators(const QString& findText,
+                                   bool visibility = true) = 0;
+  virtual bool find(const QString&,
+                    bool findNext = false,
+                    bool findBackwards = false) = 0;
   virtual void replaceSelectedText(const QString& newText) = 0;
-  virtual void replaceAll(const QString& findText, const QString& replaceText) = 0;
+  virtual void replaceAll(const QString& findText,
+                          const QString& replaceText) = 0;
   virtual QStringList colorSchemes() = 0;
   virtual bool canUndo() = 0;
   virtual void addTemplate() = 0;
   virtual void resetHighlighting() = 0;
-  virtual void setIndicator(const std::vector<IndicatorData>& indicatorData) = 0;
-  virtual QMenu *createStandardContextMenu() = 0;
+  virtual void setIndicator(
+      const std::vector<IndicatorData>& indicatorData) = 0;
+  virtual QMenu* createStandardContextMenu() = 0;
   virtual QPoint mapToGlobal(const QPoint&) = 0;
   virtual void setCursorPosition(int /*line*/, int /*col*/) {}
   virtual void setFocus() = 0;
 
-signals:
+ signals:
   void contentsChanged();
-  void modificationChanged(EditorInterface *);
+  void modificationChanged(EditorInterface*);
   void showContextMenuEvent(const QPoint& pos);
   void focusIn();
   void escapePressed();
 
-public slots:
+ public slots:
   virtual void zoomIn() = 0;
   virtual void zoomOut() = 0;
   virtual void setContentModified(bool) = 0;
@@ -61,7 +67,13 @@ public slots:
   virtual void commentSelection() = 0;
   virtual void uncommentSelection() = 0;
   virtual void setPlainText(const QString&) = 0;
-  virtual void setSelectionIndicatorStatus(EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom, int lineTo, int colTo) = 0;
+  virtual void setSelectionIndicatorStatus(
+      EditorSelectionIndicatorStatus status,
+      int level,
+      int lineFrom,
+      int colFrom,
+      int lineTo,
+      int colTo) = 0;
   virtual void clearAllSelectionIndicators() = 0;
   virtual void highlightError(int) = 0;
   virtual void unhighlightLastError() = 0;
@@ -81,14 +93,15 @@ public slots:
   virtual void prevBookmark() = 0;
   virtual void jumpToNextError() = 0;
 
-private:
+ private:
   QSize initialSizeHint;
 
-public:
-  bool contentsRendered; // Set if the source code has changes since the last render (F6)
+ public:
+  bool contentsRendered;  // Set if the source code has changes since the last
+                          // render (F6)
   int findState;
   QString filepath;
   std::string autoReloadId;
   std::vector<IndicatorData> indicatorData;
-  ParameterWidget *parameterWidget;
+  ParameterWidget* parameterWidget;
 };
diff --git a/src/gui/ErrorLog.cc b/src/gui/ErrorLog.cc
index 962f0b57b..e9707a961 100644
--- a/src/gui/ErrorLog.cc
+++ b/src/gui/ErrorLog.cc
@@ -1,5 +1,4 @@
 #include "gui/ErrorLog.h"
-#include "utils/printutils.h"
 #include <QAbstractItemView>
 #include <QColor>
 #include <QList>
@@ -9,17 +8,18 @@
 #include <QString>
 #include <QWidget>
 #include <filesystem>
+#include "utils/printutils.h"
 
-ErrorLog::ErrorLog(QWidget *parent) : QWidget(parent)
-{
+ErrorLog::ErrorLog(QWidget* parent) : QWidget(parent) {
   setupUi(this);
   initGUI();
 }
 
-void ErrorLog::initGUI()
-{
+void ErrorLog::initGUI() {
   row = 0;
-  QList<QString> labels = QList<QString>() << QString("Group") << QString("File") << QString("Line") << QString("Info");
+  QList<QString> labels = QList<QString>()
+                          << QString("Group") << QString("File")
+                          << QString("Line") << QString("Info");
 
   const int numColumns = labels.count();
   this->errorLogModel = new QStandardItemModel(row, numColumns, logTable);
@@ -32,40 +32,47 @@ void ErrorLog::initGUI()
   logTable->setColumnWidth(errorLog_column::file, 200);
   logTable->setColumnWidth(errorLog_column::lineNo, 80);
   logTable->addAction(actionRowSelected);
-  //last column will stretch itself
+  // last column will stretch itself
 
-  connect(logTable->horizontalHeader(), &QHeaderView::sectionResized, this, &ErrorLog::onSectionResized);
+  connect(logTable->horizontalHeader(), &QHeaderView::sectionResized, this,
+          &ErrorLog::onSectionResized);
 }
 
-void ErrorLog::toErrorLog(const Message& logMsg)
-{
+void ErrorLog::toErrorLog(const Message& logMsg) {
   lastMessages.push_back(logMsg);
   QString currGroup = errorLogComboBox->currentText();
 
-  //handle combobox
-  if (errorLogComboBox->currentIndex() == 0);
-  else if (currGroup.toStdString() != getGroupName(logMsg.group)) return;
+  // handle combobox
+  if (errorLogComboBox->currentIndex() == 0)
+    ;
+  else if (currGroup.toStdString() != getGroupName(logMsg.group))
+    return;
 
   showtheErrorInGUI(logMsg);
 }
 
-void ErrorLog::showtheErrorInGUI(const Message& logMsg)
-{
-  auto *groupName = new QStandardItem(QString::fromStdString(getGroupName(logMsg.group)));
+void ErrorLog::showtheErrorInGUI(const Message& logMsg) {
+  auto* groupName =
+      new QStandardItem(QString::fromStdString(getGroupName(logMsg.group)));
   groupName->setEditable(false);
 
-  if (logMsg.group == message_group::Error) groupName->setForeground(QColor::fromRgb(255, 0, 0)); //make this item red.
-  else if (logMsg.group == message_group::Warning) groupName->setForeground(QColor::fromRgb(252, 211, 3)); //make this item yellow
+  if (logMsg.group == message_group::Error)
+    groupName->setForeground(QColor::fromRgb(255, 0, 0));  // make this item
+                                                           // red.
+  else if (logMsg.group == message_group::Warning)
+    groupName->setForeground(
+        QColor::fromRgb(252, 211, 3));  // make this item yellow
 
   errorLogModel->setItem(row, errorLog_column::group, groupName);
 
-  QStandardItem *fileName;
-  QStandardItem *lineNo;
+  QStandardItem* fileName;
+  QStandardItem* lineNo;
   if (!logMsg.loc.isNone()) {
     const auto& filePath = logMsg.loc.filePath();
     if (is_regular_file(filePath)) {
       const auto path = QString::fromStdString(filePath.generic_string());
-      fileName = new QStandardItem(QString::fromStdString(filePath.filename().generic_string()));
+      fileName = new QStandardItem(
+          QString::fromStdString(filePath.filename().generic_string()));
       fileName->setToolTip(path);
       fileName->setData(path, Qt::UserRole);
     } else {
@@ -82,7 +89,7 @@ void ErrorLog::showtheErrorInGUI(const Message& logMsg)
   errorLogModel->setItem(row, errorLog_column::file, fileName);
   errorLogModel->setItem(row, errorLog_column::lineNo, lineNo);
 
-  auto *msg = new QStandardItem(QString::fromStdString(logMsg.msg));
+  auto* msg = new QStandardItem(QString::fromStdString(logMsg.msg));
   msg->setEditable(false);
   errorLogModel->setItem(row, errorLog_column::message, msg);
   errorLogModel->setRowCount(++row);
@@ -94,35 +101,32 @@ void ErrorLog::showtheErrorInGUI(const Message& logMsg)
   }
 }
 
-void ErrorLog::resize()
-{
+void ErrorLog::resize() {
   logTable->resizeRowsToContents();
 }
 
-void ErrorLog::onSectionResized(int /*logicalIndex*/, int /*oldSize*/, int /*newSize*/){
+void ErrorLog::onSectionResized(int /*logicalIndex*/,
+                                int /*oldSize*/,
+                                int /*newSize*/) {
   this->resize();
 }
 
-void ErrorLog::resizeEvent(QResizeEvent *event)
-{
+void ErrorLog::resizeEvent(QResizeEvent* event) {
   QWidget::resizeEvent(event);
   this->resize();
 }
 
-void ErrorLog::clearModel()
-{
+void ErrorLog::clearModel() {
   errorLogModel->clear();
   initGUI();
   lastMessages.clear();
 }
 
-int ErrorLog::getLine(int row, int col)
-{
+int ErrorLog::getLine(int row, int col) {
   return logTable->model()->index(row, col).data().toInt();
 }
 
-void ErrorLog::on_errorLogComboBox_currentTextChanged(const QString& group)
-{
+void ErrorLog::on_errorLogComboBox_currentTextChanged(const QString& group) {
   errorLogModel->clear();
   initGUI();
   for (auto& lastMessage : lastMessages) {
@@ -133,25 +137,25 @@ void ErrorLog::on_errorLogComboBox_currentTextChanged(const QString& group)
   }
 }
 
-void ErrorLog::on_logTable_doubleClicked(const QModelIndex& index)
-{
+void ErrorLog::on_logTable_doubleClicked(const QModelIndex& index) {
   onIndexSelected(index);
 }
 
-void ErrorLog::on_actionRowSelected_triggered(bool)
-{
+void ErrorLog::on_actionRowSelected_triggered(bool) {
   const auto indexes = logTable->selectionModel()->selectedRows(0);
   if (indexes.size() == 1) {
     onIndexSelected(indexes.first());
   }
 }
 
-void ErrorLog::onIndexSelected(const QModelIndex& index)
-{
+void ErrorLog::onIndexSelected(const QModelIndex& index) {
   if (index.isValid()) {
     const int r = index.row();
     const int line = getLine(r, errorLog_column::lineNo);
-    const auto path = logTable->model()->index(r, errorLog_column::file).data(Qt::UserRole).toString();
+    const auto path = logTable->model()
+                          ->index(r, errorLog_column::file)
+                          .data(Qt::UserRole)
+                          .toString();
     emit openFile(path, line - 1);
   }
 }
diff --git a/src/gui/ErrorLog.h b/src/gui/ErrorLog.h
index 485ae90a9..6e47b6f37 100644
--- a/src/gui/ErrorLog.h
+++ b/src/gui/ErrorLog.h
@@ -1,25 +1,22 @@
 #pragma once
 
-#include "gui/qtgettext.h"
-#include "ui_ErrorLog.h"
-#include "utils/printutils.h"
 #include <QHash>
 #include <QModelIndex>
 #include <QResizeEvent>
+#include <QStandardItemModel>
 #include <QWidget>
 #include <list>
-#include <QStandardItemModel>
+#include "gui/qtgettext.h"
+#include "ui_ErrorLog.h"
+#include "utils/printutils.h"
 
-enum errorLog_column {
-  group = 0, file, lineNo, message
-};
+enum errorLog_column { group = 0, file, lineNo, message };
 
-class ErrorLog : public QWidget, public Ui::errorLogWidget
-{
+class ErrorLog : public QWidget, public Ui::errorLogWidget {
   Q_OBJECT
 
-public:
-  ErrorLog(QWidget *parent = nullptr);
+ public:
+  ErrorLog(QWidget* parent = nullptr);
   ErrorLog(const ErrorLog& source) = delete;
   ErrorLog(ErrorLog&& source) = delete;
   ErrorLog& operator=(const ErrorLog& source) = delete;
@@ -30,24 +27,24 @@ public:
   void showtheErrorInGUI(const Message& logMsg);
   void clearModel();
   int getLine(int row, int col);
-  QStandardItemModel *errorLogModel;
+  QStandardItemModel* errorLogModel;
   QHash<QString, bool> logsMap;
   int row;
 
-protected:
-  void resizeEvent(QResizeEvent *event) override;
+ protected:
+  void resizeEvent(QResizeEvent* event) override;
 
-private:
+ private:
   void onIndexSelected(const QModelIndex& index);
   void resize();
 
-private:
+ private:
   std::list<Message> lastMessages;
 
-signals:
+ signals:
   void openFile(const QString, int);
 
-private slots:
+ private slots:
   void on_logTable_doubleClicked(const QModelIndex& index);
   void on_errorLogComboBox_currentTextChanged(const QString& arg1);
   void on_actionRowSelected_triggered(bool);
diff --git a/src/gui/EventFilter.h b/src/gui/EventFilter.h
index d172b7545..83f7349bf 100644
--- a/src/gui/EventFilter.h
+++ b/src/gui/EventFilter.h
@@ -1,23 +1,23 @@
 #pragma once
 
-#include <QObject>
 #include <QFileOpenEvent>
-#include "gui/OpenSCADApp.h"
+#include <QObject>
 #include "gui/LaunchingScreen.h"
+#include "gui/OpenSCADApp.h"
 
-class SCADEventFilter : public QObject
-{
+class SCADEventFilter : public QObject {
   Q_OBJECT;
 
-public:
-  SCADEventFilter(QObject *parent) : QObject(parent) {}
-protected:
-  bool eventFilter(QObject *obj, QEvent *event) override {
+ public:
+  SCADEventFilter(QObject* parent) : QObject(parent) {}
+
+ protected:
+  bool eventFilter(QObject* obj, QEvent* event) override {
     // Handle Apple event for opening files, only available on OS X
     if (event->type() == QEvent::FileOpen) {
-      QFileOpenEvent *foe = static_cast<QFileOpenEvent *>(event);
+      QFileOpenEvent* foe = static_cast<QFileOpenEvent*>(event);
       const QString& filename = foe->file();
-      if (LaunchingScreen *ls = LaunchingScreen::getDialog()) {
+      if (LaunchingScreen* ls = LaunchingScreen::getDialog()) {
         // We need to invoke the method since, apparently, we receive
         // this event in another thread.
         QMetaObject::invokeMethod(ls, "openFile", Qt::QueuedConnection,
diff --git a/src/gui/Export3mfDialog.cc b/src/gui/Export3mfDialog.cc
index ed3392975..a09c13124 100644
--- a/src/gui/Export3mfDialog.cc
+++ b/src/gui/Export3mfDialog.cc
@@ -26,61 +26,72 @@
 
 #include "gui/Export3mfDialog.h"
 
-#include <string>
-#include <QString>
 #include <QCheckBox>
 #include <QColor>
-#include <QDialog>
 #include <QColorDialog>
+#include <QDialog>
 #include <QLineEdit>
+#include <QString>
+#include <string>
 
-#include "io/export.h"
-#include "io/lib3mf_utils.h"
 #include "core/Settings.h"
-#include "gui/UIUtils.h"
 #include "gui/SettingsWriter.h"
+#include "gui/UIUtils.h"
+#include "io/export.h"
+#include "io/lib3mf_utils.h"
 
 using S = Settings::SettingsExport3mf;
 using SEBool = Settings::SettingsEntryBool;
 using SEString = Settings::SettingsEntryString;
 
-Export3mfDialog::Export3mfDialog()
-{
+Export3mfDialog::Export3mfDialog() {
   setupUi(this);
-  this->checkBoxAlwaysShowDialog->setChecked(S::export3mfAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowDialog->setChecked(
+      S::export3mfAlwaysShowDialog.value());
   initButtonGroup(this->buttonGroupColors, S::export3mfColorMode);
   initButtonGroup(this->buttonGroupUnit, S::export3mfUnit);
   this->color = QColor(QString::fromStdString(S::export3mfColor.value()));
-  this->labelColorsSelected->setStyleSheet(UIUtils::getBackgroundColorStyleSheet(this->color));
+  this->labelColorsSelected->setStyleSheet(
+      UIUtils::getBackgroundColorStyleSheet(this->color));
   this->spinBoxDecimalPrecision->setValue(S::export3mfDecimalPrecision.value());
   initComboBox(this->comboBoxMaterialType, S::export3mfMaterialType);
 
   groupMetaData->setChecked(S::export3mfAddMetaData.value());
-  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::export3mfMetaDataTitle);
-  initMetaData(this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner, &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
-  initMetaData(this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription, &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
-  initMetaData(this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright, &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
-  initMetaData(this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms, &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
-  initMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating, &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
+  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr,
+               S::export3mfMetaDataTitle);
+  initMetaData(this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner,
+               &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
+  initMetaData(
+      this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription,
+      &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
+  initMetaData(this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright,
+               &S::export3mfAddMetaDataCopyright,
+               S::export3mfMetaDataCopyright);
+  initMetaData(
+      this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms,
+      &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
+  initMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating,
+               &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
 
   const auto library_version = get_lib3mf_version();
   if (library_version.compare(0, 2, "1.") == 0) {
     this->spinBoxDecimalPrecision->setEnabled(false);
     this->toolButtonDecimalPrecisionReset->setEnabled(false);
     this->labelDecimalPrecision->setEnabled(false);
-    this->spinBoxDecimalPrecision->setToolTip(_("This OpenSCAD build uses lib3mf version 1. Setting the decimal precision for export needs version 2 or later."));
+    this->spinBoxDecimalPrecision->setToolTip(
+        _("This OpenSCAD build uses lib3mf version 1. Setting the decimal "
+          "precision for export needs version 2 or later."));
     this->toolButtonDecimalPrecisionReset->setToolTip("");
   }
 }
 
-void Export3mfDialog::updateColor(const QColor& color)
-{
+void Export3mfDialog::updateColor(const QColor& color) {
   this->color = color;
-  this->labelColorsSelected->setStyleSheet(UIUtils::getBackgroundColorStyleSheet(this->color));
+  this->labelColorsSelected->setStyleSheet(
+      UIUtils::getBackgroundColorStyleSheet(this->color));
 }
 
-int Export3mfDialog::exec()
-{
+int Export3mfDialog::exec() {
   bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
   if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
     showDialog = true;
@@ -89,36 +100,47 @@ int Export3mfDialog::exec()
   const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
 
   if (result == QDialog::Accepted) {
-    S::export3mfAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
+    S::export3mfAlwaysShowDialog.setValue(
+        this->checkBoxAlwaysShowDialog->isChecked());
     applyButtonGroup(this->buttonGroupColors, S::export3mfColorMode);
     applyButtonGroup(this->buttonGroupUnit, S::export3mfUnit);
     S::export3mfColor.setValue(this->color.toRgb().name().toStdString());
-    S::export3mfMaterialType.setIndex(this->comboBoxMaterialType->currentIndex());
-    S::export3mfDecimalPrecision.setValue(this->spinBoxDecimalPrecision->value());
+    S::export3mfMaterialType.setIndex(
+        this->comboBoxMaterialType->currentIndex());
+    S::export3mfDecimalPrecision.setValue(
+        this->spinBoxDecimalPrecision->value());
     S::export3mfAddMetaData.setValue(this->groupMetaData->isChecked());
-    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::export3mfMetaDataTitle);
-    applyMetaData(this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner, &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
-    applyMetaData(this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription, &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
-    applyMetaData(this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright, &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
-    applyMetaData(this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms, &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
-    applyMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating, &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
+    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr,
+                  S::export3mfMetaDataTitle);
+    applyMetaData(
+        this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner,
+        &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
+    applyMetaData(
+        this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription,
+        &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
+    applyMetaData(
+        this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright,
+        &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
+    applyMetaData(
+        this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms,
+        &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
+    applyMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating,
+                  &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
     Settings::Settings::visit(SettingsWriter());
   }
 
   return result;
 }
 
-void Export3mfDialog::on_toolButtonColorsSelected_clicked()
-{
+void Export3mfDialog::on_toolButtonColorsSelected_clicked() {
   updateColor(QColorDialog::getColor(this->color));
 }
 
-void Export3mfDialog::on_toolButtonColorsSelectedReset_clicked()
-{
+void Export3mfDialog::on_toolButtonColorsSelectedReset_clicked() {
   updateColor(QColor(QString::fromStdString(S::export3mfColor.defaultValue())));
 }
 
-void Export3mfDialog::on_toolButtonDecimalPrecisionReset_clicked()
-{
-  this->spinBoxDecimalPrecision->setValue(S::export3mfDecimalPrecision.defaultValue());
+void Export3mfDialog::on_toolButtonDecimalPrecisionReset_clicked() {
+  this->spinBoxDecimalPrecision->setValue(
+      S::export3mfDecimalPrecision.defaultValue());
 }
diff --git a/src/gui/Export3mfDialog.h b/src/gui/Export3mfDialog.h
index d579aeeee..1cf4c3049 100644
--- a/src/gui/Export3mfDialog.h
+++ b/src/gui/Export3mfDialog.h
@@ -26,23 +26,24 @@
 
 #pragma once
 
-#include <memory>
 #include <QDialog>
+#include <memory>
 
 #include "core/Settings.h"
-#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "gui/InitConfigurator.h"
+#include "gui/qtgettext.h"  // IWYU pragma: keep
 #include "io/export.h"
 #include "ui_Export3mfDialog.h"
-#include "gui/InitConfigurator.h"
 
 using SEBool = Settings::SettingsEntryBool;
 using SEString = Settings::SettingsEntryString;
 
-class Export3mfDialog : public QDialog, public Ui::Export3mfDialog, public InitConfigurator
-{
+class Export3mfDialog : public QDialog,
+                        public Ui::Export3mfDialog,
+                        public InitConfigurator {
   Q_OBJECT;
 
-public:
+ public:
   Export3mfDialog();
 
   int exec() override;
@@ -51,12 +52,12 @@ public:
     return Export3mfOptions::fromSettings();
   }
 
-private slots:
+ private slots:
   void on_toolButtonColorsSelected_clicked();
   void on_toolButtonColorsSelectedReset_clicked();
   void on_toolButtonDecimalPrecisionReset_clicked();
 
-private:
+ private:
   void updateColor(const QColor& color);
 
   QColor color;
diff --git a/src/gui/ExportPdfDialog.cc b/src/gui/ExportPdfDialog.cc
index 859525f26..d8cf37394 100644
--- a/src/gui/ExportPdfDialog.cc
+++ b/src/gui/ExportPdfDialog.cc
@@ -26,21 +26,21 @@
 
 #include "gui/ExportPdfDialog.h"
 
-#include <QString>
-#include <QDialog>
 #include <QColorDialog>
+#include <QDialog>
+#include <QString>
 
-#include "io/export.h"
 #include "core/Settings.h"
-#include "gui/UIUtils.h"
 #include "gui/SettingsWriter.h"
+#include "gui/UIUtils.h"
+#include "io/export.h"
 
 using S = Settings::SettingsExportPdf;
 
-ExportPdfDialog::ExportPdfDialog()
-{
+ExportPdfDialog::ExportPdfDialog() {
   setupUi(this);
-  this->checkBoxAlwaysShowDialog->setChecked(S::exportPdfAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowDialog->setChecked(
+      S::exportPdfAlwaysShowDialog.value());
 
   initButtonGroup(this->buttonGroupPaperSize, S::exportPdfPaperSize);
   initButtonGroup(this->buttonGroupOrientation, S::exportPdfOrientation);
@@ -48,12 +48,13 @@ ExportPdfDialog::ExportPdfDialog()
   // Get current settings or defaults
   this->checkBoxShowFilename->setChecked(S::exportPdfShowFilename.value());
   this->groupScale->setChecked(S::exportPdfShowScale.value());
-  this->checkBoxShowScaleMessage->setChecked(S::exportPdfShowScaleMessage.value());
+  this->checkBoxShowScaleMessage->setChecked(
+      S::exportPdfShowScaleMessage.value());
   this->groupGrid->setChecked(S::exportPdfShowGrid.value());
 
   // Initialize grid size from settings
   const auto gridSize = S::exportPdfGridSize.value();
-  for (auto *button : buttonGroupGridSize->buttons()) {
+  for (auto* button : buttonGroupGridSize->buttons()) {
     if (button->property("_selected_value").toDouble() == gridSize) {
       button->setChecked(true);
       break;
@@ -62,26 +63,31 @@ ExportPdfDialog::ExportPdfDialog()
 
   // Fill settings
   this->checkBoxEnableFill->setChecked(S::exportPdfFill.value());
-  this->fillColor = QColor(QString::fromStdString(S::exportPdfFillColor.value()));
+  this->fillColor =
+      QColor(QString::fromStdString(S::exportPdfFillColor.value()));
   updateFillColor(this->fillColor);
   updateFillControlsEnabled();
 
   // Stroke settings
   this->checkBoxEnableStroke->setChecked(S::exportPdfStroke.value());
-  this->strokeColor = QColor(QString::fromStdString(S::exportPdfStrokeColor.value()));
+  this->strokeColor =
+      QColor(QString::fromStdString(S::exportPdfStrokeColor.value()));
   this->doubleSpinBoxStrokeWidth->setValue(S::exportPdfStrokeWidth.value());
   updateStrokeColor(this->strokeColor);
   updateStrokeControlsEnabled();
 
   groupMetaData->setChecked(S::exportPdfAddMetaData.value());
-  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::exportPdfMetaDataTitle);
-  initMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor, &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
-  initMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject, &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
-  initMetaData(this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords, &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
+  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr,
+               S::exportPdfMetaDataTitle);
+  initMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor,
+               &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
+  initMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject,
+               &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
+  initMetaData(this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords,
+               &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
 }
 
-int ExportPdfDialog::exec()
-{
+int ExportPdfDialog::exec() {
   bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
   if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
     showDialog = true;
@@ -90,12 +96,14 @@ int ExportPdfDialog::exec()
   const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
 
   if (result == QDialog::Accepted) {
-    S::exportPdfAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
+    S::exportPdfAlwaysShowDialog.setValue(
+        this->checkBoxAlwaysShowDialog->isChecked());
     applyButtonGroup(this->buttonGroupPaperSize, S::exportPdfPaperSize);
     applyButtonGroup(this->buttonGroupOrientation, S::exportPdfOrientation);
     S::exportPdfShowFilename.setValue(this->checkBoxShowFilename->isChecked());
     S::exportPdfShowScale.setValue(this->groupScale->isChecked());
-    S::exportPdfShowScaleMessage.setValue(this->checkBoxShowScaleMessage->isChecked());
+    S::exportPdfShowScaleMessage.setValue(
+        this->checkBoxShowScaleMessage->isChecked());
     S::exportPdfShowGrid.setValue(this->groupGrid->isChecked());
     S::exportPdfGridSize.setValue(getGridSize());
     S::exportPdfFill.setValue(this->checkBoxEnableFill->isChecked());
@@ -104,46 +112,48 @@ int ExportPdfDialog::exec()
     S::exportPdfStrokeColor.setValue(this->strokeColor.name().toStdString());
     S::exportPdfStrokeWidth.setValue(this->doubleSpinBoxStrokeWidth->value());
     S::exportPdfAddMetaData.setValue(this->groupMetaData->isChecked());
-    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::exportPdfMetaDataTitle);
-    applyMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor, &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
-    applyMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject, &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
-    applyMetaData(this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords, &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
+    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr,
+                  S::exportPdfMetaDataTitle);
+    applyMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor,
+                  &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
+    applyMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject,
+                  &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
+    applyMetaData(
+        this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords,
+        &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
     Settings::Settings::visit(SettingsWriter());
   }
 
   return result;
 }
 
-double ExportPdfDialog::getGridSize() const
-{
+double ExportPdfDialog::getGridSize() const {
   const auto button = buttonGroupGridSize->checkedButton();
   return button ? button->property("_selected_value").toDouble() : 10.0;
 }
 
-void ExportPdfDialog::updateFillColor(const QColor& color)
-{
+void ExportPdfDialog::updateFillColor(const QColor& color) {
   this->fillColor = color;
-  QString styleSheet = QString("QLabel { background-color: %1; }").arg(color.name());
+  QString styleSheet =
+      QString("QLabel { background-color: %1; }").arg(color.name());
   this->labelFillColor->setStyleSheet(styleSheet);
 }
 
-void ExportPdfDialog::updateStrokeColor(const QColor& color)
-{
+void ExportPdfDialog::updateStrokeColor(const QColor& color) {
   this->strokeColor = color;
-  QString styleSheet = QString("QLabel { background-color: %1; }").arg(color.name());
+  QString styleSheet =
+      QString("QLabel { background-color: %1; }").arg(color.name());
   this->labelStrokeColor->setStyleSheet(styleSheet);
 }
 
-void ExportPdfDialog::updateFillControlsEnabled()
-{
+void ExportPdfDialog::updateFillControlsEnabled() {
   bool enabled = this->checkBoxEnableFill->isChecked();
   this->labelFillColor->setEnabled(enabled);
   this->toolButtonFillColor->setEnabled(enabled);
   this->toolButtonFillColorReset->setEnabled(enabled);
 }
 
-void ExportPdfDialog::updateStrokeControlsEnabled()
-{
+void ExportPdfDialog::updateStrokeControlsEnabled() {
   bool enabled = this->checkBoxEnableStroke->isChecked();
   this->labelStrokeColor->setEnabled(enabled);
   this->toolButtonStrokeColor->setEnabled(enabled);
@@ -153,43 +163,38 @@ void ExportPdfDialog::updateStrokeControlsEnabled()
   this->toolButtonStrokeWidthReset->setEnabled(enabled);
 }
 
-void ExportPdfDialog::on_toolButtonFillColor_clicked()
-{
+void ExportPdfDialog::on_toolButtonFillColor_clicked() {
   QColor color = QColorDialog::getColor(this->fillColor, this);
   if (color.isValid()) {
     updateFillColor(color);
   }
 }
 
-void ExportPdfDialog::on_toolButtonStrokeColor_clicked()
-{
+void ExportPdfDialog::on_toolButtonStrokeColor_clicked() {
   QColor color = QColorDialog::getColor(this->strokeColor, this);
   if (color.isValid()) {
     updateStrokeColor(color);
   }
 }
 
-void ExportPdfDialog::on_toolButtonFillColorReset_clicked()
-{
-  updateFillColor(QColor(QString::fromStdString(S::exportPdfFillColor.defaultValue())));
+void ExportPdfDialog::on_toolButtonFillColorReset_clicked() {
+  updateFillColor(
+      QColor(QString::fromStdString(S::exportPdfFillColor.defaultValue())));
 }
 
-void ExportPdfDialog::on_toolButtonStrokeColorReset_clicked()
-{
-  updateStrokeColor(QColor(QString::fromStdString(S::exportPdfStrokeColor.defaultValue())));
+void ExportPdfDialog::on_toolButtonStrokeColorReset_clicked() {
+  updateStrokeColor(
+      QColor(QString::fromStdString(S::exportPdfStrokeColor.defaultValue())));
 }
 
-void ExportPdfDialog::on_toolButtonStrokeWidthReset_clicked()
-{
+void ExportPdfDialog::on_toolButtonStrokeWidthReset_clicked() {
   this->doubleSpinBoxStrokeWidth->setValue(this->defaultStrokeWidth);
 }
 
-void ExportPdfDialog::on_checkBoxEnableFill_toggled(bool checked)
-{
+void ExportPdfDialog::on_checkBoxEnableFill_toggled(bool checked) {
   updateFillControlsEnabled();
 }
 
-void ExportPdfDialog::on_checkBoxEnableStroke_toggled(bool checked)
-{
+void ExportPdfDialog::on_checkBoxEnableStroke_toggled(bool checked) {
   updateStrokeControlsEnabled();
 }
diff --git a/src/gui/ExportPdfDialog.h b/src/gui/ExportPdfDialog.h
index f04d42f29..6da325c2f 100644
--- a/src/gui/ExportPdfDialog.h
+++ b/src/gui/ExportPdfDialog.h
@@ -26,20 +26,21 @@
 
 #pragma once
 
-#include <memory>
-#include <QDialog>
 #include <QColor>
+#include <QDialog>
+#include <memory>
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "gui/InitConfigurator.h"
+#include "gui/qtgettext.h"  // IWYU pragma: keep
 #include "io/export.h"
 #include "ui_ExportPdfDialog.h"
-#include "gui/InitConfigurator.h"
 
-class ExportPdfDialog : public QDialog, public Ui::ExportPdfDialog, public InitConfigurator
-{
+class ExportPdfDialog : public QDialog,
+                        public Ui::ExportPdfDialog,
+                        public InitConfigurator {
   Q_OBJECT;
 
-public:
+ public:
   ExportPdfDialog();
 
   int exec() override;
@@ -51,7 +52,7 @@ public:
     return ExportPdfOptions::fromSettings();
   }
 
-private slots:
+ private slots:
   void on_toolButtonFillColor_clicked();
   void on_toolButtonFillColorReset_clicked();
   void on_checkBoxEnableFill_toggled(bool checked);
@@ -60,7 +61,7 @@ private slots:
   void on_checkBoxEnableStroke_toggled(bool checked);
   void on_toolButtonStrokeWidthReset_clicked();
 
-private:
+ private:
   void updateFillColor(const QColor& color);
   void updateFillControlsEnabled();
   void updateStrokeColor(const QColor& color);
@@ -70,8 +71,3 @@ private:
   QColor strokeColor;
   double defaultStrokeWidth = 0.35;
 };
-
-
-
-
-
diff --git a/src/gui/ExternalToolInterface.cc b/src/gui/ExternalToolInterface.cc
index 4b817f18d..8620469a6 100644
--- a/src/gui/ExternalToolInterface.cc
+++ b/src/gui/ExternalToolInterface.cc
@@ -26,54 +26,56 @@
 
 #include "gui/ExternalToolInterface.h"
 
-#include <functional>
-#include <memory>
 #include <QDir>
-#include <QString>
 #include <QFileInfo>
+#include <QString>
 #include <QStringList>
 #include <QTemporaryFile>
+#include <functional>
+#include <memory>
 
 #include "core/Settings.h"
+#include "geometry/Geometry.h"
 #include "gui/OctoPrint.h"
 #include "io/export.h"
-#include "geometry/Geometry.h"
 
 namespace {
 
 QString getArgValue(const Settings::LocalAppParameter& arg,
                     const std::string& exportedFilename,
-                    const std::string& sourceFilename)
-{
+                    const std::string& sourceFilename) {
   const QFileInfo info(QString::fromStdString(exportedFilename));
   switch (arg.type) {
-  case Settings::LocalAppParameterType::string:
-    return QString::fromStdString(arg.value);
-  case Settings::LocalAppParameterType::file:
-    return QString::fromStdString(exportedFilename);
-  case Settings::LocalAppParameterType::dir:
-    return info.absoluteDir().path();
-  case Settings::LocalAppParameterType::extension:
-    return info.suffix();
-  case Settings::LocalAppParameterType::source:
-    return QString::fromStdString(sourceFilename);
-  case Settings::LocalAppParameterType::sourcedir:
-    return QFileInfo(QString::fromStdString(sourceFilename)).absoluteDir().path();
-  default:
-    return {};
+    case Settings::LocalAppParameterType::string:
+      return QString::fromStdString(arg.value);
+    case Settings::LocalAppParameterType::file:
+      return QString::fromStdString(exportedFilename);
+    case Settings::LocalAppParameterType::dir:
+      return info.absoluteDir().path();
+    case Settings::LocalAppParameterType::extension:
+      return info.suffix();
+    case Settings::LocalAppParameterType::source:
+      return QString::fromStdString(sourceFilename);
+    case Settings::LocalAppParameterType::sourcedir:
+      return QFileInfo(QString::fromStdString(sourceFilename))
+          .absoluteDir()
+          .path();
+    default:
+      return {};
   }
 }
 
 }  // namespace
 
-bool ExternalToolInterface::exportTemporaryFile(const std::shared_ptr<const Geometry>& rootGeometry,
-                                                const QString& sourceFileName, const Camera *const camera)
-{
+bool ExternalToolInterface::exportTemporaryFile(
+    const std::shared_ptr<const Geometry>& rootGeometry,
+    const QString& sourceFileName,
+    const Camera* const camera) {
   // FIXME: Remove original suffix first
   QTemporaryFile exportFile{getTempDir().filePath(
-                              QString("%1.XXXXXX.%2").
-                              arg(QString::fromStdString(sourceFileName.toStdString())).
-                              arg(QString::fromStdString(fileformat::toSuffix(exportFormat_))))};
+      QString("%1.XXXXXX.%2")
+          .arg(QString::fromStdString(sourceFileName.toStdString()))
+          .arg(QString::fromStdString(fileformat::toSuffix(exportFormat_))))};
   // FIXME: When is it safe to remove the file?
   // * Octoprint: After uploading?
   // * PrintService: After uploading?
@@ -87,54 +89,64 @@ bool ExternalToolInterface::exportTemporaryFile(const std::shared_ptr<const Geom
 
   sourceFilename_ = sourceFileName.toStdString();
   exportedFilename_ = exportFileName.toStdString();
-  ExportInfo exportInfo = createExportInfo(exportFormat_, fileformat::info(exportFormat_), sourceFileName.toStdString(), camera, {});
+  ExportInfo exportInfo =
+      createExportInfo(exportFormat_, fileformat::info(exportFormat_),
+                       sourceFileName.toStdString(), camera, {});
   const bool ok = exportFileByName(rootGeometry, exportedFilename_, exportInfo);
   LOG("Exported temporary file %1$s", exportedFilename_);
   return ok;
 }
 
-bool OctoPrintService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
+bool OctoPrintService::process(const std::string& displayName,
+                               std::function<bool(double)> progress_cb) {
   const OctoPrint octoPrint;
 
   try {
-    const QString fileUrl = octoPrint.upload(QString::fromStdString(exportedFilename_), QString::fromStdString(displayName), progress_cb);
+    const QString fileUrl =
+        octoPrint.upload(QString::fromStdString(exportedFilename_),
+                         QString::fromStdString(displayName), progress_cb);
     if (this->action == "upload") {
       return true;
     }
 
-    const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-    const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
-    octoPrint.slice(fileUrl, slicer, profile, action != "slice", action == "print");
+    const QString slicer = QString::fromStdString(
+        Settings::Settings::octoPrintSlicerEngine.value());
+    const QString profile = QString::fromStdString(
+        Settings::Settings::octoPrintSlicerProfile.value());
+    octoPrint.slice(fileUrl, slicer, profile, action != "slice",
+                    action == "print");
   } catch (const NetworkException& e) {
     LOG(message_group::Error, "%1$s", e.getErrorMessage());
   }
   return true;
 }
 
-QDir LocalProgramService::getTempDir() const
-{
+QDir LocalProgramService::getTempDir() const {
   const auto& tempDirConfig = Settings::Settings::localAppTempDir.value();
   if (tempDirConfig.empty()) {
     return QDir::temp();
   }
   const auto tempDir = QDir{QString::fromStdString(tempDirConfig)};
   if (!tempDir.exists()) {
-    LOG(message_group::Warning, "Configured temporary directory does not exist: '%1$s'", tempDirConfig);
+    LOG(message_group::Warning,
+        "Configured temporary directory does not exist: '%1$s'", tempDirConfig);
     return QDir::temp();
   }
   return tempDir;
 }
 
-bool LocalProgramService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
+bool LocalProgramService::process(const std::string& displayName,
+                                  std::function<bool(double)> progress_cb) {
   QProcess process;
   process.setProcessChannelMode(QProcess::MergedChannels);
 
-  const QString application = QString::fromStdString(Settings::Settings::localAppExecutable.value());
+  const QString application =
+      QString::fromStdString(Settings::Settings::localAppExecutable.value());
 
   if (application.trimmed().isEmpty()) {
-    LOG(message_group::Error, "No application configured, check Preferences -> 3D Print -> Local Application");
+    LOG(message_group::Error,
+        "No application configured, check Preferences -> 3D Print -> Local "
+        "Application");
     return false;
   }
 
@@ -160,10 +172,12 @@ bool LocalProgramService::process(const std::string& displayName, std::function<
   for (const auto& arg : Settings::Settings::localAppParameterList.value()) {
     args << getArgValue(arg, exportedFilename_, sourceFilename_);
   }
-  PRINTD("Executing: " + application.toStdString() + " " + args.join(" ").toStdString());
+  PRINTD("Executing: " + application.toStdString() + " " +
+         args.join(" ").toStdString());
   if (!process.startDetached(application, args)) {
-#endif // ifdef Q_OS_MACOS
-    LOG(message_group::Error, "Could not start local application '%1$s': %2$s", application.toStdString(), process.errorString().toStdString());
+#endif  // ifdef Q_OS_MACOS
+    LOG(message_group::Error, "Could not start local application '%1$s': %2$s",
+        application.toStdString(), process.errorString().toStdString());
     const auto output = process.readAll();
     if (output.length() > 0) {
       LOG(message_group::Error, "Output: %1$s", output.toStdString());
@@ -172,8 +186,8 @@ bool LocalProgramService::process(const std::string& displayName, std::function<
   return true;
 }
 
-bool ExternalPrintService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
+bool ExternalPrintService::process(const std::string& displayName,
+                                   std::function<bool(double)> progress_cb) {
   QFile file(QString::fromStdString(exportedFilename_));
   if (!file.open(QIODevice::ReadOnly)) {
     LOG(message_group::Error, "Unable to open exported STL file.");
@@ -182,14 +196,18 @@ bool ExternalPrintService::process(const std::string& displayName, std::function
   const QString fileContentBase64 = file.readAll().toBase64();
 
   if (fileContentBase64.length() > printService->getFileSizeLimit()) {
-    const auto msg = QString{_("Exported design exceeds the service upload limit of (%1 MB).")}.arg(printService->getFileSizeLimitMB());
+    const auto msg =
+        QString{
+            _("Exported design exceeds the service upload limit of (%1 MB).")}
+            .arg(printService->getFileSizeLimitMB());
     // FIXME: Move back to MainWindow
-//    QMessageBox::warning(this, _("Upload Error"), msg, QMessageBox::Ok);
-    //LOG(message_group::Error, "%1$s", msg.toStdString());
+    //    QMessageBox::warning(this, _("Upload Error"), msg, QMessageBox::Ok);
+    // LOG(message_group::Error, "%1$s", msg.toStdString());
     return false;
   }
   try {
-    const QString partUrl = printService->upload(QString::fromStdString(displayName), fileContentBase64, progress_cb);
+    const QString partUrl = printService->upload(
+        QString::fromStdString(displayName), fileContentBase64, progress_cb);
     this->url = partUrl.toStdString();
   } catch (const NetworkException& e) {
     LOG(message_group::Error, "%1$s", e.getErrorMessage());
@@ -197,24 +215,27 @@ bool ExternalPrintService::process(const std::string& displayName, std::function
   return true;
 }
 
-std::unique_ptr<ExternalPrintService> createExternalPrintService(const PrintService *printService, FileFormat fileFormat) {
+std::unique_ptr<ExternalPrintService> createExternalPrintService(
+    const PrintService* printService,
+    FileFormat fileFormat) {
   return std::make_unique<ExternalPrintService>(fileFormat, printService);
 }
 
-std::unique_ptr<OctoPrintService> createOctoPrintService(FileFormat fileFormat)
-{
+std::unique_ptr<OctoPrintService> createOctoPrintService(
+    FileFormat fileFormat) {
   auto octoPrintService = std::make_unique<OctoPrintService>(fileFormat);
 
-
-// TODO: set action, slicerEngine, slicerAction
-//    const std::string& action = Settings::Settings::octoPrintAction.value();
-// const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-// const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
-
+  // TODO: set action, slicerEngine, slicerAction
+  //    const std::string& action = Settings::Settings::octoPrintAction.value();
+  // const QString slicer =
+  // QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
+  // const QString profile =
+  // QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
 
   return octoPrintService;
 }
 
-std::unique_ptr<LocalProgramService> createLocalProgramService(FileFormat fileFormat) {
+std::unique_ptr<LocalProgramService> createLocalProgramService(
+    FileFormat fileFormat) {
   return std::make_unique<LocalProgramService>(fileFormat);
 }
diff --git a/src/gui/ExternalToolInterface.h b/src/gui/ExternalToolInterface.h
index 6744db775..d590cd6f2 100644
--- a/src/gui/ExternalToolInterface.h
+++ b/src/gui/ExternalToolInterface.h
@@ -27,57 +27,63 @@
 #pragma once
 
 #include <functional>
-#include <string>
 #include <memory>
+#include <string>
 
 #include <QDir>
 #include <QString>
 
-#include "gui/PrintService.h"
-#include "geometry/Geometry.h"
 #include "core/Settings.h"
+#include "geometry/Geometry.h"
+#include "gui/PrintService.h"
 #include "io/export.h"
 
-class ExternalToolInterface
-{
-public:
+class ExternalToolInterface {
+ public:
   ExternalToolInterface(FileFormat fileFormat) : exportFormat_(fileFormat) {}
   virtual ~ExternalToolInterface() = default;
 
-  virtual bool exportTemporaryFile(const std::shared_ptr<const Geometry>& rootGeometry, const QString& sourceFileName, const Camera *const camera);
-  virtual bool process(const std::string& displayName, std::function<bool (double)>) = 0;
+  virtual bool exportTemporaryFile(
+      const std::shared_ptr<const Geometry>& rootGeometry,
+      const QString& sourceFileName,
+      const Camera* const camera);
+  virtual bool process(const std::string& displayName,
+                       std::function<bool(double)>) = 0;
 
   FileFormat fileFormat() const { return exportFormat_; }
   virtual std::string getURL() const { return ""; }
   virtual QDir getTempDir() const { return QDir::temp(); }
-protected:
+
+ protected:
   std::string sourceFilename_;
   FileFormat exportFormat_;
   std::string exportedFilename_;
 };
 
+class ExternalPrintService : public ExternalToolInterface {
+ public:
+  ExternalPrintService(FileFormat fileFormat, const PrintService* printService)
+      : ExternalToolInterface(fileFormat), printService(printService) {}
+  bool process(const std::string& displayName,
+               std::function<bool(double)>) override;
+  std::string getURL() const override { return url; }
 
-class ExternalPrintService : public ExternalToolInterface
-{
-public:
-  ExternalPrintService(FileFormat fileFormat, const PrintService *printService) : ExternalToolInterface(fileFormat), printService(printService) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
-  std::string getURL() const override {return url;}
-
-private:
+ private:
   std::string url;
-  const PrintService *printService;
+  const PrintService* printService;
 };
 
-std::unique_ptr<ExternalPrintService> createExternalPrintService(const PrintService *printService, FileFormat fileFormat);
+std::unique_ptr<ExternalPrintService> createExternalPrintService(
+    const PrintService* printService,
+    FileFormat fileFormat);
 
-class OctoPrintService : public ExternalToolInterface
-{
-public:
+class OctoPrintService : public ExternalToolInterface {
+ public:
   OctoPrintService(FileFormat fileFormat) : ExternalToolInterface(fileFormat) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
+  bool process(const std::string& displayName,
+               std::function<bool(double)>) override;
 
-private:
+ private:
   std::string action;
   std::string slicerEngine;
   std::string slicerAction;
@@ -85,12 +91,14 @@ private:
 
 std::unique_ptr<OctoPrintService> createOctoPrintService(FileFormat fileFormat);
 
-class LocalProgramService : public ExternalToolInterface
-{
-public:
-  LocalProgramService(FileFormat fileFormat) : ExternalToolInterface(fileFormat) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
+class LocalProgramService : public ExternalToolInterface {
+ public:
+  LocalProgramService(FileFormat fileFormat)
+      : ExternalToolInterface(fileFormat) {}
+  bool process(const std::string& displayName,
+               std::function<bool(double)>) override;
   QDir getTempDir() const override;
 };
 
-std::unique_ptr<LocalProgramService> createLocalProgramService(FileFormat fileFormat);
+std::unique_ptr<LocalProgramService> createLocalProgramService(
+    FileFormat fileFormat);
diff --git a/src/gui/FontList.cc b/src/gui/FontList.cc
index b25a1aa6e..dbee576ae 100644
--- a/src/gui/FontList.cc
+++ b/src/gui/FontList.cc
@@ -6,60 +6,54 @@
 #include <vector>
 
 #include <QAbstractItemView>
+#include <QAction>
 #include <QApplication>
+#include <QClipboard>
+#include <QDesktopServices>
+#include <QDir>
+#include <QFileInfo>
+#include <QFontMetrics>
+#include <QHeaderView>
+#include <QItemSelectionModel>
+#include <QLineEdit>
+#include <QMenu>
 #include <QModelIndex>
 #include <QPainter>
 #include <QPoint>
+#include <QRegularExpression>
 #include <QResizeEvent>
 #include <QSize>
 #include <QSortFilterProxyModel>
+#include <QSpinBox>
 #include <QString>
-#include <QStyledItemDelegate>
 #include <QStyleOptionViewItem>
-#include <QItemSelectionModel>
-#include <QClipboard>
-#include <QRegularExpression>
-#include <QFileInfo>
-#include <QFontMetrics>
-#include <QMenu>
-#include <QDir>
+#include <QStyledItemDelegate>
 #include <QUrl>
-#include <QDesktopServices>
-#include <QAction>
-#include <QHeaderView>
-#include <QItemSelectionModel>
-#include <QSpinBox>
-#include <QLineEdit>
 
 #include "FontCache.h"
 #include "utils/printutils.h"
 
-FontItemDelegate::FontItemDelegate(QObject *parent) : QStyledItemDelegate(parent)
-{
-}
+FontItemDelegate::FontItemDelegate(QObject* parent)
+    : QStyledItemDelegate(parent) {}
 
-int FontItemDelegate::fontSize() const
-{
+int FontItemDelegate::fontSize() const {
   return _fontSize;
 }
 
-void FontItemDelegate::setFontSize(int fontSize)
-{
+void FontItemDelegate::setFontSize(int fontSize) {
   _fontSize = fontSize;
 }
 
-QString FontItemDelegate::text() const
-{
+QString FontItemDelegate::text() const {
   return _text;
 }
 
-void FontItemDelegate::setText(const QString& text)
-{
+void FontItemDelegate::setText(const QString& text) {
   _text = text;
 }
 
-void FontItemDelegate::initStyleOption(QStyleOptionViewItem *opt, const QModelIndex& idx) const
-{
+void FontItemDelegate::initStyleOption(QStyleOptionViewItem* opt,
+                                       const QModelIndex& idx) const {
   QStyledItemDelegate::initStyleOption(opt, idx);
 
   opt->font.setStyleStrategy(QFont::NoFontMerging);
@@ -67,13 +61,14 @@ void FontItemDelegate::initStyleOption(QStyleOptionViewItem *opt, const QModelIn
   opt->textElideMode = Qt::ElideNone;
 }
 
-QWidget *FontItemDelegate::createEditor(QWidget *, const QStyleOptionViewItem&, const QModelIndex&) const
-{
+QWidget* FontItemDelegate::createEditor(QWidget*,
+                                        const QStyleOptionViewItem&,
+                                        const QModelIndex&) const {
   return nullptr;
 }
 
-QSize FontItemDelegate::sizeHint(const QStyleOptionViewItem& option, const QModelIndex& idx) const
-{
+QSize FontItemDelegate::sizeHint(const QStyleOptionViewItem& option,
+                                 const QModelIndex& idx) const {
   QStyleOptionViewItem opt = option;
   initStyleOption(&opt, idx);
 
@@ -86,8 +81,9 @@ QSize FontItemDelegate::sizeHint(const QStyleOptionViewItem& option, const QMode
   return {4 * fm.height() + fm.horizontalAdvance(text), fm.height()};
 }
 
-void FontItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem& option, const QModelIndex& idx) const
-{
+void FontItemDelegate::paint(QPainter* painter,
+                             const QStyleOptionViewItem& option,
+                             const QModelIndex& idx) const {
   QStyleOptionViewItem opt = option;
   initStyleOption(&opt, idx);
 
@@ -96,96 +92,100 @@ void FontItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem& opti
 
   opt.font.setFamily(fontName);
   opt.font.setStyleName(fontStyle);
-  opt.text = text(); // only used if idx points to empty string
+  opt.text = text();  // only used if idx points to empty string
 
   QStyledItemDelegate::paint(painter, opt, idx);
 }
 
-FontSortFilterProxyModel::FontSortFilterProxyModel(QObject *parent) : QSortFilterProxyModel(parent)
-{
-}
+FontSortFilterProxyModel::FontSortFilterProxyModel(QObject* parent)
+    : QSortFilterProxyModel(parent) {}
 
-void FontSortFilterProxyModel::clearFilter()
-{
+void FontSortFilterProxyModel::clearFilter() {
   filterHashes.clear();
 }
 
-void FontSortFilterProxyModel::appendFilterHashes(const std::vector<uint32_t>& hashes)
-{
+void FontSortFilterProxyModel::appendFilterHashes(
+    const std::vector<uint32_t>& hashes) {
   for (const auto hash : hashes) {
     filterHashes.insert(QString::number(hash, 16));
   }
 }
 
-bool FontSortFilterProxyModel::filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const
-{
-  const bool parentResult = QSortFilterProxyModel::filterAcceptsRow(sourceRow, sourceParent);
+bool FontSortFilterProxyModel::filterAcceptsRow(
+    int sourceRow,
+    const QModelIndex& sourceParent) const {
+  const bool parentResult =
+      QSortFilterProxyModel::filterAcceptsRow(sourceRow, sourceParent);
   if (filterHashes.empty()) {
     return parentResult;
   }
 
-  const auto idx = sourceModel()->index(sourceRow, FontList::COL_HASH, sourceParent);
+  const auto idx =
+      sourceModel()->index(sourceRow, FontList::COL_HASH, sourceParent);
   const auto& data = sourceModel()->data(idx);
   const bool result = filterHashes.contains(data.toString());
   return parentResult && result;
 }
 
-FontList::FontList(QWidget *parent) : QWidget(parent), model(nullptr), proxy(nullptr)
-{
+FontList::FontList(QWidget* parent)
+    : QWidget(parent), model(nullptr), proxy(nullptr) {
   setupUi(this);
-  lineEditSampleText->addAction(actionResetSampleText, QLineEdit::TrailingPosition);
+  lineEditSampleText->addAction(actionResetSampleText,
+                                QLineEdit::TrailingPosition);
   actionResetSampleText->trigger();
-  lineEditFontNameSelected->addAction(actionCopyFontName, QLineEdit::TrailingPosition);
-  lineEditFontPathSelected->addAction(actionOpenFolder, QLineEdit::TrailingPosition);
-  lineEditFontPathSelected->addAction(actionCopyFullPath, QLineEdit::TrailingPosition);
-  lineEditFcStyleSelected->addAction(actionCopyStyle, QLineEdit::TrailingPosition);
+  lineEditFontNameSelected->addAction(actionCopyFontName,
+                                      QLineEdit::TrailingPosition);
+  lineEditFontPathSelected->addAction(actionOpenFolder,
+                                      QLineEdit::TrailingPosition);
+  lineEditFontPathSelected->addAction(actionCopyFullPath,
+                                      QLineEdit::TrailingPosition);
+  lineEditFcStyleSelected->addAction(actionCopyStyle,
+                                     QLineEdit::TrailingPosition);
   spinBoxFontSize->setValue(tableView->fontInfo().pointSize());
   selection_changed({}, {});
 
   tableView->horizontalHeader()->setContextMenuPolicy(Qt::CustomContextMenu);
-  connect(tableView->horizontalHeader(), &QHeaderView::customContextMenuRequested, this, &FontList::customHeaderContexMenuRequested);
+  connect(tableView->horizontalHeader(),
+          &QHeaderView::customContextMenuRequested, this,
+          &FontList::customHeaderContexMenuRequested);
 }
 
-void FontList::on_lineEditFontName_textChanged(const QString& text)
-{
+void FontList::on_lineEditFontName_textChanged(const QString& text) {
   updateFilter(comboBoxSearchType->currentIndex(), text);
 }
 
-void FontList::on_comboBoxSearchType_currentIndexChanged(int idx)
-{
+void FontList::on_comboBoxSearchType_currentIndexChanged(int idx) {
   updateFilter(idx, lineEditFontName->text());
 }
 
-void FontList::updateFilter(int searchTypeIdx, const QString& text)
-{
-  const auto regExp = QRegularExpression(text, QRegularExpression::CaseInsensitiveOption);
+void FontList::updateFilter(int searchTypeIdx, const QString& text) {
+  const auto regExp =
+      QRegularExpression(text, QRegularExpression::CaseInsensitiveOption);
 
   switch (searchTypeIdx) {
-  case 0:
-    proxy->setFilterFixedString(text);
-    break;
-  case 1:
-    proxy->setFilterWildcard(text);
-    break;
-  default:
-    proxy->setFilterRegularExpression(regExp);
-    break;
+    case 0:
+      proxy->setFilterFixedString(text);
+      break;
+    case 1:
+      proxy->setFilterWildcard(text);
+      break;
+    default:
+      proxy->setFilterRegularExpression(regExp);
+      break;
   }
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  groupBoxFilter->setTitle(
+      QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
 }
 
-void FontList::on_comboBoxCharFilterType_currentIndexChanged(int idx)
-{
+void FontList::on_comboBoxCharFilterType_currentIndexChanged(int idx) {
   updateCharFilter(idx, lineEditChars->text());
 }
 
-void FontList::on_lineEditChars_textChanged(const QString& text)
-{
+void FontList::on_lineEditChars_textChanged(const QString& text) {
   updateCharFilter(comboBoxCharFilterType->currentIndex(), text);
 }
 
-void FontList::updateCharFilter(int charFilterType, const QString& text)
-{
+void FontList::updateCharFilter(int charFilterType, const QString& text) {
   proxy->clearFilter();
   if (text.length() > 0) {
     if (charFilterType == 0) {
@@ -201,27 +201,24 @@ void FontList::updateCharFilter(int charFilterType, const QString& text)
     }
   }
   proxy->invalidate();
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  groupBoxFilter->setTitle(
+      QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
 }
 
-void FontList::on_actionResetSampleText_triggered()
-{
+void FontList::on_actionResetSampleText_triggered() {
   lineEditSampleText->setText(SAMPLE_TEXT_DEFAULT);
   lineEditSampleText->setCursorPosition(0);
 }
 
-void FontList::on_lineEditSampleText_textChanged(const QString& text)
-{
+void FontList::on_lineEditSampleText_textChanged(const QString& text) {
   updateSampleText(text, spinBoxFontSize->value());
 }
 
-void FontList::on_spinBoxFontSize_valueChanged(int value)
-{
+void FontList::on_spinBoxFontSize_valueChanged(int value) {
   updateSampleText(lineEditSampleText->text(), value);
 }
 
-void FontList::updateSampleText(const QString& text, int fontSize)
-{
+void FontList::updateSampleText(const QString& text, int fontSize) {
   delegate.setText(text);
   delegate.setFontSize(fontSize);
 
@@ -240,9 +237,8 @@ void FontList::updateSampleText(const QString& text, int fontSize)
   }
 }
 
-void FontList::customHeaderContexMenuRequested(const QPoint& pos)
-{
-  auto *menu = new QMenu(this);
+void FontList::customHeaderContexMenuRequested(const QPoint& pos) {
+  auto* menu = new QMenu(this);
   menu->addAction(actionShowFontNameColumn);
   menu->addAction(actionShowStyledFontNameColumn);
   menu->addAction(actionShowFontStyleColumn);
@@ -261,38 +257,31 @@ void FontList::showColumn(int column, bool show) {
   }
 }
 
-void FontList::on_actionShowFontNameColumn_toggled(bool show)
-{
+void FontList::on_actionShowFontNameColumn_toggled(bool show) {
   showColumn(COL_FONT_NAME, show);
 }
 
-void FontList::on_actionShowStyledFontNameColumn_toggled(bool show)
-{
+void FontList::on_actionShowStyledFontNameColumn_toggled(bool show) {
   showColumn(COL_STYLED_FONT_NAME, show);
 }
 
-void FontList::on_actionShowFontStyleColumn_toggled(bool show)
-{
+void FontList::on_actionShowFontStyleColumn_toggled(bool show) {
   showColumn(COL_FONT_STYLE, show);
 }
 
-void FontList::on_actionShowFontSampleColumn_toggled(bool show)
-{
+void FontList::on_actionShowFontSampleColumn_toggled(bool show) {
   showColumn(COL_SAMPLE, show);
 }
 
-void FontList::on_actionShowFileNameColumn_toggled(bool show)
-{
+void FontList::on_actionShowFileNameColumn_toggled(bool show) {
   showColumn(COL_FILE_NAME, show);
 }
 
-void FontList::on_actionShowFilePathColumn_toggled(bool show)
-{
+void FontList::on_actionShowFilePathColumn_toggled(bool show) {
   showColumn(COL_FILE_PATH, show);
 }
 
-void FontList::on_actionResetColumns_triggered()
-{
+void FontList::on_actionResetColumns_triggered() {
   actionShowFontNameColumn->setChecked(true);
   actionShowStyledFontNameColumn->setChecked(false);
   actionShowFontStyleColumn->setChecked(true);
@@ -307,9 +296,8 @@ void FontList::on_actionResetColumns_triggered()
   tableView->hideColumn(COL_HASH);
 }
 
-void FontList::on_tableView_customContextMenuRequested(const QPoint& pos)
-{
-  auto *menu = new QMenu(this);
+void FontList::on_tableView_customContextMenuRequested(const QPoint& pos) {
+  auto* menu = new QMenu(this);
   menu->addAction(actionCopyStyle);
   menu->addSeparator();
   menu->addAction(actionCopyFontName);
@@ -320,49 +308,41 @@ void FontList::on_tableView_customContextMenuRequested(const QPoint& pos)
   menu->popup(tableView->viewport()->mapToGlobal(pos));
 }
 
-const QModelIndex FontList::currentIndex() const
-{
+const QModelIndex FontList::currentIndex() const {
   return tableView->selectionModel()->currentIndex();
 }
 
-void FontList::on_actionCopyFontName_triggered()
-{
+void FontList::on_actionCopyFontName_triggered() {
   QApplication::clipboard()->setText(colStr(currentIndex(), COL_FONT_NAME));
 }
 
-void FontList::on_actionCopyStyle_triggered()
-{
+void FontList::on_actionCopyStyle_triggered() {
   font_selected(selection);
   QApplication::clipboard()->setText(selection);
 }
 
-void FontList::on_actionCopyFolder_triggered()
-{
+void FontList::on_actionCopyFolder_triggered() {
   const QFileInfo fileInfo(colStr(currentIndex(), COL_FILE_PATH));
   QApplication::clipboard()->setText(fileInfo.dir().canonicalPath());
 }
 
-void FontList::on_actionCopyFullPath_triggered()
-{
+void FontList::on_actionCopyFullPath_triggered() {
   QApplication::clipboard()->setText(colStr(currentIndex(), COL_FILE_PATH));
 }
 
-void FontList::on_actionOpenFolder_triggered()
-{
+void FontList::on_actionOpenFolder_triggered() {
   const QFileInfo fileInfo(colStr(currentIndex(), COL_FILE_PATH));
   if (fileInfo.dir().exists()) {
-    QDesktopServices::openUrl(QUrl::fromLocalFile(fileInfo.dir().absolutePath()));
+    QDesktopServices::openUrl(
+        QUrl::fromLocalFile(fileInfo.dir().absolutePath()));
   }
 }
 
-void FontList::selection_changed(const QItemSelection& current, const QItemSelection&)
-{
-  const std::array<QAction *, 5> actions = {
-    actionCopyFontName,
-    actionCopyStyle,
-    actionCopyFolder,
-    actionCopyFullPath,
-    actionOpenFolder,
+void FontList::selection_changed(const QItemSelection& current,
+                                 const QItemSelection&) {
+  const std::array<QAction*, 5> actions = {
+      actionCopyFontName, actionCopyStyle,  actionCopyFolder,
+      actionCopyFullPath, actionOpenFolder,
   };
 
   const bool disabled = current.count() == 0;
@@ -383,18 +363,19 @@ void FontList::selection_changed(const QItemSelection& current, const QItemSelec
   const auto name = model->item(idx.row(), COL_FONT_NAME)->text();
   const auto path = model->item(idx.row(), COL_FILE_PATH)->text();
   const auto style = model->item(idx.row(), COL_FONT_STYLE)->text();
-  const auto fcStyle = QString("%1:style=%2").arg(quote(name)).arg(quote(style));
+  const auto fcStyle =
+      QString("%1:style=%2").arg(quote(name)).arg(quote(style));
   this->selection = "\"" + fcStyle + "\"";
   tableView->setDragText(this->selection);
   lineEditFontNameSelected->setText(name);
   lineEditFontNameSelected->setCursorPosition(0);
-  lineEditFontPathSelected->setText(path); // keep cursor at the end to prefer the file name
+  lineEditFontPathSelected->setText(
+      path);  // keep cursor at the end to prefer the file name
   lineEditFcStyleSelected->setText(fcStyle);
   lineEditFcStyleSelected->setCursorPosition(0);
 }
 
-void FontList::update_font_list()
-{
+void FontList::update_font_list() {
   if (proxy) {
     delete proxy;
     proxy = nullptr;
@@ -404,45 +385,56 @@ void FontList::update_font_list()
     model = nullptr;
   }
 
-  const FontInfoList *list = FontCache::instance()->list_fonts();
+  const FontInfoList* list = FontCache::instance()->list_fonts();
   model = new QStandardItemModel(list->size(), COL_COUNT, this);
-  model->setHorizontalHeaderItem(COL_FONT_NAME, new QStandardItem(_("Font name")));
-  model->setHorizontalHeaderItem(COL_STYLED_FONT_NAME, new QStandardItem(_("Styled font name")));
-  model->setHorizontalHeaderItem(COL_FONT_STYLE, new QStandardItem(_("Font style")));
-  model->setHorizontalHeaderItem(COL_SAMPLE, new QStandardItem(_("Sample text"))); // text handled by delegate
-  model->setHorizontalHeaderItem(COL_FILE_NAME, new QStandardItem(_("File name")));
-  model->setHorizontalHeaderItem(COL_FILE_PATH, new QStandardItem(_("File path")));
+  model->setHorizontalHeaderItem(COL_FONT_NAME,
+                                 new QStandardItem(_("Font name")));
+  model->setHorizontalHeaderItem(COL_STYLED_FONT_NAME,
+                                 new QStandardItem(_("Styled font name")));
+  model->setHorizontalHeaderItem(COL_FONT_STYLE,
+                                 new QStandardItem(_("Font style")));
+  model->setHorizontalHeaderItem(
+      COL_SAMPLE,
+      new QStandardItem(_("Sample text")));  // text handled by delegate
+  model->setHorizontalHeaderItem(COL_FILE_NAME,
+                                 new QStandardItem(_("File name")));
+  model->setHorizontalHeaderItem(COL_FILE_PATH,
+                                 new QStandardItem(_("File path")));
   model->setHorizontalHeaderItem(COL_HASH, new QStandardItem(_("Hash")));
 
-  const QString toolTip = R"(<table style="white-space:pre"><tr><td>Name:</td><td><b>%1</b></td></tr><tr><td>Style:</td><td>%2</td></tr></table>)";
+  const QString toolTip =
+      R"(<table style="white-space:pre"><tr><td>Name:</td><td><b>%1</b></td></tr><tr><td>Style:</td><td>%2</td></tr></table>)";
 
   int idx = 0;
   for (auto it = list->begin(); it != list->end(); it++, idx++) {
     const FontInfo& font_info = (*it);
 
-    auto *family = new QStandardItem(QString::fromStdString(font_info.get_family()));
+    auto* family =
+        new QStandardItem(QString::fromStdString(font_info.get_family()));
     family->setEditable(false);
     model->setItem(idx, COL_FONT_NAME, family);
 
-    auto *style = new QStandardItem(QString::fromStdString(font_info.get_style()));
+    auto* style =
+        new QStandardItem(QString::fromStdString(font_info.get_style()));
     style->setEditable(false);
     model->setItem(idx, COL_FONT_STYLE, style);
 
-    auto *styledFamily = new QStandardItem(QString::fromStdString(font_info.get_family()));
+    auto* styledFamily =
+        new QStandardItem(QString::fromStdString(font_info.get_family()));
     styledFamily->setEditable(false);
     styledFamily->setToolTip(toolTip.arg(family->text()).arg(style->text()));
     model->setItem(idx, COL_STYLED_FONT_NAME, styledFamily);
 
     const QFileInfo fileInfo(QString::fromStdString(font_info.get_file()));
-    auto *file = new QStandardItem(fileInfo.fileName());
+    auto* file = new QStandardItem(fileInfo.fileName());
     file->setEditable(false);
     file->setToolTip(fileInfo.canonicalFilePath());
     model->setItem(idx, COL_FILE_NAME, file);
-    auto *filePath = new QStandardItem(fileInfo.canonicalFilePath());
+    auto* filePath = new QStandardItem(fileInfo.canonicalFilePath());
     filePath->setEditable(false);
     model->setItem(idx, COL_FILE_PATH, filePath);
 
-    auto *hash = new QStandardItem(QString::number(font_info.get_hash(), 16));
+    auto* hash = new QStandardItem(QString::number(font_info.get_hash(), 16));
     hash->setEditable(false);
     model->setItem(idx, COL_HASH, hash);
   }
@@ -450,7 +442,8 @@ void FontList::update_font_list()
   proxy = new FontSortFilterProxyModel(this);
   proxy->setSourceModel(model);
   proxy->setFilterCaseSensitivity(Qt::CaseInsensitive);
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  groupBoxFilter->setTitle(
+      QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
 
   this->tableView->setModel(proxy);
   on_actionResetColumns_triggered();
@@ -462,13 +455,13 @@ void FontList::update_font_list()
   this->tableView->resizeColumnsToContents();
   this->tableView->setSortingEnabled(true);
 
-  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &FontList::selection_changed);
+  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged,
+          this, &FontList::selection_changed);
 
   delete list;
 }
 
-void FontList::resizeEvent(QResizeEvent *event)
-{
+void FontList::resizeEvent(QResizeEvent* event) {
   QWidget::resizeEvent(event);
 }
 
@@ -485,26 +478,22 @@ void FontList::resizeEvent(QResizeEvent *event)
  * @param text unquoted string
  * @return quoted text
  */
-QString FontList::quote(const QString& text)
-{
+QString FontList::quote(const QString& text) {
   QString result = text;
   result.replace('\\', R"(\\\\)")
-  .replace('-', "\\\\-")
-  .replace(':', "\\\\:")
-  .replace(',', "\\\\,")
-  .replace('=', "\\\\=")
-  .replace('_', "\\\\_");
+      .replace('-', "\\\\-")
+      .replace(':', "\\\\:")
+      .replace(',', "\\\\,")
+      .replace('=', "\\\\=")
+      .replace('_', "\\\\_");
   return result;
 }
 
-const QModelIndex FontList::colIdx(const QModelIndex& idx, int column)
-{
+const QModelIndex FontList::colIdx(const QModelIndex& idx, int column) {
   return idx.model()->index(idx.row(), column, idx.parent());
 }
 
-const QString FontList::colStr(const QModelIndex& idx, int column)
-{
-  return idx.model() ?
-         idx.model()->data(colIdx(idx, column)).toString() :
-         QString{};
+const QString FontList::colStr(const QModelIndex& idx, int column) {
+  return idx.model() ? idx.model()->data(colIdx(idx, column)).toString()
+                     : QString{};
 }
diff --git a/src/gui/FontList.h b/src/gui/FontList.h
index 5b9162219..8414d2a62 100644
--- a/src/gui/FontList.h
+++ b/src/gui/FontList.h
@@ -12,60 +12,65 @@
 #include <cstdint>
 #include <vector>
 
-#include <QWidget>
+#include <QSortFilterProxyModel>
 #include <QStandardItemModel>
 #include <QStyledItemDelegate>
-#include <QSortFilterProxyModel>
+#include <QWidget>
 
 #include "gui/qtgettext.h"
 #include "ui_FontList.h"
 
-class FontItemDelegate : public QStyledItemDelegate
-{
+class FontItemDelegate : public QStyledItemDelegate {
   Q_OBJECT
 
-public:
-  explicit FontItemDelegate(QObject *parent = nullptr);
+ public:
+  explicit FontItemDelegate(QObject* parent = nullptr);
   int fontSize() const;
   void setFontSize(int fontSize);
   QString text() const;
   void setText(const QString&);
-  QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override;
-  void paint(QPainter *painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override;
-
-protected:
-  void initStyleOption(QStyleOptionViewItem *option, const QModelIndex& index) const override;
-  QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem& option, const QModelIndex& index) const override;
-
-private:
+  QSize sizeHint(const QStyleOptionViewItem& option,
+                 const QModelIndex& index) const override;
+  void paint(QPainter* painter,
+             const QStyleOptionViewItem& option,
+             const QModelIndex& index) const override;
+
+ protected:
+  void initStyleOption(QStyleOptionViewItem* option,
+                       const QModelIndex& index) const override;
+  QWidget* createEditor(QWidget* parent,
+                        const QStyleOptionViewItem& option,
+                        const QModelIndex& index) const override;
+
+ private:
   int _fontSize;
   QString _text;
 };
 
-class FontSortFilterProxyModel : public QSortFilterProxyModel
-{
+class FontSortFilterProxyModel : public QSortFilterProxyModel {
   Q_OBJECT
 
-public:
-  FontSortFilterProxyModel(QObject *parent = nullptr);
+ public:
+  FontSortFilterProxyModel(QObject* parent = nullptr);
 
   void clearFilter();
   void appendFilterHashes(const std::vector<uint32_t>&);
 
-protected:
-  bool filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const override;
+ protected:
+  bool filterAcceptsRow(int sourceRow,
+                        const QModelIndex& sourceParent) const override;
 
-private:
+ private:
   QSet<QString> filterHashes;
 };
 
-class FontList : public QWidget, public Ui::FontListWidget
-{
+class FontList : public QWidget, public Ui::FontListWidget {
   Q_OBJECT
-  static constexpr char SAMPLE_TEXT_DEFAULT[] = "abcdef ABCDEF 012345 0O5S8B 1Iil !$%&/()#";
+  static constexpr char SAMPLE_TEXT_DEFAULT[] =
+      "abcdef ABCDEF 012345 0O5S8B 1Iil !$%&/()#";
 
-public:
-  FontList(QWidget *parent = nullptr);
+ public:
+  FontList(QWidget* parent = nullptr);
   FontList(const FontList& source) = delete;
   FontList(FontList&& source) = delete;
   FontList& operator=(const FontList& source) = delete;
@@ -84,7 +89,7 @@ public:
   static constexpr int COL_HASH = 6;
   static constexpr int COL_COUNT = 7;
 
-public slots:
+ public slots:
   void on_lineEditFontName_textChanged(const QString&);
   void on_comboBoxSearchType_currentIndexChanged(int);
   void updateFilter(int, const QString&);
@@ -119,18 +124,18 @@ public slots:
   static const QModelIndex colIdx(const QModelIndex& idx, int column);
   static const QString colStr(const QModelIndex& idx, int column);
 
-signals:
+ signals:
   void font_selected(const QString font);
 
-protected:
+ protected:
   const QModelIndex currentIndex() const;
-  void resizeEvent(QResizeEvent *event) override;
+  void resizeEvent(QResizeEvent* event) override;
 
-private:
+ private:
   QString quote(const QString& text);
 
   QString selection;
   FontItemDelegate delegate;
-  QStandardItemModel *model;
-  FontSortFilterProxyModel *proxy;
+  QStandardItemModel* model;
+  FontSortFilterProxyModel* proxy;
 };
diff --git a/src/gui/FontListDialog.cc b/src/gui/FontListDialog.cc
index 933971d1a..a9c7f7fbb 100644
--- a/src/gui/FontListDialog.cc
+++ b/src/gui/FontListDialog.cc
@@ -28,36 +28,33 @@
 
 #include <QAbstractItemView>
 #include <QApplication>
+#include <QClipboard>
 #include <QItemSelection>
 #include <QModelIndex>
-#include <QClipboard>
 #include <QSortFilterProxyModel>
 
 #include "FontCache.h"
 
-FontListDialog::FontListDialog()
-{
+FontListDialog::FontListDialog() {
   model = nullptr;
   proxy = nullptr;
   setupUi(this);
   connect(this->okButton, &QPushButton::clicked, this, &FontListDialog::accept);
 }
 
-void FontListDialog::on_copyButton_clicked()
-{
+void FontListDialog::on_copyButton_clicked() {
   font_selected(selection);
 
-  QClipboard *clipboard = QApplication::clipboard();
+  QClipboard* clipboard = QApplication::clipboard();
   clipboard->setText(selection);
 }
 
-void FontListDialog::on_filterLineEdit_textChanged(const QString& text)
-{
+void FontListDialog::on_filterLineEdit_textChanged(const QString& text) {
   proxy->setFilterWildcard(text);
 }
 
-void FontListDialog::selection_changed(const QItemSelection& current, const QItemSelection&)
-{
+void FontListDialog::selection_changed(const QItemSelection& current,
+                                       const QItemSelection&) {
   if (current.count() == 0) {
     copyButton->setEnabled(false);
     tableView->setDragText("");
@@ -72,8 +69,7 @@ void FontListDialog::selection_changed(const QItemSelection& current, const QIte
   tableView->setDragText(selection);
 }
 
-void FontListDialog::updateFontList()
-{
+void FontListDialog::updateFontList() {
   copyButton->setEnabled(false);
 
   if (proxy) {
@@ -85,7 +81,7 @@ void FontListDialog::updateFontList()
     model = nullptr;
   }
 
-  FontInfoList *list = FontCache::instance()->list_fonts();
+  FontInfoList* list = FontCache::instance()->list_fonts();
   model = new QStandardItemModel(list->size(), 3, this);
   model->setHorizontalHeaderItem(0, new QStandardItem(_("Font name")));
   model->setHorizontalHeaderItem(1, new QStandardItem(_("Font style")));
@@ -94,13 +90,13 @@ void FontListDialog::updateFontList()
   int idx = 0;
   for (auto it = list->begin(); it != list->end(); it++, idx++) {
     const FontInfo& font_info = (*it);
-    auto *family = new QStandardItem(QString(font_info.get_family().c_str()));
+    auto* family = new QStandardItem(QString(font_info.get_family().c_str()));
     family->setEditable(false);
     model->setItem(idx, 0, family);
-    auto *style = new QStandardItem(QString(font_info.get_style().c_str()));
+    auto* style = new QStandardItem(QString(font_info.get_style().c_str()));
     style->setEditable(false);
     model->setItem(idx, 1, style);
-    auto *file = new QStandardItem(QString(font_info.get_file().c_str()));
+    auto* file = new QStandardItem(QString(font_info.get_file().c_str()));
     file->setEditable(false);
     model->setItem(idx, 2, file);
   }
@@ -115,7 +111,8 @@ void FontListDialog::updateFontList()
   this->tableView->resizeColumnsToContents();
   this->tableView->setSortingEnabled(true);
 
-  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &FontListDialog::selection_changed);
+  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged,
+          this, &FontListDialog::selection_changed);
 
   delete list;
 }
@@ -133,14 +130,13 @@ void FontListDialog::updateFontList()
  * @param text unquoted string
  * @return quoted text
  */
-QString FontListDialog::quote(const QString& text)
-{
+QString FontListDialog::quote(const QString& text) {
   QString result = text;
   result.replace('\\', R"(\\\\)")
-  .replace('-', "\\\\-")
-  .replace(':', "\\\\:")
-  .replace(',', "\\\\,")
-  .replace('=', "\\\\=")
-  .replace('_', "\\\\_");
+      .replace('-', "\\\\-")
+      .replace(':', "\\\\:")
+      .replace(',', "\\\\,")
+      .replace('=', "\\\\=")
+      .replace('_', "\\\\_");
   return result;
 }
diff --git a/src/gui/FontListDialog.h b/src/gui/FontListDialog.h
index 89f540b51..11304257d 100644
--- a/src/gui/FontListDialog.h
+++ b/src/gui/FontListDialog.h
@@ -2,33 +2,33 @@
 
 #include <QDialog>
 #include <QItemSelection>
-#include <QString>
-#include <QStandardItemModel>
 #include <QSortFilterProxyModel>
+#include <QStandardItemModel>
+#include <QString>
 
 #include "gui/qtgettext.h"
 #include "ui_FontListDialog.h"
 
-class FontListDialog : public QDialog, public Ui::FontListDialog
-{
+class FontListDialog : public QDialog, public Ui::FontListDialog {
   Q_OBJECT;
-public:
+
+ public:
   FontListDialog();
 
   void updateFontList();
 
-public slots:
+ public slots:
   void on_copyButton_clicked();
   void on_filterLineEdit_textChanged(const QString&);
   void selection_changed(const QItemSelection&, const QItemSelection&);
 
-signals:
+ signals:
   void font_selected(const QString font);
 
-private:
+ private:
   QString quote(const QString& text);
 
   QString selection;
-  QStandardItemModel *model;
-  QSortFilterProxyModel *proxy;
+  QStandardItemModel* model;
+  QSortFilterProxyModel* proxy;
 };
diff --git a/src/gui/FontListTableView.cc b/src/gui/FontListTableView.cc
index 00bf5291b..676e84535 100644
--- a/src/gui/FontListTableView.cc
+++ b/src/gui/FontListTableView.cc
@@ -25,27 +25,24 @@
  */
 #include "gui/FontListTableView.h"
 
-#include <QRect>
-#include <QString>
-#include <QWidget>
 #include <QDrag>
-#include <QPixmap>
-#include <QPainter>
 #include <QMimeData>
+#include <QPainter>
+#include <QPixmap>
+#include <QRect>
+#include <QString>
 #include <QTableView>
+#include <QWidget>
 
-FontListTableView::FontListTableView(QWidget *parent) : QTableView(parent)
-{
-}
+FontListTableView::FontListTableView(QWidget* parent) : QTableView(parent) {}
 
-void FontListTableView::setDragText(const QString& text)
-{
+void FontListTableView::setDragText(const QString& text) {
   this->text = text.trimmed();
 }
 
-void FontListTableView::startDrag(Qt::DropActions supportedActions)
-{
-  if (text.isEmpty()) return;
+void FontListTableView::startDrag(Qt::DropActions supportedActions) {
+  if (text.isEmpty())
+    return;
 
   auto mimeData = new QMimeData;
   mimeData->setText(text);
diff --git a/src/gui/FontListTableView.h b/src/gui/FontListTableView.h
index f2f0b4496..da083cd9f 100644
--- a/src/gui/FontListTableView.h
+++ b/src/gui/FontListTableView.h
@@ -1,20 +1,19 @@
 #pragma once
 
 #include <QString>
-#include <QWidget>
 #include <QTableView>
+#include <QWidget>
 
-class FontListTableView : public QTableView
-{
+class FontListTableView : public QTableView {
   Q_OBJECT;
 
-public:
-  FontListTableView(QWidget *parent = nullptr);
+ public:
+  FontListTableView(QWidget* parent = nullptr);
   void setDragText(const QString& text);
 
-protected:
+ protected:
   void startDrag(Qt::DropActions supportedActions) override;
 
-private:
+ private:
   QString text;
 };
diff --git a/src/gui/IgnoreWheelWhenNotFocused.cc b/src/gui/IgnoreWheelWhenNotFocused.cc
index fc12a915b..67e03bd3a 100644
--- a/src/gui/IgnoreWheelWhenNotFocused.cc
+++ b/src/gui/IgnoreWheelWhenNotFocused.cc
@@ -1,28 +1,29 @@
 #include "gui/IgnoreWheelWhenNotFocused.h"
+#include <QComboBox>
+#include <QDoubleSpinBox>
 #include <QEvent>
 #include <QObject>
-#include <QWidget>
-#include <QComboBox>
 #include <QSpinBox>
-#include <QDoubleSpinBox>
+#include <QWidget>
 
-void installIgnoreWheelWhenNotFocused(QWidget *parent){
-  auto comboBoxes = parent->findChildren<QComboBox *>();
-  auto spinBoxes = parent->findChildren<QSpinBox *>();
-  auto spinDoubleBoxes = parent->findChildren<QDoubleSpinBox *>();
+void installIgnoreWheelWhenNotFocused(QWidget* parent) {
+  auto comboBoxes = parent->findChildren<QComboBox*>();
+  auto spinBoxes = parent->findChildren<QSpinBox*>();
+  auto spinDoubleBoxes = parent->findChildren<QDoubleSpinBox*>();
 
-  if (comboBoxes.size() == 0 && spinBoxes.size() == 0 && spinDoubleBoxes.size() == 0){
-    return; //nothing do
+  if (comboBoxes.size() == 0 && spinBoxes.size() == 0 &&
+      spinDoubleBoxes.size() == 0) {
+    return;  // nothing do
   }
 
-  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(parent);
+  auto* ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(parent);
 
   for (auto comboBox : comboBoxes) {
     comboBox->installEventFilter(ignoreWheelWhenNotFocused);
     comboBox->setFocusPolicy(Qt::StrongFocus);
   }
 
-  for (const auto& spinBox : spinBoxes){
+  for (const auto& spinBox : spinBoxes) {
     spinBox->installEventFilter(ignoreWheelWhenNotFocused);
     spinBox->setFocusPolicy(Qt::StrongFocus);
   }
@@ -34,15 +35,13 @@ void installIgnoreWheelWhenNotFocused(QWidget *parent){
 
 }  // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks): False positive
 
-IgnoreWheelWhenNotFocused::IgnoreWheelWhenNotFocused(QWidget *parent) : QObject(parent)
-{
-}
+IgnoreWheelWhenNotFocused::IgnoreWheelWhenNotFocused(QWidget* parent)
+    : QObject(parent) {}
 
-//https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
-bool IgnoreWheelWhenNotFocused::eventFilter(QObject *obj, QEvent *event)
-{
+// https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
+bool IgnoreWheelWhenNotFocused::eventFilter(QObject* obj, QEvent* event) {
   if (event->type() == QEvent::Wheel) {
-    if (!((QWidget *)obj)->hasFocus()) {
+    if (!((QWidget*)obj)->hasFocus()) {
       return true;
     } else {
       return QObject::eventFilter(obj, event);
@@ -51,4 +50,3 @@ bool IgnoreWheelWhenNotFocused::eventFilter(QObject *obj, QEvent *event)
     return QObject::eventFilter(obj, event);
   }
 }
-
diff --git a/src/gui/IgnoreWheelWhenNotFocused.h b/src/gui/IgnoreWheelWhenNotFocused.h
index 192b80d77..05beedfd3 100644
--- a/src/gui/IgnoreWheelWhenNotFocused.h
+++ b/src/gui/IgnoreWheelWhenNotFocused.h
@@ -1,31 +1,29 @@
-//This event filter ignores Mouse Wheel events when the object is not focused.
-//A lot of elements in OpenSCAD are in Scroll Areas.
-//This causes a conflict, as some elements within the Scroll Areas are
-//also reacting to the mousewheel.
-//Especially in the settings, where the user might spend a considerable
-//amount of time to get it just right, it is annoying when simply
-//scrowling down unintentionally changes various settings.
+// This event filter ignores Mouse Wheel events when the object is not focused.
+// A lot of elements in OpenSCAD are in Scroll Areas.
+// This causes a conflict, as some elements within the Scroll Areas are
+// also reacting to the mousewheel.
+// Especially in the settings, where the user might spend a considerable
+// amount of time to get it just right, it is annoying when simply
+// scrowling down unintentionally changes various settings.
 
-//for reference:
-//https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
-//http://doc.qt.io/archives/qt-4.8/qobject.html#installEventFilter
+// for reference:
+// https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
+// http://doc.qt.io/archives/qt-4.8/qobject.html#installEventFilter
 
 #pragma once
 
 #include <QEvent>
+#include <QMouseEvent>
 #include <QObject>
 #include <QWidget>
-#include <QMouseEvent>
 
-void installIgnoreWheelWhenNotFocused(QWidget *parent);
+void installIgnoreWheelWhenNotFocused(QWidget* parent);
 
-class IgnoreWheelWhenNotFocused : public QObject
-{
+class IgnoreWheelWhenNotFocused : public QObject {
   Q_OBJECT
-public:
-  IgnoreWheelWhenNotFocused(QWidget *parent);
+ public:
+  IgnoreWheelWhenNotFocused(QWidget* parent);
 
-protected:
-  bool eventFilter(QObject *obj, QEvent *event) override;
+ protected:
+  bool eventFilter(QObject* obj, QEvent* event) override;
 };
-
diff --git a/src/gui/ImportUtils.cc b/src/gui/ImportUtils.cc
index 25097a58d..ab26d1ee4 100644
--- a/src/gui/ImportUtils.cc
+++ b/src/gui/ImportUtils.cc
@@ -2,7 +2,7 @@
 
 QMap<QString, QString> Importer::knownFileExtensions;
 
-int Importer::init(){
+int Importer::init() {
   const QString importStatement = "import(\"%1\");\n";
   const QString surfaceStatement = "surface(\"%1\");\n";
   const QString importFunction = "data = import(\"%1\");\n";
diff --git a/src/gui/ImportUtils.h b/src/gui/ImportUtils.h
index f186ad3c8..8e1d8e5a0 100644
--- a/src/gui/ImportUtils.h
+++ b/src/gui/ImportUtils.h
@@ -3,9 +3,8 @@
 #include <QMap>
 #include <QString>
 
-class Importer
-{
-public:
+class Importer {
+ public:
   static int init();
   static QMap<QString, QString> knownFileExtensions;
 };
diff --git a/src/gui/InitConfigurator.cc b/src/gui/InitConfigurator.cc
index 14ed64320..fd89bc737 100644
--- a/src/gui/InitConfigurator.cc
+++ b/src/gui/InitConfigurator.cc
@@ -1,45 +1,47 @@
 
 #include "gui/InitConfigurator.h"
 
-#include <QListWidget>
 #include <QCheckBox>
 #include <QComboBox>
 #include <QDoubleSpinBox>
+#include <QGroupBox>
+#include <QLineEdit>
+#include <QListWidget>
 #include <QRadioButton>
+#include <QSettings>
 #include <QSpinBox>
 #include <QString>
-#include <QSettings>
-#include <QLineEdit>
-#include <QGroupBox>
 
 #include "core/Settings.h"
 #include "gui/SettingsWriter.h"
 
 #include <string>
 
-void InitConfigurator::writeSettings()
-{
+void InitConfigurator::writeSettings() {
   Settings::Settings::visit(SettingsWriter());
 }
 
-void InitConfigurator::initUpdateCheckBox(const BlockSignals<QCheckBox *>& checkBox, const Settings::SettingsEntryBool& entry)
-{
+void InitConfigurator::initUpdateCheckBox(
+    const BlockSignals<QCheckBox*>& checkBox,
+    const Settings::SettingsEntryBool& entry) {
   checkBox->setChecked(entry.value());
 }
 
-void InitConfigurator::initIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry)
-{
+void InitConfigurator::initIntSpinBox(const BlockSignals<QSpinBox*>& spinBox,
+                                      const Settings::SettingsEntryInt& entry) {
   spinBox->setMinimum(entry.minimum());
   spinBox->setMaximum(entry.maximum());
 }
 
-void InitConfigurator::updateIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry)
-{
+void InitConfigurator::updateIntSpinBox(
+    const BlockSignals<QSpinBox*>& spinBox,
+    const Settings::SettingsEntryInt& entry) {
   spinBox->setValue(entry.value());
 }
 
-void InitConfigurator::initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble& entry)
-{
+void InitConfigurator::initUpdateDoubleSpinBox(
+    QDoubleSpinBox* spinBox,
+    const Settings::SettingsEntryDouble& entry) {
   spinBox->blockSignals(true);
   spinBox->setSingleStep(entry.step());
   spinBox->setMinimum(entry.minimum());
@@ -48,28 +50,37 @@ void InitConfigurator::initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox, const Se
   spinBox->blockSignals(false);
 }
 
-void InitConfigurator::initListBox(QListWidget *listBox, const Settings::SettingsEntryList<Settings::LocalAppParameter>& list)
-{
+void InitConfigurator::initListBox(
+    QListWidget* listBox,
+    const Settings::SettingsEntryList<Settings::LocalAppParameter>& list) {
   listBox->blockSignals(true);
   listBox->clear();
   for (const auto& listitem : list.value()) {
     if (listitem.type == Settings::LocalAppParameterType::string) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::string), QString::fromStdString(listitem.value));
+      const auto item =
+          createListItem(Settings::LocalAppParameterType(
+                             Settings::LocalAppParameterType::string),
+                         QString::fromStdString(listitem.value));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::file) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::file));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::file));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::dir) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::dir));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::dir));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::extension) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::extension));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::extension));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::source) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::source));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::source));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::sourcedir) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::sourcedir));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::sourcedir));
       listBox->insertItem(listBox->count(), item);
     }
   }
@@ -77,8 +88,8 @@ void InitConfigurator::initListBox(QListWidget *listBox, const Settings::Setting
   listBox->blockSignals(false);
 }
 
-void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *>& comboBox, const std::string& value)
-{
+void InitConfigurator::updateComboBox(const BlockSignals<QComboBox*>& comboBox,
+                                      const std::string& value) {
   int index = comboBox->findData(QString::fromStdString(value));
   if (index >= 0) {
     comboBox->setCurrentIndex(index);
@@ -87,14 +98,22 @@ void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *>& comboBox,
   }
 }
 
-void InitConfigurator::initMetaData(QCheckBox *checkBox, QLineEdit *lineEdit, Settings::SettingsEntryBool *settingsEntryFlag, Settings::SettingsEntryString& settingsEntry) {
+void InitConfigurator::initMetaData(
+    QCheckBox* checkBox,
+    QLineEdit* lineEdit,
+    Settings::SettingsEntryBool* settingsEntryFlag,
+    Settings::SettingsEntryString& settingsEntry) {
   lineEdit->setText(QString::fromStdString(settingsEntry.value()));
   if (checkBox && settingsEntryFlag) {
     checkBox->setChecked(settingsEntryFlag->value());
   }
 }
 
-void InitConfigurator::applyMetaData(const QCheckBox *checkBox, const QLineEdit *lineEdit, Settings::SettingsEntryBool *settingsEntryFlag, Settings::SettingsEntryString& settingsEntry) {
+void InitConfigurator::applyMetaData(
+    const QCheckBox* checkBox,
+    const QLineEdit* lineEdit,
+    Settings::SettingsEntryBool* settingsEntryFlag,
+    Settings::SettingsEntryString& settingsEntry) {
   if (checkBox && settingsEntryFlag) {
     settingsEntryFlag->setValue(checkBox->isChecked());
   }
diff --git a/src/gui/InitConfigurator.h b/src/gui/InitConfigurator.h
index 10557128c..ed9bb427f 100644
--- a/src/gui/InitConfigurator.h
+++ b/src/gui/InitConfigurator.h
@@ -1,21 +1,20 @@
 #pragma once
 
-#include <QSettings>
-#include <QObject>
-#include <QComboBox>
-#include <QSpinBox>
+#include <QButtonGroup>
 #include <QCheckBox>
+#include <QComboBox>
 #include <QListWidget>
-#include <QButtonGroup>
+#include <QObject>
+#include <QSettings>
+#include <QSpinBox>
 #include <cstdint>
 #include <string>
 
 #include "core/Settings.h"
 
 template <class WidgetPtr>
-class BlockSignals
-{
-public:
+class BlockSignals {
+ public:
   BlockSignals(WidgetPtr w) : w(w) { w->blockSignals(true); }
   ~BlockSignals() { w->blockSignals(false); }
   WidgetPtr operator->() const { return w; }
@@ -23,50 +22,72 @@ public:
   BlockSignals(const BlockSignals&) = delete;
   BlockSignals& operator=(BlockSignals const&) = delete;
 
-private:
+ private:
   WidgetPtr w;
 };
 
-class InitConfigurator
-{
-protected:
+class InitConfigurator {
+ protected:
   void writeSettings();
   /** Set checkbox status from the settings value */
-  void initUpdateCheckBox(const BlockSignals<QCheckBox *>& checkBox, const Settings::SettingsEntryBool& entry);
+  void initUpdateCheckBox(const BlockSignals<QCheckBox*>& checkBox,
+                          const Settings::SettingsEntryBool& entry);
   /** Initialize spinbox min/max values from the settings range values */
-  void initIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry);
+  void initIntSpinBox(const BlockSignals<QSpinBox*>& spinBox,
+                      const Settings::SettingsEntryInt& entry);
   /** Set spinbox value from the settings value */
-  void updateIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry);
+  void updateIntSpinBox(const BlockSignals<QSpinBox*>& spinBox,
+                        const Settings::SettingsEntryInt& entry);
   /** Set spinbox value and min/max/step from the settings value */
-  void initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble& entry);
+  void initUpdateDoubleSpinBox(QDoubleSpinBox* spinBox,
+                               const Settings::SettingsEntryDouble& entry);
   /** Initialize specialized list box */
-  void initListBox(QListWidget *listBox, const Settings::SettingsEntryList<Settings::LocalAppParameter>& list);
+  void initListBox(
+      QListWidget* listBox,
+      const Settings::SettingsEntryList<Settings::LocalAppParameter>& list);
   /** Initialize combobox list values from the settings range values */
   template <typename enum_type>
-  void initComboBox(QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type>& entry);
+  void initComboBox(QComboBox* comboBox,
+                    const Settings::SettingsEntryEnum<enum_type>& entry);
   /** Update combobox from current settings */
   template <typename enum_type>
-  void updateComboBox(const BlockSignals<QComboBox *>& comboBox, const Settings::SettingsEntryEnum<enum_type>& entry);
+  void updateComboBox(const BlockSignals<QComboBox*>& comboBox,
+                      const Settings::SettingsEntryEnum<enum_type>& entry);
   /** Update combobox from current settings */
-  void updateComboBox(const BlockSignals<QComboBox *>& comboBox, const std::string& value);
-  /** Init a button group with an enum setting, this needs a custom property on the radio buttons */
+  void updateComboBox(const BlockSignals<QComboBox*>& comboBox,
+                      const std::string& value);
+  /** Init a button group with an enum setting, this needs a custom property on
+   * the radio buttons */
   template <typename enum_type>
-  void initButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, const Settings::SettingsEntryEnum<enum_type>& entry);
-  /** Apply selected value from button to settings, this needs a custom property on the radio buttons */
+  void initButtonGroup(const BlockSignals<QButtonGroup*>& buttonGroup,
+                       const Settings::SettingsEntryEnum<enum_type>& entry);
+  /** Apply selected value from button to settings, this needs a custom property
+   * on the radio buttons */
   template <typename enum_type>
-  void applyButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, Settings::SettingsEntryEnum<enum_type>& entry);
+  void applyButtonGroup(const BlockSignals<QButtonGroup*>& buttonGroup,
+                        Settings::SettingsEntryEnum<enum_type>& entry);
 
-  void initMetaData(QCheckBox *, QLineEdit *, Settings::SettingsEntryBool *, Settings::SettingsEntryString&);
-  void applyMetaData(const QCheckBox *, const QLineEdit *, Settings::SettingsEntryBool *, Settings::SettingsEntryString&);
+  void initMetaData(QCheckBox*,
+                    QLineEdit*,
+                    Settings::SettingsEntryBool*,
+                    Settings::SettingsEntryString&);
+  void applyMetaData(const QCheckBox*,
+                     const QLineEdit*,
+                     Settings::SettingsEntryBool*,
+                     Settings::SettingsEntryString&);
 
   template <typename item_type>
-  QListWidgetItem *createListItem(const item_type& itemType, const QString& text = "", bool editable = false) {
+  QListWidgetItem* createListItem(const item_type& itemType,
+                                  const QString& text = "",
+                                  bool editable = false) {
     const auto icon = QIcon::fromTheme(QString::fromStdString(itemType.icon()));
     std::string description = itemType.description();
-    const auto itemText = description.empty() ? text : QString::fromStdString(description);
-    const auto listItem = new QListWidgetItem(icon, itemText,
-                                              nullptr,
-                                              static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(itemType));
+    const auto itemText =
+        description.empty() ? text : QString::fromStdString(description);
+    const auto listItem =
+        new QListWidgetItem(icon, itemText, nullptr,
+                            static_cast<int>(QListWidgetItem::UserType) +
+                                static_cast<int>(itemType));
     if (editable) {
       listItem->setFlags(listItem->flags() | Qt::ItemIsEditable);
     }
@@ -75,26 +96,31 @@ protected:
 };
 
 template <typename enum_type>
-void InitConfigurator::initComboBox(QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
+void InitConfigurator::initComboBox(
+    QComboBox* comboBox,
+    const Settings::SettingsEntryEnum<enum_type>& entry) {
   comboBox->clear();
   for (const auto& item : entry.items()) {
-    comboBox->addItem(QString::fromStdString(item.description), QString::fromStdString(item.name));
+    comboBox->addItem(QString::fromStdString(item.description),
+                      QString::fromStdString(item.name));
   }
   updateComboBox(comboBox, entry);
 }
 
 template <typename enum_type>
-void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *>& comboBox, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
+void InitConfigurator::updateComboBox(
+    const BlockSignals<QComboBox*>& comboBox,
+    const Settings::SettingsEntryEnum<enum_type>& entry) {
   comboBox->setCurrentIndex(entry.index());
 }
 
 template <typename enum_type>
-void InitConfigurator::initButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
+void InitConfigurator::initButtonGroup(
+    const BlockSignals<QButtonGroup*>& buttonGroup,
+    const Settings::SettingsEntryEnum<enum_type>& entry) {
   for (const auto button : buttonGroup->buttons()) {
-    const auto settingsValue = button->property(Settings::PROPERTY_NAME).toString().toStdString();
+    const auto settingsValue =
+        button->property(Settings::PROPERTY_NAME).toString().toStdString();
     if (settingsValue == entry.item().name) {
       button->setChecked(true);
     }
@@ -102,11 +128,13 @@ void InitConfigurator::initButtonGroup(const BlockSignals<QButtonGroup *>& butto
 }
 
 template <typename enum_type>
-void InitConfigurator::applyButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, Settings::SettingsEntryEnum<enum_type>& entry)
-{
+void InitConfigurator::applyButtonGroup(
+    const BlockSignals<QButtonGroup*>& buttonGroup,
+    Settings::SettingsEntryEnum<enum_type>& entry) {
   const auto button = buttonGroup->checkedButton();
   if (button) {
-    const auto settingsValue = button->property(Settings::PROPERTY_NAME).toString().toStdString();
+    const auto settingsValue =
+        button->property(Settings::PROPERTY_NAME).toString().toStdString();
     entry.setValue(entry.decode(settingsValue));
   }
 }
diff --git a/src/gui/LaunchingScreen.cc b/src/gui/LaunchingScreen.cc
index adc36e103..dbbd10bbf 100644
--- a/src/gui/LaunchingScreen.cc
+++ b/src/gui/LaunchingScreen.cc
@@ -1,42 +1,43 @@
 #include "gui/LaunchingScreen.h"
 
 #include <QDialog>
+#include <QFileInfo>
+#include <QListWidgetItem>
 #include <QModelIndex>
 #include <QStringList>
 #include <QVariant>
 #include <QWidget>
-#include <QFileInfo>
-#include <QListWidgetItem>
 
-#include "version.h"
-#include "ui_LaunchingScreen.h"
 #include "gui/QSettingsCached.h"
+#include "ui_LaunchingScreen.h"
+#include "version.h"
 
 #include "gui/UIUtils.h"
 
-LaunchingScreen *LaunchingScreen::inst = nullptr;
+LaunchingScreen* LaunchingScreen::inst = nullptr;
 
-LaunchingScreen *LaunchingScreen::getDialog() {
+LaunchingScreen* LaunchingScreen::getDialog() {
   return LaunchingScreen::inst;
 }
 
 // Called (possibly multiple times) by EventFilter on MacOS, e.g.
 // when the user opens files from Finder.
-void LaunchingScreen::openFile(const QString& filename)
-{
+void LaunchingScreen::openFile(const QString& filename) {
   QVariant v(filename);
   this->checkOpen(v, false);
   this->done(QDialog::Accepted);
 }
 
-LaunchingScreen::LaunchingScreen(QWidget *parent) : QDialog(parent)
-{
+LaunchingScreen::LaunchingScreen(QWidget* parent) : QDialog(parent) {
   LaunchingScreen::inst = this;
   setupUi(this);
 
-  this->setStyleSheet("QDialog {background-image:url(':/icons/background.png')} QPushButton {color:white;}");
+  this->setStyleSheet(
+      "QDialog {background-image:url(':/icons/background.png')} QPushButton "
+      "{color:white;}");
 
-  this->versionNumberLabel->setText("OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
+  this->versionNumberLabel->setText(
+      "OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
 
   QStringList recentFiles = UIUtils::recentFiles();
   for (const auto& recentFile : recentFiles) {
@@ -49,9 +50,11 @@ LaunchingScreen::LaunchingScreen(QWidget *parent) : QDialog(parent)
 
   for (const auto& category : UIUtils::exampleCategories()) {
     auto examples = UIUtils::exampleFiles(category.name);
-    auto categoryItem = new QTreeWidgetItem(QStringList(gettext(category.name.toStdString().c_str())));
+    auto categoryItem = new QTreeWidgetItem(
+        QStringList(gettext(category.name.toStdString().c_str())));
     if (!category.tooltip.trimmed().isEmpty()) {
-      categoryItem->setToolTip(0, gettext(category.tooltip.toStdString().c_str()));
+      categoryItem->setToolTip(0,
+                               gettext(category.tooltip.toStdString().c_str()));
     }
 
     for (const auto& example : examples) {
@@ -63,44 +66,51 @@ LaunchingScreen::LaunchingScreen(QWidget *parent) : QDialog(parent)
     this->treeWidget->addTopLevelItem(categoryItem);
   }
 
-  connect(this->pushButtonNew, &QPushButton::clicked, this, &LaunchingScreen::accept);
-  connect(this->pushButtonOpen, &QPushButton::clicked, this, &LaunchingScreen::openUserFile);
-  connect(this->pushButtonHelp, &QPushButton::clicked, this, &LaunchingScreen::openUserManualURL);
-  connect(this->recentList->selectionModel(), &QItemSelectionModel::currentRowChanged, this, &LaunchingScreen::enableRecentButton);
-
-  connect(this->recentList, &QListWidget::itemDoubleClicked, this, &LaunchingScreen::openRecent);
-  connect(this->treeWidget, &QTreeWidget::currentItemChanged, this, &LaunchingScreen::enableExampleButton);
-
-  connect(this->treeWidget, &QTreeWidget::itemDoubleClicked, this, &LaunchingScreen::openExample);
-  connect(this->openRecentButton, &QPushButton::clicked, this, &LaunchingScreen::openRecent);
-  connect(this->openExampleButton, &QPushButton::clicked, this, &LaunchingScreen::openExample);
-  connect(this->checkBox, &QCheckBox::toggled, this, &LaunchingScreen::checkboxState);
+  connect(this->pushButtonNew, &QPushButton::clicked, this,
+          &LaunchingScreen::accept);
+  connect(this->pushButtonOpen, &QPushButton::clicked, this,
+          &LaunchingScreen::openUserFile);
+  connect(this->pushButtonHelp, &QPushButton::clicked, this,
+          &LaunchingScreen::openUserManualURL);
+  connect(this->recentList->selectionModel(),
+          &QItemSelectionModel::currentRowChanged, this,
+          &LaunchingScreen::enableRecentButton);
+
+  connect(this->recentList, &QListWidget::itemDoubleClicked, this,
+          &LaunchingScreen::openRecent);
+  connect(this->treeWidget, &QTreeWidget::currentItemChanged, this,
+          &LaunchingScreen::enableExampleButton);
+
+  connect(this->treeWidget, &QTreeWidget::itemDoubleClicked, this,
+          &LaunchingScreen::openExample);
+  connect(this->openRecentButton, &QPushButton::clicked, this,
+          &LaunchingScreen::openRecent);
+  connect(this->openExampleButton, &QPushButton::clicked, this,
+          &LaunchingScreen::openExample);
+  connect(this->checkBox, &QCheckBox::toggled, this,
+          &LaunchingScreen::checkboxState);
 }
 
-LaunchingScreen::~LaunchingScreen()
-{
+LaunchingScreen::~LaunchingScreen() {
   LaunchingScreen::inst = nullptr;
 }
 
-QStringList LaunchingScreen::selectedFiles() const
-{
+QStringList LaunchingScreen::selectedFiles() const {
   return this->files;
 }
 
-bool LaunchingScreen::isForceShowEditor() const
-{
+bool LaunchingScreen::isForceShowEditor() const {
   return this->forceShowEditor || this->files.isEmpty();
 }
 
-void LaunchingScreen::enableRecentButton(const QModelIndex&, const QModelIndex&)
-{
+void LaunchingScreen::enableRecentButton(const QModelIndex&,
+                                         const QModelIndex&) {
   this->openRecentButton->setEnabled(true);
   this->openRecentButton->setDefault(true);
 }
 
-void LaunchingScreen::openRecent()
-{
-  QListWidgetItem *item = this->recentList->currentItem();
+void LaunchingScreen::openRecent() {
+  QListWidgetItem* item = this->recentList->currentItem();
   if (item == nullptr) {
     return;
   }
@@ -108,16 +118,15 @@ void LaunchingScreen::openRecent()
   checkOpen(item->data(Qt::UserRole), false);
 }
 
-void LaunchingScreen::enableExampleButton(QTreeWidgetItem *current, QTreeWidgetItem *)
-{
+void LaunchingScreen::enableExampleButton(QTreeWidgetItem* current,
+                                          QTreeWidgetItem*) {
   const bool enable = current->childCount() == 0;
   this->openExampleButton->setEnabled(enable);
   this->openExampleButton->setDefault(true);
 }
 
-void LaunchingScreen::openExample()
-{
-  QTreeWidgetItem *item = this->treeWidget->currentItem();
+void LaunchingScreen::openExample() {
+  QTreeWidgetItem* item = this->treeWidget->currentItem();
   if (item == nullptr) {
     return;
   }
@@ -125,8 +134,7 @@ void LaunchingScreen::openExample()
   checkOpen(item->data(0, Qt::UserRole), true);
 }
 
-void LaunchingScreen::checkOpen(const QVariant& data, bool forceShowEditor)
-{
+void LaunchingScreen::checkOpen(const QVariant& data, bool forceShowEditor) {
   const QString path = data.toString();
   if (path.isEmpty()) {
     return;
@@ -137,8 +145,7 @@ void LaunchingScreen::checkOpen(const QVariant& data, bool forceShowEditor)
   accept();
 }
 
-void LaunchingScreen::openUserFile()
-{
+void LaunchingScreen::openUserFile() {
   QFileInfo fileInfo = UIUtils::openFile(this);
   if (fileInfo.exists()) {
     this->forceShowEditor = false;
@@ -147,13 +154,11 @@ void LaunchingScreen::openUserFile()
   }
 }
 
-void LaunchingScreen::checkboxState(bool state) const
-{
+void LaunchingScreen::checkboxState(bool state) const {
   QSettingsCached settings;
   settings.setValue("launcher/showOnStartup", !state);
 }
 
-void LaunchingScreen::openUserManualURL() const
-{
+void LaunchingScreen::openUserManualURL() const {
   UIUtils::openUserManualURL();
 }
diff --git a/src/gui/LaunchingScreen.h b/src/gui/LaunchingScreen.h
index dba08efa9..bbf429b4e 100644
--- a/src/gui/LaunchingScreen.h
+++ b/src/gui/LaunchingScreen.h
@@ -1,43 +1,43 @@
 #pragma once
 
+#include <QDialog>
 #include <QModelIndex>
+#include <QString>
 #include <QStringList>
+#include <QTreeWidgetItem>
 #include <QVariant>
 #include <QWidget>
-#include <QString>
-#include <QDialog>
-#include <QTreeWidgetItem>
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "gui/qtgettext.h"  // IWYU pragma: keep
 #include "ui_LaunchingScreen.h"
 
-class LaunchingScreen : public QDialog, public Ui::LaunchingScreen
-{
+class LaunchingScreen : public QDialog, public Ui::LaunchingScreen {
   Q_OBJECT
 
-public:
-  static LaunchingScreen *getDialog();
-  explicit LaunchingScreen(QWidget *parent = nullptr);
+ public:
+  static LaunchingScreen* getDialog();
+  explicit LaunchingScreen(QWidget* parent = nullptr);
   ~LaunchingScreen() override;
   QStringList selectedFiles() const;
   bool isForceShowEditor() const;
 
-public slots:
+ public slots:
   void openFile(const QString& filename);
 
-private slots:
+ private slots:
   void checkboxState(bool state) const;
-  void enableRecentButton(const QModelIndex& current, const QModelIndex& previous);
-  void enableExampleButton(QTreeWidgetItem *current, QTreeWidgetItem *previous);
+  void enableRecentButton(const QModelIndex& current,
+                          const QModelIndex& previous);
+  void enableExampleButton(QTreeWidgetItem* current, QTreeWidgetItem* previous);
   void openUserFile();
   void openRecent();
   void openExample();
   void openUserManualURL() const;
 
-private:
+ private:
   void checkOpen(const QVariant& data, bool forceShowEditor);
 
   QStringList files;
   bool forceShowEditor{true};
-  static LaunchingScreen *inst;
+  static LaunchingScreen* inst;
 };
diff --git a/src/gui/LibraryInfoDialog.cc b/src/gui/LibraryInfoDialog.cc
index 9742125a9..65accda92 100644
--- a/src/gui/LibraryInfoDialog.cc
+++ b/src/gui/LibraryInfoDialog.cc
@@ -6,20 +6,19 @@
 #include <QTextEdit>
 #include "LibraryInfo.h"
 
-LibraryInfoDialog::LibraryInfoDialog(const QString& rendererInfo)
-{
+LibraryInfoDialog::LibraryInfoDialog(const QString& rendererInfo) {
   setupUi(this);
-  connect(this->okButton, &QPushButton::clicked, this, &LibraryInfoDialog::accept);
+  connect(this->okButton, &QPushButton::clicked, this,
+          &LibraryInfoDialog::accept);
   updateLibraryInfo(rendererInfo);
 }
 
-void LibraryInfoDialog::updateLibraryInfo(const QString& rendererInfo)
-{
-  //Get library infos
+void LibraryInfoDialog::updateLibraryInfo(const QString& rendererInfo) {
+  // Get library infos
   QString info(LibraryInfo::info().c_str());
   info += rendererInfo;
 
-  //Parse infos and make it html
+  // Parse infos and make it html
   info = info.replace("<", "&lt;").replace(">", "&gt;").replace("\n", "<br/>");
 
   auto end = false;
@@ -27,13 +26,13 @@ void LibraryInfoDialog::updateLibraryInfo(const QString& rendererInfo)
   while (!end) {
     int endIndex = info.indexOf(":", startIndex);
     if (endIndex != -1) {
-      //add bold to property name
+      // add bold to property name
       info = info.insert(startIndex, "<b>");
       endIndex += 3;
       info = info.replace(endIndex, 1, ":</b>");
       startIndex = info.indexOf("<br/>", endIndex);
 
-      //handle property with multiple lines
+      // handle property with multiple lines
       auto endInd = info.indexOf(":", startIndex);
       if (endInd != -1) {
         QStringRef lines(&info, startIndex, endInd - startIndex);
diff --git a/src/gui/LibraryInfoDialog.h b/src/gui/LibraryInfoDialog.h
index c7f6c8fa4..1809816f4 100644
--- a/src/gui/LibraryInfoDialog.h
+++ b/src/gui/LibraryInfoDialog.h
@@ -3,14 +3,13 @@
 #include <QDialog>
 #include <QString>
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "gui/qtgettext.h"  // IWYU pragma: keep
 #include "ui_LibraryInfoDialog.h"
 
-class LibraryInfoDialog : public QDialog, public Ui::LibraryInfoDialog
-{
+class LibraryInfoDialog : public QDialog, public Ui::LibraryInfoDialog {
   Q_OBJECT;
 
-public:
+ public:
   LibraryInfoDialog(const QString& rendererInfo);
 
   void updateLibraryInfo(const QString& rendererInfo);
diff --git a/src/gui/MainWindow.cc b/src/gui/MainWindow.cc
index 9bb195a24..959d84127 100644
--- a/src/gui/MainWindow.cc
+++ b/src/gui/MainWindow.cc
@@ -26,27 +26,23 @@
 
 #include "gui/MainWindow.h"
 
+#include <sys/stat.h>
+#include <algorithm>
+#include <cassert>
+#include <cstdio>
 #include <cstring>
-#include <filesystem>
 #include <deque>
-#include <cassert>
-#include <functional>
 #include <exception>
-#include <sstream>
+#include <filesystem>
+#include <fstream>
+#include <functional>
 #include <iostream>
 #include <memory>
+#include <sstream>
 #include <string>
-#include <vector>
-#include <cstdio>
-#include <memory>
 #include <utility>
-#include <memory>
-#include <string>
-#include <fstream>
-#include <algorithm>
-#include <sys/stat.h>
+#include <vector>
 
-#include <boost/version.hpp>
 #include <QApplication>
 #include <QClipboard>
 #include <QDesktopServices>
@@ -74,7 +70,7 @@
 #include <QProcess>
 #include <QProgressDialog>
 #include <QScreen>
-#include <QSettings> //Include QSettings for direct operations on settings arrays
+#include <QSettings>  //Include QSettings for direct operations on settings arrays
 #include <QSignalMapper>
 #include <QSoundEffect>
 #include <QSplitter>
@@ -89,43 +85,42 @@
 #include <QUrl>
 #include <QVBoxLayout>
 #include <QWidget>
+#include <boost/version.hpp>
 
 #include "core/AST.h"
 #include "core/BuiltinContext.h"
 #include "core/Builtins.h"
 #include "core/CSGNode.h"
 #include "core/Context.h"
-#include "core/customizer/CommentParser.h"
 #include "core/EvaluationSession.h"
 #include "core/Expression.h"
-#include "core/node.h"
-#include "core/parsersettings.h"
-#include "core/progress.h"
 #include "core/RenderVariables.h"
 #include "core/ScopeContext.h"
 #include "core/Settings.h"
 #include "core/SourceFileCache.h"
+#include "core/customizer/CommentParser.h"
+#include "core/node.h"
+#include "core/parsersettings.h"
+#include "core/progress.h"
 #include "geometry/Geometry.h"
 #include "geometry/GeometryCache.h"
 #include "geometry/GeometryEvaluator.h"
 #include "glview/PolySetRenderer.h"
+#include "glview/RenderSettings.h"
 #include "glview/cgal/CGALRenderer.h"
 #include "glview/preview/CSGTreeNormalizer.h"
 #include "glview/preview/ThrownTogetherRenderer.h"
-#include "glview/RenderSettings.h"
 #include "gui/AboutDialog.h"
 #include "gui/CGALWorker.h"
-#include "gui/Editor.h"
 #include "gui/Dock.h"
-#include "gui/Measurement.h"
+#include "gui/Editor.h"
 #include "gui/Export3mfDialog.h"
 #include "gui/ExportPdfDialog.h"
 #include "gui/ExternalToolInterface.h"
 #include "gui/FontListDialog.h"
 #include "gui/ImportUtils.h"
-#include "gui/input/InputDriverEvent.h"
-#include "gui/input/InputDriverManager.h"
 #include "gui/LibraryInfoDialog.h"
+#include "gui/Measurement.h"
 #include "gui/OpenSCADApp.h"
 #include "gui/Preferences.h"
 #include "gui/PrintInitDialog.h"
@@ -133,10 +128,12 @@
 #include "gui/QGLView.h"
 #include "gui/QSettingsCached.h"
 #include "gui/QWordSearchField.h"
-#include "gui/SettingsWriter.h"
 #include "gui/ScintillaEditor.h"
+#include "gui/SettingsWriter.h"
 #include "gui/TabManager.h"
 #include "gui/UIUtils.h"
+#include "gui/input/InputDriverEvent.h"
+#include "gui/input/InputDriverManager.h"
 #include "io/dxfdim.h"
 #include "io/export.h"
 #include "io/fileutils.h"
@@ -147,34 +144,34 @@
 #include "version.h"
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgal.h"
 #include "geometry/cgal/CGALCache.h"
 #include "geometry/cgal/CGALNefGeometry.h"
-#endif // ENABLE_CGAL
+#include "geometry/cgal/cgal.h"
+#endif  // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-#include "geometry/manifold/manifoldutils.h"
 #include "geometry/manifold/ManifoldGeometry.h"
-#endif // ENABLE_MANIFOLD
+#include "geometry/manifold/manifoldutils.h"
+#endif  // ENABLE_MANIFOLD
 #ifdef ENABLE_OPENCSG
+#include <opencsg.h>
 #include "core/CSGTreeEvaluator.h"
 #include "glview/preview/OpenCSGRenderer.h"
-#include <opencsg.h>
 #endif
 #ifdef OPENSCAD_UPDATER
 #include "gui/AutoUpdater.h"
 #endif
 
 #ifdef ENABLE_PYTHON
-#include "python/python_public.h"
-#include "nettle/sha2.h"
 #include "nettle/base64.h"
+#include "nettle/sha2.h"
+#include "python/python_public.h"
 
-std::string SHA256HashString(std::string aString){
+std::string SHA256HashString(std::string aString) {
   uint8_t digest[SHA256_DIGEST_SIZE];
   sha256_ctx sha256_ctx;
 
   sha256_init(&sha256_ctx);
-  sha256_update(&sha256_ctx, aString.length(), (uint8_t *) aString.c_str());
+  sha256_update(&sha256_ctx, aString.length(), (uint8_t*)aString.c_str());
   sha256_digest(&sha256_ctx, SHA256_DIGEST_SIZE, digest);
 
   base64_encode_ctx base64_ctx;
@@ -187,66 +184,69 @@ std::string SHA256HashString(std::string aString){
   return digest_base64;
 }
 
-#endif // ifdef ENABLE_PYTHON
+#endif  // ifdef ENABLE_PYTHON
 
 #include "gui/PrintService.h"
 
-
 // Global application state
 unsigned int GuiLocker::guiLocked = 0;
 
 bool MainWindow::undockMode = false;
 bool MainWindow::reorderMode = false;
 const int MainWindow::tabStopWidth = 15;
-QElapsedTimer *MainWindow::progressThrottle = new QElapsedTimer();
+QElapsedTimer* MainWindow::progressThrottle = new QElapsedTimer();
 
 namespace {
 
 const int autoReloadPollingPeriodMS = 200;
 const char copyrighttext[] =
-  "<p>Copyright (C) 2009-2025 The OpenSCAD Developers</p>"
-  "<p>This program is free software; you can redistribute it and/or modify "
-  "it under the terms of the GNU General Public License as published by "
-  "the Free Software Foundation; either version 2 of the License, or "
-  "(at your option) any later version.<p>";
+    "<p>Copyright (C) 2009-2025 The OpenSCAD Developers</p>"
+    "<p>This program is free software; you can redistribute it and/or modify "
+    "it under the terms of the GNU General Public License as published by "
+    "the Free Software Foundation; either version 2 of the License, or "
+    "(at your option) any later version.<p>";
 
 struct DockFocus {
-  Dock *widget;
-  std::function<void(MainWindow *)> focus;
+  Dock* widget;
+  std::function<void(MainWindow*)> focus;
 };
 
-QAction *findAction(const QList<QAction *>& actions, const std::string& name)
-{
+QAction* findAction(const QList<QAction*>& actions, const std::string& name) {
   for (const auto action : actions) {
     if (action->objectName().toStdString() == name) {
       return action;
     }
     if (action->menu()) {
       auto foundAction = findAction(action->menu()->actions(), name);
-      if (foundAction) return foundAction;
+      if (foundAction)
+        return foundAction;
     }
   }
   return nullptr;
 }
 
 void fileExportedMessage(const QString& format, const QString& filename) {
-  LOG("%1$s export finished: %2$s", format.toUtf8().constData(), filename.toUtf8().constData());
+  LOG("%1$s export finished: %2$s", format.toUtf8().constData(),
+      filename.toUtf8().constData());
 }
 
-void removeExportActions(QToolBar *toolbar, QAction *action) {
+void removeExportActions(QToolBar* toolbar, QAction* action) {
   int idx = toolbar->actions().indexOf(action);
   while (idx > 0) {
-    QAction *a = toolbar->actions().at(idx - 1);
-    if (a->objectName().isEmpty())     // separator
+    QAction* a = toolbar->actions().at(idx - 1);
+    if (a->objectName().isEmpty())  // separator
       break;
     toolbar->removeAction(a);
     idx--;
   }
 }
 
-void addExportActions(const MainWindow *mainWindow, QToolBar *toolbar, QAction *action) {
-  for (const std::string& identifier : {Settings::Settings::toolbarExport3D.value(),
-                                        Settings::Settings::toolbarExport2D.value()}) {
+void addExportActions(const MainWindow* mainWindow,
+                      QToolBar* toolbar,
+                      QAction* action) {
+  for (const std::string& identifier :
+       {Settings::Settings::toolbarExport3D.value(),
+        Settings::Settings::toolbarExport2D.value()}) {
     FileFormat format;
     fileformat::fromIdentifier(identifier, format);
     const auto it = mainWindow->exportMap.find(format);
@@ -258,36 +258,36 @@ void addExportActions(const MainWindow *mainWindow, QToolBar *toolbar, QAction *
 }
 
 std::unique_ptr<ExternalToolInterface> createExternalToolService(
-  print_service_t serviceType, const QString& serviceName, FileFormat fileFormat)
-{
+    print_service_t serviceType,
+    const QString& serviceName,
+    FileFormat fileFormat) {
   switch (serviceType) {
-  case print_service_t::NONE:
-    // TODO: Print warning
-    return nullptr;
-    break;
-  case print_service_t::PRINT_SERVICE: {
-    if (const auto printService = PrintService::getPrintService(serviceName.toStdString())) {
-      return createExternalPrintService(printService, fileFormat);
-    }
-    LOG("Unknown print service \"%1$s\"", serviceName.toStdString());
-    return nullptr;
-    break;
-  }
-  case print_service_t::OCTOPRINT:
-    return createOctoPrintService(fileFormat);
-    break;
-  case print_service_t::LOCAL_APPLICATION:
-    return createLocalProgramService(fileFormat);
-    break;
+    case print_service_t::NONE:
+      // TODO: Print warning
+      return nullptr;
+      break;
+    case print_service_t::PRINT_SERVICE: {
+      if (const auto printService =
+              PrintService::getPrintService(serviceName.toStdString())) {
+        return createExternalPrintService(printService, fileFormat);
+      }
+      LOG("Unknown print service \"%1$s\"", serviceName.toStdString());
+      return nullptr;
+      break;
+    }
+    case print_service_t::OCTOPRINT:
+      return createOctoPrintService(fileFormat);
+      break;
+    case print_service_t::LOCAL_APPLICATION:
+      return createLocalProgramService(fileFormat);
+      break;
   }
   return {};
 }
 
-} // namespace
+}  // namespace
 
-MainWindow::MainWindow(const QStringList& filenames) :
-  rubberBandManager(this)
-{
+MainWindow::MainWindow(const QStringList& filenames) : rubberBandManager(this) {
   installEventFilter(this);
   setupUi(this);
 
@@ -301,15 +301,13 @@ MainWindow::MainWindow(const QStringList& filenames) :
   this->addAction(editActionInsertTemplate);
   this->addAction(editActionFoldAll);
 
-  docks = {
-    {editorDock, QString(_("Editor"))},
-    {consoleDock, QString(_("Console"))},
-    {parameterDock, QString(_("Customizer"))},
-    {errorLogDock, QString(_("Error-Log"))},
-    {animateDock, QString(_("Animate"))},
-    {fontListDock, QString(_("Font Lists"))},
-    {viewportControlDock, QString(_("Viewport-Control"))}
-  };
+  docks = {{editorDock, QString(_("Editor"))},
+           {consoleDock, QString(_("Console"))},
+           {parameterDock, QString(_("Customizer"))},
+           {errorLogDock, QString(_("Error-Log"))},
+           {animateDock, QString(_("Animate"))},
+           {fontListDock, QString(_("Font Lists"))},
+           {viewportControlDock, QString(_("Viewport-Control"))}};
 
   this->editorDock->setConfigKey("view/hideEditor");
   this->consoleDock->setConfigKey("view/hideConsole");
@@ -319,7 +317,8 @@ MainWindow::MainWindow(const QStringList& filenames) :
   this->fontListDock->setConfigKey("view/hideFontList");
   this->viewportControlDock->setConfigKey("view/hideViewportControl");
 
-  this->versionLabel = nullptr;   // must be initialized before calling updateStatusBar()
+  this->versionLabel =
+      nullptr;  // must be initialized before calling updateStatusBar()
   updateStatusBar(nullptr);
 
   renderCompleteSoundEffect = new QSoundEffect();
@@ -337,55 +336,94 @@ MainWindow::MainWindow(const QStringList& filenames) :
     connect(recent, &QAction::triggered, this, &MainWindow::actionOpenRecent);
   }
 
-  // Preferences initialization happens on first tab creation, and depends on colorschemes from editor.
-  // Any code dependent on Preferences must come after the TabManager instantiation
-  tabManager = new TabManager(this, filenames.isEmpty() ? QString() : filenames[0]);
+  // Preferences initialization happens on first tab creation, and depends on
+  // colorschemes from editor. Any code dependent on Preferences must come after
+  // the TabManager instantiation
+  tabManager =
+      new TabManager(this, filenames.isEmpty() ? QString() : filenames[0]);
   editorDockContents->layout()->addWidget(tabManager->getTabContent());
 
-  connect(this, &MainWindow::highlightError, tabManager, &TabManager::highlightError);
-  connect(this, &MainWindow::unhighlightLastError, tabManager, &TabManager::unhighlightLastError);
-
-  connect(this->editActionUndo, &QAction::triggered, tabManager, &TabManager::undo);
-  connect(this->editActionRedo, &QAction::triggered, tabManager, &TabManager::redo);
-  connect(this->editActionRedo_2, &QAction::triggered, tabManager, &TabManager::redo);
-  connect(this->editActionCut, &QAction::triggered, tabManager, &TabManager::cut);
-  connect(this->editActionPaste, &QAction::triggered, tabManager, &TabManager::paste);
-
-  connect(this->editActionIndent, &QAction::triggered, tabManager, &TabManager::indentSelection);
-  connect(this->editActionUnindent, &QAction::triggered, tabManager, &TabManager::unindentSelection);
-  connect(this->editActionComment, &QAction::triggered, tabManager, &TabManager::commentSelection);
-  connect(this->editActionUncomment, &QAction::triggered, tabManager, &TabManager::uncommentSelection);
-
-  connect(this->editActionToggleBookmark, &QAction::triggered, tabManager, &TabManager::toggleBookmark);
-  connect(this->editActionNextBookmark, &QAction::triggered, tabManager, &TabManager::nextBookmark);
-  connect(this->editActionPrevBookmark, &QAction::triggered, tabManager, &TabManager::prevBookmark);
-  connect(this->editActionJumpToNextError, &QAction::triggered, tabManager, &TabManager::jumpToNextError);
-
-  connect(tabManager, &TabManager::editorAboutToClose, this, &MainWindow::onTabManagerAboutToCloseEditor);
-  connect(tabManager, &TabManager::currentEditorChanged, this, &MainWindow::onTabManagerEditorChanged);
-  connect(tabManager, &TabManager::editorContentReloaded, this, &MainWindow::onTabManagerEditorContentReloaded);
-
-  connect(GlobalPreferences::inst(), &Preferences::consoleFontChanged, this->console, &Console::setFont);
-
-  const QString version = QString("<b>OpenSCAD %1</b>").arg(QString::fromStdString(openscad_versionnumber));
-  const QString weblink = "<a href=\"https://www.openscad.org/\">https://www.openscad.org/</a><br>";
+  connect(this, &MainWindow::highlightError, tabManager,
+          &TabManager::highlightError);
+  connect(this, &MainWindow::unhighlightLastError, tabManager,
+          &TabManager::unhighlightLastError);
+
+  connect(this->editActionUndo, &QAction::triggered, tabManager,
+          &TabManager::undo);
+  connect(this->editActionRedo, &QAction::triggered, tabManager,
+          &TabManager::redo);
+  connect(this->editActionRedo_2, &QAction::triggered, tabManager,
+          &TabManager::redo);
+  connect(this->editActionCut, &QAction::triggered, tabManager,
+          &TabManager::cut);
+  connect(this->editActionPaste, &QAction::triggered, tabManager,
+          &TabManager::paste);
+
+  connect(this->editActionIndent, &QAction::triggered, tabManager,
+          &TabManager::indentSelection);
+  connect(this->editActionUnindent, &QAction::triggered, tabManager,
+          &TabManager::unindentSelection);
+  connect(this->editActionComment, &QAction::triggered, tabManager,
+          &TabManager::commentSelection);
+  connect(this->editActionUncomment, &QAction::triggered, tabManager,
+          &TabManager::uncommentSelection);
+
+  connect(this->editActionToggleBookmark, &QAction::triggered, tabManager,
+          &TabManager::toggleBookmark);
+  connect(this->editActionNextBookmark, &QAction::triggered, tabManager,
+          &TabManager::nextBookmark);
+  connect(this->editActionPrevBookmark, &QAction::triggered, tabManager,
+          &TabManager::prevBookmark);
+  connect(this->editActionJumpToNextError, &QAction::triggered, tabManager,
+          &TabManager::jumpToNextError);
+
+  connect(tabManager, &TabManager::editorAboutToClose, this,
+          &MainWindow::onTabManagerAboutToCloseEditor);
+  connect(tabManager, &TabManager::currentEditorChanged, this,
+          &MainWindow::onTabManagerEditorChanged);
+  connect(tabManager, &TabManager::editorContentReloaded, this,
+          &MainWindow::onTabManagerEditorContentReloaded);
+
+  connect(GlobalPreferences::inst(), &Preferences::consoleFontChanged,
+          this->console, &Console::setFont);
+
+  const QString version =
+      QString("<b>OpenSCAD %1</b>")
+          .arg(QString::fromStdString(openscad_versionnumber));
+  const QString weblink =
+      "<a href=\"https://www.openscad.org/\">https://www.openscad.org/</a><br>";
   this->console->setFont(
-    GlobalPreferences::inst()->getValue("advanced/consoleFontFamily").toString(),
-    GlobalPreferences::inst()->getValue("advanced/consoleFontSize").toUInt()
-    );
+      GlobalPreferences::inst()
+          ->getValue("advanced/consoleFontFamily")
+          .toString(),
+      GlobalPreferences::inst()->getValue("advanced/consoleFontSize").toUInt());
 
   consoleOutputRaw(version);
   consoleOutputRaw(weblink);
   consoleOutputRaw(copyrighttext);
-  this->consoleUpdater->start(0);   // Show "Loaded Design" message from TabManager
-
-  connect(this->errorLogWidget, &ErrorLog::openFile, this, &MainWindow::openFileFromPath);
-  connect(this->console, &Console::openFile, this, &MainWindow::openFileFromPath);
-
-  connect(GlobalPreferences::inst()->ButtonConfig, &ButtonConfigWidget::inputMappingChanged, InputDriverManager::instance(), &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputMappingChanged, InputDriverManager::instance(), &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputCalibrationChanged, InputDriverManager::instance(), &InputDriverManager::onInputCalibrationUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputGainChanged, InputDriverManager::instance(), &InputDriverManager::onInputGainUpdated, Qt::UniqueConnection);
+  this->consoleUpdater->start(
+      0);  // Show "Loaded Design" message from TabManager
+
+  connect(this->errorLogWidget, &ErrorLog::openFile, this,
+          &MainWindow::openFileFromPath);
+  connect(this->console, &Console::openFile, this,
+          &MainWindow::openFileFromPath);
+
+  connect(GlobalPreferences::inst()->ButtonConfig,
+          &ButtonConfigWidget::inputMappingChanged,
+          InputDriverManager::instance(),
+          &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
+  connect(GlobalPreferences::inst()->AxisConfig,
+          &AxisConfigWidget::inputMappingChanged,
+          InputDriverManager::instance(),
+          &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
+  connect(GlobalPreferences::inst()->AxisConfig,
+          &AxisConfigWidget::inputCalibrationChanged,
+          InputDriverManager::instance(),
+          &InputDriverManager::onInputCalibrationUpdated, Qt::UniqueConnection);
+  connect(GlobalPreferences::inst()->AxisConfig,
+          &AxisConfigWidget::inputGainChanged, InputDriverManager::instance(),
+          &InputDriverManager::onInputGainUpdated, Qt::UniqueConnection);
 
   setCorner(Qt::TopLeftCorner, Qt::LeftDockWidgetArea);
   setCorner(Qt::TopRightCorner, Qt::RightDockWidgetArea);
@@ -397,7 +435,8 @@ MainWindow::MainWindow(const QStringList& filenames) :
   scadApp->windowManager.add(this);
 
   this->cgalworker = new CGALWorker();
-  connect(this->cgalworker, &CGALWorker::done, this, &MainWindow::actionRenderDone);
+  connect(this->cgalworker, &CGALWorker::done, this,
+          &MainWindow::actionRenderDone);
 
   rootNode = nullptr;
 
@@ -406,8 +445,10 @@ MainWindow::MainWindow(const QStringList& filenames) :
   statusBar()->addWidget(this->qglview->statusLabel);
 
   const QSettingsCached settings;
-  this->qglview->setMouseCentricZoom(Settings::Settings::mouseCentricZoom.value());
-  this->qglview->setMouseSwapButtons(Settings::Settings::mouseSwapButtons.value());
+  this->qglview->setMouseCentricZoom(
+      Settings::Settings::mouseCentricZoom.value());
+  this->qglview->setMouseSwapButtons(
+      Settings::Settings::mouseSwapButtons.value());
   this->meas.setView(qglview);
   this->designActionMeasureDist->setEnabled(false);
   this->designActionMeasureAngle->setEnabled(false);
@@ -415,46 +456,68 @@ MainWindow::MainWindow(const QStringList& filenames) :
   autoReloadTimer = new QTimer(this);
   autoReloadTimer->setSingleShot(false);
   autoReloadTimer->setInterval(autoReloadPollingPeriodMS);
-  connect(autoReloadTimer, &QTimer::timeout, this, &MainWindow::checkAutoReload);
+  connect(autoReloadTimer, &QTimer::timeout, this,
+          &MainWindow::checkAutoReload);
 
   this->exportFormatMapper = new QSignalMapper(this);
 #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
-  connect(this->exportFormatMapper, &QSignalMapper::mappedInt, this, &MainWindow::actionExportFileFormat);
+  connect(this->exportFormatMapper, &QSignalMapper::mappedInt, this,
+          &MainWindow::actionExportFileFormat);
 #else
-  connect(this->exportFormatMapper, static_cast<void (QSignalMapper::*)(int)>(&QSignalMapper::mapped), this, &MainWindow::actionExportFileFormat);
+  connect(this->exportFormatMapper,
+          static_cast<void (QSignalMapper::*)(int)>(&QSignalMapper::mapped),
+          this, &MainWindow::actionExportFileFormat);
 #endif
 
   waitAfterReloadTimer = new QTimer(this);
   waitAfterReloadTimer->setSingleShot(true);
   waitAfterReloadTimer->setInterval(autoReloadPollingPeriodMS);
-  connect(waitAfterReloadTimer, &QTimer::timeout, this, &MainWindow::waitAfterReload);
-  connect(GlobalPreferences::inst(), &Preferences::ExperimentalChanged, this, &MainWindow::changeParameterWidget);
+  connect(waitAfterReloadTimer, &QTimer::timeout, this,
+          &MainWindow::waitAfterReload);
+  connect(GlobalPreferences::inst(), &Preferences::ExperimentalChanged, this,
+          &MainWindow::changeParameterWidget);
 
   progressThrottle->start();
 
   this->hideFind();
   frameCompileResult->hide();
   this->labelCompileResultMessage->setOpenExternalLinks(false);
-  connect(this->labelCompileResultMessage, &QLabel::linkActivated, this, &MainWindow::showLink);
+  connect(this->labelCompileResultMessage, &QLabel::linkActivated, this,
+          &MainWindow::showLink);
 
   // File menu
-  connect(this->fileActionNewWindow, &QAction::triggered, this, &MainWindow::actionNewWindow);
-  connect(this->fileActionNew, &QAction::triggered, tabManager, &TabManager::actionNew);
-  connect(this->fileActionOpenWindow, &QAction::triggered, this, &MainWindow::actionOpenWindow);
-  connect(this->fileActionOpen, &QAction::triggered, this, &MainWindow::actionOpen);
-  connect(this->fileActionSave, &QAction::triggered, this, &MainWindow::actionSave);
-  connect(this->fileActionSaveAs, &QAction::triggered, this, &MainWindow::actionSaveAs);
-  connect(this->fileActionSaveACopy, &QAction::triggered, this, &MainWindow::actionSaveACopy);
-  connect(this->fileActionSaveAll, &QAction::triggered, tabManager, &TabManager::saveAll);
-  connect(this->fileActionReload, &QAction::triggered, this, &MainWindow::actionReload);
-  connect(this->fileActionClose, &QAction::triggered, tabManager, &TabManager::closeCurrentTab);
-  connect(this->fileActionQuit, &QAction::triggered, scadApp, &OpenSCADApp::quit, Qt::QueuedConnection);
-  connect(this->fileShowLibraryFolder, &QAction::triggered, this, &MainWindow::actionShowLibraryFolder);
+  connect(this->fileActionNewWindow, &QAction::triggered, this,
+          &MainWindow::actionNewWindow);
+  connect(this->fileActionNew, &QAction::triggered, tabManager,
+          &TabManager::actionNew);
+  connect(this->fileActionOpenWindow, &QAction::triggered, this,
+          &MainWindow::actionOpenWindow);
+  connect(this->fileActionOpen, &QAction::triggered, this,
+          &MainWindow::actionOpen);
+  connect(this->fileActionSave, &QAction::triggered, this,
+          &MainWindow::actionSave);
+  connect(this->fileActionSaveAs, &QAction::triggered, this,
+          &MainWindow::actionSaveAs);
+  connect(this->fileActionSaveACopy, &QAction::triggered, this,
+          &MainWindow::actionSaveACopy);
+  connect(this->fileActionSaveAll, &QAction::triggered, tabManager,
+          &TabManager::saveAll);
+  connect(this->fileActionReload, &QAction::triggered, this,
+          &MainWindow::actionReload);
+  connect(this->fileActionClose, &QAction::triggered, tabManager,
+          &TabManager::closeCurrentTab);
+  connect(this->fileActionQuit, &QAction::triggered, scadApp,
+          &OpenSCADApp::quit, Qt::QueuedConnection);
+  connect(this->fileShowLibraryFolder, &QAction::triggered, this,
+          &MainWindow::actionShowLibraryFolder);
 
 #ifdef ENABLE_PYTHON
-  connect(this->fileActionPythonRevoke, &QAction::triggered, this, &MainWindow::actionPythonRevokeTrustedFiles);
-  connect(this->fileActionPythonCreateVenv, &QAction::triggered, this, &MainWindow::actionPythonCreateVenv);
-  connect(this->fileActionPythonSelectVenv, &QAction::triggered, this, &MainWindow::actionPythonSelectVenv);
+  connect(this->fileActionPythonRevoke, &QAction::triggered, this,
+          &MainWindow::actionPythonRevokeTrustedFiles);
+  connect(this->fileActionPythonCreateVenv, &QAction::triggered, this,
+          &MainWindow::actionPythonCreateVenv);
+  connect(this->fileActionPythonSelectVenv, &QAction::triggered, this,
+          &MainWindow::actionPythonSelectVenv);
 #else
   this->menuPython->menuAction()->setVisible(false);
 #endif
@@ -469,43 +532,70 @@ MainWindow::MainWindow(const QStringList& filenames) :
 
   this->menuOpenRecent->addSeparator();
   this->menuOpenRecent->addAction(this->fileActionClearRecent);
-  connect(this->fileActionClearRecent, &QAction::triggered, this, &MainWindow::clearRecentFiles);
+  connect(this->fileActionClearRecent, &QAction::triggered, this,
+          &MainWindow::clearRecentFiles);
 
   show_examples();
 
-  connect(this->editActionNextTab, &QAction::triggered, tabManager, &TabManager::nextTab);
-  connect(this->editActionPrevTab, &QAction::triggered, tabManager, &TabManager::prevTab);
-
-  connect(this->editActionCopy, &QAction::triggered, this, &MainWindow::copyText);
-  connect(this->editActionCopyViewport, &QAction::triggered, this, &MainWindow::actionCopyViewport);
-  connect(this->editActionConvertTabsToSpaces, &QAction::triggered, this, &MainWindow::convertTabsToSpaces);
-  connect(this->editActionCopyVPT, &QAction::triggered, this, &MainWindow::copyViewportTranslation);
-  connect(this->editActionCopyVPR, &QAction::triggered, this, &MainWindow::copyViewportRotation);
-  connect(this->editActionCopyVPD, &QAction::triggered, this, &MainWindow::copyViewportDistance);
-  connect(this->editActionCopyVPF, &QAction::triggered, this, &MainWindow::copyViewportFov);
-  connect(this->editActionPreferences, &QAction::triggered, this, &MainWindow::preferences);
+  connect(this->editActionNextTab, &QAction::triggered, tabManager,
+          &TabManager::nextTab);
+  connect(this->editActionPrevTab, &QAction::triggered, tabManager,
+          &TabManager::prevTab);
+
+  connect(this->editActionCopy, &QAction::triggered, this,
+          &MainWindow::copyText);
+  connect(this->editActionCopyViewport, &QAction::triggered, this,
+          &MainWindow::actionCopyViewport);
+  connect(this->editActionConvertTabsToSpaces, &QAction::triggered, this,
+          &MainWindow::convertTabsToSpaces);
+  connect(this->editActionCopyVPT, &QAction::triggered, this,
+          &MainWindow::copyViewportTranslation);
+  connect(this->editActionCopyVPR, &QAction::triggered, this,
+          &MainWindow::copyViewportRotation);
+  connect(this->editActionCopyVPD, &QAction::triggered, this,
+          &MainWindow::copyViewportDistance);
+  connect(this->editActionCopyVPF, &QAction::triggered, this,
+          &MainWindow::copyViewportFov);
+  connect(this->editActionPreferences, &QAction::triggered, this,
+          &MainWindow::preferences);
   // Edit->Find
-  connect(this->editActionFind, &QAction::triggered, this, &MainWindow::actionShowFind);
-  connect(this->editActionFindAndReplace, &QAction::triggered, this, &MainWindow::actionShowFindAndReplace);
+  connect(this->editActionFind, &QAction::triggered, this,
+          &MainWindow::actionShowFind);
+  connect(this->editActionFindAndReplace, &QAction::triggered, this,
+          &MainWindow::actionShowFindAndReplace);
 #ifdef Q_OS_WIN
   this->editActionFindAndReplace->setShortcut(QKeySequence("Ctrl+Shift+F"));
 #endif
-  connect(this->editActionFindNext, &QAction::triggered, this, &MainWindow::findNext);
-  connect(this->editActionFindPrevious, &QAction::triggered, this, &MainWindow::findPrev);
-  connect(this->editActionUseSelectionForFind, &QAction::triggered, this, &MainWindow::useSelectionForFind);
+  connect(this->editActionFindNext, &QAction::triggered, this,
+          &MainWindow::findNext);
+  connect(this->editActionFindPrevious, &QAction::triggered, this,
+          &MainWindow::findPrev);
+  connect(this->editActionUseSelectionForFind, &QAction::triggered, this,
+          &MainWindow::useSelectionForFind);
 
   // Design menu
-  connect(this->designActionAutoReload, &QAction::toggled, this, &MainWindow::autoReloadSet);
-  connect(this->designActionReloadAndPreview, &QAction::triggered, this, &MainWindow::actionReloadRenderPreview);
-  connect(this->designActionPreview, &QAction::triggered, this, &MainWindow::actionRenderPreview);
-  connect(this->designActionRender, &QAction::triggered, this, &MainWindow::actionRender);
-  connect(this->designActionMeasureDist, &QAction::triggered, this, &MainWindow::actionMeasureDistance);
-  connect(this->designActionMeasureAngle, &QAction::triggered, this, &MainWindow::actionMeasureAngle);
-  connect(this->designAction3DPrint, &QAction::triggered, this, &MainWindow::action3DPrint);
-  connect(this->designCheckValidity, &QAction::triggered, this, &MainWindow::actionCheckValidity);
-  connect(this->designActionDisplayAST, &QAction::triggered, this, &MainWindow::actionDisplayAST);
-  connect(this->designActionDisplayCSGTree, &QAction::triggered, this, &MainWindow::actionDisplayCSGTree);
-  connect(this->designActionDisplayCSGProducts, &QAction::triggered, this, &MainWindow::actionDisplayCSGProducts);
+  connect(this->designActionAutoReload, &QAction::toggled, this,
+          &MainWindow::autoReloadSet);
+  connect(this->designActionReloadAndPreview, &QAction::triggered, this,
+          &MainWindow::actionReloadRenderPreview);
+  connect(this->designActionPreview, &QAction::triggered, this,
+          &MainWindow::actionRenderPreview);
+  connect(this->designActionRender, &QAction::triggered, this,
+          &MainWindow::actionRender);
+  connect(this->designActionMeasureDist, &QAction::triggered, this,
+          &MainWindow::actionMeasureDistance);
+  connect(this->designActionMeasureAngle, &QAction::triggered, this,
+          &MainWindow::actionMeasureAngle);
+  connect(this->designAction3DPrint, &QAction::triggered, this,
+          &MainWindow::action3DPrint);
+  connect(this->designCheckValidity, &QAction::triggered, this,
+          &MainWindow::actionCheckValidity);
+  connect(this->designActionDisplayAST, &QAction::triggered, this,
+          &MainWindow::actionDisplayAST);
+  connect(this->designActionDisplayCSGTree, &QAction::triggered, this,
+          &MainWindow::actionDisplayCSGTree);
+  connect(this->designActionDisplayCSGProducts, &QAction::triggered, this,
+          &MainWindow::actionDisplayCSGProducts);
 
   exportMap[FileFormat::BINARY_STL] = this->fileActionExportBinarySTL;
   exportMap[FileFormat::ASCII_STL] = this->fileActionExportAsciiSTL;
@@ -522,11 +612,13 @@ MainWindow::MainWindow(const QStringList& filenames) :
   exportMap[FileFormat::PNG] = this->fileActionExportImage;
 
   for (auto& [format, action] : exportMap) {
-    connect(action, &QAction::triggered, this->exportFormatMapper, QOverload<>::of(&QSignalMapper::map));
+    connect(action, &QAction::triggered, this->exportFormatMapper,
+            QOverload<>::of(&QSignalMapper::map));
     this->exportFormatMapper->setMapping(action, int(format));
   }
 
-  connect(this->designActionFlushCaches, &QAction::triggered, this, &MainWindow::actionFlushCaches);
+  connect(this->designActionFlushCaches, &QAction::triggered, this,
+          &MainWindow::actionFlushCaches);
 
 #ifndef ENABLE_LIB3MF
   this->fileActionExport3MF->setVisible(false);
@@ -543,57 +635,89 @@ MainWindow::MainWindow(const QStringList& filenames) :
     this->viewActionThrownTogether->setChecked(true);
   }
 
-  connect(this->viewActionPreview, &QAction::triggered, this, &MainWindow::viewModePreview);
-  connect(this->viewActionThrownTogether, &QAction::triggered, this, &MainWindow::viewModeThrownTogether);
-  connect(this->viewActionShowEdges, &QAction::triggered, this, &MainWindow::viewModeShowEdges);
-  connect(this->viewActionShowAxes, &QAction::triggered, this, &MainWindow::viewModeShowAxes);
-  connect(this->viewActionShowCrosshairs, &QAction::triggered, this, &MainWindow::viewModeShowCrosshairs);
-  connect(this->viewActionShowScaleProportional, &QAction::triggered, this, &MainWindow::viewModeShowScaleProportional);
-  connect(this->viewActionTop, &QAction::triggered, this, &MainWindow::viewAngleTop);
-  connect(this->viewActionBottom, &QAction::triggered, this, &MainWindow::viewAngleBottom);
-  connect(this->viewActionLeft, &QAction::triggered, this, &MainWindow::viewAngleLeft);
-  connect(this->viewActionRight, &QAction::triggered, this, &MainWindow::viewAngleRight);
-  connect(this->viewActionFront, &QAction::triggered, this, &MainWindow::viewAngleFront);
-  connect(this->viewActionBack, &QAction::triggered, this, &MainWindow::viewAngleBack);
-  connect(this->viewActionDiagonal, &QAction::triggered, this, &MainWindow::viewAngleDiagonal);
-  connect(this->viewActionCenter, &QAction::triggered, this, &MainWindow::viewCenter);
-  connect(this->viewActionResetView, &QAction::triggered, this, &MainWindow::viewResetView);
-  connect(this->viewActionViewAll, &QAction::triggered, this, &MainWindow::viewAll);
-  connect(this->viewActionPerspective, &QAction::triggered, this, &MainWindow::viewPerspective);
-  connect(this->viewActionOrthogonal, &QAction::triggered, this, &MainWindow::viewOrthogonal);
-  connect(this->viewActionZoomIn, &QAction::triggered, qglview, &QGLView::ZoomIn);
-  connect(this->viewActionZoomOut, &QAction::triggered, qglview, &QGLView::ZoomOut);
-  connect(this->viewActionHideEditorToolBar, &QAction::triggered, this, &MainWindow::hideEditorToolbar);
-  connect(this->viewActionHide3DViewToolBar, &QAction::triggered, this, &MainWindow::hide3DViewToolbar);
+  connect(this->viewActionPreview, &QAction::triggered, this,
+          &MainWindow::viewModePreview);
+  connect(this->viewActionThrownTogether, &QAction::triggered, this,
+          &MainWindow::viewModeThrownTogether);
+  connect(this->viewActionShowEdges, &QAction::triggered, this,
+          &MainWindow::viewModeShowEdges);
+  connect(this->viewActionShowAxes, &QAction::triggered, this,
+          &MainWindow::viewModeShowAxes);
+  connect(this->viewActionShowCrosshairs, &QAction::triggered, this,
+          &MainWindow::viewModeShowCrosshairs);
+  connect(this->viewActionShowScaleProportional, &QAction::triggered, this,
+          &MainWindow::viewModeShowScaleProportional);
+  connect(this->viewActionTop, &QAction::triggered, this,
+          &MainWindow::viewAngleTop);
+  connect(this->viewActionBottom, &QAction::triggered, this,
+          &MainWindow::viewAngleBottom);
+  connect(this->viewActionLeft, &QAction::triggered, this,
+          &MainWindow::viewAngleLeft);
+  connect(this->viewActionRight, &QAction::triggered, this,
+          &MainWindow::viewAngleRight);
+  connect(this->viewActionFront, &QAction::triggered, this,
+          &MainWindow::viewAngleFront);
+  connect(this->viewActionBack, &QAction::triggered, this,
+          &MainWindow::viewAngleBack);
+  connect(this->viewActionDiagonal, &QAction::triggered, this,
+          &MainWindow::viewAngleDiagonal);
+  connect(this->viewActionCenter, &QAction::triggered, this,
+          &MainWindow::viewCenter);
+  connect(this->viewActionResetView, &QAction::triggered, this,
+          &MainWindow::viewResetView);
+  connect(this->viewActionViewAll, &QAction::triggered, this,
+          &MainWindow::viewAll);
+  connect(this->viewActionPerspective, &QAction::triggered, this,
+          &MainWindow::viewPerspective);
+  connect(this->viewActionOrthogonal, &QAction::triggered, this,
+          &MainWindow::viewOrthogonal);
+  connect(this->viewActionZoomIn, &QAction::triggered, qglview,
+          &QGLView::ZoomIn);
+  connect(this->viewActionZoomOut, &QAction::triggered, qglview,
+          &QGLView::ZoomOut);
+  connect(this->viewActionHideEditorToolBar, &QAction::triggered, this,
+          &MainWindow::hideEditorToolbar);
+  connect(this->viewActionHide3DViewToolBar, &QAction::triggered, this,
+          &MainWindow::hide3DViewToolbar);
 
   // Create the docks and connect corresponding action
   for (auto& [dock, title] : docks) {
     dock->setName(title);
     dock->setFocusPolicy(Qt::FocusPolicy::StrongFocus);
 
-    // It is neede to have the event filter installed in each dock so that the events are
-    // correctly processed when the dock are floating (is in a different window that the mainwindow)
+    // It is neede to have the event filter installed in each dock so that the
+    // events are correctly processed when the dock are floating (is in a
+    // different window that the mainwindow)
     dock->installEventFilter(this);
 
     menuWindow->addAction(dock->toggleViewAction());
   }
 
   // Help menu
-  connect(this->helpActionAbout, &QAction::triggered, this, &MainWindow::helpAbout);
-  connect(this->helpActionHomepage, &QAction::triggered, this, &MainWindow::helpHomepage);
-  connect(this->helpActionManual, &QAction::triggered, this, &MainWindow::helpManual);
-  connect(this->helpActionCheatSheet, &QAction::triggered, this, &MainWindow::helpCheatSheet);
-  connect(this->helpActionLibraryInfo, &QAction::triggered, this, &MainWindow::helpLibrary);
-  connect(this->helpActionFontInfo, &QAction::triggered, this, &MainWindow::helpFontInfo);
-
-  // Checks if the Documentation has been downloaded and hides the Action otherwise
+  connect(this->helpActionAbout, &QAction::triggered, this,
+          &MainWindow::helpAbout);
+  connect(this->helpActionHomepage, &QAction::triggered, this,
+          &MainWindow::helpHomepage);
+  connect(this->helpActionManual, &QAction::triggered, this,
+          &MainWindow::helpManual);
+  connect(this->helpActionCheatSheet, &QAction::triggered, this,
+          &MainWindow::helpCheatSheet);
+  connect(this->helpActionLibraryInfo, &QAction::triggered, this,
+          &MainWindow::helpLibrary);
+  connect(this->helpActionFontInfo, &QAction::triggered, this,
+          &MainWindow::helpFontInfo);
+
+  // Checks if the Documentation has been downloaded and hides the Action
+  // otherwise
   if (UIUtils::hasOfflineUserManual()) {
-    connect(this->helpActionOfflineManual, &QAction::triggered, this, &MainWindow::helpOfflineManual);
+    connect(this->helpActionOfflineManual, &QAction::triggered, this,
+            &MainWindow::helpOfflineManual);
   } else {
     this->helpActionOfflineManual->setVisible(false);
   }
   if (UIUtils::hasOfflineCheatSheet()) {
-    connect(this->helpActionOfflineCheatSheet, &QAction::triggered, this, &MainWindow::helpOfflineCheatSheet);
+    connect(this->helpActionOfflineCheatSheet, &QAction::triggered, this,
+            &MainWindow::helpOfflineCheatSheet);
   } else {
     this->helpActionOfflineCheatSheet->setVisible(false);
   }
@@ -601,76 +725,111 @@ MainWindow::MainWindow(const QStringList& filenames) :
   this->menuBar()->addMenu(AutoUpdater::updater()->updateMenu);
 #endif
 
-  connect(this->qglview, &QGLView::cameraChanged, animateWidget, &Animate::cameraChanged);
-  connect(this->qglview, &QGLView::cameraChanged, viewportControlWidget, &ViewportControl::cameraChanged);
-  connect(this->qglview, &QGLView::resized, viewportControlWidget, &ViewportControl::viewResized);
+  connect(this->qglview, &QGLView::cameraChanged, animateWidget,
+          &Animate::cameraChanged);
+  connect(this->qglview, &QGLView::cameraChanged, viewportControlWidget,
+          &ViewportControl::cameraChanged);
+  connect(this->qglview, &QGLView::resized, viewportControlWidget,
+          &ViewportControl::viewResized);
   connect(this->qglview, &QGLView::doRightClick, this, &MainWindow::rightClick);
   connect(this->qglview, &QGLView::doLeftClick, this, &MainWindow::leftClick);
 
-  connect(GlobalPreferences::inst(), &Preferences::requestRedraw, this->qglview, QOverload<>::of(&QGLView::update));
-  connect(GlobalPreferences::inst(), &Preferences::updateMouseCentricZoom, this->qglview, &QGLView::setMouseCentricZoom);
-  connect(GlobalPreferences::inst(), &Preferences::updateMouseSwapButtons, this->qglview, &QGLView::setMouseSwapButtons);
-  connect(GlobalPreferences::inst(), &Preferences::updateReorderMode, this, &MainWindow::updateReorderMode);
-  connect(GlobalPreferences::inst(), &Preferences::updateUndockMode, this, &MainWindow::updateUndockMode);
-  connect(GlobalPreferences::inst(), &Preferences::openCSGSettingsChanged, this, &MainWindow::openCSGSettingsChanged);
-  connect(GlobalPreferences::inst(), &Preferences::colorSchemeChanged, this, &MainWindow::setColorScheme);
-  connect(GlobalPreferences::inst(), &Preferences::toolbarExportChanged, this, &MainWindow::updateExportActions);
-
-  GlobalPreferences::inst()->apply_win();   // not sure if to be commented, checked must not be commented(done some changes in apply())
-
-  const QString cs = GlobalPreferences::inst()->getValue("3dview/colorscheme").toString();
+  connect(GlobalPreferences::inst(), &Preferences::requestRedraw, this->qglview,
+          QOverload<>::of(&QGLView::update));
+  connect(GlobalPreferences::inst(), &Preferences::updateMouseCentricZoom,
+          this->qglview, &QGLView::setMouseCentricZoom);
+  connect(GlobalPreferences::inst(), &Preferences::updateMouseSwapButtons,
+          this->qglview, &QGLView::setMouseSwapButtons);
+  connect(GlobalPreferences::inst(), &Preferences::updateReorderMode, this,
+          &MainWindow::updateReorderMode);
+  connect(GlobalPreferences::inst(), &Preferences::updateUndockMode, this,
+          &MainWindow::updateUndockMode);
+  connect(GlobalPreferences::inst(), &Preferences::openCSGSettingsChanged, this,
+          &MainWindow::openCSGSettingsChanged);
+  connect(GlobalPreferences::inst(), &Preferences::colorSchemeChanged, this,
+          &MainWindow::setColorScheme);
+  connect(GlobalPreferences::inst(), &Preferences::toolbarExportChanged, this,
+          &MainWindow::updateExportActions);
+
+  GlobalPreferences::inst()
+      ->apply_win();  // not sure if to be commented, checked must not be
+                      // commented(done some changes in apply())
+
+  const QString cs =
+      GlobalPreferences::inst()->getValue("3dview/colorscheme").toString();
   this->setColorScheme(cs);
 
-  //find and replace panel
-  connect(this->findTypeComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &MainWindow::actionSelectFind);
-  connect(this->findInputField, &QWordSearchField::textChanged, this, &MainWindow::findString);
-  connect(this->findInputField, &QWordSearchField::returnPressed, this->findNextButton, [this] {
-    this->findNextButton->animateClick();
-  });
+  // find and replace panel
+  connect(this->findTypeComboBox,
+          QOverload<int>::of(&QComboBox::currentIndexChanged), this,
+          &MainWindow::actionSelectFind);
+  connect(this->findInputField, &QWordSearchField::textChanged, this,
+          &MainWindow::findString);
+  connect(this->findInputField, &QWordSearchField::returnPressed,
+          this->findNextButton,
+          [this] { this->findNextButton->animateClick(); });
   find_panel->installEventFilter(this);
   if (QApplication::clipboard()->supportsFindBuffer()) {
-    connect(this->findInputField, &QWordSearchField::textChanged, this, &MainWindow::updateFindBuffer);
-    connect(QApplication::clipboard(), &QClipboard::findBufferChanged, this, &MainWindow::findBufferChanged);
-    // With Qt 4.8.6, there seems to be a bug that often gives an incorrect findbuffer content when
-    // the app receives focus for the first time
-    this->findInputField->setText(QApplication::clipboard()->text(QClipboard::FindBuffer));
-  }
-
-  connect(this->findPrevButton, &QPushButton::clicked, this, &MainWindow::findPrev);
-  connect(this->findNextButton, &QPushButton::clicked, this, &MainWindow::findNext);
-  connect(this->cancelButton, &QPushButton::clicked, this, &MainWindow::hideFind);
-  connect(this->replaceButton, &QPushButton::clicked, this, &MainWindow::replace);
-  connect(this->replaceAllButton, &QPushButton::clicked, this, &MainWindow::replaceAll);
-  connect(this->replaceInputField, &QLineEdit::returnPressed, this->replaceButton, [this] {
-    this->replaceButton->animateClick();
-  });
+    connect(this->findInputField, &QWordSearchField::textChanged, this,
+            &MainWindow::updateFindBuffer);
+    connect(QApplication::clipboard(), &QClipboard::findBufferChanged, this,
+            &MainWindow::findBufferChanged);
+    // With Qt 4.8.6, there seems to be a bug that often gives an incorrect
+    // findbuffer content when the app receives focus for the first time
+    this->findInputField->setText(
+        QApplication::clipboard()->text(QClipboard::FindBuffer));
+  }
+
+  connect(this->findPrevButton, &QPushButton::clicked, this,
+          &MainWindow::findPrev);
+  connect(this->findNextButton, &QPushButton::clicked, this,
+          &MainWindow::findNext);
+  connect(this->cancelButton, &QPushButton::clicked, this,
+          &MainWindow::hideFind);
+  connect(this->replaceButton, &QPushButton::clicked, this,
+          &MainWindow::replace);
+  connect(this->replaceAllButton, &QPushButton::clicked, this,
+          &MainWindow::replaceAll);
+  connect(this->replaceInputField, &QLineEdit::returnPressed,
+          this->replaceButton, [this] { this->replaceButton->animateClick(); });
   addKeyboardShortCut(this->viewerToolBar->actions());
   addKeyboardShortCut(this->editortoolbar->actions());
 
-  Preferences *instance = GlobalPreferences::inst();
+  Preferences* instance = GlobalPreferences::inst();
 
-  InputDriverManager::instance()->registerActions(this->menuBar()->actions(), "", "");
-  InputDriverManager::instance()->registerActions(this->animateWidget->actions(), "animation", "animate");
+  InputDriverManager::instance()->registerActions(this->menuBar()->actions(),
+                                                  "", "");
+  InputDriverManager::instance()->registerActions(
+      this->animateWidget->actions(), "animation", "animate");
   instance->ButtonConfig->init();
 
   // fetch window states to be restored after restoreState() call
-  const bool isConsoldDockVisible = !settings.value("view/hideConsole").toBool();
+  const bool isConsoldDockVisible =
+      !settings.value("view/hideConsole").toBool();
   const bool isEditorDockVisible = !settings.value("view/hideEditor").toBool();
-  bool isCustomizerDockVisible = !settings.value("view/hideCustomizer").toBool();
+  bool isCustomizerDockVisible =
+      !settings.value("view/hideCustomizer").toBool();
   const bool isErrorLogVisible = !settings.value("view/hideErrorLog").toBool();
-  const bool isAnimateDockVisible = !settings.value("view/hideAnimate").toBool();
-  const bool isFontListDockVisible = !settings.value("view/hideFontList").toBool();
-  bool isViewportControlVisible = !settings.value("view/hideViewportControl").toBool();
-  const bool isEditorToolbarVisible = !settings.value("view/hideEditorToolbar").toBool();
-  const bool is3DViewToolbarVisible = !settings.value("view/hide3DViewToolbar").toBool();
+  const bool isAnimateDockVisible =
+      !settings.value("view/hideAnimate").toBool();
+  const bool isFontListDockVisible =
+      !settings.value("view/hideFontList").toBool();
+  bool isViewportControlVisible =
+      !settings.value("view/hideViewportControl").toBool();
+  const bool isEditorToolbarVisible =
+      !settings.value("view/hideEditorToolbar").toBool();
+  const bool is3DViewToolbarVisible =
+      !settings.value("view/hide3DViewToolbar").toBool();
 
   // make sure it looks nice..
-  const auto windowState = settings.value("window/state", QByteArray()).toByteArray();
-  restoreGeometry(settings.value("window/geometry", QByteArray()).toByteArray());
+  const auto windowState =
+      settings.value("window/state", QByteArray()).toByteArray();
+  restoreGeometry(
+      settings.value("window/geometry", QByteArray()).toByteArray());
 #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
-  // Workaround for a Qt bug (possible QTBUG-46620, but it's still there in Qt-6.5.3)
-  // Blindly restoring a maximized window to a different screen resolution causes a crash
-  // on the next move/resize operation on macOS:
+  // Workaround for a Qt bug (possible QTBUG-46620, but it's still there in
+  // Qt-6.5.3) Blindly restoring a maximized window to a different screen
+  // resolution causes a crash on the next move/resize operation on macOS:
   // https://github.com/openscad/openscad/issues/5486
   if (isMaximized()) {
     setGeometry(screen()->availableGeometry());
@@ -707,7 +866,9 @@ MainWindow::MainWindow(const QStringList& filenames) :
     // On Windows that causes the main window to open in a not
     // easily reachable place.
     auto primaryScreen = QApplication::primaryScreen();
-    auto desktopRect = primaryScreen->availableGeometry().adjusted(250, 150, -250, -150).normalized();
+    auto desktopRect = primaryScreen->availableGeometry()
+                           .adjusted(250, 150, -250, -150)
+                           .normalized();
     auto windowRect = frameGeometry();
     if (!desktopRect.intersects(windowRect)) {
       windowRect.moveCenter(desktopRect.center());
@@ -715,61 +876,74 @@ MainWindow::MainWindow(const QStringList& filenames) :
       move(windowRect.topLeft());
       resize(windowRect.size());
     }
-#endif // ifdef Q_OS_WIN
+#endif  // ifdef Q_OS_WIN
   }
 
-  updateWindowSettings(isConsoldDockVisible, isEditorDockVisible, isCustomizerDockVisible, isErrorLogVisible, isEditorToolbarVisible, is3DViewToolbarVisible, isAnimateDockVisible, isFontListDockVisible, isViewportControlVisible);
+  updateWindowSettings(
+      isConsoldDockVisible, isEditorDockVisible, isCustomizerDockVisible,
+      isErrorLogVisible, isEditorToolbarVisible, is3DViewToolbarVisible,
+      isAnimateDockVisible, isFontListDockVisible, isViewportControlVisible);
 
-  // Connect the menu "Windows/Navigation" to slot that process it by opening in a pop menu
-  // the navigationMenu.
-  connect(windowActionJumpTo, &QAction::triggered, this, &MainWindow::onNavigationOpenContextMenu);
+  // Connect the menu "Windows/Navigation" to slot that process it by opening in
+  // a pop menu the navigationMenu.
+  connect(windowActionJumpTo, &QAction::triggered, this,
+          &MainWindow::onNavigationOpenContextMenu);
 
   // Create the popup menu to navigate between the docks by keyboard.
   navigationMenu = new QMenu();
   for (auto& [dock, title] : docks) {
     auto action2 = navigationMenu->addAction(title);
     action2->setProperty("id", QVariant::fromValue(dock));
-    connect(action2, &QAction::triggered, this, &MainWindow::onNavigationTriggerContextMenuEntry);
-    connect(action2, &QAction::hovered, this, &MainWindow::onNavigationHoveredContextMenuEntry);
-  }
-  connect(navigationMenu, &QMenu::aboutToHide, this, &MainWindow::onNavigationCloseContextMenu);
-  connect(menuWindow, &QMenu::aboutToHide, this, &MainWindow::onNavigationCloseContextMenu);
+    connect(action2, &QAction::triggered, this,
+            &MainWindow::onNavigationTriggerContextMenuEntry);
+    connect(action2, &QAction::hovered, this,
+            &MainWindow::onNavigationHoveredContextMenuEntry);
+  }
+  connect(navigationMenu, &QMenu::aboutToHide, this,
+          &MainWindow::onNavigationCloseContextMenu);
+  connect(menuWindow, &QMenu::aboutToHide, this,
+          &MainWindow::onNavigationCloseContextMenu);
   windowActionJumpTo->setMenu(navigationMenu);
 
   // connect the signal of next/prev windowAction and the dedicated slot
-  // hovering is connected to rubberband activation while triggering is for actual
-  // activation of the corresponding dock.
-  const std::vector<QAction *> actions = {windowActionNextWindow, windowActionPreviousWindow};
+  // hovering is connected to rubberband activation while triggering is for
+  // actual activation of the corresponding dock.
+  const std::vector<QAction*> actions = {windowActionNextWindow,
+                                         windowActionPreviousWindow};
   for (auto& action : actions) {
-    connect(action, &QAction::hovered, this, &MainWindow::onWindowActionNextPrevHovered);
-    connect(action, &QAction::triggered, this, &MainWindow::onWindowActionNextPrevTriggered);
+    connect(action, &QAction::hovered, this,
+            &MainWindow::onWindowActionNextPrevHovered);
+    connect(action, &QAction::triggered, this,
+            &MainWindow::onWindowActionNextPrevTriggered);
   }
 
   // Adds shortcut for the prev/next window switching
   shortcutNextWindow = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_K), this);
-  QObject::connect(shortcutNextWindow,    &QShortcut::activated,
-                   this,        &MainWindow::onWindowShortcutNextPrevActivated);
-  shortcutPreviousWindow = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_H), this);
-  QObject::connect(shortcutPreviousWindow,    &QShortcut::activated,
-                   this,        &MainWindow::onWindowShortcutNextPrevActivated);
+  QObject::connect(shortcutNextWindow, &QShortcut::activated, this,
+                   &MainWindow::onWindowShortcutNextPrevActivated);
+  shortcutPreviousWindow =
+      new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_H), this);
+  QObject::connect(shortcutPreviousWindow, &QShortcut::activated, this,
+                   &MainWindow::onWindowShortcutNextPrevActivated);
 
   // Adds dock specific behavior on visibility change
-  QObject::connect(editorDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onEditorDockVisibilityChanged);
-  QObject::connect(consoleDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onConsoleDockVisibilityChanged);
-  QObject::connect(errorLogDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onErrorLogDockVisibilityChanged);
-  QObject::connect(animateDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onAnimateDockVisibilityChanged);
-  QObject::connect(fontListDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onFontListDockVisibilityChanged);
-  QObject::connect(viewportControlDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onViewportControlDockVisibilityChanged);
-  QObject::connect(parameterDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onParametersDockVisibilityChanged);
-
-  connect(this->activeEditor, &EditorInterface::escapePressed, this, &MainWindow::measureFinished);
+  QObject::connect(editorDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onEditorDockVisibilityChanged);
+  QObject::connect(consoleDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onConsoleDockVisibilityChanged);
+  QObject::connect(errorLogDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onErrorLogDockVisibilityChanged);
+  QObject::connect(animateDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onAnimateDockVisibilityChanged);
+  QObject::connect(fontListDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onFontListDockVisibilityChanged);
+  QObject::connect(viewportControlDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onViewportControlDockVisibilityChanged);
+  QObject::connect(parameterDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onParametersDockVisibilityChanged);
+
+  connect(this->activeEditor, &EditorInterface::escapePressed, this,
+          &MainWindow::measureFinished);
   // display this window and check for OpenGL 2.0 (OpenCSG) support
   viewModeThrownTogether();
   show();
@@ -797,7 +971,8 @@ MainWindow::MainWindow(const QStringList& filenames) :
   // Configure the highlighting color scheme from the active editor one.
   // This is done only one time at creation of the first MainWindow instance
   auto preferences = GlobalPreferences::inst();
-  if (!preferences->hasHighlightingColorScheme())preferences->setHighlightingColorSchemes(activeEditor->colorSchemes());
+  if (!preferences->hasHighlightingColorScheme())
+    preferences->setHighlightingColorSchemes(activeEditor->colorSchemes());
 
   onTabManagerEditorChanged(activeEditor);
 
@@ -813,11 +988,12 @@ void MainWindow::onNavigationCloseContextMenu() {
   rubberBandManager.hide();
 }
 
-void MainWindow::onNavigationTriggerContextMenuEntry(){
-  auto *action = qobject_cast<QAction *>(sender());
-  if (!action || !action->property("id").isValid()) return;
+void MainWindow::onNavigationTriggerContextMenuEntry() {
+  auto* action = qobject_cast<QAction*>(sender());
+  if (!action || !action->property("id").isValid())
+    return;
 
-  Dock *dock = action->property("id").value<Dock *>();
+  Dock* dock = action->property("id").value<Dock*>();
   assert(dock != nullptr);
 
   dock->raise();
@@ -830,16 +1006,18 @@ void MainWindow::onNavigationTriggerContextMenuEntry(){
   }
 }
 
-void MainWindow::onNavigationHoveredContextMenuEntry(){
-  auto *action = qobject_cast<QAction *>(sender());
-  if (!action || !action->property("id").isValid()) return;
+void MainWindow::onNavigationHoveredContextMenuEntry() {
+  auto* action = qobject_cast<QAction*>(sender());
+  if (!action || !action->property("id").isValid())
+    return;
 
-  Dock *dock = action->property("id").value<Dock *>();
+  Dock* dock = action->property("id").value<Dock*>();
   assert(dock != nullptr);
 
   // Hover signal is emitted at each mouse move, to avoid excessive
   // load we only raise/emphasize if it is not yet done.
-  if (rubberBandManager.isEmphasized(dock)) return;
+  if (rubberBandManager.isEmphasized(dock))
+    return;
 
   dock->raise();
   rubberBandManager.emphasize(dock);
@@ -849,37 +1027,40 @@ void MainWindow::updateExportActions() {
   removeExportActions(editortoolbar, this->designAction3DPrint);
   addExportActions(this, editortoolbar, this->designAction3DPrint);
 
-  //handle the hide/show of export action in view toolbar according to the visibility of editor dock
+  // handle the hide/show of export action in view toolbar according to the
+  // visibility of editor dock
   removeExportActions(viewerToolBar, this->viewActionViewAll);
   if (!editorDock->isVisible()) {
     addExportActions(this, viewerToolBar, this->viewActionViewAll);
   }
 }
 
-void MainWindow::openFileFromPath(const QString& path, int line)
-{
+void MainWindow::openFileFromPath(const QString& path, int line) {
   if (editorDock->isVisible()) {
     activeEditor->setFocus();
-    if (!path.isEmpty()) tabManager->open(path);
+    if (!path.isEmpty())
+      tabManager->open(path);
     activeEditor->setFocus();
     activeEditor->setCursorPosition(line, 0);
   }
 }
 
-void MainWindow::addKeyboardShortCut(const QList<QAction *>& actions)
-{
+void MainWindow::addKeyboardShortCut(const QList<QAction*>& actions) {
   for (auto& action : actions) {
     // prevent adding shortcut twice if action is added to multiple toolbars
     if (action->toolTip().contains("&nbsp;")) {
       continue;
     }
 
-    const QString shortCut(action->shortcut().toString(QKeySequence::NativeText));
+    const QString shortCut(
+        action->shortcut().toString(QKeySequence::NativeText));
     if (shortCut.isEmpty()) {
       continue;
     }
 
-    const QString toolTip("%1 &nbsp;<span style=\"color: gray; font-size: small; font-style: italic\">%2</span>");
+    const QString toolTip(
+        "%1 &nbsp;<span style=\"color: gray; font-size: small; font-style: "
+        "italic\">%2</span>");
     action->setToolTip(toolTip.arg(action->toolTip(), shortCut));
   }
 }
@@ -897,8 +1078,7 @@ void MainWindow::updateWindowSettings(bool isConsoleVisible,
                                       bool isViewToolbarVisible,
                                       bool isAnimateVisible,
                                       bool isFontListVisible,
-                                      bool isViewportControlVisible)
-{
+                                      bool isViewportControlVisible) {
   editorDock->setVisible(isEditorVisible);
   consoleDock->setVisible(isConsoleVisible);
   errorLogDock->setVisible(isErrorLogVisible);
@@ -913,42 +1093,33 @@ void MainWindow::updateWindowSettings(bool isConsoleVisible,
   hide3DViewToolbar();
 }
 
-void MainWindow::onAxisChanged(InputEventAxisChanged *)
-{
+void MainWindow::onAxisChanged(InputEventAxisChanged*) {}
 
-}
-
-void MainWindow::onButtonChanged(InputEventButtonChanged *)
-{
+void MainWindow::onButtonChanged(InputEventButtonChanged*) {}
 
-}
-
-void MainWindow::onTranslateEvent(InputEventTranslate *event)
-{
+void MainWindow::onTranslateEvent(InputEventTranslate* event) {
   const double zoomFactor = 0.001 * qglview->cam.zoomValue();
 
   if (event->viewPortRelative) {
     qglview->translate(event->x, event->y, event->z, event->relative, true);
   } else {
-    qglview->translate(zoomFactor * event->x, event->y, zoomFactor * event->z, event->relative, false);
+    qglview->translate(zoomFactor * event->x, event->y, zoomFactor * event->z,
+                       event->relative, false);
   }
 }
 
-void MainWindow::onRotateEvent(InputEventRotate *event)
-{
+void MainWindow::onRotateEvent(InputEventRotate* event) {
   qglview->rotate(event->x, event->y, event->z, event->relative);
 }
 
-void MainWindow::onRotate2Event(InputEventRotate2 *event)
-{
+void MainWindow::onRotate2Event(InputEventRotate2* event) {
   qglview->rotate2(event->x, event->y, event->z);
 }
 
-void MainWindow::onActionEvent(InputEventAction *event)
-{
+void MainWindow::onActionEvent(InputEventAction* event) {
   const std::string actionName = event->action;
   if (actionName.find("::") == std::string::npos) {
-    QAction *action = findAction(this->menuBar()->actions(), actionName);
+    QAction* action = findAction(this->menuBar()->actions(), actionName);
     if (action) {
       action->trigger();
     } else if ("viewActionTogglePerspective" == actionName) {
@@ -964,12 +1135,11 @@ void MainWindow::onActionEvent(InputEventAction *event)
   }
 }
 
-void MainWindow::onZoomEvent(InputEventZoom *event)
-{
+void MainWindow::onZoomEvent(InputEventZoom* event) {
   qglview->zoom(event->zoom, event->relative);
 }
 
-void MainWindow::loadViewSettings(){
+void MainWindow::loadViewSettings() {
   const QSettingsCached settings;
 
   if (settings.value("view/showEdges").toBool()) {
@@ -994,83 +1164,102 @@ void MainWindow::loadViewSettings(){
     viewPerspective();
   }
 
-  updateUndockMode(GlobalPreferences::inst()->getValue("advanced/undockableWindows").toBool());
-  updateReorderMode(GlobalPreferences::inst()->getValue("advanced/reorderWindows").toBool());
+  updateUndockMode(GlobalPreferences::inst()
+                       ->getValue("advanced/undockableWindows")
+                       .toBool());
+  updateReorderMode(
+      GlobalPreferences::inst()->getValue("advanced/reorderWindows").toBool());
 }
 
-void MainWindow::loadDesignSettings()
-{
+void MainWindow::loadDesignSettings() {
   const QSettingsCached settings;
   if (settings.value("design/autoReload", false).toBool()) {
     designActionAutoReload->setChecked(true);
   }
-  auto polySetCacheSizeMB = GlobalPreferences::inst()->getValue("advanced/polysetCacheSizeMB").toUInt();
+  auto polySetCacheSizeMB = GlobalPreferences::inst()
+                                ->getValue("advanced/polysetCacheSizeMB")
+                                .toUInt();
   GeometryCache::instance()->setMaxSizeMB(polySetCacheSizeMB);
-  auto cgalCacheSizeMB = GlobalPreferences::inst()->getValue("advanced/cgalCacheSizeMB").toUInt();
+  auto cgalCacheSizeMB =
+      GlobalPreferences::inst()->getValue("advanced/cgalCacheSizeMB").toUInt();
   CGALCache::instance()->setMaxSizeMB(cgalCacheSizeMB);
-  auto backend3D = GlobalPreferences::inst()->getValue("advanced/renderBackend3D").toString().toStdString();
+  auto backend3D = GlobalPreferences::inst()
+                       ->getValue("advanced/renderBackend3D")
+                       .toString()
+                       .toStdString();
   RenderSettings::inst()->backend3D = renderBackend3DFromString(backend3D);
 }
 
-void MainWindow::updateUndockMode(bool undockMode)
-{
+void MainWindow::updateUndockMode(bool undockMode) {
   MainWindow::undockMode = undockMode;
   if (undockMode) {
-    editorDock->setFeatures(editorDock->features() | QDockWidget::DockWidgetFloatable);
-    consoleDock->setFeatures(consoleDock->features() | QDockWidget::DockWidgetFloatable);
-    parameterDock->setFeatures(parameterDock->features() | QDockWidget::DockWidgetFloatable);
-    errorLogDock->setFeatures(errorLogDock->features() | QDockWidget::DockWidgetFloatable);
-    animateDock->setFeatures(animateDock->features() | QDockWidget::DockWidgetFloatable);
-    fontListDock->setFeatures(fontListDock->features() | QDockWidget::DockWidgetFloatable);
-    viewportControlDock->setFeatures(viewportControlDock->features() | QDockWidget::DockWidgetFloatable);
+    editorDock->setFeatures(editorDock->features() |
+                            QDockWidget::DockWidgetFloatable);
+    consoleDock->setFeatures(consoleDock->features() |
+                             QDockWidget::DockWidgetFloatable);
+    parameterDock->setFeatures(parameterDock->features() |
+                               QDockWidget::DockWidgetFloatable);
+    errorLogDock->setFeatures(errorLogDock->features() |
+                              QDockWidget::DockWidgetFloatable);
+    animateDock->setFeatures(animateDock->features() |
+                             QDockWidget::DockWidgetFloatable);
+    fontListDock->setFeatures(fontListDock->features() |
+                              QDockWidget::DockWidgetFloatable);
+    viewportControlDock->setFeatures(viewportControlDock->features() |
+                                     QDockWidget::DockWidgetFloatable);
   } else {
     if (editorDock->isFloating()) {
       editorDock->setFloating(false);
     }
-    editorDock->setFeatures(editorDock->features() & ~QDockWidget::DockWidgetFloatable);
+    editorDock->setFeatures(editorDock->features() &
+                            ~QDockWidget::DockWidgetFloatable);
 
     if (consoleDock->isFloating()) {
       consoleDock->setFloating(false);
     }
-    consoleDock->setFeatures(consoleDock->features() & ~QDockWidget::DockWidgetFloatable);
+    consoleDock->setFeatures(consoleDock->features() &
+                             ~QDockWidget::DockWidgetFloatable);
 
     if (parameterDock->isFloating()) {
       parameterDock->setFloating(false);
     }
-    parameterDock->setFeatures(parameterDock->features() & ~QDockWidget::DockWidgetFloatable);
+    parameterDock->setFeatures(parameterDock->features() &
+                               ~QDockWidget::DockWidgetFloatable);
 
     if (errorLogDock->isFloating()) {
       errorLogDock->setFloating(false);
     }
-    errorLogDock->setFeatures(errorLogDock->features() & ~QDockWidget::DockWidgetFloatable);
+    errorLogDock->setFeatures(errorLogDock->features() &
+                              ~QDockWidget::DockWidgetFloatable);
 
     if (animateDock->isFloating()) {
       animateDock->setFloating(false);
     }
-    animateDock->setFeatures(animateDock->features() & ~QDockWidget::DockWidgetFloatable);
+    animateDock->setFeatures(animateDock->features() &
+                             ~QDockWidget::DockWidgetFloatable);
 
     if (fontListDock->isFloating()) {
       fontListDock->setFloating(false);
     }
-    fontListDock->setFeatures(fontListDock->features() & ~QDockWidget::DockWidgetFloatable);
+    fontListDock->setFeatures(fontListDock->features() &
+                              ~QDockWidget::DockWidgetFloatable);
 
     if (viewportControlDock->isFloating()) {
       viewportControlDock->setFloating(false);
     }
-    viewportControlDock->setFeatures(viewportControlDock->features() & ~QDockWidget::DockWidgetFloatable);
+    viewportControlDock->setFeatures(viewportControlDock->features() &
+                                     ~QDockWidget::DockWidgetFloatable);
   }
 }
 
-void MainWindow::updateReorderMode(bool reorderMode)
-{
+void MainWindow::updateReorderMode(bool reorderMode) {
   MainWindow::reorderMode = reorderMode;
   for (auto& [dock, name] : docks) {
     dock->setTitleBarVisibility(!reorderMode);
   }
 }
 
-MainWindow::~MainWindow()
-{
+MainWindow::~MainWindow() {
   // If root_file is not null then it will be the same as parsed_file,
   // so no need to delete it.
   delete parsedFile;
@@ -1082,51 +1271,52 @@ MainWindow::~MainWindow()
   }
 }
 
-void MainWindow::showProgress()
-{
-  updateStatusBar(qobject_cast<ProgressWidget *>(sender()));
+void MainWindow::showProgress() {
+  updateStatusBar(qobject_cast<ProgressWidget*>(sender()));
 }
 
-void MainWindow::report_func(const std::shared_ptr<const AbstractNode>&, void *vp, int mark)
-{
+void MainWindow::report_func(const std::shared_ptr<const AbstractNode>&,
+                             void* vp,
+                             int mark) {
   // limit to progress bar update calls to 5 per second
   static const qint64 MIN_TIMEOUT = 200;
   if (progressThrottle->hasExpired(MIN_TIMEOUT)) {
     progressThrottle->start();
 
-    auto thisp = static_cast<MainWindow *>(vp);
+    auto thisp = static_cast<MainWindow*>(vp);
     auto v = static_cast<int>((mark * 1000.0) / progress_report_count);
     auto permille = v < 1000 ? v : 999;
     if (permille > thisp->progresswidget->value()) {
-      QMetaObject::invokeMethod(thisp->progresswidget, "setValue", Qt::QueuedConnection,
-                                Q_ARG(int, permille));
+      QMetaObject::invokeMethod(thisp->progresswidget, "setValue",
+                                Qt::QueuedConnection, Q_ARG(int, permille));
       QApplication::processEvents();
     }
 
     // FIXME: Check if cancel was requested by e.g. Application quit
-    if (thisp->progresswidget->wasCanceled()) throw ProgressCancelException();
+    if (thisp->progresswidget->wasCanceled())
+      throw ProgressCancelException();
   }
 }
 
-bool MainWindow::network_progress_func(const double permille)
-{
-  QMetaObject::invokeMethod(this->progresswidget, "setValue", Qt::QueuedConnection, Q_ARG(int, (int)permille));
+bool MainWindow::network_progress_func(const double permille) {
+  QMetaObject::invokeMethod(this->progresswidget, "setValue",
+                            Qt::QueuedConnection, Q_ARG(int, (int)permille));
   return (progresswidget && progresswidget->wasCanceled());
 }
 
-void MainWindow::updateRecentFiles(const QString& FileSavedOrOpened)
-{
+void MainWindow::updateRecentFiles(const QString& FileSavedOrOpened) {
   // Check that the canonical file path exists - only update recent files
   // if it does. Should prevent empty list items on initial open etc.
-  QSettingsCached settings;   // already set up properly via main.cpp
+  QSettingsCached settings;  // already set up properly via main.cpp
   auto files = settings.value("recentFileList").toStringList();
   files.removeAll(FileSavedOrOpened);
   files.prepend(FileSavedOrOpened);
-  while (files.size() > UIUtils::maxRecentFiles) files.removeLast();
+  while (files.size() > UIUtils::maxRecentFiles)
+    files.removeLast();
   settings.setValue("recentFileList", files);
 
   for (auto& widget : QApplication::topLevelWidgets()) {
-    auto mainWin = qobject_cast<MainWindow *>(widget);
+    auto mainWin = qobject_cast<MainWindow*>(widget);
     if (mainWin) {
       mainWin->updateRecentFileActions();
     }
@@ -1136,15 +1326,24 @@ void MainWindow::updateRecentFiles(const QString& FileSavedOrOpened)
 /*!
    compiles the design. Calls compileDone() if anything was compiled
  */
-void MainWindow::compile(bool reload, bool forcedone)
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  OpenSCAD::traceDepth = GlobalPreferences::inst()->getValue("advanced/traceDepth").toUInt();
-  OpenSCAD::traceUsermoduleParameters = GlobalPreferences::inst()->getValue("advanced/enableTraceUsermoduleParameters").toBool();
-  OpenSCAD::parameterCheck = GlobalPreferences::inst()->getValue("advanced/enableParameterCheck").toBool();
-  OpenSCAD::rangeCheck = GlobalPreferences::inst()->getValue("advanced/enableParameterRangeCheck").toBool();
-
-  try{
+void MainWindow::compile(bool reload, bool forcedone) {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst()
+                               ->getValue("advanced/enableHardwarnings")
+                               .toBool();
+  OpenSCAD::traceDepth =
+      GlobalPreferences::inst()->getValue("advanced/traceDepth").toUInt();
+  OpenSCAD::traceUsermoduleParameters =
+      GlobalPreferences::inst()
+          ->getValue("advanced/enableTraceUsermoduleParameters")
+          .toBool();
+  OpenSCAD::parameterCheck = GlobalPreferences::inst()
+                                 ->getValue("advanced/enableParameterCheck")
+                                 .toBool();
+  OpenSCAD::rangeCheck = GlobalPreferences::inst()
+                             ->getValue("advanced/enableParameterRangeCheck")
+                             .toBool();
+
+  try {
     bool shouldcompiletoplevel = false;
     bool didcompile = false;
 
@@ -1153,18 +1352,23 @@ void MainWindow::compile(bool reload, bool forcedone)
 
     this->renderStatistic.start();
 
-    // Reload checks the timestamp of the toplevel file and refreshes if necessary,
+    // Reload checks the timestamp of the toplevel file and refreshes if
+    // necessary,
     if (reload) {
       // Refresh files if it has changed on disk
       if (fileChangedOnDisk() && checkEditorModified()) {
-        shouldcompiletoplevel = tabManager->refreshDocument();         // don't compile if we couldn't open the file
-        if (shouldcompiletoplevel && GlobalPreferences::inst()->getValue("advanced/autoReloadRaise").toBool()) {
+        shouldcompiletoplevel =
+            tabManager->refreshDocument();  // don't compile if we couldn't open
+                                            // the file
+        if (shouldcompiletoplevel && GlobalPreferences::inst()
+                                         ->getValue("advanced/autoReloadRaise")
+                                         .toBool()) {
           // reloading the 'same' document brings the 'old' one to front.
           this->raise();
         }
       }
-      // If the file has some content and there is no currently compiled content,
-      // then we force the top level compilation.
+      // If the file has some content and there is no currently compiled
+      // content, then we force the top level compilation.
       else {
         auto current_doc = activeEditor->toPlainText();
         if (current_doc.size() && lastCompiledDoc.size() == 0) {
@@ -1183,23 +1387,29 @@ void MainWindow::compile(bool reload, bool forcedone)
       }
     }
 
-    // Parsing and dependency handling must run to completion even with stop on errors to prevent auto
-    // reload picking up where it left off, thwarting the stop, so we turn off exceptions in PRINT.
+    // Parsing and dependency handling must run to completion even with stop on
+    // errors to prevent auto reload picking up where it left off, thwarting the
+    // stop, so we turn off exceptions in PRINT.
     no_exceptions_for_warnings();
     if (shouldcompiletoplevel) {
       initialize_rng();
       this->errorLogWidget->clearModel();
-      if (GlobalPreferences::inst()->getValue("advanced/consoleAutoClear").toBool()) {
+      if (GlobalPreferences::inst()
+              ->getValue("advanced/consoleAutoClear")
+              .toBool()) {
         this->console->actionClearConsole_triggered();
       }
-      if (activeEditor->isContentModified()) saveBackup();
+      if (activeEditor->isContentModified())
+        saveBackup();
       parseTopLevelDocument();
       didcompile = true;
     }
 
     if (didcompile && parser_error_pos != lastParserErrorPos) {
-      if (lastParserErrorPos >= 0) emit unhighlightLastError();
-      if (parser_error_pos >= 0) emit highlightError(parser_error_pos);
+      if (lastParserErrorPos >= 0)
+        emit unhighlightLastError();
+      if (parser_error_pos >= 0)
+        emit highlightError(parser_error_pos);
       lastParserErrorPos = parser_error_pos;
     }
 
@@ -1207,15 +1417,17 @@ void MainWindow::compile(bool reload, bool forcedone)
       auto mtime = this->rootFile->handleDependencies();
       if (mtime > this->depsMTime) {
         this->depsMTime = mtime;
-        LOG("Used file cache size: %1$d files", SourceFileCache::instance()->size());
+        LOG("Used file cache size: %1$d files",
+            SourceFileCache::instance()->size());
         didcompile = true;
       }
     }
 
     // Had any errors in the parse that would have caused exceptions via PRINT.
-    if (would_have_thrown()) throw HardWarningException("");
-    // If we're auto-reloading, listen for a cascade of changes by starting a timer
-    // if something changed _and_ there are any external dependencies
+    if (would_have_thrown())
+      throw HardWarningException("");
+    // If we're auto-reloading, listen for a cascade of changes by starting a
+    // timer if something changed _and_ there are any external dependencies
     if (reload && didcompile && this->rootFile) {
       if (this->rootFile->hasIncludes() || this->rootFile->usesLibraries()) {
         this->waitAfterReloadTimer->start();
@@ -1234,26 +1446,25 @@ void MainWindow::compile(bool reload, bool forcedone)
   }
 }
 
-void MainWindow::waitAfterReload()
-{
+void MainWindow::waitAfterReload() {
   no_exceptions_for_warnings();
   auto mtime = this->rootFile->handleDependencies();
   auto stop = would_have_thrown();
-  if (mtime > this->depsMTime) this->depsMTime = mtime;
+  if (mtime > this->depsMTime)
+    this->depsMTime = mtime;
   else if (!stop) {
-    compile(true, true);     // In case file itself or top-level includes changed during dependency updates
+    compile(true, true);  // In case file itself or top-level includes changed
+                          // during dependency updates
     return;
   }
   this->waitAfterReloadTimer->start();
 }
 
-void MainWindow::on_toolButtonCompileResultClose_clicked()
-{
+void MainWindow::on_toolButtonCompileResultClose_clicked() {
   frameCompileResult->hide();
 }
 
-void MainWindow::updateCompileResult()
-{
+void MainWindow::updateCompileResult() {
   if ((compileErrors == 0) && (compileWarnings == 0)) {
     frameCompileResult->hide();
     return;
@@ -1271,11 +1482,15 @@ void MainWindow::updateCompileResult()
       const QFileInfo fileInfo(activeEditor->filepath);
       msg = QString(_("Error while compiling '%1'.")).arg(fileInfo.fileName());
     }
-    toolButtonCompileResultIcon->setIcon(QIcon(QString::fromUtf8(":/icons/information-icons-error.png")));
+    toolButtonCompileResultIcon->setIcon(
+        QIcon(QString::fromUtf8(":/icons/information-icons-error.png")));
   } else {
-    const char *fmt = ngettext("Compilation generated %1 warning.", "Compilation generated %1 warnings.", compileWarnings);
+    const char* fmt =
+        ngettext("Compilation generated %1 warning.",
+                 "Compilation generated %1 warnings.", compileWarnings);
     msg = QString(fmt).arg(compileWarnings);
-    toolButtonCompileResultIcon->setIcon(QIcon(QString::fromUtf8(":/icons/information-icons-warning.png")));
+    toolButtonCompileResultIcon->setIcon(
+        QIcon(QString::fromUtf8(":/icons/information-icons-warning.png")));
   }
   const QFontMetrics fm(labelCompileResultMessage->font());
   const int sizeIcon = std::max(12, std::min(32, fm.height()));
@@ -1283,16 +1498,18 @@ void MainWindow::updateCompileResult()
   toolButtonCompileResultIcon->setIconSize(QSize(sizeIcon, sizeIcon));
   toolButtonCompileResultClose->setIconSize(QSize(sizeClose, sizeClose));
 
-  msg += _(R"( For details see the <a href="#errorlog">error log</a> and <a href="#console">console window</a>.)");
+  msg += _(
+      R"( For details see the <a href="#errorlog">error log</a> and <a href="#console">console window</a>.)");
   labelCompileResultMessage->setText(msg);
   frameCompileResult->show();
 }
 
-void MainWindow::compileDone(bool didchange)
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  try{
-    const char *callslot;
+void MainWindow::compileDone(bool didchange) {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst()
+                               ->getValue("advanced/enableHardwarnings")
+                               .toBool();
+  try {
+    const char* callslot;
     if (didchange) {
       instantiateRoot();
       updateCompileResult();
@@ -1308,32 +1525,33 @@ void MainWindow::compileDone(bool didchange)
   }
 }
 
-void MainWindow::compileEnded()
-{
+void MainWindow::compileEnded() {
   clearCurrentOutput();
   GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+  if (designActionAutoReload->isChecked())
+    autoReloadTimer->start();
 #ifdef ENABLE_GUI_TESTS
   emit compilationDone(this->rootFile);
 #endif
 }
 
 #ifdef ENABLE_GUI_TESTS
-std::shared_ptr<AbstractNode> MainWindow::instantiateRootFromSource(SourceFile *file)
-{
+std::shared_ptr<AbstractNode> MainWindow::instantiateRootFromSource(
+    SourceFile* file) {
   EvaluationSession session{file->getFullpath()};
-  ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
+  ContextHandle<BuiltinContext> builtin_context{
+      Context::create<BuiltinContext>(&session)};
   setRenderVariables(builtin_context);
 
   std::shared_ptr<const FileContext> file_context;
-  std::shared_ptr<AbstractNode> node = this->rootFile->instantiate(*builtin_context, &file_context);
+  std::shared_ptr<AbstractNode> node =
+      this->rootFile->instantiate(*builtin_context, &file_context);
 
   return node;
 }
-#endif // ifdef ENABLE_GUI_TESTS
+#endif  // ifdef ENABLE_GUI_TESTS
 
-void MainWindow::instantiateRoot()
-{
+void MainWindow::instantiateRoot() {
   // Go on and instantiate root_node, then call the continuation slot
 
   // Invalidate renderers before we kill the CSG tree
@@ -1366,15 +1584,18 @@ void MainWindow::instantiateRoot()
     AbstractNode::resetIndexCounter();
 
     EvaluationSession session{doc.parent_path().string()};
-    ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
+    ContextHandle<BuiltinContext> builtin_context{
+        Context::create<BuiltinContext>(&session)};
     setRenderVariables(builtin_context);
 
     std::shared_ptr<const FileContext> file_context;
 #ifdef ENABLE_PYTHON
-    if (python_result_node != NULL && this->python_active) this->absoluteRootNode = python_result_node;
+    if (python_result_node != NULL && this->python_active)
+      this->absoluteRootNode = python_result_node;
     else
 #endif
-    this->absoluteRootNode = this->rootFile->instantiate(*builtin_context, &file_context);
+      this->absoluteRootNode =
+          this->rootFile->instantiate(*builtin_context, &file_context);
     if (file_context) {
       this->qglview->cam.updateView(file_context, false);
       viewportControlWidget->cameraChanged();
@@ -1382,22 +1603,26 @@ void MainWindow::instantiateRoot()
 
     if (this->absoluteRootNode) {
       // Do we have an explicit root node (! modifier)?
-      const Location *nextLocation = nullptr;
-      if (!(this->rootNode = find_root_tag(this->absoluteRootNode, &nextLocation))) {
+      const Location* nextLocation = nullptr;
+      if (!(this->rootNode =
+                find_root_tag(this->absoluteRootNode, &nextLocation))) {
         this->rootNode = this->absoluteRootNode;
       }
       if (nextLocation) {
-        LOG(message_group::NONE, *nextLocation, builtin_context->documentRoot(), "More than one Root Modifier (!)");
+        LOG(message_group::NONE, *nextLocation, builtin_context->documentRoot(),
+            "More than one Root Modifier (!)");
       }
 
-      // FIXME: Consider giving away ownership of root_node to the Tree, or use reference counted pointers
+      // FIXME: Consider giving away ownership of root_node to the Tree, or use
+      // reference counted pointers
       this->tree.setRoot(this->rootNode);
     }
   }
 
   if (!this->rootNode) {
     if (parser_error_pos < 0) {
-      LOG(message_group::Error, "Compilation failed! (no top level object found)");
+      LOG(message_group::Error,
+          "Compilation failed! (no top level object found)");
     } else {
       LOG(message_group::Error, "Compilation failed!");
     }
@@ -1408,27 +1633,32 @@ void MainWindow::instantiateRoot()
 
 /*!
    Generates CSG tree for OpenCSG evaluation.
-   Assumes that the design has been parsed and evaluated (this->root_node is set)
+   Assumes that the design has been parsed and evaluated (this->root_node is
+   set)
  */
-void MainWindow::compileCSG()
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  try{
+void MainWindow::compileCSG() {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst()
+                               ->getValue("advanced/enableHardwarnings")
+                               .toBool();
+  try {
     assert(this->rootNode);
     LOG("Compiling design (CSG Products generation)...");
     this->processEvents();
 
     // Main CSG evaluation
     this->progresswidget = new ProgressWidget(this);
-    connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+    connect(this->progresswidget, &ProgressWidget::requestShow, this,
+            &MainWindow::showProgress);
 
     GeometryEvaluator geomevaluator(this->tree);
 #ifdef ENABLE_OPENCSG
     CSGTreeEvaluator csgrenderer(this->tree, &geomevaluator);
 #endif
 
-    if (!isClosing) progress_report_prep(this->rootNode, report_func, this);
-    else return;
+    if (!isClosing)
+      progress_report_prep(this->rootNode, report_func, this);
+    else
+      return;
     try {
 #ifdef ENABLE_OPENCSG
       this->processEvents();
@@ -1447,7 +1677,9 @@ void MainWindow::compileCSG()
     LOG("Compiling design (CSG Products normalization)...");
     this->processEvents();
 
-    const size_t normalizelimit = 2ul * GlobalPreferences::inst()->getValue("advanced/openCSGLimit").toUInt();
+    const size_t normalizelimit =
+        2ul *
+        GlobalPreferences::inst()->getValue("advanced/openCSGLimit").toUInt();
     CSGTreeNormalizer normalizer(normalizelimit);
 
     if (this->csgRoot) {
@@ -1457,12 +1689,14 @@ void MainWindow::compileCSG()
         this->rootProduct->import(this->normalizedRoot);
       } else {
         this->rootProduct.reset();
-        LOG(message_group::Warning, "CSG normalization resulted in an empty tree");
+        LOG(message_group::Warning,
+            "CSG normalization resulted in an empty tree");
         this->processEvents();
       }
     }
 
-    const std::vector<std::shared_ptr<CSGNode>>& highlight_terms = csgrenderer.getHighlightNodes();
+    const std::vector<std::shared_ptr<CSGNode>>& highlight_terms =
+        csgrenderer.getHighlightNodes();
     if (highlight_terms.size() > 0) {
       LOG("Compiling highlights (%1$d CSG Trees)...", highlight_terms.size());
       this->processEvents();
@@ -1495,23 +1729,24 @@ void MainWindow::compileCSG()
     }
 
     if (this->rootProduct &&
-        (this->rootProduct->size() >
-         GlobalPreferences::inst()->getValue("advanced/openCSGLimit").toUInt())) {
-      LOG(message_group::UI_Warning, "Normalized tree has %1$d elements!", this->rootProduct->size());
+        (this->rootProduct->size() > GlobalPreferences::inst()
+                                         ->getValue("advanced/openCSGLimit")
+                                         .toUInt())) {
+      LOG(message_group::UI_Warning, "Normalized tree has %1$d elements!",
+          this->rootProduct->size());
       LOG(message_group::UI_Warning, "OpenCSG rendering has been disabled.");
     }
 #ifdef ENABLE_OPENCSG
     else {
       LOG("Normalized tree has %1$d elements!",
           (this->rootProduct ? this->rootProduct->size() : 0));
-      this->previewRenderer = std::make_shared<OpenCSGRenderer>(this->rootProduct,
-                                                                this->highlightsProducts,
-                                                                this->backgroundProducts);
-    }
-#endif // ifdef ENABLE_OPENCSG
-    this->thrownTogetherRenderer = std::make_shared<ThrownTogetherRenderer>(this->rootProduct,
-                                                                            this->highlightsProducts,
-                                                                            this->backgroundProducts);
+      this->previewRenderer = std::make_shared<OpenCSGRenderer>(
+          this->rootProduct, this->highlightsProducts,
+          this->backgroundProducts);
+    }
+#endif  // ifdef ENABLE_OPENCSG
+    this->thrownTogetherRenderer = std::make_shared<ThrownTogetherRenderer>(
+        this->rootProduct, this->highlightsProducts, this->backgroundProducts);
     LOG("Compile and preview finished.");
     renderStatistic.printRenderingTime();
     this->processEvents();
@@ -1520,8 +1755,7 @@ void MainWindow::compileCSG()
   }
 }
 
-void MainWindow::actionOpen()
-{
+void MainWindow::actionOpen() {
   auto fileInfoList = UIUtils::openFiles(this);
   for (auto& i : fileInfoList) {
     if (!i.exists()) {
@@ -1531,13 +1765,11 @@ void MainWindow::actionOpen()
   }
 }
 
-void MainWindow::actionNewWindow()
-{
+void MainWindow::actionNewWindow() {
   new MainWindow(QStringList());
 }
 
-void MainWindow::actionOpenWindow()
-{
+void MainWindow::actionOpenWindow() {
   auto fileInfoList = UIUtils::openFiles(this);
   for (auto& i : fileInfoList) {
     if (!i.exists()) {
@@ -1547,15 +1779,13 @@ void MainWindow::actionOpenWindow()
   }
 }
 
-void MainWindow::actionOpenRecent()
-{
-  auto action = qobject_cast<QAction *>(sender());
+void MainWindow::actionOpenRecent() {
+  auto action = qobject_cast<QAction*>(sender());
   tabManager->open(action->data().toString());
 }
 
-void MainWindow::clearRecentFiles()
-{
-  QSettingsCached settings;   // already set up properly via main.cpp
+void MainWindow::clearRecentFiles() {
+  QSettingsCached settings;  // already set up properly via main.cpp
   const QStringList files;
   settings.setValue("recentFileList", files);
 
@@ -1564,12 +1794,12 @@ void MainWindow::clearRecentFiles()
 
 // Updates the content of the recent files menu entries
 // by iterating over the recently opened files.
-void MainWindow::updateRecentFileActions()
-{
+void MainWindow::updateRecentFileActions() {
   auto files = UIUtils::recentFiles();
 
   for (int i = 0; i < files.size(); ++i) {
-    this->actionRecentFile[i]->setText(QFileInfo(files[i]).fileName().replace("&", "&&"));
+    this->actionRecentFile[i]->setText(
+        QFileInfo(files[i]).fileName().replace("&", "&&"));
     this->actionRecentFile[i]->setData(files[i]);
     this->actionRecentFile[i]->setVisible(true);
   }
@@ -1578,13 +1808,13 @@ void MainWindow::updateRecentFileActions()
   }
 }
 
-void MainWindow::show_examples()
-{
+void MainWindow::show_examples() {
   bool found_example = false;
 
   for (const auto& cat : UIUtils::exampleCategories()) {
     auto examples = UIUtils::exampleFiles(cat.name);
-    auto menu = this->menuExamples->addMenu(gettext(cat.name.toStdString().c_str()));
+    auto menu =
+        this->menuExamples->addMenu(gettext(cat.name.toStdString().c_str()));
     if (!cat.tooltip.trimmed().isEmpty()) {
       menu->setToolTip(gettext(cat.tooltip.toStdString().c_str()));
       menu->setToolTipsVisible(true);
@@ -1592,7 +1822,8 @@ void MainWindow::show_examples()
 
     for (const auto& ex : examples) {
       auto openAct = new QAction(ex.fileName().replace("&", "&&"), this);
-      connect(openAct, &QAction::triggered, this, &MainWindow::actionOpenExample);
+      connect(openAct, &QAction::triggered, this,
+              &MainWindow::actionOpenExample);
       menu->addAction(openAct);
       openAct->setData(ex.canonicalFilePath());
       found_example = true;
@@ -1605,17 +1836,15 @@ void MainWindow::show_examples()
   }
 }
 
-void MainWindow::actionOpenExample()
-{
-  const auto action = qobject_cast<QAction *>(sender());
+void MainWindow::actionOpenExample() {
+  const auto action = qobject_cast<QAction*>(sender());
   if (action) {
     const auto& path = action->data().toString();
     tabManager->open(path);
   }
 }
 
-void MainWindow::writeBackup(QFile *file)
-{
+void MainWindow::writeBackup(QFile* file) {
   // see MainWindow::saveBackup()
   file->resize(0);
   QTextStream writer(file);
@@ -1628,8 +1857,7 @@ void MainWindow::writeBackup(QFile *file)
   LOG("Saved backup file: %1$s", file->fileName().toUtf8().constData());
 }
 
-void MainWindow::saveBackup()
-{
+void MainWindow::saveBackup() {
   auto path = PlatformUtils::backupPath();
   if ((!fs::exists(path)) && (!PlatformUtils::createBackupPath())) {
     LOG(message_group::UI_Warning, "Cannot create backup path: %1$s", path);
@@ -1637,7 +1865,8 @@ void MainWindow::saveBackup()
   }
 
   auto backupPath = QString::fromLocal8Bit(path.c_str());
-  if (!backupPath.endsWith("/")) backupPath.append("/");
+  if (!backupPath.endsWith("/"))
+    backupPath.append("/");
 
   QString basename = "unsaved";
   if (!activeEditor->filepath.isEmpty()) {
@@ -1651,7 +1880,8 @@ void MainWindow::saveBackup()
 #else
     const QString suffix = "scad";
 #endif
-    this->tempFile = new QTemporaryFile(backupPath.append(basename + "-backup-XXXXXXXX." + suffix));
+    this->tempFile = new QTemporaryFile(
+        backupPath.append(basename + "-backup-XXXXXXXX." + suffix));
   }
 
   if ((!this->tempFile->isOpen()) && (!this->tempFile->open())) {
@@ -1661,31 +1891,29 @@ void MainWindow::saveBackup()
   return writeBackup(this->tempFile);
 }
 
-void MainWindow::actionSave()
-{
+void MainWindow::actionSave() {
   tabManager->save(activeEditor);
 }
 
-void MainWindow::actionSaveAs()
-{
+void MainWindow::actionSaveAs() {
   tabManager->saveAs(activeEditor);
 }
 
-void MainWindow::actionPythonRevokeTrustedFiles()
-{
+void MainWindow::actionPythonRevokeTrustedFiles() {
   QSettingsCached settings;
 #ifdef ENABLE_PYTHON
   python_trusted = false;
   this->trusted_edit_document_name = "";
 #endif
   settings.remove("python_hash");
-  QMessageBox::information(this, _("Trusted Files"), "All trusted python files revoked", QMessageBox::Ok);
+  QMessageBox::information(this, _("Trusted Files"),
+                           "All trusted python files revoked", QMessageBox::Ok);
 }
 
-void MainWindow::actionPythonCreateVenv()
-{
+void MainWindow::actionPythonCreateVenv() {
 #ifdef ENABLE_PYTHON
-  const QString selectedDir = QFileDialog::getExistingDirectory(this, "Create Virtual Environment");
+  const QString selectedDir =
+      QFileDialog::getExistingDirectory(this, "Create Virtual Environment");
   if (selectedDir.isEmpty()) {
     return;
   }
@@ -1693,16 +1921,18 @@ void MainWindow::actionPythonCreateVenv()
   const QDir venvDir{selectedDir};
   if (!venvDir.exists()) {
     // Should not happen, but just in case double check...
-    QMessageBox::critical(this, _("Create Virtual Environment"),
-                          "Directory does not exist. Can't create virtual environment.",
-                          QMessageBox::Ok);
+    QMessageBox::critical(
+        this, _("Create Virtual Environment"),
+        "Directory does not exist. Can't create virtual environment.",
+        QMessageBox::Ok);
     return;
   }
 
   if (!venvDir.isEmpty()) {
-    QMessageBox::critical(this, _("Create Virtual Environment"),
-                          "Directory is not empty. Can't create virtual environment.",
-                          QMessageBox::Ok);
+    QMessageBox::critical(
+        this, _("Create Virtual Environment"),
+        "Directory is not empty. Can't create virtual environment.",
+        QMessageBox::Ok);
     return;
   }
 
@@ -1714,22 +1944,23 @@ void MainWindow::actionPythonCreateVenv()
     Settings::SettingsPython::pythonVirtualEnv.setValue(path);
     Settings::Settings::visit(SettingsWriter());
     LOG("Python virtual environment creation successfull.");
-    QMessageBox::information(this, _("Create Virtual Environment"),
-                             "Virtual environment created, please restart OpenSCAD to activate.",
-                             QMessageBox::Ok);
+    QMessageBox::information(
+        this, _("Create Virtual Environment"),
+        "Virtual environment created, please restart OpenSCAD to activate.",
+        QMessageBox::Ok);
   } else {
     LOG("Python virtual environment creation failed.");
     QMessageBox::critical(this, _("Create Virtual Environment"),
                           "Virtual environment creation failed.",
                           QMessageBox::Ok);
   }
-#endif // ifdef ENABLE_PYTHON
+#endif  // ifdef ENABLE_PYTHON
 }
 
-void MainWindow::actionPythonSelectVenv()
-{
+void MainWindow::actionPythonSelectVenv() {
 #ifdef ENABLE_PYTHON
-  const QString venvDir = QFileDialog::getExistingDirectory(this, "Select Virtual Environment");
+  const QString venvDir =
+      QFileDialog::getExistingDirectory(this, "Select Virtual Environment");
   if (venvDir.isEmpty()) {
     return;
   }
@@ -1737,23 +1968,23 @@ void MainWindow::actionPythonSelectVenv()
   if (fileInfo.exists()) {
     Settings::SettingsPython::pythonVirtualEnv.setValue(venvDir.toStdString());
     Settings::Settings::visit(SettingsWriter());
-    QMessageBox::information(this, _("Select Virtual Environment"),
-                             "Virtual environment selected, please restart OpenSCAD to activate.",
-                             QMessageBox::Ok);
+    QMessageBox::information(
+        this, _("Select Virtual Environment"),
+        "Virtual environment selected, please restart OpenSCAD to activate.",
+        QMessageBox::Ok);
   }
-#endif // ifdef ENABLE_PYTHON
+#endif  // ifdef ENABLE_PYTHON
 }
 
-void MainWindow::actionSaveACopy()
-{
+void MainWindow::actionSaveACopy() {
   tabManager->saveACopy(activeEditor);
 }
 
-void MainWindow::actionShowLibraryFolder()
-{
+void MainWindow::actionShowLibraryFolder() {
   auto path = PlatformUtils::userLibraryPath();
   if (!fs::exists(path)) {
-    LOG(message_group::UI_Warning, "Library path %1$s doesn't exist. Creating", path);
+    LOG(message_group::UI_Warning, "Library path %1$s doesn't exist. Creating",
+        path);
     if (!PlatformUtils::createUserLibraryPath()) {
       LOG(message_group::UI_Error, "Cannot create library path: %1$s", path);
     }
@@ -1763,48 +1994,42 @@ void MainWindow::actionShowLibraryFolder()
   QDesktopServices::openUrl(QUrl::fromLocalFile(url));
 }
 
-void MainWindow::actionReload()
-{
+void MainWindow::actionReload() {
   if (checkEditorModified()) {
-    fileChangedOnDisk();     // force cached autoReloadId to update
-    (void)tabManager->refreshDocument();     // ignore errors opening the file
+    fileChangedOnDisk();                  // force cached autoReloadId to update
+    (void)tabManager->refreshDocument();  // ignore errors opening the file
   }
 }
 
-void MainWindow::copyViewportTranslation()
-{
+void MainWindow::copyViewportTranslation() {
   const auto vpt = qglview->cam.getVpt();
   const QString txt = QString("[ %1, %2, %3 ]")
-    .arg(vpt.x(), 0, 'f', 2)
-    .arg(vpt.y(), 0, 'f', 2)
-    .arg(vpt.z(), 0, 'f', 2);
+                          .arg(vpt.x(), 0, 'f', 2)
+                          .arg(vpt.y(), 0, 'f', 2)
+                          .arg(vpt.z(), 0, 'f', 2);
   QApplication::clipboard()->setText(txt);
 }
 
-void MainWindow::copyViewportRotation()
-{
+void MainWindow::copyViewportRotation() {
   const auto vpr = qglview->cam.getVpr();
   const QString txt = QString("[ %1, %2, %3 ]")
-    .arg(vpr.x(), 0, 'f', 2)
-    .arg(vpr.y(), 0, 'f', 2)
-    .arg(vpr.z(), 0, 'f', 2);
+                          .arg(vpr.x(), 0, 'f', 2)
+                          .arg(vpr.y(), 0, 'f', 2)
+                          .arg(vpr.z(), 0, 'f', 2);
   QApplication::clipboard()->setText(txt);
 }
 
-void MainWindow::copyViewportDistance()
-{
+void MainWindow::copyViewportDistance() {
   const QString txt = QString::number(qglview->cam.zoomValue(), 'f', 2);
   QApplication::clipboard()->setText(txt);
 }
 
-void MainWindow::copyViewportFov()
-{
+void MainWindow::copyViewportFov() {
   const QString txt = QString::number(qglview->cam.fovValue(), 'f', 2);
   QApplication::clipboard()->setText(txt);
 }
 
-QList<double> MainWindow::getTranslation() const
-{
+QList<double> MainWindow::getTranslation() const {
   QList<double> ret;
   ret.append(qglview->cam.object_trans.x());
   ret.append(qglview->cam.object_trans.y());
@@ -1812,8 +2037,7 @@ QList<double> MainWindow::getTranslation() const
   return ret;
 }
 
-QList<double> MainWindow::getRotation() const
-{
+QList<double> MainWindow::getRotation() const {
   QList<double> ret;
   ret.append(qglview->cam.object_rot.x());
   ret.append(qglview->cam.object_rot.y());
@@ -1821,25 +2045,25 @@ QList<double> MainWindow::getRotation() const
   return ret;
 }
 
-void MainWindow::hideFind()
-{
+void MainWindow::hideFind() {
   find_panel->hide();
   activeEditor->findState = TabManager::FIND_HIDDEN;
   editActionFindNext->setEnabled(false);
   editActionFindPrevious->setEnabled(false);
-  this->findInputField->setFindCount(activeEditor->updateFindIndicators(this->findInputField->text(), false));
+  this->findInputField->setFindCount(
+      activeEditor->updateFindIndicators(this->findInputField->text(), false));
   this->processEvents();
 }
 
 // Prepare the UI for the find (and replace if requested)
-// Among other thing it makes the text field and replacement field visible and well as it configures the
-// activeEditor to appropriate search mode.
-void MainWindow::showFind(bool doFindAndReplace)
-{
-  findInputField->setFindCount(activeEditor->updateFindIndicators(findInputField->text()));
+// Among other thing it makes the text field and replacement field visible and
+// well as it configures the activeEditor to appropriate search mode.
+void MainWindow::showFind(bool doFindAndReplace) {
+  findInputField->setFindCount(
+      activeEditor->updateFindIndicators(findInputField->text()));
   processEvents();
 
-  if (doFindAndReplace){
+  if (doFindAndReplace) {
     findTypeComboBox->setCurrentIndex(1);
     replaceInputField->show();
     replaceButton->show();
@@ -1863,42 +2087,37 @@ void MainWindow::showFind(bool doFindAndReplace)
   findInputField->selectAll();
 }
 
-void MainWindow::actionShowFind()
-{
+void MainWindow::actionShowFind() {
   showFind(false);
 }
 
-void MainWindow::findString(const QString& textToFind)
-{
-  this->findInputField->setFindCount(activeEditor->updateFindIndicators(textToFind));
+void MainWindow::findString(const QString& textToFind) {
+  this->findInputField->setFindCount(
+      activeEditor->updateFindIndicators(textToFind));
   this->processEvents();
   activeEditor->find(textToFind);
 }
 
-void MainWindow::actionShowFindAndReplace()
-{
+void MainWindow::actionShowFindAndReplace() {
   showFind(true);
 }
 
-void MainWindow::actionSelectFind(int type)
-{
+void MainWindow::actionSelectFind(int type) {
   // If type is one, then we shows the find and replace UI component
   showFind(type == 1);
 }
 
-void MainWindow::replace()
-{
+void MainWindow::replace() {
   activeEditor->replaceSelectedText(this->replaceInputField->text());
   activeEditor->find(this->findInputField->text());
 }
 
-void MainWindow::replaceAll()
-{
-  activeEditor->replaceAll(this->findInputField->text(), this->replaceInputField->text());
+void MainWindow::replaceAll() {
+  activeEditor->replaceAll(this->findInputField->text(),
+                           this->replaceInputField->text());
 }
 
-void MainWindow::convertTabsToSpaces()
-{
+void MainWindow::convertTabsToSpaces() {
   const auto text = activeEditor->toPlainText();
 
   QString converted;
@@ -1920,38 +2139,34 @@ void MainWindow::convertTabsToSpaces()
   activeEditor->setText(converted);
 }
 
-void MainWindow::findNext()
-{
+void MainWindow::findNext() {
   activeEditor->find(this->findInputField->text(), true);
 }
 
-void MainWindow::findPrev()
-{
+void MainWindow::findPrev() {
   activeEditor->find(this->findInputField->text(), true, true);
 }
 
-void MainWindow::useSelectionForFind()
-{
+void MainWindow::useSelectionForFind() {
   findInputField->setText(activeEditor->selectedText());
 }
 
-void MainWindow::updateFindBuffer(const QString& s)
-{
+void MainWindow::updateFindBuffer(const QString& s) {
   QApplication::clipboard()->setText(s, QClipboard::FindBuffer);
 }
 
-void MainWindow::findBufferChanged()
-{
+void MainWindow::findBufferChanged() {
   auto t = QApplication::clipboard()->text(QClipboard::FindBuffer);
-  // The convention seems to be to not update the search field if the findbuffer is empty
+  // The convention seems to be to not update the search field if the findbuffer
+  // is empty
   if (!t.isEmpty()) {
     findInputField->setText(t);
   }
 }
 
-bool MainWindow::event(QEvent *event) {
+bool MainWindow::event(QEvent* event) {
   if (event->type() == InputEvent::eventType) {
-    auto *inputEvent = dynamic_cast<InputEvent *>(event);
+    auto* inputEvent = dynamic_cast<InputEvent*>(event);
     if (inputEvent) {
       inputEvent->deliver(this);
     }
@@ -1961,11 +2176,10 @@ bool MainWindow::event(QEvent *event) {
   return QMainWindow::event(event);
 }
 
-bool MainWindow::eventFilter(QObject *obj, QEvent *event)
-{
+bool MainWindow::eventFilter(QObject* obj, QEvent* event) {
   if (rubberBandManager.isVisible()) {
     if (event->type() == QEvent::KeyRelease) {
-      auto keyEvent = static_cast<QKeyEvent *>(event);
+      auto keyEvent = static_cast<QKeyEvent*>(event);
       if (keyEvent->key() == Qt::Key_Control) {
         rubberBandManager.hide();
       }
@@ -1974,7 +2188,7 @@ bool MainWindow::eventFilter(QObject *obj, QEvent *event)
 
   if (obj == find_panel) {
     if (event->type() == QEvent::KeyPress) {
-      auto keyEvent = static_cast<QKeyEvent *>(event);
+      auto keyEvent = static_cast<QKeyEvent*>(event);
       if (keyEvent->key() == Qt::Key_Escape) {
         this->hideFind();
         return true;
@@ -1986,28 +2200,28 @@ bool MainWindow::eventFilter(QObject *obj, QEvent *event)
   return QMainWindow::eventFilter(obj, event);
 }
 
-void MainWindow::setRenderVariables(ContextHandle<BuiltinContext>& context)
-{
+void MainWindow::setRenderVariables(ContextHandle<BuiltinContext>& context) {
   const RenderVariables r = {
-    .preview = this->isPreview,
-    .time = this->animateWidget->getAnimTval(),
-    .camera = qglview->cam,
+      .preview = this->isPreview,
+      .time = this->animateWidget->getAnimTval(),
+      .camera = qglview->cam,
   };
   r.applyToContext(context);
 }
 
 /*!
-   Returns true if the current document is a file on disk and that file has new content.
-   Returns false if a file on disk has disappeared or if we haven't yet saved.
+   Returns true if the current document is a file on disk and that file has new
+   content. Returns false if a file on disk has disappeared or if we haven't yet
+   saved.
  */
-bool MainWindow::fileChangedOnDisk()
-{
+bool MainWindow::fileChangedOnDisk() {
   if (!activeEditor->filepath.isEmpty()) {
     struct stat st;
     memset(&st, 0, sizeof(struct stat));
     const bool valid = (stat(activeEditor->filepath.toLocal8Bit(), &st) == 0);
     // If file isn't there, just return and use current editor text
-    if (!valid) return false;
+    if (!valid)
+      return false;
 
     auto newid = str(boost::format("%x.%x") % st.st_mtime % st.st_size);
     if (newid != activeEditor->autoReloadId) {
@@ -2023,27 +2237,32 @@ bool MainWindow::fileChangedOnDisk()
  */
 
 #ifdef ENABLE_PYTHON
-bool MainWindow::trust_python_file(const std::string& file,  const std::string& content) {
+bool MainWindow::trust_python_file(const std::string& file,
+                                   const std::string& content) {
   QSettingsCached settings;
   char setting_key[256];
-  if (python_trusted) return true;
+  if (python_trusted)
+    return true;
 
   std::string act_hash, ref_hash;
-  snprintf(setting_key, sizeof(setting_key) - 1, "python_hash/%s", file.c_str());
+  snprintf(setting_key, sizeof(setting_key) - 1, "python_hash/%s",
+           file.c_str());
   act_hash = SHA256HashString(content);
 
-  if (file == this->untrusted_edit_document_name) return false;
+  if (file == this->untrusted_edit_document_name)
+    return false;
 
   if (file == this->trusted_edit_document_name) {
     settings.setValue(setting_key, act_hash.c_str());
     return true;
   }
 
-  if (content.size() <= 1) {   // 1st character already typed
+  if (content.size() <= 1) {  // 1st character already typed
     this->trusted_edit_document_name = file;
     return true;
   }
-  if (content.rfind("from openscad import", 0) == 0) {   // 1st character already typed
+  if (content.rfind("from openscad import", 0) ==
+      0) {  // 1st character already typed
     this->trusted_edit_document_name = file;
     return true;
   }
@@ -2059,9 +2278,11 @@ bool MainWindow::trust_python_file(const std::string& file,  const std::string&
     return true;
   }
 
-  auto ret = QMessageBox::warning(this, "Application",
-                                  _("Python files can potentially contain harmful stuff.\n"
-                                    "Do you trust this file ?\n"), QMessageBox::Yes | QMessageBox::YesAll | QMessageBox::No);
+  auto ret = QMessageBox::warning(
+      this, "Application",
+      _("Python files can potentially contain harmful stuff.\n"
+        "Do you trust this file ?\n"),
+      QMessageBox::Yes | QMessageBox::YesAll | QMessageBox::No);
   if (ret == QMessageBox::YesAll) {
     python_trusted = true;
     return true;
@@ -2078,33 +2299,34 @@ bool MainWindow::trust_python_file(const std::string& file,  const std::string&
   }
   return false;
 }
-#endif // ifdef ENABLE_PYTHON
-
+#endif  // ifdef ENABLE_PYTHON
 
-SourceFile *MainWindow::parseDocument(EditorInterface *editor)
-{
+SourceFile* MainWindow::parseDocument(EditorInterface* editor) {
   resetSuppressedMessages();
 
   auto document = editor->toPlainText();
-  auto fulltext = std::string(document.toUtf8().constData()) + "\n\x03\n" + commandline_commands;
+  auto fulltext = std::string(document.toUtf8().constData()) + "\n\x03\n" +
+                  commandline_commands;
   auto fnameba = editor->filepath.toLocal8Bit();
 
-  const char *fname = editor->filepath.isEmpty() ? "" : fnameba.constData();
+  const char* fname = editor->filepath.isEmpty() ? "" : fnameba.constData();
 #ifdef ENABLE_PYTHON
   this->python_active = false;
   if (fname != NULL) {
     if (boost::algorithm::ends_with(fname, ".py")) {
-      std::string content = std::string(this->lastCompiledDoc.toUtf8().constData());
-      if (
-        Feature::ExperimentalPythonEngine.is_enabled()
-        && trust_python_file(std::string(fname), content)) this->python_active = true;
-      else LOG(message_group::Warning, Location::NONE, "", "Python is not enabled");
+      std::string content =
+          std::string(this->lastCompiledDoc.toUtf8().constData());
+      if (Feature::ExperimentalPythonEngine.is_enabled() &&
+          trust_python_file(std::string(fname), content))
+        this->python_active = true;
+      else
+        LOG(message_group::Warning, Location::NONE, "",
+            "Python is not enabled");
     }
   }
 
   if (this->python_active) {
-    auto fulltext_py =
-      std::string(this->lastCompiledDoc.toUtf8().constData());
+    auto fulltext_py = std::string(this->lastCompiledDoc.toUtf8().constData());
 
     const auto& venv = venvBinDirFromSettings();
     const auto& binDir = venv.empty() ? PlatformUtils::applicationPath() : venv;
@@ -2117,17 +2339,19 @@ SourceFile *MainWindow::parseDocument(EditorInterface *editor)
       LOG("Running %1$s in venv '%2$s'.", python_version(), v);
     }
     auto error = evaluatePython(fulltext_py, false);
-    if (error.size() > 0) LOG(message_group::Error, Location::NONE, "", error.c_str());
+    if (error.size() > 0)
+      LOG(message_group::Error, Location::NONE, "", error.c_str());
     fulltext = "\n";
   }
-#endif // ifdef ENABLE_PYTHON
+#endif  // ifdef ENABLE_PYTHON
 
-  SourceFile *sourceFile;
-  sourceFile = parse(sourceFile, fulltext, fname, fname, false) ? sourceFile : nullptr;
+  SourceFile* sourceFile;
+  sourceFile =
+      parse(sourceFile, fulltext, fname, fname, false) ? sourceFile : nullptr;
 
   editor->resetHighlighting();
   if (sourceFile) {
-    //add parameters as annotation in AST
+    // add parameters as annotation in AST
     CommentParser::collectParameters(fulltext, sourceFile);
     editor->parameterWidget->setParameters(sourceFile, fulltext);
     editor->parameterWidget->applyParameters(sourceFile);
@@ -2140,8 +2364,7 @@ SourceFile *MainWindow::parseDocument(EditorInterface *editor)
   return sourceFile;
 }
 
-void MainWindow::parseTopLevelDocument()
-{
+void MainWindow::parseTopLevelDocument() {
   resetSuppressedMessages();
 
   this->lastCompiledDoc = activeEditor->toPlainText();
@@ -2151,20 +2374,17 @@ void MainWindow::parseTopLevelDocument()
   this->parsedFile = this->rootFile;
 }
 
-void MainWindow::changeParameterWidget()
-{
+void MainWindow::changeParameterWidget() {
   parameterDock->setVisible(true);
 }
 
-void MainWindow::checkAutoReload()
-{
+void MainWindow::checkAutoReload() {
   if (!activeEditor->filepath.isEmpty()) {
     actionReloadRenderPreview();
   }
 }
 
-void MainWindow::autoReloadSet(bool on)
-{
+void MainWindow::autoReloadSet(bool on) {
   QSettingsCached settings;
   settings.setValue("design/autoReload", designActionAutoReload->isChecked());
   if (on) {
@@ -2174,8 +2394,7 @@ void MainWindow::autoReloadSet(bool on)
   }
 }
 
-bool MainWindow::checkEditorModified()
-{
+bool MainWindow::checkEditorModified() {
   if (activeEditor->isContentModified()) {
     auto ret = QMessageBox::warning(this, _("Application"),
                                     _("The document has been modified.\n"
@@ -2188,9 +2407,9 @@ bool MainWindow::checkEditorModified()
   return true;
 }
 
-void MainWindow::actionReloadRenderPreview()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::actionReloadRenderPreview() {
+  if (GuiLocker::isLocked())
+    return;
   GuiLocker::lock();
   autoReloadTimer->stop();
   setCurrentOutput();
@@ -2201,9 +2420,9 @@ void MainWindow::actionReloadRenderPreview()
   compile(true);
 }
 
-void MainWindow::csgReloadRender()
-{
-  if (this->rootNode) compileCSG();
+void MainWindow::csgReloadRender() {
+  if (this->rootNode)
+    compileCSG();
 
   // Go to non-CGAL view mode
   if (viewActionThrownTogether->isChecked()) {
@@ -2218,8 +2437,9 @@ void MainWindow::csgReloadRender()
   compileEnded();
 }
 
-void MainWindow::prepareCompile(const char *afterCompileSlot, bool procevents, bool preview)
-{
+void MainWindow::prepareCompile(const char* afterCompileSlot,
+                                bool procevents,
+                                bool preview) {
   autoReloadTimer->stop();
   setCurrentOutput();
   LOG(" ");
@@ -2230,12 +2450,12 @@ void MainWindow::prepareCompile(const char *afterCompileSlot, bool procevents, b
   this->isPreview = preview;
 }
 
-void MainWindow::actionRenderPreview()
-{
+void MainWindow::actionRenderPreview() {
   static bool preview_requested;
   preview_requested = true;
 
-  if (GuiLocker::isLocked()) return;
+  if (GuiLocker::isLocked())
+    return;
 
   GuiLocker::lock();
   preview_requested = false;
@@ -2247,17 +2467,17 @@ void MainWindow::actionRenderPreview()
   compile(false, false);
 
   if (preview_requested) {
-    // if the action was called when the gui was locked, we must request it one more time
-    // however, it's not possible to call it directly NOR make the loop
-    // it must be called from the mainloop
+    // if the action was called when the gui was locked, we must request it one
+    // more time however, it's not possible to call it directly NOR make the
+    // loop it must be called from the mainloop
     QTimer::singleShot(0, this, &MainWindow::actionRenderPreview);
     return;
   }
 }
 
-void MainWindow::csgRender()
-{
-  if (this->rootNode) compileCSG();
+void MainWindow::csgRender() {
+  if (this->rootNode)
+    compileCSG();
 
   // Go to non-CGAL view mode
   if (viewActionThrownTogether->isChecked()) {
@@ -2270,36 +2490,43 @@ void MainWindow::csgRender()
 #endif
   }
 
-  if (animateWidget->dumpPictures() ) {
+  if (animateWidget->dumpPictures()) {
     const int steps = animateWidget->nextFrame();
     const QImage img = this->qglview->grabFrame();
-    const QString filename = QString("frame%1.png").arg(steps, 5, 10, QChar('0'));
+    const QString filename =
+        QString("frame%1.png").arg(steps, 5, 10, QChar('0'));
     img.save(filename, "PNG");
   }
 
   compileEnded();
 }
 
-void MainWindow::sendToExternalTool(ExternalToolInterface& externalToolService)
-{
+void MainWindow::sendToExternalTool(
+    ExternalToolInterface& externalToolService) {
   const QFileInfo activeFile(activeEditor->filepath);
   QString activeFileName = activeFile.fileName();
-  if (activeFileName.isEmpty()) activeFileName = "Untitled.scad";
+  if (activeFileName.isEmpty())
+    activeFileName = "Untitled.scad";
   // TODO: Replace suffix to match exported file format?
 
-  activeFileName = activeFileName + QString::fromStdString("." + fileformat::toSuffix(externalToolService.fileFormat()));
+  activeFileName =
+      activeFileName +
+      QString::fromStdString(
+          "." + fileformat::toSuffix(externalToolService.fileFormat()));
 
-  const bool export_status = externalToolService.exportTemporaryFile(rootGeom, activeFileName, &qglview->cam);
+  const bool export_status = externalToolService.exportTemporaryFile(
+      rootGeom, activeFileName, &qglview->cam);
   if (!export_status) {
     return;
   }
 
   this->progresswidget = new ProgressWidget(this);
-  connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+  connect(this->progresswidget, &ProgressWidget::requestShow, this,
+          &MainWindow::showProgress);
 
-  const bool process_status = externalToolService.process(activeFileName.toStdString(), [this](double permille) {
-    return network_progress_func(permille);
-  });
+  const bool process_status = externalToolService.process(
+      activeFileName.toStdString(),
+      [this](double permille) { return network_progress_func(permille); });
   updateStatusBar(nullptr);
   if (!process_status) {
     return;
@@ -2311,16 +2538,17 @@ void MainWindow::sendToExternalTool(ExternalToolInterface& externalToolService)
   }
 }
 
-void MainWindow::action3DPrint()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::action3DPrint() {
+  if (GuiLocker::isLocked())
+    return;
   const GuiLocker lock;
 
   setCurrentOutput();
 
-  //Make sure we can export:
+  // Make sure we can export:
   const unsigned int dim = 3;
-  if (!canExport(dim)) return;
+  if (!canExport(dim))
+    return;
 
   PrintInitDialog printInitDialog;
   const auto status = printInitDialog.exec();
@@ -2333,26 +2561,28 @@ void MainWindow::action3DPrint()
     LOG("Selected File format: %1$s", fileformat::info(fileFormat).description);
 
     GlobalPreferences::inst()->updateGUI();
-    const auto externalToolService = createExternalToolService(serviceType, serviceName, fileFormat);
+    const auto externalToolService =
+        createExternalToolService(serviceType, serviceName, fileFormat);
     if (!externalToolService) {
-      LOG("Error: Unable to create service: %1$d %2$s %3$d", static_cast<int>(serviceType), serviceName.toStdString(), static_cast<int>(fileFormat));
+      LOG("Error: Unable to create service: %1$d %2$s %3$d",
+          static_cast<int>(serviceType), serviceName.toStdString(),
+          static_cast<int>(fileFormat));
       return;
     }
     sendToExternalTool(*externalToolService);
   }
 }
 
-void MainWindow::actionRender()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::actionRender() {
+  if (GuiLocker::isLocked())
+    return;
   GuiLocker::lock();
 
   prepareCompile("cgalRender", true, false);
   compile(false);
 }
 
-void MainWindow::cgalRender()
-{
+void MainWindow::cgalRender() {
   if (!this->rootFile || !this->rootNode) {
     compileEnded();
     return;
@@ -2366,16 +2596,19 @@ void MainWindow::cgalRender()
       renderBackend3DToString(RenderSettings::inst()->backend3D).c_str());
 
   this->progresswidget = new ProgressWidget(this);
-  connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+  connect(this->progresswidget, &ProgressWidget::requestShow, this,
+          &MainWindow::showProgress);
 
-  if (!isClosing) progress_report_prep(this->rootNode, report_func, this);
-  else return;
+  if (!isClosing)
+    progress_report_prep(this->rootNode, report_func, this);
+  else
+    return;
 
   this->cgalworker->start(this->tree);
 }
 
-void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_geom)
-{
+void MainWindow::actionRenderDone(
+    const std::shared_ptr<const Geometry>& root_geom) {
 #ifdef ENABLE_PYTHON
   python_lock();
 #endif
@@ -2395,8 +2628,8 @@ void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_ge
     LOG("Rendering finished.");
 
     this->rootGeom = root_geom;
-    // Choose PolySetRenderer for PolySet and Polygon2d, and for Manifold since we
-    // know that all geometries are convertible to PolySet.
+    // Choose PolySetRenderer for PolySet and Polygon2d, and for Manifold since
+    // we know that all geometries are convertible to PolySet.
     if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend ||
         std::dynamic_pointer_cast<const PolySet>(this->rootGeom) ||
         std::dynamic_pointer_cast<const Polygon2d>(this->rootGeom)) {
@@ -2417,9 +2650,16 @@ void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_ge
 
   updateStatusBar(nullptr);
 
-  const bool renderSoundEnabled = GlobalPreferences::inst()->getValue("advanced/enableSoundNotification").toBool();
-  const uint soundThreshold = GlobalPreferences::inst()->getValue("advanced/timeThresholdOnRenderCompleteSound").toUInt();
-  if (renderSoundEnabled && soundThreshold <= renderStatistic.ms().count() / 1000) {
+  const bool renderSoundEnabled =
+      GlobalPreferences::inst()
+          ->getValue("advanced/enableSoundNotification")
+          .toBool();
+  const uint soundThreshold =
+      GlobalPreferences::inst()
+          ->getValue("advanced/timeThresholdOnRenderCompleteSound")
+          .toUInt();
+  if (renderSoundEnabled &&
+      soundThreshold <= renderStatistic.ms().count() / 1000) {
     renderCompleteSoundEffect->play();
   }
 
@@ -2428,18 +2668,15 @@ void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_ge
   compileEnded();
 }
 
-void MainWindow::actionMeasureDistance()
-{
+void MainWindow::actionMeasureDistance() {
   meas.startMeasureDist();
 }
 
-void MainWindow::actionMeasureAngle()
-{
+void MainWindow::actionMeasureAngle() {
   meas.startMeasureAngle();
 }
 
-void MainWindow::leftClick(QPoint mouse)
-{
+void MainWindow::leftClick(QPoint mouse) {
   const QString str = meas.statemachine(mouse);
   if (str.size() > 0) {
     this->qglview->measure_state = MEASURE_IDLE;
@@ -2453,10 +2690,10 @@ void MainWindow::leftClick(QPoint mouse)
 /**
  * Call the mouseselection to determine the id of the clicked-on object.
  * Use the generated ID and try to find it within the list of products
- * And finally move the cursor to the beginning of the selected object in the editor
+ * And finally move the cursor to the beginning of the selected object in the
+ * editor
  */
-void MainWindow::rightClick(QPoint position)
-{
+void MainWindow::rightClick(QPoint position) {
   // selecting without a renderer?!
   if (!this->qglview->renderer) {
     return;
@@ -2469,7 +2706,8 @@ void MainWindow::rightClick(QPoint position)
   // Select the object at mouse coordinates
   const int index = this->qglview->pickObject(position);
   std::deque<std::shared_ptr<const AbstractNode>> path;
-  const std::shared_ptr<const AbstractNode> result = this->rootNode->getNodeByID(index, path);
+  const std::shared_ptr<const AbstractNode> result =
+      this->rootNode->getNodeByID(index, path);
 
   if (result) {
     // Create context menu with the backtrace
@@ -2483,13 +2721,17 @@ void MainWindow::rightClick(QPoint position)
       auto location = step->modinst->location();
       ss.str("");
 
-      // Remove the "module" prefix if any as it induce confusion between the module declaration and instanciation
-      const int first_position = (step->verbose_name().find("module") == std::string::npos)? 0 : 7;
+      // Remove the "module" prefix if any as it induce confusion between the
+      // module declaration and instanciation
+      const int first_position =
+          (step->verbose_name().find("module") == std::string::npos) ? 0 : 7;
       std::string name = step->verbose_name().substr(first_position);
 
-      // It happens that the verbose_name is empty (eg: in for loops), when this happens instead of letting
-      // empty entry in the menu we prefer using the name in the modinstanciation.
-      if (step->verbose_name().empty()) name = step->modinst->name();
+      // It happens that the verbose_name is empty (eg: in for loops), when this
+      // happens instead of letting empty entry in the menu we prefer using the
+      // name in the modinstanciation.
+      if (step->verbose_name().empty())
+        name = step->modinst->name();
 
       // Check if the path is contained in a library (using parsersettings.h)
       const fs::path libpath = get_library_for_path(location.filePath());
@@ -2498,31 +2740,39 @@ void MainWindow::rightClick(QPoint position)
         ss << name << " (library "
            << location.fileName().substr(libpath.string().length() + 1) << ":"
            << location.firstLine() << ")";
-      } else if (renderedEditor->filepath.toStdString() == location.fileName()) {
-        // removes the "module" prefix if any as it makes it not clear if it is module declaration or call.
+      } else if (renderedEditor->filepath.toStdString() ==
+                 location.fileName()) {
+        // removes the "module" prefix if any as it makes it not clear if it is
+        // module declaration or call.
         ss << name << " (" << location.filePath().filename().string() << ":"
            << location.firstLine() << ")";
       } else {
-        auto relative_filename = fs_uncomplete(location.filePath(), fs::path(renderedEditor->filepath.toStdString()).parent_path())
-          .generic_string();
+        auto relative_filename =
+            fs_uncomplete(
+                location.filePath(),
+                fs::path(renderedEditor->filepath.toStdString()).parent_path())
+                .generic_string();
 
         // Set the displayed name relative to the active editor window
-        ss << name << " (" << relative_filename << ":" << location.firstLine() << ")";
+        ss << name << " (" << relative_filename << ":" << location.firstLine()
+           << ")";
       }
       // Prepare the action to be sent
       auto action = tracemenu.addAction(QString::fromStdString(ss.str()));
       if (editorDock->isVisible()) {
         action->setProperty("id", step->idx);
-        connect(action, &QAction::hovered, this, &MainWindow::onHoveredObjectInSelectionMenu);
+        connect(action, &QAction::hovered, this,
+                &MainWindow::onHoveredObjectInSelectionMenu);
       }
     }
 
-    // Before starting we need to lock the GUI to avoid interferance with reload/update
-    // triggered by other part of the application (eg: changing the renderedEditor)
+    // Before starting we need to lock the GUI to avoid interferance with
+    // reload/update triggered by other part of the application (eg: changing
+    // the renderedEditor)
     GuiLocker::lock();
 
     // Execute this lambda function when the selection menu is closing.
-    connect(&tracemenu, &QMenu::aboutToHide, [this](){
+    connect(&tracemenu, &QMenu::aboutToHide, [this]() {
       // remove the visual hints in the editor
       renderedEditor->clearAllSelectionIndicators();
       // unlock the GUI so the other part of the interface can now be updated.
@@ -2535,18 +2785,18 @@ void MainWindow::rightClick(QPoint position)
   }
 }
 
-void MainWindow::measureFinished()
-{
+void MainWindow::measureFinished() {
   meas.stopMeasure();
 }
 
-void MainWindow::clearAllSelectionIndicators()
-{
+void MainWindow::clearAllSelectionIndicators() {
   this->activeEditor->clearAllSelectionIndicators();
 }
 
-void MainWindow::setSelectionIndicatorStatus(EditorInterface *editor, int nodeIndex, EditorSelectionIndicatorStatus status)
-{
+void MainWindow::setSelectionIndicatorStatus(
+    EditorInterface* editor,
+    int nodeIndex,
+    EditorSelectionIndicatorStatus status) {
   std::deque<std::shared_ptr<const AbstractNode>> stack;
   this->rootNode->getNodeByID(nodeIndex, stack);
 
@@ -2564,10 +2814,11 @@ void MainWindow::setSelectionIndicatorStatus(EditorInterface *editor, int nodeIn
       continue;
     }
 
-    if (node->verbose_name().rfind("module", 0) == 0 || node->modinst->name() == "children") {
+    if (node->verbose_name().rfind("module", 0) == 0 ||
+        node->modinst->name() == "children") {
       editor->setSelectionIndicatorStatus(
-        status, level,
-        location.firstLine() - 1, location.firstColumn() - 1, location.lastLine() - 1, location.lastColumn() - 1);
+          status, level, location.firstLine() - 1, location.firstColumn() - 1,
+          location.lastLine() - 1, location.lastColumn() - 1);
       level++;
     }
   }
@@ -2582,18 +2833,21 @@ void MainWindow::setSelectionIndicatorStatus(EditorInterface *editor, int nodeIn
   // Update the location returned by location to cover the whole section.
   node->getCodeLocation(0, 0, &line, &column, &lastLine, &lastColumn, 0);
 
-  editor->setSelectionIndicatorStatus(status, 0, line - 1, column - 1, lastLine - 1, lastColumn - 1);
+  editor->setSelectionIndicatorStatus(status, 0, line - 1, column - 1,
+                                      lastLine - 1, lastColumn - 1);
 }
 
-void MainWindow::setSelection(int index)
-{
+void MainWindow::setSelection(int index) {
   assert(renderedEditor != nullptr);
-  if (currentlySelectedObject == index) return;
+  if (currentlySelectedObject == index)
+    return;
 
   std::deque<std::shared_ptr<const AbstractNode>> path;
-  const std::shared_ptr<const AbstractNode> selected_node = rootNode->getNodeByID(index, path);
+  const std::shared_ptr<const AbstractNode> selected_node =
+      rootNode->getNodeByID(index, path);
 
-  if (!selected_node) return;
+  if (!selected_node)
+    return;
 
   currentlySelectedObject = index;
 
@@ -2602,8 +2856,8 @@ void MainWindow::setSelection(int index)
   auto line = location.firstLine();
   auto column = location.firstColumn();
 
-  // Unsaved files do have the pwd as current path, therefore we will not open a new
-  // tab on click
+  // Unsaved files do have the pwd as current path, therefore we will not open a
+  // new tab on click
   if (!fs::is_directory(fs::path(file))) {
     tabManager->open(QString::fromStdString(file));
   }
@@ -2615,16 +2869,20 @@ void MainWindow::setSelection(int index)
   std::vector<std::shared_ptr<const AbstractNode>> nodesSameModule{};
   rootNode->findNodesWithSameMod(selected_node, nodesSameModule);
 
-  // highlight in the text editor all the text fragment of the hierarchy of object with same mode.
+  // highlight in the text editor all the text fragment of the hierarchy of
+  // object with same mode.
   for (const auto& element : nodesSameModule) {
     if (element->index() != currentlySelectedObject) {
-      setSelectionIndicatorStatus(renderedEditor, element->index(), EditorSelectionIndicatorStatus::IMPACTED);
+      setSelectionIndicatorStatus(renderedEditor, element->index(),
+                                  EditorSelectionIndicatorStatus::IMPACTED);
     }
   }
 
-  // highlight in the text editor only the fragment correponding to the selected stack.
-  // this step must be done after all the impacted element have been marked.
-  setSelectionIndicatorStatus(renderedEditor, currentlySelectedObject, EditorSelectionIndicatorStatus::SELECTED);
+  // highlight in the text editor only the fragment correponding to the selected
+  // stack. this step must be done after all the impacted element have been
+  // marked.
+  setSelectionIndicatorStatus(renderedEditor, currentlySelectedObject,
+                              EditorSelectionIndicatorStatus::SELECTED);
 
   renderedEditor->setCursorPosition(line - 1, column - 1);
 }
@@ -2632,10 +2890,9 @@ void MainWindow::setSelection(int index)
 /**
  * Expects the sender to have properties "id" defined
  */
-void MainWindow::onHoveredObjectInSelectionMenu()
-{
+void MainWindow::onHoveredObjectInSelectionMenu() {
   assert(renderedEditor != nullptr);
-  auto *action = qobject_cast<QAction *>(sender());
+  auto* action = qobject_cast<QAction*>(sender());
   if (!action || !action->property("id").isValid()) {
     return;
   }
@@ -2643,7 +2900,7 @@ void MainWindow::onHoveredObjectInSelectionMenu()
   setSelection(action->property("id").toInt());
 }
 
-void MainWindow::setLastFocus(QWidget *widget) {
+void MainWindow::setLastFocus(QWidget* widget) {
   this->lastFocus = widget;
 }
 
@@ -2657,8 +2914,7 @@ void MainWindow::setLastFocus(QWidget *widget) {
  * @param progressWidget a pointer to the progress widget to show or nullptr in
  * case the display should switch back to the version label.
  */
-void MainWindow::updateStatusBar(ProgressWidget *progressWidget)
-{
+void MainWindow::updateStatusBar(ProgressWidget* progressWidget) {
   auto sb = this->statusBar();
   if (progressWidget == nullptr) {
     if (this->progresswidget != nullptr) {
@@ -2667,7 +2923,8 @@ void MainWindow::updateStatusBar(ProgressWidget *progressWidget)
       this->progresswidget = nullptr;
     }
     if (versionLabel == nullptr) {
-      versionLabel = new QLabel("OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
+      versionLabel = new QLabel(
+          "OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
       sb->addPermanentWidget(this->versionLabel);
     }
   } else {
@@ -2680,15 +2937,16 @@ void MainWindow::updateStatusBar(ProgressWidget *progressWidget)
   }
 }
 
-void MainWindow::exceptionCleanup(){
+void MainWindow::exceptionCleanup() {
   LOG("Execution aborted");
   LOG(" ");
   GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+  if (designActionAutoReload->isChecked())
+    autoReloadTimer->start();
 }
 
-void MainWindow::UnknownExceptionCleanup(std::string msg){
-  setCurrentOutput();   // we need to show this error
+void MainWindow::UnknownExceptionCleanup(std::string msg) {
+  setCurrentOutput();  // we need to show this error
   if (msg.size() == 0) {
     LOG(message_group::Error, "Compilation aborted by unknown exception");
   } else {
@@ -2696,56 +2954,61 @@ void MainWindow::UnknownExceptionCleanup(std::string msg){
   }
   LOG(" ");
   GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+  if (designActionAutoReload->isChecked())
+    autoReloadTimer->start();
 }
 
-void MainWindow::showTextInWindow(const QString& type, const QString& content)
-{
+void MainWindow::showTextInWindow(const QString& type, const QString& content) {
   auto e = new QTextEdit(this);
   e->setAttribute(Qt::WA_DeleteOnClose);
   e->setWindowFlags(Qt::Window);
   e->setTabStopDistance(tabStopWidth);
   e->setWindowTitle(type + " Dump");
-  if (content.isEmpty())e->setPlainText("No " + type + " to dump. Please try compiling first...");
-  else e->setPlainText(content);
+  if (content.isEmpty())
+    e->setPlainText("No " + type + " to dump. Please try compiling first...");
+  else
+    e->setPlainText(content);
 
   e->setReadOnly(true);
   e->resize(600, 400);
   e->show();
 }
 
-void MainWindow::actionDisplayAST()
-{
+void MainWindow::actionDisplayAST() {
   setCurrentOutput();
-  QString text = (rootFile)? QString::fromStdString(rootFile->dump("")) : "";
+  QString text = (rootFile) ? QString::fromStdString(rootFile->dump("")) : "";
   showTextInWindow("AST", text);
   clearCurrentOutput();
 }
 
-void MainWindow::actionDisplayCSGTree()
-{
+void MainWindow::actionDisplayCSGTree() {
   setCurrentOutput();
-  QString text = (rootNode)? QString::fromStdString(tree.getString(*rootNode, "  ")) : "";
+  QString text =
+      (rootNode) ? QString::fromStdString(tree.getString(*rootNode, "  ")) : "";
   showTextInWindow("CSG", text);
   clearCurrentOutput();
 }
 
-void MainWindow::actionDisplayCSGProducts()
-{
+void MainWindow::actionDisplayCSGProducts() {
   setCurrentOutput();
   // a small lambda to avoid code duplication
-  auto constexpr dump = [](auto node){
-      return QString::fromStdString(node? node->dump() : "N/A");
-    };
-  auto text = QString("\nCSG before normalization:\n%1\n\n\nCSG after normalization:\n%2\n\n\nCSG rendering chain:\n%3\n\n\nHighlights CSG rendering chain:\n%4\n\n\nBackground CSG rendering chain:\n%5\n")
-    .arg(dump(csgRoot), dump(normalizedRoot), dump(rootProduct), dump(highlightsProducts), dump(backgroundProducts));
+  auto constexpr dump = [](auto node) {
+    return QString::fromStdString(node ? node->dump() : "N/A");
+  };
+  auto text =
+      QString(
+          "\nCSG before normalization:\n%1\n\n\nCSG after "
+          "normalization:\n%2\n\n\nCSG rendering chain:\n%3\n\n\nHighlights "
+          "CSG rendering chain:\n%4\n\n\nBackground CSG rendering chain:\n%5\n")
+          .arg(dump(csgRoot), dump(normalizedRoot), dump(rootProduct),
+               dump(highlightsProducts), dump(backgroundProducts));
   showTextInWindow("CSG Products Dump", text);
   clearCurrentOutput();
 }
 
-void MainWindow::actionCheckValidity()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::actionCheckValidity() {
+  if (GuiLocker::isLocked())
+    return;
   const GuiLocker lock;
   setCurrentOutput();
 
@@ -2764,11 +3027,13 @@ void MainWindow::actionCheckValidity()
   bool valid = true;
 #ifdef ENABLE_CGAL
   if (auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(rootGeom)) {
-    valid = N->p3 ? const_cast<CGAL_Nef_polyhedron3&>(*N->p3).is_valid() : false;
+    valid =
+        N->p3 ? const_cast<CGAL_Nef_polyhedron3&>(*N->p3).is_valid() : false;
   } else
 #endif
 #ifdef ENABLE_MANIFOLD
-  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(rootGeom)) {
+      if (auto mani =
+              std::dynamic_pointer_cast<const ManifoldGeometry>(rootGeom)) {
     valid = mani->isValid();
   }
 #endif
@@ -2776,22 +3041,23 @@ void MainWindow::actionCheckValidity()
   clearCurrentOutput();
 }
 
-//Returns if we can export (true) or not(false) (bool)
-//Separated into it's own function for re-use.
-bool MainWindow::canExport(unsigned int dim)
-{
+// Returns if we can export (true) or not(false) (bool)
+// Separated into it's own function for re-use.
+bool MainWindow::canExport(unsigned int dim) {
   if (!rootGeom) {
-    LOG(message_group::Error, "Nothing to export! Try rendering first (press F6)");
+    LOG(message_group::Error,
+        "Nothing to export! Try rendering first (press F6)");
     clearCurrentOutput();
     return false;
   }
 
   // editor has changed since last render
   if (!activeEditor->contentsRendered) {
-    auto ret = QMessageBox::warning(this, "Application",
-                                    "The current tab has been modified since its last render (F6).\n"
-                                    "Do you really want to export the previous content?",
-                                    QMessageBox::Yes | QMessageBox::No);
+    auto ret = QMessageBox::warning(
+        this, "Application",
+        "The current tab has been modified since its last render (F6).\n"
+        "Do you really want to export the previous content?",
+        QMessageBox::Yes | QMessageBox::No);
     if (ret != QMessageBox::Yes) {
       return false;
     }
@@ -2799,17 +3065,19 @@ bool MainWindow::canExport(unsigned int dim)
 
   // other tab contents most recently rendered
   if (renderedEditor != activeEditor) {
-    auto ret = QMessageBox::warning(this, "Application",
-                                    "The rendered data is of different tab.\n"
-                                    "Do you really want to export the another tab's content?",
-                                    QMessageBox::Yes | QMessageBox::No);
+    auto ret = QMessageBox::warning(
+        this, "Application",
+        "The rendered data is of different tab.\n"
+        "Do you really want to export the another tab's content?",
+        QMessageBox::Yes | QMessageBox::No);
     if (ret != QMessageBox::Yes) {
       return false;
     }
   }
 
   if (rootGeom->getDimension() != dim) {
-    LOG(message_group::UI_Error, "Current top level object is not a %1$dD object.", dim);
+    LOG(message_group::UI_Error,
+        "Current top level object is not a %1$dD object.", dim);
     clearCurrentOutput();
     return false;
   }
@@ -2821,16 +3089,22 @@ bool MainWindow::canExport(unsigned int dim)
   }
 
 #ifdef ENABLE_CGAL
-  auto N = dynamic_cast<const CGALNefGeometry *>(rootGeom.get());
+  auto N = dynamic_cast<const CGALNefGeometry*>(rootGeom.get());
   if (N && !N->p3->is_simple()) {
-    LOG(message_group::UI_Warning, "Object may not be a valid 2-manifold and may need repair! See https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/STL_Import_and_Export");
+    LOG(message_group::UI_Warning,
+        "Object may not be a valid 2-manifold and may need repair! See "
+        "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/"
+        "STL_Import_and_Export");
   }
 #endif
 #ifdef ENABLE_MANIFOLD
-  auto manifold = dynamic_cast<const ManifoldGeometry *>(rootGeom.get());
-  if (manifold && !manifold->isValid() ) {
-    LOG(message_group::UI_Warning, "Object may not be a valid manifold and may need repair! "
-        "Error message: %1$s. See https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/STL_Import_and_Export",
+  auto manifold = dynamic_cast<const ManifoldGeometry*>(rootGeom.get());
+  if (manifold && !manifold->isValid()) {
+    LOG(message_group::UI_Warning,
+        "Object may not be a valid manifold and may need repair! "
+        "Error message: %1$s. See "
+        "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/"
+        "STL_Import_and_Export",
         ManifoldUtils::statusToString(manifold->getManifold().Status()));
   }
 #endif
@@ -2838,123 +3112,128 @@ bool MainWindow::canExport(unsigned int dim)
   return true;
 }
 
-void MainWindow::actionExport(unsigned int dim, ExportInfo& exportInfo)
-{
+void MainWindow::actionExport(unsigned int dim, ExportInfo& exportInfo) {
   const auto type_name = QString::fromStdString(exportInfo.info.description);
   const auto suffix = QString::fromStdString(exportInfo.info.suffix);
 
-  //Setting filename skips the file selection dialog and uses the path provided instead.
-  if (GuiLocker::isLocked()) return;
+  // Setting filename skips the file selection dialog and uses the path provided
+  // instead.
+  if (GuiLocker::isLocked())
+    return;
   const GuiLocker lock;
 
   setCurrentOutput();
 
-  //Return if something is wrong and we can't export.
-  if (!canExport(dim)) return;
+  // Return if something is wrong and we can't export.
+  if (!canExport(dim))
+    return;
 
   auto title = QString(_("Export %1 File")).arg(type_name);
   auto filter = QString(_("%1 Files (*%2)")).arg(type_name, suffix);
-  auto exportFilename = QFileDialog::getSaveFileName(this, title, exportPath(suffix), filter);
+  auto exportFilename =
+      QFileDialog::getSaveFileName(this, title, exportPath(suffix), filter);
   if (exportFilename.isEmpty()) {
     clearCurrentOutput();
     return;
   }
   this->exportPaths[suffix] = exportFilename;
 
-  const bool exportResult = exportFileByName(rootGeom, exportFilename.toStdString(), exportInfo);
+  const bool exportResult =
+      exportFileByName(rootGeom, exportFilename.toStdString(), exportInfo);
 
-  if (exportResult) fileExportedMessage(type_name, exportFilename);
+  if (exportResult)
+    fileExportedMessage(type_name, exportFilename);
   clearCurrentOutput();
 }
 
-void MainWindow::actionExportFileFormat(int fmt)
-{
+void MainWindow::actionExportFileFormat(int fmt) {
   const auto format = static_cast<FileFormat>(fmt);
   const FileFormatInfo& info = fileformat::info(format);
 
-  ExportInfo exportInfo = createExportInfo(format, info, activeEditor->filepath.toStdString(), &qglview->cam, {});
+  ExportInfo exportInfo = createExportInfo(
+      format, info, activeEditor->filepath.toStdString(), &qglview->cam, {});
 
   switch (format) {
-  case FileFormat::PDF:
-  {
-    ExportPdfDialog exportPdfDialog;
-    if (exportPdfDialog.exec() == QDialog::Rejected) {
-      return;
-    }
-
-    exportInfo.optionsPdf = exportPdfDialog.getOptions();
-    actionExport(2, exportInfo);
-  }
-  break;
-  case FileFormat::_3MF:
-  {
-    Export3mfDialog export3mfDialog;
-    if (export3mfDialog.exec() == QDialog::Rejected) {
-      return;
-    }
+    case FileFormat::PDF: {
+      ExportPdfDialog exportPdfDialog;
+      if (exportPdfDialog.exec() == QDialog::Rejected) {
+        return;
+      }
 
-    exportInfo.options3mf = export3mfDialog.getOptions();
-    actionExport(3, exportInfo);
-  }
-  break;
-  case FileFormat::CSG:
-  {
-    setCurrentOutput();
+      exportInfo.optionsPdf = exportPdfDialog.getOptions();
+      actionExport(2, exportInfo);
+    } break;
+    case FileFormat::_3MF: {
+      Export3mfDialog export3mfDialog;
+      if (export3mfDialog.exec() == QDialog::Rejected) {
+        return;
+      }
 
-    if (!this->rootNode) {
-      LOG(message_group::Error, "Nothing to export. Please try compiling first.");
-      clearCurrentOutput();
-      return;
-    }
-    const QString suffix = "csg";
-    auto csg_filename = QFileDialog::getSaveFileName(this,
-                                                     _("Export CSG File"), exportPath(suffix), _("CSG Files (*.csg)"));
+      exportInfo.options3mf = export3mfDialog.getOptions();
+      actionExport(3, exportInfo);
+    } break;
+    case FileFormat::CSG: {
+      setCurrentOutput();
 
-    if (csg_filename.isEmpty()) {
-      clearCurrentOutput();
-      return;
-    }
-
-    std::ofstream fstream(csg_filename.toLocal8Bit());
-    if (!fstream.is_open()) {
-      LOG("Can't open file \"%1$s\" for export", csg_filename.toLocal8Bit().constData());
-    } else {
-      fstream << this->tree.getString(*this->rootNode, "\t") << "\n";
-      fstream.close();
-      fileExportedMessage("CSG", csg_filename);
-      this->exportPaths[suffix] = csg_filename;
-    }
+      if (!this->rootNode) {
+        LOG(message_group::Error,
+            "Nothing to export. Please try compiling first.");
+        clearCurrentOutput();
+        return;
+      }
+      const QString suffix = "csg";
+      auto csg_filename = QFileDialog::getSaveFileName(
+          this, _("Export CSG File"), exportPath(suffix),
+          _("CSG Files (*.csg)"));
 
-    clearCurrentOutput();
-  }      break;
-  case FileFormat::PNG:
-  {
-    // Grab first to make sure dialog box isn't part of the grabbed image
-    qglview->grabFrame();
-    const QString suffix = "png";
-    auto img_filename = QFileDialog::getSaveFileName(this,
-                                                     _("Export Image"), exportPath(suffix), _("PNG Files (*.png)"));
-    if (!img_filename.isEmpty()) {
-      const bool saveResult = qglview->save(img_filename.toLocal8Bit().constData());
-      if (saveResult) {
-        this->exportPaths[suffix] = img_filename;
-        setCurrentOutput();
-        fileExportedMessage("PNG", img_filename);
+      if (csg_filename.isEmpty()) {
         clearCurrentOutput();
+        return;
+      }
+
+      std::ofstream fstream(csg_filename.toLocal8Bit());
+      if (!fstream.is_open()) {
+        LOG("Can't open file \"%1$s\" for export",
+            csg_filename.toLocal8Bit().constData());
       } else {
-        LOG("Can't open file \"%1$s\" for export image", img_filename.toLocal8Bit().constData());
+        fstream << this->tree.getString(*this->rootNode, "\t") << "\n";
+        fstream.close();
+        fileExportedMessage("CSG", csg_filename);
+        this->exportPaths[suffix] = csg_filename;
       }
-    }
-  }
-  break;
-  default:
-    actionExport(fileformat::is3D(format) ? 3 : fileformat::is2D(format) ? 2 : 0, exportInfo);
+
+      clearCurrentOutput();
+    } break;
+    case FileFormat::PNG: {
+      // Grab first to make sure dialog box isn't part of the grabbed image
+      qglview->grabFrame();
+      const QString suffix = "png";
+      auto img_filename = QFileDialog::getSaveFileName(
+          this, _("Export Image"), exportPath(suffix), _("PNG Files (*.png)"));
+      if (!img_filename.isEmpty()) {
+        const bool saveResult =
+            qglview->save(img_filename.toLocal8Bit().constData());
+        if (saveResult) {
+          this->exportPaths[suffix] = img_filename;
+          setCurrentOutput();
+          fileExportedMessage("PNG", img_filename);
+          clearCurrentOutput();
+        } else {
+          LOG("Can't open file \"%1$s\" for export image",
+              img_filename.toLocal8Bit().constData());
+        }
+      }
+    } break;
+    default:
+      actionExport(fileformat::is3D(format)   ? 3
+                   : fileformat::is2D(format) ? 2
+                                              : 0,
+                   exportInfo);
   }
 }
 
-void MainWindow::copyText()
-{
-  auto *c = dynamic_cast<Console *>(lastFocus);
+void MainWindow::copyText() {
+  auto* c = dynamic_cast<Console*>(lastFocus);
   if (c) {
     c->copy();
   } else {
@@ -2962,15 +3241,13 @@ void MainWindow::copyText()
   }
 }
 
-void MainWindow::actionCopyViewport()
-{
+void MainWindow::actionCopyViewport() {
   const auto& image = qglview->grabFrame();
   auto clipboard = QApplication::clipboard();
   clipboard->setImage(image);
 }
 
-void MainWindow::actionFlushCaches()
-{
+void MainWindow::actionFlushCaches() {
   GeometryCache::instance()->clear();
   CGALCache::instance()->clear();
   dxf_dim_cache.clear();
@@ -2981,16 +3258,14 @@ void MainWindow::actionFlushCaches()
   LOG("Caches Flushed");
 }
 
-void MainWindow::viewModeActionsUncheck()
-{
+void MainWindow::viewModeActionsUncheck() {
   viewActionPreview->setChecked(false);
   viewActionThrownTogether->setChecked(false);
 }
 
 #ifdef ENABLE_OPENCSG
 
-void MainWindow::viewModeRender()
-{
+void MainWindow::viewModeRender() {
   viewActionThrownTogether->setEnabled(false);
   viewActionPreview->setEnabled(false);
   this->qglview->setRenderer(this->geomRenderer);
@@ -3002,14 +3277,15 @@ void MainWindow::viewModeRender()
    Go to the OpenCSG view mode.
    Falls back to thrown together mode if OpenCSG is not available
  */
-void MainWindow::viewModePreview()
-{
+void MainWindow::viewModePreview() {
   viewActionThrownTogether->setEnabled(true);
   viewActionPreview->setEnabled(this->qglview->hasOpenCSGSupport());
   if (this->qglview->hasOpenCSGSupport()) {
     viewActionPreview->setChecked(true);
     viewActionThrownTogether->setChecked(false);
-    this->qglview->setRenderer(this->previewRenderer ? this->previewRenderer : this->thrownTogetherRenderer);
+    this->qglview->setRenderer(this->previewRenderer
+                                   ? this->previewRenderer
+                                   : this->thrownTogetherRenderer);
     this->qglview->updateColorScheme();
     this->qglview->update();
   } else {
@@ -3019,8 +3295,7 @@ void MainWindow::viewModePreview()
 
 #endif /* ENABLE_OPENCSG */
 
-void MainWindow::viewModeThrownTogether()
-{
+void MainWindow::viewModeThrownTogether() {
   viewActionThrownTogether->setEnabled(true);
   viewActionPreview->setEnabled(this->qglview->hasOpenCSGSupport());
   viewActionThrownTogether->setChecked(true);
@@ -3030,16 +3305,14 @@ void MainWindow::viewModeThrownTogether()
   this->qglview->update();
 }
 
-void MainWindow::viewModeShowEdges()
-{
+void MainWindow::viewModeShowEdges() {
   QSettingsCached settings;
   settings.setValue("view/showEdges", viewActionShowEdges->isChecked());
   this->qglview->setShowEdges(viewActionShowEdges->isChecked());
   this->qglview->update();
 }
 
-void MainWindow::viewModeShowAxes()
-{
+void MainWindow::viewModeShowAxes() {
   const bool showaxes = viewActionShowAxes->isChecked();
   QSettingsCached settings;
   settings.setValue("view/showAxes", showaxes);
@@ -3048,29 +3321,28 @@ void MainWindow::viewModeShowAxes()
   this->qglview->update();
 }
 
-void MainWindow::viewModeShowCrosshairs()
-{
+void MainWindow::viewModeShowCrosshairs() {
   QSettingsCached settings;
-  settings.setValue("view/showCrosshairs", viewActionShowCrosshairs->isChecked());
+  settings.setValue("view/showCrosshairs",
+                    viewActionShowCrosshairs->isChecked());
   this->qglview->setShowCrosshairs(viewActionShowCrosshairs->isChecked());
   this->qglview->update();
 }
 
-void MainWindow::viewModeShowScaleProportional()
-{
+void MainWindow::viewModeShowScaleProportional() {
   QSettingsCached settings;
-  settings.setValue("view/showScaleProportional", viewActionShowScaleProportional->isChecked());
-  this->qglview->setShowScaleProportional(viewActionShowScaleProportional->isChecked());
+  settings.setValue("view/showScaleProportional",
+                    viewActionShowScaleProportional->isChecked());
+  this->qglview->setShowScaleProportional(
+      viewActionShowScaleProportional->isChecked());
   this->qglview->update();
 }
 
-bool MainWindow::isEmpty()
-{
+bool MainWindow::isEmpty() {
   return activeEditor->toPlainText().isEmpty();
 }
 
-void MainWindow::editorContentChanged()
-{
+void MainWindow::editorContentChanged() {
   // this slot is called when the content of the active editor changed.
   // it rely on the activeEditor member to pick the new data.
 
@@ -3083,56 +3355,47 @@ void MainWindow::editorContentChanged()
   }
 }
 
-void MainWindow::viewAngleTop()
-{
+void MainWindow::viewAngleTop() {
   qglview->cam.object_rot << 90, 0, 0;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleBottom()
-{
+void MainWindow::viewAngleBottom() {
   qglview->cam.object_rot << 270, 0, 0;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleLeft()
-{
+void MainWindow::viewAngleLeft() {
   qglview->cam.object_rot << 0, 0, 90;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleRight()
-{
+void MainWindow::viewAngleRight() {
   qglview->cam.object_rot << 0, 0, 270;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleFront()
-{
+void MainWindow::viewAngleFront() {
   qglview->cam.object_rot << 0, 0, 0;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleBack()
-{
+void MainWindow::viewAngleBack() {
   qglview->cam.object_rot << 0, 0, 180;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleDiagonal()
-{
+void MainWindow::viewAngleDiagonal() {
   qglview->cam.object_rot << 35, 0, -25;
   this->qglview->update();
 }
 
-void MainWindow::viewCenter()
-{
+void MainWindow::viewCenter() {
   qglview->cam.object_trans << 0, 0, 0;
   this->qglview->update();
 }
 
-void MainWindow::setProjectionType(ProjectionType mode)
-{
+void MainWindow::setProjectionType(ProjectionType mode) {
   bool isOrthogonal = ProjectionType::ORTHOGONAL == mode;
   QSettingsCached settings;
   settings.setValue("view/orthogonalProjection", isOrthogonal);
@@ -3142,37 +3405,32 @@ void MainWindow::setProjectionType(ProjectionType mode)
   qglview->update();
 }
 
-void MainWindow::viewPerspective()
-{
+void MainWindow::viewPerspective() {
   setProjectionType(ProjectionType::PERSPECTIVE);
 }
 
-void MainWindow::viewOrthogonal()
-{
+void MainWindow::viewOrthogonal() {
   setProjectionType(ProjectionType::ORTHOGONAL);
 }
 
-void MainWindow::viewTogglePerspective()
-{
+void MainWindow::viewTogglePerspective() {
   const QSettingsCached settings;
   bool isOrtho = settings.value("view/orthogonalProjection").toBool();
-  setProjectionType(isOrtho?ProjectionType::PERSPECTIVE:ProjectionType::ORTHOGONAL);
+  setProjectionType(isOrtho ? ProjectionType::PERSPECTIVE
+                            : ProjectionType::ORTHOGONAL);
 }
 
-void MainWindow::viewResetView()
-{
+void MainWindow::viewResetView() {
   this->qglview->resetView();
   this->qglview->update();
 }
 
-void MainWindow::viewAll()
-{
+void MainWindow::viewAll() {
   this->qglview->viewAll();
   this->qglview->update();
 }
 
-void MainWindow::hideEditorToolbar()
-{
+void MainWindow::hideEditorToolbar() {
   QSettingsCached settings;
   const bool shouldHide = viewActionHideEditorToolBar->isChecked();
   settings.setValue("view/hideEditorToolbar", shouldHide);
@@ -3184,8 +3442,7 @@ void MainWindow::hideEditorToolbar()
   }
 }
 
-void MainWindow::hide3DViewToolbar()
-{
+void MainWindow::hide3DViewToolbar() {
   QSettingsCached settings;
   const bool shouldHide = viewActionHide3DViewToolBar->isChecked();
   settings.setValue("view/hide3DViewToolbar", shouldHide);
@@ -3197,8 +3454,7 @@ void MainWindow::hide3DViewToolbar()
   }
 }
 
-void MainWindow::showLink(const QString& link)
-{
+void MainWindow::showLink(const QString& link) {
   if (link == "#console") {
     consoleDock->show();
   } else if (link == "#errorlog") {
@@ -3206,9 +3462,8 @@ void MainWindow::showLink(const QString& link)
   }
 }
 
-void MainWindow::onEditorDockVisibilityChanged(bool isVisible)
-{
-  auto e = (ScintillaEditor *) this->activeEditor;
+void MainWindow::onEditorDockVisibilityChanged(bool isVisible) {
+  auto e = (ScintillaEditor*)this->activeEditor;
   if (isVisible) {
     e->qsci->setReadOnly(false);
     e->setupAutoComplete(false);
@@ -3226,8 +3481,7 @@ void MainWindow::onEditorDockVisibilityChanged(bool isVisible)
   updateExportActions();
 }
 
-void MainWindow::onConsoleDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onConsoleDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     frameCompileResult->hide();
     consoleDock->raise();
@@ -3235,8 +3489,7 @@ void MainWindow::onConsoleDockVisibilityChanged(bool isVisible)
   }
 }
 
-void MainWindow::onErrorLogDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onErrorLogDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     frameCompileResult->hide();
     errorLogDock->raise();
@@ -3244,16 +3497,14 @@ void MainWindow::onErrorLogDockVisibilityChanged(bool isVisible)
   }
 }
 
-void MainWindow::onAnimateDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onAnimateDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     animateDock->raise();
     animateWidget->setFocus();
   }
 }
 
-void MainWindow::onFontListDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onFontListDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     fontListWidget->update_font_list();
     fontListWidget->setFocus();
@@ -3261,16 +3512,14 @@ void MainWindow::onFontListDockVisibilityChanged(bool isVisible)
   }
 }
 
-void MainWindow::onViewportControlDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onViewportControlDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     viewportControlDock->raise();
     viewportControlWidget->setFocus();
   }
 }
 
-void MainWindow::onParametersDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onParametersDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     parameterDock->raise();
     activeEditor->parameterWidget->scrollArea->setFocus();
@@ -3280,79 +3529,78 @@ void MainWindow::onParametersDockVisibilityChanged(bool isVisible)
 // Use the sender's to detect if we are moving forward/backward in docks
 // and search for the next dock to "activate" or "emphasize"
 // If no dock can be found, returns the first one.
-Dock *MainWindow::getNextDockFromSender(QObject *sender)
-{
+Dock* MainWindow::getNextDockFromSender(QObject* sender) {
   int direction = 0;
 
-  auto *action = qobject_cast<QAction *>(sender);
+  auto* action = qobject_cast<QAction*>(sender);
   if (action != nullptr) {
     direction = (action == windowActionNextWindow) ? 1 : -1;
   } else {
-    auto *shortcut = qobject_cast<QShortcut *>(sender);
+    auto* shortcut = qobject_cast<QShortcut*>(sender);
     direction = (shortcut == shortcutNextWindow) ? 1 : -1;
   }
 
   return findVisibleDockToActivate(direction);
 }
 
-void MainWindow::onWindowActionNextPrevHovered()
-{
+void MainWindow::onWindowActionNextPrevHovered() {
   auto dock = getNextDockFromSender(sender());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
   // Hover signal is emitted at each mouse move, to avoid excessive
   // load we only raise/emphasize if it is not yet done.
-  if (rubberBandManager.isEmphasized(dock)) return;
+  if (rubberBandManager.isEmphasized(dock))
+    return;
 
   dock->raise();
   rubberBandManager.emphasize(dock);
 }
 
-void MainWindow::onWindowActionNextPrevTriggered()
-{
+void MainWindow::onWindowActionNextPrevTriggered() {
   auto dock = getNextDockFromSender(sender());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
   activateDock(dock);
 }
 
-void MainWindow::onWindowShortcutNextPrevActivated()
-{
+void MainWindow::onWindowShortcutNextPrevActivated() {
   auto dock = getNextDockFromSender(sender());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
   activateDock(dock);
   rubberBandManager.emphasize(dock);
 }
 
-void MainWindow::on_editActionInsertTemplate_triggered()
-{
+void MainWindow::on_editActionInsertTemplate_triggered() {
   activeEditor->displayTemplates();
 }
 
-void MainWindow::on_editActionFoldAll_triggered()
-{
+void MainWindow::on_editActionFoldAll_triggered() {
   activeEditor->foldUnfold();
 }
 
-QString MainWindow::getCurrentFileName() const
-{
-  if (activeEditor == nullptr) return {};
+QString MainWindow::getCurrentFileName() const {
+  if (activeEditor == nullptr)
+    return {};
 
   const QFileInfo fileInfo(activeEditor->filepath);
   QString fname = _("Untitled.scad");
-  if (!fileInfo.fileName().isEmpty()) fname = fileInfo.fileName();
+  if (!fileInfo.fileName().isEmpty())
+    fname = fileInfo.fileName();
   return fname.replace("&", "&&");
 }
 
-void MainWindow::onTabManagerAboutToCloseEditor(EditorInterface *closingEditor)
-{
+void MainWindow::onTabManagerAboutToCloseEditor(
+    EditorInterface* closingEditor) {
   // This slots is in charge of closing properly the preview when the
   // associated editor is about to close.
   if (closingEditor == renderedEditor) {
@@ -3360,9 +3608,9 @@ void MainWindow::onTabManagerAboutToCloseEditor(EditorInterface *closingEditor)
 
     // Invalidate renderers before we kill the CSG tree
     this->qglview->setRenderer(nullptr);
-       #ifdef ENABLE_OPENCSG
+#ifdef ENABLE_OPENCSG
     this->previewRenderer = nullptr;
-       #endif
+#endif
     this->thrownTogetherRenderer = nullptr;
 
     // Remove previous CSG tree
@@ -3378,11 +3626,11 @@ void MainWindow::onTabManagerAboutToCloseEditor(EditorInterface *closingEditor)
   }
 }
 
-void MainWindow::onTabManagerEditorContentReloaded(EditorInterface *reloadedEditor)
-{
+void MainWindow::onTabManagerEditorContentReloaded(
+    EditorInterface* reloadedEditor) {
   try {
-    // when a new editor is created, it is important to compile the initial geometry
-    // so the customizer panels are ok.
+    // when a new editor is created, it is important to compile the initial
+    // geometry so the customizer panels are ok.
     parseDocument(reloadedEditor);
   } catch (const HardWarningException&) {
     exceptionCleanup();
@@ -3393,16 +3641,16 @@ void MainWindow::onTabManagerEditorContentReloaded(EditorInterface *reloadedEdit
   }
 
   // updates the content of the Recents Files menu to integrate the one possibly
-  // associated with the created editor. The reason is that an editor can be created
-  // or updated without a file associated with it.
+  // associated with the created editor. The reason is that an editor can be
+  // created or updated without a file associated with it.
   updateRecentFileActions();
 }
 
-void MainWindow::onTabManagerEditorChanged(EditorInterface *newEditor)
-{
+void MainWindow::onTabManagerEditorChanged(EditorInterface* newEditor) {
   activeEditor = newEditor;
 
-  if (newEditor == nullptr) return;
+  if (newEditor == nullptr)
+    return;
 
   parameterDock->setWidget(newEditor->parameterWidget);
   editActionUndo->setEnabled(newEditor->canUndo());
@@ -3422,17 +3670,17 @@ void MainWindow::onTabManagerEditorChanged(EditorInterface *newEditor)
   }
 }
 
-Dock *MainWindow::findVisibleDockToActivate(int offset) const
-{
+Dock* MainWindow::findVisibleDockToActivate(int offset) const {
   const unsigned int dockCount = docks.size();
 
   int focusedDockIndice = -1;
 
   // search among the docks the one that is having the focus. This is done by
-  // traversing the widget hierarchy from the focused widget up to the docks that
-  // contains it.
+  // traversing the widget hierarchy from the focused widget up to the docks
+  // that contains it.
   const auto focusWidget = QApplication::focusWidget();
-  for (auto widget = focusWidget; widget != nullptr; widget = widget->parentWidget()) {
+  for (auto widget = focusWidget; widget != nullptr;
+       widget = widget->parentWidget()) {
     for (unsigned int index = 0; index < dockCount; ++index) {
       auto dock = std::get<0>(docks[index]);
       if (dock == focusWidget) {
@@ -3447,7 +3695,8 @@ Dock *MainWindow::findVisibleDockToActivate(int offset) const
 
   for (int o = 1; o < dockCount; ++o) {
     // starting from dockCount + focusedDockIndice move left or right (o*offset)
-    // to find the first visible one. dockCount is there so there is no situation in which
+    // to find the first visible one. dockCount is there so there is no
+    // situation in which
     // (-1) % dockCount
     const int target = (dockCount + focusedDockIndice + o * offset) % dockCount;
     const auto& dock = std::get<0>(docks.at(target));
@@ -3459,27 +3708,27 @@ Dock *MainWindow::findVisibleDockToActivate(int offset) const
   return nullptr;
 }
 
-void MainWindow::activateDock(Dock *dock)
-{
-  if (dock == nullptr) return;
+void MainWindow::activateDock(Dock* dock) {
+  if (dock == nullptr)
+    return;
 
   // We always need to activate the window.
-  if (dock->isFloating()) dock->activateWindow();
-  else QMainWindow::activateWindow();
+  if (dock->isFloating())
+    dock->activateWindow();
+  else
+    QMainWindow::activateWindow();
 
   dock->raise();
   dock->setFocus();
 }
 
-void MainWindow::dragEnterEvent(QDragEnterEvent *event)
-{
+void MainWindow::dragEnterEvent(QDragEnterEvent* event) {
   if (event->mimeData()->hasUrls()) {
     event->acceptProposedAction();
   }
 }
 
-void MainWindow::dropEvent(QDropEvent *event)
-{
+void MainWindow::dropEvent(QDropEvent* event) {
   setCurrentOutput();
   const QList<QUrl> urls = event->mimeData()->urls();
   for (const auto& url : urls) {
@@ -3488,9 +3737,9 @@ void MainWindow::dropEvent(QDropEvent *event)
   clearCurrentOutput();
 }
 
-void MainWindow::handleFileDrop(const QUrl& url)
-{
-  if (url.scheme() != "file") return;
+void MainWindow::handleFileDrop(const QUrl& url) {
+  if (url.scheme() != "file")
+    return;
   const auto fileName = url.toLocalFile();
   const auto fileInfo = QFileInfo{fileName};
   const auto suffix = fileInfo.suffix().toLower();
@@ -3502,41 +3751,34 @@ void MainWindow::handleFileDrop(const QUrl& url)
   }
 }
 
-void MainWindow::helpAbout()
-{
+void MainWindow::helpAbout() {
   qApp->setWindowIcon(QApplication::windowIcon());
   auto dialog = new AboutDialog(this);
   dialog->exec();
   dialog->deleteLater();
 }
 
-void MainWindow::helpHomepage()
-{
+void MainWindow::helpHomepage() {
   UIUtils::openHomepageURL();
 }
 
-void MainWindow::helpManual()
-{
+void MainWindow::helpManual() {
   UIUtils::openUserManualURL();
 }
 
-void MainWindow::helpOfflineManual()
-{
+void MainWindow::helpOfflineManual() {
   UIUtils::openOfflineUserManual();
 }
 
-void MainWindow::helpCheatSheet()
-{
+void MainWindow::helpCheatSheet() {
   UIUtils::openCheatSheetURL();
 }
 
-void MainWindow::helpOfflineCheatSheet()
-{
+void MainWindow::helpOfflineCheatSheet() {
   UIUtils::openOfflineCheatSheet();
 }
 
-void MainWindow::helpLibrary()
-{
+void MainWindow::helpLibrary() {
   if (!this->libraryInfoDialog) {
     const QString rendererInfo(qglview->getRendererInfo().c_str());
     auto dialog = new LibraryInfoDialog(rendererInfo);
@@ -3545,8 +3787,7 @@ void MainWindow::helpLibrary()
   this->libraryInfoDialog->show();
 }
 
-void MainWindow::helpFontInfo()
-{
+void MainWindow::helpFontInfo() {
   if (!this->fontListDialog) {
     auto dialog = new FontListDialog();
     this->fontListDialog = dialog;
@@ -3555,8 +3796,7 @@ void MainWindow::helpFontInfo()
   this->fontListDialog->show();
 }
 
-void MainWindow::closeEvent(QCloseEvent *event)
-{
+void MainWindow::closeEvent(QCloseEvent* event) {
   if (tabManager->shouldClose()) {
     isClosing = true;
     progress_report_fin();
@@ -3571,7 +3811,7 @@ void MainWindow::closeEvent(QCloseEvent *event)
       delete this->tempFile;
       this->tempFile = nullptr;
     }
-    for (auto dock : findChildren<Dock *>()) {
+    for (auto dock : findChildren<Dock*>()) {
       dock->disableSettingsUpdate();
     }
     event->accept();
@@ -3580,103 +3820,103 @@ void MainWindow::closeEvent(QCloseEvent *event)
   }
 }
 
-void MainWindow::preferences()
-{
+void MainWindow::preferences() {
   GlobalPreferences::inst()->update();
   GlobalPreferences::inst()->show();
   GlobalPreferences::inst()->activateWindow();
   GlobalPreferences::inst()->raise();
 }
 
-void MainWindow::setColorScheme(const QString& scheme)
-{
+void MainWindow::setColorScheme(const QString& scheme) {
   RenderSettings::inst()->colorscheme = scheme.toStdString();
   this->qglview->setColorScheme(scheme.toStdString());
   this->qglview->update();
 }
 
-void MainWindow::setFont(const QString& family, uint size)
-{
+void MainWindow::setFont(const QString& family, uint size) {
   QFont font;
-  if (!family.isEmpty()) font.setFamily(family);
-  else font.setFixedPitch(true);
-  if (size > 0) font.setPointSize(size);
+  if (!family.isEmpty())
+    font.setFamily(family);
+  else
+    font.setFixedPitch(true);
+  if (size > 0)
+    font.setPointSize(size);
   font.setStyleHint(QFont::TypeWriter);
   activeEditor->setFont(font);
 }
 
-void MainWindow::consoleOutput(const Message& msgObj, void *userdata)
-{
+void MainWindow::consoleOutput(const Message& msgObj, void* userdata) {
   // Invoke the method in the main thread in case the output
   // originates in a worker thread.
-  auto thisp = static_cast<MainWindow *>(userdata);
+  auto thisp = static_cast<MainWindow*>(userdata);
   QMetaObject::invokeMethod(thisp, "consoleOutput", Q_ARG(Message, msgObj));
 }
 
-void MainWindow::consoleOutput(const Message& msgObj)
-{
+void MainWindow::consoleOutput(const Message& msgObj) {
   this->console->addMessage(msgObj);
-  if (msgObj.group == message_group::Warning || msgObj.group == message_group::Deprecated) {
+  if (msgObj.group == message_group::Warning ||
+      msgObj.group == message_group::Deprecated) {
     ++this->compileWarnings;
   } else if (msgObj.group == message_group::Error) {
     ++this->compileErrors;
   }
-  // FIXME: scad parsing/evaluation should be done on separate thread so as not to block the gui.
-  // Then processEvents should no longer be needed here.
+  // FIXME: scad parsing/evaluation should be done on separate thread so as not
+  // to block the gui. Then processEvents should no longer be needed here.
   this->processEvents();
   if (consoleUpdater && !consoleUpdater->isActive()) {
-    consoleUpdater->start(50);     // Limit console updates to 20 FPS
+    consoleUpdater->start(50);  // Limit console updates to 20 FPS
   }
 }
 
-void MainWindow::consoleOutputRaw(const QString& html)
-{
+void MainWindow::consoleOutputRaw(const QString& html) {
   this->console->addHtml(html);
   this->processEvents();
 }
 
-void MainWindow::errorLogOutput(const Message& log_msg, void *userdata)
-{
-  auto thisp = static_cast<MainWindow *>(userdata);
+void MainWindow::errorLogOutput(const Message& log_msg, void* userdata) {
+  auto thisp = static_cast<MainWindow*>(userdata);
   QMetaObject::invokeMethod(thisp, "errorLogOutput", Q_ARG(Message, log_msg));
 }
 
-void MainWindow::errorLogOutput(const Message& log_msg)
-{
+void MainWindow::errorLogOutput(const Message& log_msg) {
   this->errorLogWidget->toErrorLog(log_msg);
 }
 
-void MainWindow::setCurrentOutput()
-{
-  set_output_handler(&MainWindow::consoleOutput, &MainWindow::errorLogOutput, this);
+void MainWindow::setCurrentOutput() {
+  set_output_handler(&MainWindow::consoleOutput, &MainWindow::errorLogOutput,
+                     this);
 }
 
-void MainWindow::hideCurrentOutput()
-{
-  set_output_handler(&MainWindow::noOutputConsole, &MainWindow::noOutputErrorLog, this);
+void MainWindow::hideCurrentOutput() {
+  set_output_handler(&MainWindow::noOutputConsole,
+                     &MainWindow::noOutputErrorLog, this);
 }
 
-void MainWindow::clearCurrentOutput()
-{
+void MainWindow::clearCurrentOutput() {
   set_output_handler(nullptr, nullptr, nullptr);
 }
 
-void MainWindow::openCSGSettingsChanged()
-{
+void MainWindow::openCSGSettingsChanged() {
 #ifdef ENABLE_OPENCSG
-  OpenCSG::setOption(OpenCSG::AlgorithmSetting, GlobalPreferences::inst()->getValue("advanced/forceGoldfeather").toBool() ?
-                     OpenCSG::Goldfeather : OpenCSG::Automatic);
+  OpenCSG::setOption(
+      OpenCSG::AlgorithmSetting,
+      GlobalPreferences::inst()->getValue("advanced/forceGoldfeather").toBool()
+          ? OpenCSG::Goldfeather
+          : OpenCSG::Automatic);
 #endif
 }
 
-void MainWindow::processEvents()
-{
-  if (this->procevents) QApplication::processEvents();
+void MainWindow::processEvents() {
+  if (this->procevents)
+    QApplication::processEvents();
 }
 
 QString MainWindow::exportPath(const QString& suffix) {
   const auto path_it = this->exportPaths.find(suffix);
-  const auto basename = activeEditor->filepath.isEmpty() ? "Untitled" : QFileInfo(activeEditor->filepath).completeBaseName();
+  const auto basename =
+      activeEditor->filepath.isEmpty()
+          ? "Untitled"
+          : QFileInfo(activeEditor->filepath).completeBaseName();
   QString dir;
   if (path_it != exportPaths.end()) {
     dir = QFileInfo(path_it->second).absolutePath();
@@ -3688,7 +3928,6 @@ QString MainWindow::exportPath(const QString& suffix) {
   return QString("%1/%2.%3").arg(dir, basename, suffix);
 }
 
-void MainWindow::jumpToLine(int line, int col)
-{
+void MainWindow::jumpToLine(int line, int col) {
   this->activeEditor->setCursorPosition(line, col);
 }
diff --git a/src/gui/MainWindow.h b/src/gui/MainWindow.h
index 5f46b993c..0f6c72cc5 100644
--- a/src/gui/MainWindow.h
+++ b/src/gui/MainWindow.h
@@ -1,41 +1,41 @@
 #pragma once
 
 #include <ctime>
-#include <tuple>
-#include <unordered_map>
 #include <memory>
 #include <string>
+#include <tuple>
+#include <unordered_map>
 #include <vector>
 
 #include <QAction>
 #include <QCloseEvent>
 #include <QDragEnterEvent>
 #include <QDropEvent>
+#include <QElapsedTimer>
 #include <QEvent>
 #include <QFile>
+#include <QIODevice>
+#include <QIcon>
 #include <QLabel>
 #include <QList>
+#include <QMainWindow>
 #include <QMap>
+#include <QMutex>
 #include <QObject>
 #include <QPoint>
+#include <QShortcut>
+#include <QSignalMapper>
+#include <QSoundEffect>
 #include <QString>
 #include <QStringList>
 #include <QTemporaryFile>
+#include <QTime>
 #include <QTimer>
 #include <QUrl>
 #include <QWidget>
-#include <QMainWindow>
-#include <QElapsedTimer>
-#include <QIcon>
-#include <QIODevice>
-#include <QMutex>
-#include <QSoundEffect>
-#include <QTime>
-#include <QSignalMapper>
-#include <QShortcut>
 #include "core/Context.h"
-#include "glview/Renderer.h"
 #include "core/SourceFile.h"
+#include "glview/Renderer.h"
 #ifdef STATIC_QT_SVG_PLUGIN
 #include <QtPlugin>
 Q_IMPORT_PLUGIN(QSvgPlugin)
@@ -51,45 +51,46 @@ class Preferences;
 class ProgressWidget;
 class ThrownTogetherRenderer;
 
+#include "RenderStatistic.h"
 #include "core/Tree.h"
 #include "geometry/Geometry.h"
 #include "gui/Editor.h"
-#include "gui/input/InputDriverEvent.h"
 #include "gui/Measurement.h"
-#include "gui/qt-obsolete.h" // IWYU pragma: keep
-#include "gui/qtgettext.h" // IWYU pragma: keep
 #include "gui/RubberBandManager.h"
 #include "gui/TabManager.h"
 #include "gui/UIUtils.h"
-#include "io/export_enums.h"
-#include "io/export.h"
+#include "gui/input/InputDriverEvent.h"
+#include "gui/qt-obsolete.h"  // IWYU pragma: keep
+#include "gui/qtgettext.h"    // IWYU pragma: keep
 #include "io/export.h"
-#include "RenderStatistic.h"
+#include "io/export_enums.h"
 #include "ui_MainWindow.h"
 #include "utils/printutils.h"
 
 class UXTest;
-class MainWindow : public QMainWindow, public Ui::MainWindow, public InputEventHandler
-{
+class MainWindow : public QMainWindow,
+                   public Ui::MainWindow,
+                   public InputEventHandler {
   Q_OBJECT
 
   friend UXTest;
 
-public:
-  Preferences *prefs;
+ public:
+  Preferences* prefs;
 
-  QTimer *consoleUpdater;
+  QTimer* consoleUpdater;
 
   bool isPreview;
 
-  QTimer *autoReloadTimer;
-  QTimer *waitAfterReloadTimer;
+  QTimer* autoReloadTimer;
+  QTimer* waitAfterReloadTimer;
   RenderStatistic renderStatistic;
 
-  SourceFile *rootFile; // Result of parsing
-  SourceFile *parsedFile; // Last parse for include list
-  std::shared_ptr<AbstractNode> absoluteRootNode; // Result of tree evaluation
-  std::shared_ptr<AbstractNode> rootNode; // Root if the root modifier (!) is used
+  SourceFile* rootFile;    // Result of parsing
+  SourceFile* parsedFile;  // Last parse for include list
+  std::shared_ptr<AbstractNode> absoluteRootNode;  // Result of tree evaluation
+  std::shared_ptr<AbstractNode>
+      rootNode;  // Root if the root modifier (!) is used
 #ifdef ENABLE_PYTHON
   bool python_active;
   std::string trusted_edit_document_name;
@@ -97,8 +98,8 @@ public:
   bool trust_python_file(const std::string& file, const std::string& content);
 #endif
   Tree tree;
-  EditorInterface *activeEditor;
-  TabManager *tabManager;
+  EditorInterface* activeEditor;
+  TabManager* tabManager;
 
   std::shared_ptr<const Geometry> rootGeom;
   std::shared_ptr<Renderer> geomRenderer;
@@ -109,11 +110,11 @@ public:
 
   QString lastCompiledDoc;
 
-  QAction *actionRecentFile[UIUtils::maxRecentFiles];
-  QShortcut *shortcutNextWindow{nullptr};
-  QShortcut *shortcutPreviousWindow{nullptr};
+  QAction* actionRecentFile[UIUtils::maxRecentFiles];
+  QShortcut* shortcutNextWindow{nullptr};
+  QShortcut* shortcutPreviousWindow{nullptr};
 
-  QLabel *versionLabel;
+  QLabel* versionLabel;
 
   Measurement meas;
 
@@ -123,20 +124,22 @@ public:
   MainWindow(const QStringList& filenames);
   ~MainWindow() override;
 
-private:
+ private:
   RubberBandManager rubberBandManager;
 
-  std::vector<std::tuple<Dock *, QString>> docks;
+  std::vector<std::tuple<Dock*, QString>> docks;
 
   volatile bool isClosing = false;
   void consoleOutputRaw(const QString& msg);
   void clearAllSelectionIndicators();
-  void setSelectionIndicatorStatus(EditorInterface *editor, int nodeIndex, EditorSelectionIndicatorStatus status);
+  void setSelectionIndicatorStatus(EditorInterface* editor,
+                                   int nodeIndex,
+                                   EditorSelectionIndicatorStatus status);
 
-protected:
-  void closeEvent(QCloseEvent *event) override;
+ protected:
+  void closeEvent(QCloseEvent* event) override;
 
-private slots:
+ private slots:
   void updateUndockMode(bool undockMode);
   void updateReorderMode(bool reorderMode);
   void setFont(const QString& family, uint size);
@@ -147,7 +150,8 @@ private slots:
   void setSelection(int index);
 
   // implements the actions to be done when the selection menu is closing
-  // the seclection menu is the one that show up when right click on the geometry in the 3d view.
+  // the seclection menu is the one that show up when right click on the
+  // geometry in the 3d view.
   void onHoveredObjectInSelectionMenu();
 
   void measureFinished();
@@ -159,35 +163,35 @@ private slots:
 
   // implement the different actions needed when
   // the tab manager editor is changed.
-  void onTabManagerEditorChanged(EditorInterface *);
+  void onTabManagerEditorChanged(EditorInterface*);
 
   // implement the different actions needed when
   // the tab manager editor is about to close one of the tab
-  void onTabManagerAboutToCloseEditor(EditorInterface *);
+  void onTabManagerAboutToCloseEditor(EditorInterface*);
 
   // implement the different actions needed when an editor
   // has its content replaced (because of load)
-  void onTabManagerEditorContentReloaded(EditorInterface *reloadedEditor);
+  void onTabManagerEditorContentReloaded(EditorInterface* reloadedEditor);
 
-public:
-  static void consoleOutput(const Message& msgObj, void *userdata);
-  static void errorLogOutput(const Message& log_msg, void *userdata);
-  static void noOutputConsole(const Message&, void *) {} // /dev/null
-  static void noOutputErrorLog(const Message&, void *) {} // /dev/null
+ public:
+  static void consoleOutput(const Message& msgObj, void* userdata);
+  static void errorLogOutput(const Message& log_msg, void* userdata);
+  static void noOutputConsole(const Message&, void*) {}   // /dev/null
+  static void noOutputErrorLog(const Message&, void*) {}  // /dev/null
 
   bool fileChangedOnDisk();
 
-  // Parse the document contained in the editor, update the editors's parameters and returns a SourceFile object
-  // if parsing suceeded. Nullptr otherwise.
-  SourceFile *parseDocument(EditorInterface *editor);
+  // Parse the document contained in the editor, update the editors's parameters
+  // and returns a SourceFile object if parsing suceeded. Nullptr otherwise.
+  SourceFile* parseDocument(EditorInterface* editor);
 
   void parseTopLevelDocument();
   void exceptionCleanup();
-  void setLastFocus(QWidget *widget);
+  void setLastFocus(QWidget* widget);
   void UnknownExceptionCleanup(std::string msg = "");
   void showFind(bool doFindAndReplace);
 
-private:
+ private:
   [[nodiscard]] QString getCurrentFileName() const;
 
   void setRenderVariables(ContextHandle<BuiltinContext>& context);
@@ -197,8 +201,9 @@ private:
   bool checkEditorModified();
   QString dumpCSGTree(const std::shared_ptr<AbstractNode>& root);
 
-  // Opens an independent windows with a text area showing the text given in argument
-  // The "type" is used to specify the type of content with the title of the window,
+  // Opens an independent windows with a text area showing the text given in
+  // argument The "type" is used to specify the type of content with the title
+  // of the window,
   void showTextInWindow(const QString& type, const QString& textToShow);
 
   // Change the perspective mode of the 3D view.
@@ -207,28 +212,38 @@ private:
 
   void loadViewSettings();
   void loadDesignSettings();
-  void prepareCompile(const char *afterCompileSlot, bool procevents, bool preview);
-  void updateWindowSettings(bool console, bool editor, bool customizer, bool errorLog, bool editorToolbar, bool viewToolbar, bool animate, bool fontList, bool ViewportControlWidget);
+  void prepareCompile(const char* afterCompileSlot,
+                      bool procevents,
+                      bool preview);
+  void updateWindowSettings(bool console,
+                            bool editor,
+                            bool customizer,
+                            bool errorLog,
+                            bool editorToolbar,
+                            bool viewToolbar,
+                            bool animate,
+                            bool fontList,
+                            bool ViewportControlWidget);
   void saveBackup();
-  void writeBackup(QFile *file);
+  void writeBackup(QFile* file);
   void show_examples();
-  void addKeyboardShortCut(const QList<QAction *>& actions);
-  void updateStatusBar(ProgressWidget *progressWidget);
-  void activateDock(Dock *);
-  Dock *findVisibleDockToActivate(int offset) const;
-  Dock *getNextDockFromSender(QObject *sender);
+  void addKeyboardShortCut(const QList<QAction*>& actions);
+  void updateStatusBar(ProgressWidget* progressWidget);
+  void activateDock(Dock*);
+  Dock* findVisibleDockToActivate(int offset) const;
+  Dock* getNextDockFromSender(QObject* sender);
 
-  LibraryInfoDialog *libraryInfoDialog{nullptr};
-  FontListDialog *fontListDialog{nullptr};
-  QSignalMapper *exportFormatMapper;
+  LibraryInfoDialog* libraryInfoDialog{nullptr};
+  FontListDialog* fontListDialog{nullptr};
+  QSignalMapper* exportFormatMapper;
 
-public slots:
+ public slots:
   void updateExportActions();
   void updateRecentFiles(const QString& FileSavedOrOpened);
   void updateRecentFileActions();
   void handleFileDrop(const QUrl& url);
 
-private slots:
+ private slots:
   void actionOpen();
   void actionNewWindow();
   void actionOpenWindow();
@@ -251,7 +266,7 @@ private slots:
   void compileEnded();
   void changeParameterWidget();
 
-private slots:
+ private slots:
   void copyViewportTranslation();
   void copyViewportRotation();
   void copyViewportDistance();
@@ -261,11 +276,12 @@ private slots:
   void hide3DViewToolbar();
   void showLink(const QString&);
 
-  // Handle the Next/Prev dock menu action when the is hovered, currently this activate the rubberband
+  // Handle the Next/Prev dock menu action when the is hovered, currently this
+  // activate the rubberband
   void onWindowActionNextPrevHovered();
 
-  // Handle the Next/Prev dock menu action when the is validatee, currently switch to the targetted dock
-  // and remove the rubberband
+  // Handle the Next/Prev dock menu action when the is validatee, currently
+  // switch to the targetted dock and remove the rubberband
   void onWindowActionNextPrevTriggered();
 
   // Handle the Next/Prev shortcut, currently switch to the targetted dock
@@ -283,12 +299,12 @@ private slots:
   void on_editActionInsertTemplate_triggered();
   void on_editActionFoldAll_triggered();
 
-public slots:
+ public slots:
   void hideFind();
   void actionShowFind();
   void actionShowFindAndReplace();
 
-private slots:
+ private slots:
   void actionSelectFind(int);
   void findString(const QString&);
   void findNext();
@@ -300,17 +316,18 @@ private slots:
   // Mac OSX FindBuffer support
   void findBufferChanged();
   void updateFindBuffer(const QString&);
-  bool event(QEvent *event) override;
-protected:
-  bool eventFilter(QObject *obj, QEvent *event) override;
+  bool event(QEvent* event) override;
+
+ protected:
+  bool eventFilter(QObject* obj, QEvent* event) override;
 
-public slots:
+ public slots:
   void actionRenderPreview();
-private slots:
+ private slots:
   void csgRender();
   void csgReloadRender();
   void action3DPrint();
-  void sendToExternalTool(class ExternalToolInterface &externalToolService);
+  void sendToExternalTool(class ExternalToolInterface& externalToolService);
   void actionRender();
   void actionRenderDone(const std::shared_ptr<const Geometry>&);
   void cgalRender();
@@ -326,27 +343,27 @@ private slots:
   void actionCopyViewport();
   void actionFlushCaches();
 
-public:
+ public:
   void viewModeActionsUncheck();
   void setCurrentOutput();
   void clearCurrentOutput();
   void hideCurrentOutput();
   bool isEmpty();
 
-  void onAxisChanged(InputEventAxisChanged *event) override;
-  void onButtonChanged(InputEventButtonChanged *event) override;
+  void onAxisChanged(InputEventAxisChanged* event) override;
+  void onButtonChanged(InputEventButtonChanged* event) override;
 
-  void onTranslateEvent(InputEventTranslate *event) override;
-  void onRotateEvent(InputEventRotate *event) override;
-  void onRotate2Event(InputEventRotate2 *event) override;
-  void onActionEvent(InputEventAction *event) override;
-  void onZoomEvent(InputEventZoom *event) override;
+  void onTranslateEvent(InputEventTranslate* event) override;
+  void onRotateEvent(InputEventRotate* event) override;
+  void onRotate2Event(InputEventRotate2* event) override;
+  void onActionEvent(InputEventAction* event) override;
+  void onZoomEvent(InputEventZoom* event) override;
 
   QList<double> getTranslation() const;
   QList<double> getRotation() const;
-  std::unordered_map<FileFormat, QAction *> exportMap;
+  std::unordered_map<FileFormat, QAction*> exportMap;
 
-public slots:
+ public slots:
   void actionReloadRenderPreview();
   void on_toolButtonCompileResultClose_clicked();
   void processEvents();
@@ -378,8 +395,8 @@ public slots:
   void editorContentChanged();
   void leftClick(QPoint coordinate);
   void rightClick(QPoint coordinate);
-  void dragEnterEvent(QDragEnterEvent *event) override;
-  void dropEvent(QDropEvent *event) override;
+  void dragEnterEvent(QDragEnterEvent* event) override;
+  void dropEvent(QDropEvent* event) override;
   void helpAbout();
   void helpHomepage();
   void helpManual();
@@ -392,74 +409,71 @@ public slots:
   void waitAfterReload();
   void autoReloadSet(bool);
 
-private:
+ private:
   bool network_progress_func(const double permille);
-  static void report_func(const std::shared_ptr<const AbstractNode>&, void *vp, int mark);
+  static void report_func(const std::shared_ptr<const AbstractNode>&,
+                          void* vp,
+                          int mark);
   static bool undockMode;
   static bool reorderMode;
   static const int tabStopWidth;
-  static QElapsedTimer *progressThrottle;
-  QWidget *lastFocus; // keep track of active copyable widget (Editor|Console) for global menu action Edit->Copy
+  static QElapsedTimer* progressThrottle;
+  QWidget* lastFocus;  // keep track of active copyable widget (Editor|Console)
+                       // for global menu action Edit->Copy
 
-  std::shared_ptr<CSGNode> csgRoot; // Result of the CSGTreeEvaluator
-  std::shared_ptr<CSGNode> normalizedRoot; // Normalized CSG tree
+  std::shared_ptr<CSGNode> csgRoot;         // Result of the CSGTreeEvaluator
+  std::shared_ptr<CSGNode> normalizedRoot;  // Normalized CSG tree
   std::shared_ptr<CSGProducts> rootProduct;
   std::shared_ptr<CSGProducts> highlightsProducts;
   std::shared_ptr<CSGProducts> backgroundProducts;
-  int currentlySelectedObject {-1};
+  int currentlySelectedObject{-1};
 
-  char const *afterCompileSlot;
+  char const* afterCompileSlot;
   bool procevents{false};
-  QTemporaryFile *tempFile{nullptr};
-  ProgressWidget *progresswidget{nullptr};
-  CGALWorker *cgalworker;
+  QTemporaryFile* tempFile{nullptr};
+  ProgressWidget* progresswidget{nullptr};
+  CGALWorker* cgalworker;
   QMutex consolemutex;
-  EditorInterface *renderedEditor; // stores pointer to editor which has been most recently rendered
-  time_t includesMTime{0}; // latest include mod time
-  time_t depsMTime{0}; // latest dependency mod time
-  std::unordered_map<QString, QString> exportPaths; // for each file type, where it was exported to last
-  QString exportPath(const QString& suffix); // look up the last export path and generate one if not found
-  int lastParserErrorPos{-1}; // last highlighted error position
+  EditorInterface* renderedEditor;  // stores pointer to editor which has been
+                                    // most recently rendered
+  time_t includesMTime{0};          // latest include mod time
+  time_t depsMTime{0};              // latest dependency mod time
+  std::unordered_map<QString, QString>
+      exportPaths;  // for each file type, where it was exported to last
+  QString exportPath(const QString& suffix);  // look up the last export path
+                                              // and generate one if not found
+  int lastParserErrorPos{-1};                 // last highlighted error position
   int tabCount = 0;
   ExportPdfPaperSize sizeString2Enum(const QString& current);
   ExportPdfPaperOrientation orientationsString2Enum(const QString& current);
 
-  QMenu *navigationMenu{nullptr};
-  QSoundEffect *renderCompleteSoundEffect;
+  QMenu* navigationMenu{nullptr};
+  QSoundEffect* renderCompleteSoundEffect;
   std::vector<std::unique_ptr<QTemporaryFile>> allTempFiles;
 
-signals:
+ signals:
   void highlightError(int);
   void unhighlightLastError();
 
 #ifdef ENABLE_GUI_TESTS
-public:
-  std::shared_ptr<AbstractNode> instantiateRootFromSource(SourceFile *file);
-signals:
-  // This is a new signal introduced while drafting the testing framework, while in experimental mode
-  // we protected it using the #ifdef/endif so it should not be considered as part of the MainWindow API.
-  void compilationDone(SourceFile *);
-#endif //
-
+ public:
+  std::shared_ptr<AbstractNode> instantiateRootFromSource(SourceFile* file);
+ signals:
+  // This is a new signal introduced while drafting the testing framework, while
+  // in experimental mode we protected it using the #ifdef/endif so it should
+  // not be considered as part of the MainWindow API.
+  void compilationDone(SourceFile*);
+#endif  //
 };
 
-class GuiLocker
-{
-public:
-  GuiLocker() {
-    GuiLocker::lock();
-  }
-  ~GuiLocker() {
-    GuiLocker::unlock();
-  }
+class GuiLocker {
+ public:
+  GuiLocker() { GuiLocker::lock(); }
+  ~GuiLocker() { GuiLocker::unlock(); }
   static bool isLocked() { return guiLocked > 0; }
-  static void lock() {
-    guiLocked++;
-  }
-  static void unlock() {
-    guiLocked--;
-  }
-
-private:
+  static void lock() { guiLocked++; }
+  static void unlock() { guiLocked--; }
+
+ private:
   static unsigned int guiLocked;
 };
diff --git a/src/gui/Measurement.cc b/src/gui/Measurement.cc
index 579e51478..30a69715e 100644
--- a/src/gui/Measurement.cc
+++ b/src/gui/Measurement.cc
@@ -24,93 +24,106 @@
  *
  */
 
-#include "geometry/linalg.h"
 #include "gui/Measurement.h"
+#include "geometry/linalg.h"
 
 #include <QPoint>
 #include <QString>
 #include <cmath>
 #include <sstream>
 
-Measurement::Measurement()
-{
-}
+Measurement::Measurement() {}
 
-void Measurement::setView(QGLView *qglview) {
+void Measurement::setView(QGLView* qglview) {
   this->qglview = qglview;
   this->qglview->measure_state = MEASURE_IDLE;
 }
 
-void Measurement::startMeasureDist(void)
-{
+void Measurement::startMeasureDist(void) {
   this->qglview->selected_obj.clear();
   this->qglview->update();
   this->qglview->measure_state = MEASURE_DIST1;
 }
 
-void Measurement::startMeasureAngle(void)
-{
+void Measurement::startMeasureAngle(void) {
   this->qglview->selected_obj.clear();
   this->qglview->update();
   this->qglview->measure_state = MEASURE_ANG1;
 }
 
-void Measurement::stopMeasure()
-{
+void Measurement::stopMeasure() {
   qglview->selected_obj.clear();
   qglview->shown_obj.clear();
   qglview->update();
   qglview->measure_state = MEASURE_IDLE;
 }
 
-QString Measurement::statemachine(QPoint mouse)
-{
-  if (qglview->measure_state == MEASURE_IDLE)return "";
+QString Measurement::statemachine(QPoint mouse) {
+  if (qglview->measure_state == MEASURE_IDLE)
+    return "";
   qglview->selectPoint(mouse.x(), mouse.y());
   double ang = NAN;
   double dist = NAN;
   SelectedObject obj1, obj2, obj3;
   switch (qglview->measure_state) {
-  case MEASURE_DIST1:
-    if (qglview->selected_obj.size() == 1) qglview->measure_state = MEASURE_DIST2;
-    break;
-  case MEASURE_DIST2:
-    if (qglview->selected_obj.size() == 2){
-      double lat;
-      obj1 = qglview->selected_obj[0];
-      obj2 = qglview->selected_obj[1];
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_POINT) dist = (obj2.p1 - obj1.p1).norm();
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_LINE) dist = calculateLinePointDistance(obj2.p1, obj2.p2, obj1.p1, lat);
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_POINT) dist = calculateLinePointDistance(obj1.p1, obj1.p2, obj2.p1, lat);
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_LINE) dist = calculateSegSegDistance(obj1.p1, obj1.p2, obj2.p1, obj2.p2, lat);
-      if (!std::isnan(dist)) {
-        return QString("Distance is %1").arg(fabs(dist));
+    case MEASURE_DIST1:
+      if (qglview->selected_obj.size() == 1)
+        qglview->measure_state = MEASURE_DIST2;
+      break;
+    case MEASURE_DIST2:
+      if (qglview->selected_obj.size() == 2) {
+        double lat;
+        obj1 = qglview->selected_obj[0];
+        obj2 = qglview->selected_obj[1];
+        if (obj1.type == SelectionType::SELECTION_POINT &&
+            obj2.type == SelectionType::SELECTION_POINT)
+          dist = (obj2.p1 - obj1.p1).norm();
+        if (obj1.type == SelectionType::SELECTION_POINT &&
+            obj2.type == SelectionType::SELECTION_LINE)
+          dist = calculateLinePointDistance(obj2.p1, obj2.p2, obj1.p1, lat);
+        if (obj1.type == SelectionType::SELECTION_LINE &&
+            obj2.type == SelectionType::SELECTION_POINT)
+          dist = calculateLinePointDistance(obj1.p1, obj1.p2, obj2.p1, lat);
+        if (obj1.type == SelectionType::SELECTION_LINE &&
+            obj2.type == SelectionType::SELECTION_LINE)
+          dist =
+              calculateSegSegDistance(obj1.p1, obj1.p2, obj2.p1, obj2.p2, lat);
+        if (!std::isnan(dist)) {
+          return QString("Distance is %1").arg(fabs(dist));
+        }
+        stopMeasure();
       }
-      stopMeasure();
-    }
-    break;
-  case MEASURE_ANG1:
-    if (qglview->selected_obj.size() == 1) qglview->measure_state = MEASURE_ANG2;
-    break;
-  case MEASURE_ANG2:
-    if (qglview->selected_obj.size() == 2){
-      obj1 = qglview->selected_obj[0];
-      obj2 = qglview->selected_obj[1];
-      Vector3d side1, side2;
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_POINT){
-        side1 = (obj1.p2 - obj1.p1).normalized();
-        side2 = (obj1.p2 - obj2.p1).normalized();
-        ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
-        goto display_angle;
-      } else if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_LINE) {
-        side1 = (obj2.p2 - obj2.p1).normalized();
-        side2 = (obj2.p2 - obj1.p1).normalized();
-        ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
-        goto display_angle;
-      } else if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_LINE) {
-        // Check all 4 permutations of the lines' directions and use the one where the starting points are closest to one another as the corner point for the angle
-        double nearestDist = INFINITY;
-        auto permutation = [&nearestDist, &side1, &side2](const Vector3d& s1s, const Vector3d& s1e, const Vector3d& s2s, const Vector3d& s2e) {
+      break;
+    case MEASURE_ANG1:
+      if (qglview->selected_obj.size() == 1)
+        qglview->measure_state = MEASURE_ANG2;
+      break;
+    case MEASURE_ANG2:
+      if (qglview->selected_obj.size() == 2) {
+        obj1 = qglview->selected_obj[0];
+        obj2 = qglview->selected_obj[1];
+        Vector3d side1, side2;
+        if (obj1.type == SelectionType::SELECTION_LINE &&
+            obj2.type == SelectionType::SELECTION_POINT) {
+          side1 = (obj1.p2 - obj1.p1).normalized();
+          side2 = (obj1.p2 - obj2.p1).normalized();
+          ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+          goto display_angle;
+        } else if (obj1.type == SelectionType::SELECTION_POINT &&
+                   obj2.type == SelectionType::SELECTION_LINE) {
+          side1 = (obj2.p2 - obj2.p1).normalized();
+          side2 = (obj2.p2 - obj1.p1).normalized();
+          ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+          goto display_angle;
+        } else if (obj1.type == SelectionType::SELECTION_LINE &&
+                   obj2.type == SelectionType::SELECTION_LINE) {
+          // Check all 4 permutations of the lines' directions and use the one
+          // where the starting points are closest to one another as the corner
+          // point for the angle
+          double nearestDist = INFINITY;
+          auto permutation = [&nearestDist, &side1, &side2](
+                                 const Vector3d& s1s, const Vector3d& s1e,
+                                 const Vector3d& s2s, const Vector3d& s2e) {
             double dist = (s1s - s2s).squaredNorm();
             if (dist < nearestDist) {
               nearestDist = dist;
@@ -119,33 +132,36 @@ QString Measurement::statemachine(QPoint mouse)
             }
           };
 
-        permutation(obj1.p1, obj1.p2, obj2.p1, obj2.p2);
-        permutation(obj1.p2, obj1.p1, obj2.p1, obj2.p2);
-        permutation(obj1.p1, obj1.p2, obj2.p2, obj2.p1);
-        permutation(obj1.p2, obj1.p1, obj2.p2, obj2.p1);
+          permutation(obj1.p1, obj1.p2, obj2.p1, obj2.p2);
+          permutation(obj1.p2, obj1.p1, obj2.p1, obj2.p2);
+          permutation(obj1.p1, obj1.p2, obj2.p2, obj2.p1);
+          permutation(obj1.p2, obj1.p1, obj2.p2, obj2.p1);
 
-        ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
-        goto display_angle;
-      } else qglview->measure_state = MEASURE_ANG3;
-    }
-    break;
-  case MEASURE_ANG3:
-    if (qglview->selected_obj.size() == 3){
-      obj1 = qglview->selected_obj[0];
-      obj2 = qglview->selected_obj[1];
-      obj3 = qglview->selected_obj[2];
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_POINT && obj3.type == SelectionType::SELECTION_POINT){
-        Vector3d side1 = (obj2.p1 - obj1.p1).normalized();
-        Vector3d side2 = (obj2.p1 - obj3.p1).normalized();
-        ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+          ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+          goto display_angle;
+        } else
+          qglview->measure_state = MEASURE_ANG3;
       }
-display_angle:
-      if (!std::isnan(ang)){
-        return QString("Angle  is %1 Degrees").arg(ang);
+      break;
+    case MEASURE_ANG3:
+      if (qglview->selected_obj.size() == 3) {
+        obj1 = qglview->selected_obj[0];
+        obj2 = qglview->selected_obj[1];
+        obj3 = qglview->selected_obj[2];
+        if (obj1.type == SelectionType::SELECTION_POINT &&
+            obj2.type == SelectionType::SELECTION_POINT &&
+            obj3.type == SelectionType::SELECTION_POINT) {
+          Vector3d side1 = (obj2.p1 - obj1.p1).normalized();
+          Vector3d side2 = (obj2.p1 - obj3.p1).normalized();
+          ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+        }
+      display_angle:
+        if (!std::isnan(ang)) {
+          return QString("Angle  is %1 Degrees").arg(ang);
+        }
+        stopMeasure();
       }
-      stopMeasure();
-    }
-    break;
+      break;
   }
   return "";
 }
diff --git a/src/gui/Measurement.h b/src/gui/Measurement.h
index 21254b65a..4e3de2b7c 100644
--- a/src/gui/Measurement.h
+++ b/src/gui/Measurement.h
@@ -6,21 +6,39 @@
 #include "geometry/linalg.h"
 #include "gui/QGLView.h"
 
-enum { MEASURE_IDLE, MEASURE_DIST1, MEASURE_DIST2, MEASURE_ANG1, MEASURE_ANG2, MEASURE_ANG3 };
+enum {
+  MEASURE_IDLE,
+  MEASURE_DIST1,
+  MEASURE_DIST2,
+  MEASURE_ANG1,
+  MEASURE_ANG2,
+  MEASURE_ANG3
+};
 
-extern double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat);
-extern double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
-extern double calculateSegSegDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
+extern double calculateLinePointDistance(const Vector3d& l1,
+                                         const Vector3d& l2,
+                                         const Vector3d& pt,
+                                         double& dist_lat);
+extern double calculateLineLineDistance(const Vector3d& l1b,
+                                        const Vector3d& l1e,
+                                        const Vector3d& l2b,
+                                        const Vector3d& l2e,
+                                        double& dist_lat);
+extern double calculateSegSegDistance(const Vector3d& l1b,
+                                      const Vector3d& l1e,
+                                      const Vector3d& l2b,
+                                      const Vector3d& l2e,
+                                      double& dist_lat);
 
-class Measurement
-{
-public:
+class Measurement {
+ public:
   Measurement(void);
-  void setView(QGLView *qglview);
+  void setView(QGLView* qglview);
   QString statemachine(QPoint mouse);
   void startMeasureDist(void);
   void startMeasureAngle(void);
   void stopMeasure();
-private:
-  QGLView *qglview;
+
+ private:
+  QGLView* qglview;
 };
diff --git a/src/gui/MouseSelector.cc b/src/gui/MouseSelector.cc
index cbbb5df67..e00d89fad 100644
--- a/src/gui/MouseSelector.cc
+++ b/src/gui/MouseSelector.cc
@@ -1,33 +1,33 @@
 #include "gui/MouseSelector.h"
 
-#include "glview/system-gl.h"
 #include "glview/fbo.h"
+#include "glview/system-gl.h"
 
 #include <cstdint>
-#include <string>
 #include <memory>
+#include <string>
 /**
- * The selection is making use of a special shader, that renders each object in a color
- * that is derived from its index(), by using the first 24 bits of the identifier as a
- * 3-tuple for color.
+ * The selection is making use of a special shader, that renders each object in
+ * a color that is derived from its index(), by using the first 24 bits of the
+ * identifier as a 3-tuple for color.
  *
- * Roughly at most 1/3rd of the index()-es are rendered, therefore exhausting the keyspace
- * faster than expected.
- * If this ever becomes a problem, the index-mapping can be adjusted to use 10 up to 16 bit
- * per color channel to store the identifier.
- * Increasing this should be done carefully while testing on older graphics cards, they
- * might do "fancy" optimization.
+ * Roughly at most 1/3rd of the index()-es are rendered, therefore exhausting
+ * the keyspace faster than expected. If this ever becomes a problem, the
+ * index-mapping can be adjusted to use 10 up to 16 bit per color channel to
+ * store the identifier. Increasing this should be done carefully while testing
+ * on older graphics cards, they might do "fancy" optimization.
  */
 
-MouseSelector::MouseSelector(GLView *view) {
+MouseSelector::MouseSelector(GLView* view) {
   this->view = view;
-  if (view) this->reset(view);
+  if (view)
+    this->reset(view);
 }
 
 /**
  * Resize the framebuffer whenever it changed
  */
-void MouseSelector::reset(GLView *view) {
+void MouseSelector::reset(GLView* view) {
   this->view = view;
   this->setupFramebuffer(view->cam.pixel_width, view->cam.pixel_height);
 }
@@ -37,22 +37,28 @@ void MouseSelector::reset(GLView *view) {
  */
 void MouseSelector::initShader() {
   // Attributes:
-  // frag_idcolor - (uniform) 24 bit of the selected object's id encoded into R/G/B components as float values
+  // frag_idcolor - (uniform) 24 bit of the selected object's id encoded into
+  // R/G/B components as float values
   const auto selectshader = ShaderUtils::compileShaderProgram(
-    ShaderUtils::loadShaderSource("MouseSelector.vert"),
-    ShaderUtils::loadShaderSource("MouseSelector.frag"));
+      ShaderUtils::loadShaderSource("MouseSelector.vert"),
+      ShaderUtils::loadShaderSource("MouseSelector.frag"));
 
-  const GLint frag_idcolor = glGetUniformLocation(selectshader.shader_program, "frag_idcolor");
+  const GLint frag_idcolor =
+      glGetUniformLocation(selectshader.shader_program, "frag_idcolor");
   if (frag_idcolor < 0) {
     // TODO: Surface error better
-    fprintf(stderr, __FILE__ ": OpenGL symbol retrieval went wrong, id is %i\n\n", frag_idcolor);
+    fprintf(stderr,
+            __FILE__ ": OpenGL symbol retrieval went wrong, id is %i\n\n",
+            frag_idcolor);
   }
   this->shaderinfo = {
-    .resource = selectshader,
-    .type = ShaderUtils::ShaderType::SELECT_RENDERING,
-    .uniforms = {
-      {"frag_idcolor", glGetUniformLocation(selectshader.shader_program, "frag_idcolor")},
-    },
+      .resource = selectshader,
+      .type = ShaderUtils::ShaderType::SELECT_RENDERING,
+      .uniforms =
+          {
+              {"frag_idcolor", glGetUniformLocation(selectshader.shader_program,
+                                                    "frag_idcolor")},
+          },
   };
 }
 
@@ -60,8 +66,7 @@ void MouseSelector::initShader() {
  * Resize or create the framebuffer
  */
 void MouseSelector::setupFramebuffer(int width, int height) {
-  if (!this->framebuffer ||
-      this->framebuffer->width() != width ||
+  if (!this->framebuffer || this->framebuffer->width() != width ||
       this->framebuffer->height() != height) {
     this->framebuffer = createFBO(width, height);
     // We bind the framebuffer before initializing shaders since
@@ -74,12 +79,13 @@ void MouseSelector::setupFramebuffer(int width, int height) {
 
 /**
  * Setup the shaders, Projection and Model matrix and call the given renderer.
- * The renderer has to support rendering with ID colors (using the shader we provide),
- * otherwise the selection won't work.
+ * The renderer has to support rendering with ID colors (using the shader we
+ * provide), otherwise the selection won't work.
  *
- * returns index of picked node (AbstractNode::idx) or -1 if no object was found.
+ * returns index of picked node (AbstractNode::idx) or -1 if no object was
+ * found.
  */
-int MouseSelector::select(const Renderer *renderer, int x, int y) {
+int MouseSelector::select(const Renderer* renderer, int x, int y) {
   // This function should render a frame, as usual, with the following changes:
   // * Render to as custom framebuffer
   // * The shader should be the selector shader
@@ -87,7 +93,8 @@ int MouseSelector::select(const Renderer *renderer, int x, int y) {
   // * No lighting
   // * No decorations, like axes
 
-  // TODO: Ideally, we should make the above configurable and reduce duplicate render code in this function.
+  // TODO: Ideally, we should make the above configurable and reduce duplicate
+  // render code in this function.
 
   const int width = this->view->cam.pixel_width;
   const int height = this->view->cam.pixel_height;
@@ -96,10 +103,10 @@ int MouseSelector::select(const Renderer *renderer, int x, int y) {
   }
 
   // Initialize GL to draw to texture
-  // Ideally a texture of only 1x1 or 2x2 pixels as a subset of the viewing frustrum
-  // of the currently selected frame.
-  // For now, i will use a texture the same size as the normal viewport
-  // and select the identifier at the mouse coordinates
+  // Ideally a texture of only 1x1 or 2x2 pixels as a subset of the viewing
+  // frustrum of the currently selected frame. For now, i will use a texture the
+  // same size as the normal viewport and select the identifier at the mouse
+  // coordinates
   GL_CHECKD(this->framebuffer->bind());
 
   glClearColor(0, 0, 0, 1.0);
@@ -125,11 +132,12 @@ int MouseSelector::select(const Renderer *renderer, int x, int y) {
   glFinish();
 
   // Grab the color from the framebuffer and convert it back to an identifier
-  GLubyte color[3] = { 0 };
+  GLubyte color[3] = {0};
   // Qt position is originated top-left, so flip y to get GL coordinates.
   GL_CHECKD(glReadPixels(x, height - y, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, color));
 
-  const int index = (uint32_t)color[0] | ((uint32_t)color[1] << 8) | ((uint32_t)color[2] << 16);
+  const int index = (uint32_t)color[0] | ((uint32_t)color[1] << 8) |
+                    ((uint32_t)color[2] << 16);
 
   // Switch the active framebuffer back to the default
   this->framebuffer->unbind();
diff --git a/src/gui/MouseSelector.h b/src/gui/MouseSelector.h
index dbfc6a8b5..1dbfbeb5c 100644
--- a/src/gui/MouseSelector.h
+++ b/src/gui/MouseSelector.h
@@ -9,23 +9,22 @@
 /**
  * Grab the of the Tree element that was rendered at a specific location
  */
-class MouseSelector
-{
-public:
-  MouseSelector(GLView *view);
+class MouseSelector {
+ public:
+  MouseSelector(GLView* view);
 
   /// Resize the renderbuffer
-  void reset(GLView *view);
+  void reset(GLView* view);
 
-  int select(const Renderer *renderer, int x, int y);
+  int select(const Renderer* renderer, int x, int y);
 
   ShaderUtils::ShaderInfo shaderinfo;
 
-private:
+ private:
   void initShader();
   void setupFramebuffer(int width, int height);
 
   std::unique_ptr<FBO> framebuffer;
 
-  GLView *view;
+  GLView* view;
 };
diff --git a/src/gui/Network.h b/src/gui/Network.h
index 70db4f4e5..bfdb0a07e 100644
--- a/src/gui/Network.h
+++ b/src/gui/Network.h
@@ -30,61 +30,69 @@
 #include <QNetworkAccessManager>
 #include <QNetworkReply>
 #include <QNetworkRequest>
-#include <QTimer>
-#include <algorithm>
-#include <functional>
-#include <exception>
 #include <QObject>
 #include <QString>
+#include <QTimer>
 #include <QtNetwork>
+#include <algorithm>
+#include <exception>
+#include <functional>
 
-#include <utility>
 #include <string>
+#include <utility>
 #include <vector>
 
-#include "utils/printutils.h"
-#include "platform/PlatformUtils.h"
 #include "gui/NetworkSignal.h"
+#include "platform/PlatformUtils.h"
+#include "utils/printutils.h"
 
-class NetworkException : public std::exception
-{
-public:
-  NetworkException(const QNetworkReply::NetworkError& error, const QString& errorMessage) : error(error), errorMessage(errorMessage.toStdString()) { }
+class NetworkException : public std::exception {
+ public:
+  NetworkException(const QNetworkReply::NetworkError& error,
+                   const QString& errorMessage)
+      : error(error), errorMessage(errorMessage.toStdString()) {}
 
   const QNetworkReply::NetworkError& getError() const { return error; }
   const std::string& getErrorMessage() const { return errorMessage; }
 
-  const char *what() const noexcept override
-  {
-    return errorMessage.c_str();
-  }
+  const char* what() const noexcept override { return errorMessage.c_str(); }
 
-private:
+ private:
   QNetworkReply::NetworkError error;
   std::string errorMessage;
 };
 
-using network_progress_func_t = std::function<bool (double)>;
+using network_progress_func_t = std::function<bool(double)>;
 
 template <typename ResultType>
-class NetworkRequest
-{
-public:
-  using setup_func_t = std::function<void (QNetworkRequest&)>;
-  using reply_func_t = std::function<QNetworkReply *(QNetworkAccessManager&, QNetworkRequest&)>;
-  using transform_func_t = std::function<ResultType (QNetworkReply *)>;
-  using error_func_t = std::function<ResultType (QNetworkReply *)>;
-
-  NetworkRequest(QUrl url, std::vector<int> accepted_codes, const int timeout_seconds)
-    : url(std::move(url)), accepted_codes(std::move(accepted_codes)), timeout_seconds(timeout_seconds)
-  { }
+class NetworkRequest {
+ public:
+  using setup_func_t = std::function<void(QNetworkRequest&)>;
+  using reply_func_t =
+      std::function<QNetworkReply*(QNetworkAccessManager&, QNetworkRequest&)>;
+  using transform_func_t = std::function<ResultType(QNetworkReply*)>;
+  using error_func_t = std::function<ResultType(QNetworkReply*)>;
+
+  NetworkRequest(QUrl url,
+                 std::vector<int> accepted_codes,
+                 const int timeout_seconds)
+      : url(std::move(url)),
+        accepted_codes(std::move(accepted_codes)),
+        timeout_seconds(timeout_seconds) {}
   virtual ~NetworkRequest() = default;
 
-  void set_progress_func(const network_progress_func_t& progress_func) { this->progress_func = progress_func; }
-  ResultType execute(const setup_func_t& setup_func, const reply_func_t& reply_func, const transform_func_t& transform_func);
-  ResultType execute(const setup_func_t& setup_func, const reply_func_t& reply_func, const transform_func_t& transform_func, const error_func_t& error_func);
-
-private:
+  void set_progress_func(const network_progress_func_t& progress_func) {
+    this->progress_func = progress_func;
+  }
+  ResultType execute(const setup_func_t& setup_func,
+                     const reply_func_t& reply_func,
+                     const transform_func_t& transform_func);
+  ResultType execute(const setup_func_t& setup_func,
+                     const reply_func_t& reply_func,
+                     const transform_func_t& transform_func,
+                     const error_func_t& error_func);
+
+ private:
   QUrl url;
   std::vector<int> accepted_codes;
   int timeout_seconds;
@@ -93,33 +101,34 @@ private:
 
 template <typename ResultType>
 ResultType NetworkRequest<ResultType>::execute(
-  const NetworkRequest::setup_func_t& setup_func,
-  const NetworkRequest::reply_func_t& reply_func,
-  const NetworkRequest::transform_func_t& transform_func)
-{
-  return execute(setup_func, reply_func, transform_func, [](QNetworkReply *reply) -> ResultType {
-    throw NetworkException{reply->error(), reply->errorString()};
-  });
+    const NetworkRequest::setup_func_t& setup_func,
+    const NetworkRequest::reply_func_t& reply_func,
+    const NetworkRequest::transform_func_t& transform_func) {
+  return execute(setup_func, reply_func, transform_func,
+                 [](QNetworkReply* reply) -> ResultType {
+                   throw NetworkException{reply->error(), reply->errorString()};
+                 });
 }
 
 template <typename ResultType>
 ResultType NetworkRequest<ResultType>::execute(
-  const NetworkRequest::setup_func_t& setup_func,
-  const NetworkRequest::reply_func_t& reply_func,
-  const NetworkRequest::transform_func_t& transform_func,
-  const NetworkRequest::error_func_t& error_func)
-{
+    const NetworkRequest::setup_func_t& setup_func,
+    const NetworkRequest::reply_func_t& reply_func,
+    const NetworkRequest::transform_func_t& transform_func,
+    const NetworkRequest::error_func_t& error_func) {
   QNetworkRequest request(url);
-  request.setHeader(QNetworkRequest::UserAgentHeader, QString::fromStdString(PlatformUtils::user_agent()));
+  request.setHeader(QNetworkRequest::UserAgentHeader,
+                    QString::fromStdString(PlatformUtils::user_agent()));
   setup_func(request);
 
   QNetworkAccessManager nam;
-  QNetworkReply *reply = reply_func(nam, request);
+  QNetworkReply* reply = reply_func(nam, request);
 
   QTimer timer;
   QEventLoop loop;
   NetworkSignal forwarder{nullptr, [&](qint64 bytesSent, qint64 bytesTotal) {
-                            const double permille = (1000.0 * bytesSent) / bytesTotal;
+                            const double permille =
+                                (1000.0 * bytesSent) / bytesTotal;
                             timer.start();
                             if (progress_func && progress_func(permille)) {
                               reply->abort();
@@ -127,7 +136,8 @@ ResultType NetworkRequest<ResultType>::execute(
                           }};
   QObject::connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);
   QObject::connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
-  QObject::connect(reply, &QNetworkReply::uploadProgress, &forwarder, &NetworkSignal::network_progress);
+  QObject::connect(reply, &QNetworkReply::uploadProgress, &forwarder,
+                   &NetworkSignal::network_progress);
   timer.setSingleShot(true);
   timer.start(timeout_seconds * 1000);
   loop.exec();
@@ -148,9 +158,13 @@ ResultType NetworkRequest<ResultType>::execute(
   if (reply->error() != QNetworkReply::NoError) {
     return error_func(reply);
   } else {
-    const auto statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    if (std::find(accepted_codes.begin(), accepted_codes.end(), statusCode) == accepted_codes.end()) {
-      QString reason = reply->attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString();
+    const auto statusCode =
+        reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+    if (std::find(accepted_codes.begin(), accepted_codes.end(), statusCode) ==
+        accepted_codes.end()) {
+      QString reason =
+          reply->attribute(QNetworkRequest::HttpReasonPhraseAttribute)
+              .toString();
       throw NetworkException{QNetworkReply::ProtocolFailure, reason};
     }
   }
diff --git a/src/gui/NetworkSignal.h b/src/gui/NetworkSignal.h
index f51832ed5..133918586 100644
--- a/src/gui/NetworkSignal.h
+++ b/src/gui/NetworkSignal.h
@@ -31,23 +31,24 @@
 #include <QObject>
 #include <utility>
 
-using network_progress_func_t = std::function<bool (double)>;
+using network_progress_func_t = std::function<bool(double)>;
 
-class NetworkSignal : public QObject
-{
+class NetworkSignal : public QObject {
   Q_OBJECT;
 
-  using callback_t = std::function<void (qint64, qint64)>;
+  using callback_t = std::function<void(qint64, qint64)>;
 
-  NetworkSignal(QObject *parent, callback_t callback) : QObject(parent), callback(std::move(callback)) { }
+  NetworkSignal(QObject* parent, callback_t callback)
+      : QObject(parent), callback(std::move(callback)) {}
 
-public slots:
+ public slots:
   void network_progress(qint64 bytesSent, qint64 bytesTotal) {
     callback(bytesSent, bytesTotal);
   }
 
-private:
+ private:
   callback_t callback;
 
-  template <typename T> friend class NetworkRequest;
+  template <typename T>
+  friend class NetworkRequest;
 };
diff --git a/src/gui/OctoPrint.cc b/src/gui/OctoPrint.cc
index eed99045d..97a5a8329 100644
--- a/src/gui/OctoPrint.cc
+++ b/src/gui/OctoPrint.cc
@@ -39,55 +39,56 @@
 #include <vector>
 
 #include "core/Settings.h"
-#include "utils/printutils.h"
 #include "platform/PlatformUtils.h"
+#include "utils/printutils.h"
 
-const QString OctoPrint::url() const
-{
+const QString OctoPrint::url() const {
   return QString::fromStdString(Settings::Settings::octoPrintUrl.value());
 }
 
-const std::string OctoPrint::apiKey() const
-{
+const std::string OctoPrint::apiKey() const {
   return Settings::Settings::octoPrintApiKey.value();
 }
 
-const QJsonDocument OctoPrint::getJsonData(const QString& endpoint) const
-{
+const QJsonDocument OctoPrint::getJsonData(const QString& endpoint) const {
   if (url().trimmed().isEmpty()) {
-    throw NetworkException{QNetworkReply::ProtocolFailure, "OctoPrint URL not configured."};
+    throw NetworkException{QNetworkReply::ProtocolFailure,
+                           "OctoPrint URL not configured."};
   }
 
-  auto networkRequest = NetworkRequest<const QJsonDocument>{QUrl{url() + endpoint}, { 200 }, 30};
+  auto networkRequest =
+      NetworkRequest<const QJsonDocument>{QUrl{url() + endpoint}, {200}, 30};
 
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.get(request);
-  },
-    [](QNetworkReply *reply) -> const QJsonDocument {
-    auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    return doc;
-  }
-    );
+      [&](QNetworkRequest& request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+        request.setRawHeader(QByteArray{"X-Api-Key"},
+                             QByteArray{apiKey().c_str()});
+      },
+      [](QNetworkAccessManager& nam, QNetworkRequest& request) {
+        return nam.get(request);
+      },
+      [](QNetworkReply* reply) -> const QJsonDocument {
+        auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+        return doc;
+      });
 }
 
-const std::vector<std::pair<const QString, const QString>> OctoPrint::getSlicers() const
-{
+const std::vector<std::pair<const QString, const QString>>
+OctoPrint::getSlicers() const {
   const auto obj = getJsonData("/slicing").object();
   std::vector<std::pair<const QString, const QString>> slicers;
   for (const auto& key : obj.keys()) {
-    slicers.emplace_back(std::make_pair(key, obj[key].toObject().value("displayName").toString()));
+    slicers.emplace_back(std::make_pair(
+        key, obj[key].toObject().value("displayName").toString()));
   }
   return slicers;
 }
 
-const std::vector<std::pair<const QString, const QString>> OctoPrint::getProfiles(const QString& slicer) const
-{
+const std::vector<std::pair<const QString, const QString>>
+OctoPrint::getProfiles(const QString& slicer) const {
   const auto obj = getJsonData("/slicing").object();
   std::vector<std::pair<const QString, const QString>> profiles;
   for (const auto& key : obj.keys()) {
@@ -97,7 +98,10 @@ const std::vector<std::pair<const QString, const QString>> OctoPrint::getProfile
     if ((slicer == name) || (slicer.isEmpty() && isDefault)) {
       const auto profilesObject = entry.value("profiles").toObject();
       for (const auto& profileKey : profilesObject.keys()) {
-        const auto displayName = profilesObject[profileKey].toObject().value("displayName").toString();
+        const auto displayName = profilesObject[profileKey]
+                                     .toObject()
+                                     .value("displayName")
+                                     .toString();
         profiles.emplace_back(std::make_pair(profileKey, displayName));
       }
       break;
@@ -106,8 +110,7 @@ const std::vector<std::pair<const QString, const QString>> OctoPrint::getProfile
   return profiles;
 }
 
-const std::pair<const QString, const QString> OctoPrint::getVersion() const
-{
+const std::pair<const QString, const QString> OctoPrint::getVersion() const {
   const auto obj = getJsonData("/version").object();
   const auto api_version = obj.value("api").toString();
   const auto server_version = obj.value("server").toString();
@@ -115,90 +118,104 @@ const std::pair<const QString, const QString> OctoPrint::getVersion() const
   return result;
 }
 
-const QString OctoPrint::requestApiKey() const
-{
+const QString OctoPrint::requestApiKey() const {
   QJsonObject jsonInput;
   jsonInput.insert("app", QString{"OpenSCAD"});
 
-  auto networkRequest = NetworkRequest<QString>{QUrl{url() + "/../plugin/appkeys/request"}, { 201 }, 30};
+  auto networkRequest = NetworkRequest<QString>{
+      QUrl{url() + "/../plugin/appkeys/request"}, {201}, 30};
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) -> QString {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    const auto obj = doc.object();
-    const auto token = obj.value("app_token").toString();
-    return token;
-  }
-    );
+      [&](QNetworkRequest& request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+      },
+      [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
+        return nam.post(request, QJsonDocument(jsonInput).toJson());
+      },
+      [](QNetworkReply* reply) -> QString {
+        const auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+        const auto obj = doc.object();
+        const auto token = obj.value("app_token").toString();
+        return token;
+      });
 }
 
-const std::pair<int, QString> OctoPrint::pollApiKeyApproval(const QString& token) const
-{
-  auto networkRequest = NetworkRequest<std::pair<int, QString>>{QUrl{url() + "/../plugin/appkeys/request/" + token}, { 200, 202, 404 }, 30};
+const std::pair<int, QString> OctoPrint::pollApiKeyApproval(
+    const QString& token) const {
+  auto networkRequest = NetworkRequest<std::pair<int, QString>>{
+      QUrl{url() + "/../plugin/appkeys/request/" + token}, {200, 202, 404}, 30};
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.get(request);
-  },
-    [](QNetworkReply *reply) -> std::pair<int, QString> {
-    const auto code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    PRINTDB("Response Code: %d", code);
-    const auto obj = QJsonDocument::fromJson(reply->readAll()).object();
-    return std::make_pair(code, obj.value("api_key").toString());
-  },
-    [](QNetworkReply *reply) -> std::pair<int, QString> {
-    const auto code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    PRINTDB("Response (Error) Code: %d", code);
-    return std::make_pair(code, "");
-  }
-    );
+      [&](QNetworkRequest& request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+      },
+      [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
+        return nam.get(request);
+      },
+      [](QNetworkReply* reply) -> std::pair<int, QString> {
+        const auto code =
+            reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+        PRINTDB("Response Code: %d", code);
+        const auto obj = QJsonDocument::fromJson(reply->readAll()).object();
+        return std::make_pair(code, obj.value("api_key").toString());
+      },
+      [](QNetworkReply* reply) -> std::pair<int, QString> {
+        const auto code =
+            reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+        PRINTDB("Response (Error) Code: %d", code);
+        return std::make_pair(code, "");
+      });
 }
 
-const QString OctoPrint::upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const {
-
-  auto *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);
+const QString OctoPrint::upload(
+    const QString& exportFileName,
+    const QString& fileName,
+    const network_progress_func_t& progress_func) const {
+  auto* multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);
   QHttpPart filePart;
-  filePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant{R"(form-data; name="file"; filename=")" + fileName + "\""});
-  filePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant{"application/octet-stream"});
+  filePart.setHeader(
+      QNetworkRequest::ContentDispositionHeader,
+      QVariant{R"(form-data; name="file"; filename=")" + fileName + "\""});
+  filePart.setHeader(QNetworkRequest::ContentTypeHeader,
+                     QVariant{"application/octet-stream"});
 
-  auto *file = new QFile(exportFileName, multiPart);
+  auto* file = new QFile(exportFileName, multiPart);
   file->open(QIODevice::ReadOnly);
   filePart.setBodyDevice(file);
 
   multiPart->append(filePart);
 
-  auto networkRequest = NetworkRequest<const QString>{QUrl{url() + "/files/local"}, { 200, 201 }, 180};
+  auto networkRequest = NetworkRequest<const QString>{
+      QUrl{url() + "/files/local"}, {200, 201}, 180};
   networkRequest.set_progress_func(progress_func);
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::UserAgentHeader, QString::fromStdString(PlatformUtils::user_agent()));
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    const auto reply = nam.post(request, multiPart);
-    multiPart->setParent(reply);
-    return reply;
-  },
-    [](QNetworkReply *reply) -> const QString {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    auto location = reply->header(QNetworkRequest::LocationHeader).toString();
-    LOG("Uploaded successfully to %1$s", location.toStdString());
-    return location;
-  }
-    );
+      [&](QNetworkRequest& request) {
+        request.setHeader(QNetworkRequest::UserAgentHeader,
+                          QString::fromStdString(PlatformUtils::user_agent()));
+        request.setRawHeader(QByteArray{"X-Api-Key"},
+                             QByteArray{apiKey().c_str()});
+      },
+      [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
+        const auto reply = nam.post(request, multiPart);
+        multiPart->setParent(reply);
+        return reply;
+      },
+      [](QNetworkReply* reply) -> const QString {
+        const auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+        auto location =
+            reply->header(QNetworkRequest::LocationHeader).toString();
+        LOG("Uploaded successfully to %1$s", location.toStdString());
+        return location;
+      });
 }
 
-void OctoPrint::slice(const QString& fileUrl, const QString& slicer, const QString& profile, const bool select, const bool print) const
-{
+void OctoPrint::slice(const QString& fileUrl,
+                      const QString& slicer,
+                      const QString& profile,
+                      const bool select,
+                      const bool print) const {
   QJsonObject jsonInput;
   jsonInput.insert("command", QString{"slice"});
   jsonInput.insert("slicer", slicer);
@@ -206,19 +223,20 @@ void OctoPrint::slice(const QString& fileUrl, const QString& slicer, const QStri
   jsonInput.insert("select", QString{select ? "true" : "false"});
   jsonInput.insert("print", QString{print ? "true" : "false"});
 
-  auto networkRequest = NetworkRequest<void>{QUrl{fileUrl}, { 200, 202 }, 30};
+  auto networkRequest = NetworkRequest<void>{QUrl{fileUrl}, {200, 202}, 30};
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    LOG("Slice command successfully executed.");
-  }
-    );
+      [&](QNetworkRequest& request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+        request.setRawHeader(QByteArray{"X-Api-Key"},
+                             QByteArray{apiKey().c_str()});
+      },
+      [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
+        return nam.post(request, QJsonDocument(jsonInput).toJson());
+      },
+      [](QNetworkReply* reply) {
+        const auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+        LOG("Slice command successfully executed.");
+      });
 }
diff --git a/src/gui/OctoPrint.h b/src/gui/OctoPrint.h
index b4f39e82c..d462425fb 100644
--- a/src/gui/OctoPrint.h
+++ b/src/gui/OctoPrint.h
@@ -26,19 +26,18 @@
 
 #pragma once
 
-#include <utility>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include <QFile>
-#include <QString>
 #include <QJsonDocument>
+#include <QString>
 
 #include "gui/Network.h"
 
-class OctoPrint
-{
-public:
+class OctoPrint {
+ public:
   OctoPrint() = default;
   virtual ~OctoPrint() = default;
 
@@ -48,10 +47,17 @@ public:
   const QString requestApiKey() const;
   const std::pair<int, QString> pollApiKeyApproval(const QString& token) const;
   const std::vector<std::pair<const QString, const QString>> getSlicers() const;
-  const std::vector<std::pair<const QString, const QString>> getProfiles(const QString& slicer) const;
-  const QString upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const;
-  void slice(const QString& fileUrl, const QString& slicer, const QString& profile, const bool select, const bool print) const;
+  const std::vector<std::pair<const QString, const QString>> getProfiles(
+      const QString& slicer) const;
+  const QString upload(const QString& exportFileName,
+                       const QString& fileName,
+                       const network_progress_func_t& progress_func) const;
+  void slice(const QString& fileUrl,
+             const QString& slicer,
+             const QString& profile,
+             const bool select,
+             const bool print) const;
 
-private:
+ private:
   const QJsonDocument getJsonData(const QString& endpoint) const;
 };
diff --git a/src/gui/OctoPrintApiKeyDialog.cc b/src/gui/OctoPrintApiKeyDialog.cc
index 5495bdc68..014ebcd0b 100644
--- a/src/gui/OctoPrintApiKeyDialog.cc
+++ b/src/gui/OctoPrintApiKeyDialog.cc
@@ -26,35 +26,36 @@
 
 #include "gui/OctoPrintApiKeyDialog.h"
 
-#include <QString>
 #include <QCheckBox>
 #include <QColor>
-#include <QDialog>
 #include <QColorDialog>
+#include <QDialog>
 #include <QLineEdit>
-#include <QSvgRenderer>
-#include <QPalette>
 #include <QPainter>
+#include <QPalette>
+#include <QString>
+#include <QSvgRenderer>
 
 #include "OctoPrint.h"
 
-OctoPrintApiKeyDialog::OctoPrintApiKeyDialog()
-{
+OctoPrintApiKeyDialog::OctoPrintApiKeyDialog() {
   setupUi(this);
-  QObject::connect(&networkTimer, &QTimer::timeout, this, &OctoPrintApiKeyDialog::timeout);
-  QObject::connect(&animationTimer, &QTimer::timeout, this, &OctoPrintApiKeyDialog::animationUpdate);
+  QObject::connect(&networkTimer, &QTimer::timeout, this,
+                   &OctoPrintApiKeyDialog::timeout);
+  QObject::connect(&animationTimer, &QTimer::timeout, this,
+                   &OctoPrintApiKeyDialog::animationUpdate);
 
   this->iconOk = QIcon::fromTheme("chokusen-circle-checkmark");
   this->iconError = QIcon::fromTheme("chokusen-circle-error");
   this->iconWaiting = QIcon::fromTheme("chokusen-loading");
 }
 
-void OctoPrintApiKeyDialog::startRequest()
-{
+void OctoPrintApiKeyDialog::startRequest() {
   OctoPrint octoPrint;
   this->token = octoPrint.requestApiKey();
   this->apiKey.clear();
-  this->labelMessage->setText(_("API key created, waiting for approval in OctoPrint..."));
+  this->labelMessage->setText(
+      _("API key created, waiting for approval in OctoPrint..."));
   networkTimer.setSingleShot(true);
   networkTimer.start(1000);
   animationTimer.setInterval(100);
@@ -63,73 +64,69 @@ void OctoPrintApiKeyDialog::startRequest()
   this->pushButtonRetry->setEnabled(false);
 }
 
-void OctoPrintApiKeyDialog::paintIcon(const QIcon& icon, const qreal rotation)
-{
+void OctoPrintApiKeyDialog::paintIcon(const QIcon& icon, const qreal rotation) {
   QPalette palette;
-  QImage image(this->labelIcon->width(), this->labelIcon->width(), QImage::Format_ARGB32);
+  QImage image(this->labelIcon->width(), this->labelIcon->width(),
+               QImage::Format_ARGB32);
   image.fill(0x000000ff);
   QPainter painter(&image);
-  painter.translate(QPoint{this->labelIcon->width() / 2, this->labelIcon->width() / 2});
+  painter.translate(
+      QPoint{this->labelIcon->width() / 2, this->labelIcon->width() / 2});
   painter.rotate(rotation);
-  painter.translate(QPoint{-this->labelIcon->width() / 2, -this->labelIcon->width() / 2});
+  painter.translate(
+      QPoint{-this->labelIcon->width() / 2, -this->labelIcon->width() / 2});
   icon.paint(&painter, image.rect());
   QPixmap pixmap = QPixmap::fromImage(image);
   this->labelIcon->setPixmap(QPixmap::fromImage(image));
 }
 
-void OctoPrintApiKeyDialog::timeout()
-{
+void OctoPrintApiKeyDialog::timeout() {
   OctoPrint octoPrint;
   const auto [code, apiKey] = octoPrint.pollApiKeyApproval(this->token);
   switch (code) {
-  case 200:
-    this->token.clear();
-    this->apiKey = apiKey;
-    this->labelMessage->setText(_("API key approved."));
-    animationTimer.stop();
-    paintIcon(this->iconOk);
-    this->pushButtonOk->setEnabled(true);
-    break;
-  case 202:
-    networkTimer.start(1000);
-    break;
-  case 404:
-  default:
-    this->token.clear();
-    this->apiKey.clear();
-    this->labelMessage->setText(_("API key approval failed."));
-    animationTimer.stop();
-    paintIcon(this->iconError);
-    this->pushButtonRetry->setEnabled(true);
-    break;
+    case 200:
+      this->token.clear();
+      this->apiKey = apiKey;
+      this->labelMessage->setText(_("API key approved."));
+      animationTimer.stop();
+      paintIcon(this->iconOk);
+      this->pushButtonOk->setEnabled(true);
+      break;
+    case 202:
+      networkTimer.start(1000);
+      break;
+    case 404:
+    default:
+      this->token.clear();
+      this->apiKey.clear();
+      this->labelMessage->setText(_("API key approval failed."));
+      animationTimer.stop();
+      paintIcon(this->iconError);
+      this->pushButtonRetry->setEnabled(true);
+      break;
   }
 }
 
-void OctoPrintApiKeyDialog::animationUpdate()
-{
+void OctoPrintApiKeyDialog::animationUpdate() {
   static qreal rotation = 0.0;
   paintIcon(this->iconWaiting, rotation);
   rotation += 30;
 }
 
-int OctoPrintApiKeyDialog::exec()
-{
+int OctoPrintApiKeyDialog::exec() {
   startRequest();
   return QDialog::exec();
 }
 
-void OctoPrintApiKeyDialog::on_pushButtonRetry_clicked()
-{
+void OctoPrintApiKeyDialog::on_pushButtonRetry_clicked() {
   startRequest();
 }
 
-void OctoPrintApiKeyDialog::on_pushButtonOk_clicked()
-{
+void OctoPrintApiKeyDialog::on_pushButtonOk_clicked() {
   accept();
 }
 
-void OctoPrintApiKeyDialog::on_pushButtonCancel_clicked()
-{
+void OctoPrintApiKeyDialog::on_pushButtonCancel_clicked() {
   this->token.clear();
   this->apiKey.clear();
   reject();
diff --git a/src/gui/OctoPrintApiKeyDialog.h b/src/gui/OctoPrintApiKeyDialog.h
index 78b1b3a8a..8d1a6452d 100644
--- a/src/gui/OctoPrintApiKeyDialog.h
+++ b/src/gui/OctoPrintApiKeyDialog.h
@@ -26,32 +26,31 @@
 
 #pragma once
 
-#include <QIcon>
-#include <QTimer>
 #include <QDialog>
+#include <QIcon>
 #include <QString>
+#include <QTimer>
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "gui/qtgettext.h"  // IWYU pragma: keep
 #include "ui_OctoPrintApiKeyDialog.h"
 
-class OctoPrintApiKeyDialog : public QDialog, public Ui::OctoPrintApiKeyDialog
-{
+class OctoPrintApiKeyDialog : public QDialog, public Ui::OctoPrintApiKeyDialog {
   Q_OBJECT;
 
-public:
+ public:
   OctoPrintApiKeyDialog();
 
   int exec() override;
   const QString& getApiKey() const { return apiKey; }
 
-private slots:
+ private slots:
   void timeout();
   void animationUpdate();
   void on_pushButtonRetry_clicked();
   void on_pushButtonOk_clicked();
   void on_pushButtonCancel_clicked();
 
-private:
+ private:
   void startRequest();
   void paintIcon(const QIcon& icon, const qreal rotation = 0.0);
 
diff --git a/src/gui/OpenCSGWarningDialog.cc b/src/gui/OpenCSGWarningDialog.cc
index 642f858c1..767aefe03 100644
--- a/src/gui/OpenCSGWarningDialog.cc
+++ b/src/gui/OpenCSGWarningDialog.cc
@@ -3,18 +3,15 @@
 #include <QWidget>
 #include "gui/Preferences.h"
 
-OpenCSGWarningDialog::OpenCSGWarningDialog(QWidget *)
-{
+OpenCSGWarningDialog::OpenCSGWarningDialog(QWidget*) {
   setupUi(this);
 
   connect(this->showBox, &QCheckBox::toggled,
           GlobalPreferences::inst()->openCSGWarningBox, &QCheckBox::setChecked);
-  connect(this->showBox, &QCheckBox::toggled,
-          GlobalPreferences::inst(), &Preferences::on_openCSGWarningBox_toggled);
+  connect(this->showBox, &QCheckBox::toggled, GlobalPreferences::inst(),
+          &Preferences::on_openCSGWarningBox_toggled);
 }
 
-void OpenCSGWarningDialog::setText(const QString& text)
-{
+void OpenCSGWarningDialog::setText(const QString& text) {
   this->warningText->setPlainText(text);
 }
-
diff --git a/src/gui/OpenCSGWarningDialog.h b/src/gui/OpenCSGWarningDialog.h
index 0a58e0090..223b7023c 100644
--- a/src/gui/OpenCSGWarningDialog.h
+++ b/src/gui/OpenCSGWarningDialog.h
@@ -1,16 +1,16 @@
 #pragma once
 
-#include "gui/qtgettext.h"
 #include <QDialog>
 #include <QWidget>
+#include "gui/qtgettext.h"
 #include "ui_OpenCSGWarningDialog.h"
 
-class OpenCSGWarningDialog : public QDialog, public Ui::OpenCSGWarningDialog
-{
+class OpenCSGWarningDialog : public QDialog, public Ui::OpenCSGWarningDialog {
   Q_OBJECT;
-public:
-  OpenCSGWarningDialog(QWidget *parent);
 
-public slots:
+ public:
+  OpenCSGWarningDialog(QWidget* parent);
+
+ public slots:
   void setText(const QString& text);
 };
diff --git a/src/gui/OpenSCADApp.cc b/src/gui/OpenSCADApp.cc
index 2f9b07ee8..859cc5851 100644
--- a/src/gui/OpenSCADApp.cc
+++ b/src/gui/OpenSCADApp.cc
@@ -7,31 +7,27 @@
 #include <QApplication>
 #include <QEvent>
 #include <QObject>
+#include <QProgressDialog>
 #include <QString>
 #include <QStringList>
+#include <boost/foreach.hpp>
 #include <cassert>
 #include <exception>
-#include <QProgressDialog>
-#include <boost/foreach.hpp>
 #include "gui/QSettingsCached.h"
 
-OpenSCADApp::OpenSCADApp(int& argc, char **argv)
-  : QApplication(argc, argv)
-{
+OpenSCADApp::OpenSCADApp(int& argc, char** argv) : QApplication(argc, argv) {
 #ifdef Q_OS_MACOS
   this->installEventFilter(new SCADEventFilter(this));
 #endif
 }
 
-OpenSCADApp::~OpenSCADApp()
-{
+OpenSCADApp::~OpenSCADApp() {
   delete this->fontCacheDialog;
 }
 
 #include <QMessageBox>
 
-bool OpenSCADApp::notify(QObject *object, QEvent *event)
-{
+bool OpenSCADApp::notify(QObject* object, QEvent* event) {
   QString msg;
   try {
     return QApplication::notify(object, event);
@@ -41,15 +37,18 @@ bool OpenSCADApp::notify(QObject *object, QEvent *event)
     msg = _("Unknown error");
   }
   // This happens when an uncaught exception is thrown in a Qt event handler
-  QMessageBox::critical(nullptr, QString(_("Critical Error")), QString(_("A critical error was caught. The application may have become unstable:\n%1")).arg(QString(msg)));
+  QMessageBox::critical(nullptr, QString(_("Critical Error")),
+                        QString(_("A critical error was caught. The "
+                                  "application may have become unstable:\n%1"))
+                            .arg(QString(msg)));
   return false;
 }
 
 /*!
-   Requests to open a file from an external event, e.g. by double-clicking a filename.
+   Requests to open a file from an external event, e.g. by double-clicking a
+   filename.
  */
-void OpenSCADApp::requestOpenFile(const QString& filename)
-{
+void OpenSCADApp::requestOpenFile(const QString& filename) {
   for (auto win : this->windowManager.getWindows()) {
     // if we have an empty open window, use that one
     if (win->isEmpty()) {
@@ -62,18 +61,19 @@ void OpenSCADApp::requestOpenFile(const QString& filename)
   new MainWindow(QStringList(filename));
 }
 
-void OpenSCADApp::showFontCacheDialog()
-{
-  if (!this->fontCacheDialog) this->fontCacheDialog = new QProgressDialog();
-  this->fontCacheDialog->setLabelText(_("Fontconfig needs to update its font cache.\nThis can take up to a couple of minutes."));
+void OpenSCADApp::showFontCacheDialog() {
+  if (!this->fontCacheDialog)
+    this->fontCacheDialog = new QProgressDialog();
+  this->fontCacheDialog->setLabelText(
+      _("Fontconfig needs to update its font cache.\nThis can take up to a "
+        "couple of minutes."));
   this->fontCacheDialog->setMinimum(0);
   this->fontCacheDialog->setMaximum(0);
   this->fontCacheDialog->setCancelButton(nullptr);
   this->fontCacheDialog->exec();
 }
 
-void OpenSCADApp::hideFontCacheDialog()
-{
+void OpenSCADApp::hideFontCacheDialog() {
   assert(this->fontCacheDialog);
   this->fontCacheDialog->reset();
 }
diff --git a/src/gui/OpenSCADApp.h b/src/gui/OpenSCADApp.h
index 720c2c4a9..4f1e74d29 100644
--- a/src/gui/OpenSCADApp.h
+++ b/src/gui/OpenSCADApp.h
@@ -1,33 +1,32 @@
 #pragma once
 
+#include <QApplication>
 #include <QEvent>
 #include <QObject>
 #include <QString>
-#include <QApplication>
 #include "gui/WindowManager.h"
 
 class QProgressDialog;
 
-class OpenSCADApp : public QApplication
-{
+class OpenSCADApp : public QApplication {
   Q_OBJECT
 
-public:
-  OpenSCADApp(int& argc, char **argv);
+ public:
+  OpenSCADApp(int& argc, char** argv);
   ~OpenSCADApp() override;
 
-  bool notify(QObject *object, QEvent *event) override;
+  bool notify(QObject* object, QEvent* event) override;
   void requestOpenFile(const QString& filename);
 
-public slots:
+ public slots:
   void showFontCacheDialog();
   void hideFontCacheDialog();
 
-public:
+ public:
   WindowManager windowManager;
 
-private:
-  QProgressDialog *fontCacheDialog{nullptr};
+ private:
+  QProgressDialog* fontCacheDialog{nullptr};
 };
 
-#define scadApp (static_cast<OpenSCADApp *>(QCoreApplication::instance()))
+#define scadApp (static_cast<OpenSCADApp*>(QCoreApplication::instance()))
diff --git a/src/gui/Preferences.cc b/src/gui/Preferences.cc
index 35e4e3bac..0dae9c314 100644
--- a/src/gui/Preferences.cc
+++ b/src/gui/Preferences.cc
@@ -26,82 +26,81 @@
 
 #include "gui/Preferences.h"
 
-#include <unordered_map>
-#include <vector>
+#include <QActionGroup>
+#include <QDialog>
+#include <QFileDialog>
 #include <QFont>
 #include <QFontComboBox>
+#include <QFontDatabase>
+#include <QKeyEvent>
+#include <QListWidget>
+#include <QListWidgetItem>
 #include <QMainWindow>
+#include <QMenu>
+#include <QMessageBox>
 #include <QObject>
-#include <QDialog>
+#include <QRegularExpression>
+#include <QRegularExpressionValidator>
+#include <QSettings>
 #include <QSizePolicy>
 #include <QSpacerItem>
+#include <QStatusBar>
 #include <QString>
 #include <QStringList>
+#include <QTextDocument>
 #include <QWidget>
-#include <tuple>
+#include <boost/algorithm/string.hpp>
 #include <cassert>
 #include <list>
-#include <QMenu>
-#include <QActionGroup>
-#include <QMessageBox>
-#include <QFontDatabase>
-#include <QKeyEvent>
-#include <QFileDialog>
-#include <QRegularExpression>
-#include <QRegularExpressionValidator>
-#include <QStatusBar>
-#include <QSettings>
-#include <QTextDocument>
-#include <QListWidget>
-#include <QListWidgetItem>
-#include <boost/algorithm/string.hpp>
+#include <tuple>
+#include <unordered_map>
+#include <vector>
+#include "Feature.h"
 #include "OctoPrintApiKeyDialog.h"
+#include "core/Settings.h"
 #include "geometry/GeometryCache.h"
 #include "gui/AutoUpdater.h"
-#include "Feature.h"
-#include "core/Settings.h"
 #include "utils/printutils.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALCache.h"
 #endif
 #include "glview/ColorMap.h"
 #include "glview/RenderSettings.h"
-#include "gui/QSettingsCached.h"
-#include "gui/SettingsWriter.h"
-#include "gui/OctoPrint.h"
 #include "gui/IgnoreWheelWhenNotFocused.h"
+#include "gui/OctoPrint.h"
 #include "gui/PrintService.h"
+#include "gui/QSettingsCached.h"
+#include "gui/SettingsWriter.h"
 
 #include <string>
 
-
-static const char *featurePropertyName = "FeatureProperty";
+static const char* featurePropertyName = "FeatureProperty";
 
 using S = Settings::Settings;
 
-Q_DECLARE_METATYPE(Feature *);
+Q_DECLARE_METATYPE(Feature*);
 
-class SettingsReader : public Settings::SettingsVisitor
-{
+class SettingsReader : public Settings::SettingsVisitor {
   QSettingsCached settings;
 
-  void handle(Settings::SettingsEntryBase& entry) const override
-  {
+  void handle(Settings::SettingsEntryBase& entry) const override {
     if (settings.contains(QString::fromStdString(entry.key()))) {
-      std::string value = settings.value(QString::fromStdString(entry.key())).toString().toStdString();
+      std::string value = settings.value(QString::fromStdString(entry.key()))
+                              .toString()
+                              .toStdString();
       PRINTDB("SettingsReader R: %s = '%s'", entry.key() % value);
       entry.set(value);
     }
   }
 };
 
-Preferences::Preferences(QWidget *parent) : QMainWindow(parent)
-{
+Preferences::Preferences(QWidget* parent) : QMainWindow(parent) {
   setupUi(this);
 
   std::list<std::string> names = ColorMap::inst()->colorSchemeNames(true);
   QStringList renderColorSchemes;
-  for (const auto& name : names) renderColorSchemes << name.c_str();
+  for (const auto& name : names)
+    renderColorSchemes << name.c_str();
 
   syntaxHighlight->clear();
   colorSchemeChooser->clear();
@@ -143,15 +142,23 @@ void Preferences::init() {
 
   // Setup default settings
   this->defaultmap["advanced/opencsg_show_warning"] = true;
-  this->defaultmap["advanced/polysetCacheSize"] = qulonglong(GeometryCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
-  this->defaultmap["advanced/polysetCacheSizeMB"] = getValue("advanced/polysetCacheSize").toULongLong() / (1024ul * 1024ul); // carry over old settings if they exist
-  this->defaultmap["advanced/cgalCacheSize"] = qulonglong(CGALCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
-  this->defaultmap["advanced/cgalCacheSizeMB"] = getValue("advanced/cgalCacheSize").toULongLong() / (1024ul * 1024ul); // carry over old settings if they exist
-  this->defaultmap["advanced/openCSGLimit"] = RenderSettings::inst()->openCSGTermLimit;
+  this->defaultmap["advanced/polysetCacheSize"] =
+      qulonglong(GeometryCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
+  this->defaultmap["advanced/polysetCacheSizeMB"] =
+      getValue("advanced/polysetCacheSize").toULongLong() /
+      (1024ul * 1024ul);  // carry over old settings if they exist
+  this->defaultmap["advanced/cgalCacheSize"] =
+      qulonglong(CGALCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
+  this->defaultmap["advanced/cgalCacheSizeMB"] =
+      getValue("advanced/cgalCacheSize").toULongLong() /
+      (1024ul * 1024ul);  // carry over old settings if they exist
+  this->defaultmap["advanced/openCSGLimit"] =
+      RenderSettings::inst()->openCSGTermLimit;
   this->defaultmap["advanced/forceGoldfeather"] = false;
   this->defaultmap["advanced/undockableWindows"] = false;
   this->defaultmap["advanced/reorderWindows"] = true;
-  this->defaultmap["advanced/renderBackend3D"] = QString::fromStdString(renderBackend3DToString(RenderSettings::inst()->backend3D));
+  this->defaultmap["advanced/renderBackend3D"] = QString::fromStdString(
+      renderBackend3DToString(RenderSettings::inst()->backend3D));
   this->defaultmap["launcher/showOnStartup"] = true;
   this->defaultmap["advanced/localization"] = true;
   this->defaultmap["advanced/autoReloadRaise"] = false;
@@ -175,7 +182,7 @@ void Preferences::init() {
   this->defaultmap["editor/stepSize"] = 1;
 
   // Toolbar
-  auto *group = new QActionGroup(this);
+  auto* group = new QActionGroup(this);
   addPrefPage(group, prefsAction3DView, page3DView);
   addPrefPage(group, prefsActionEditor, pageEditor);
 #ifdef OPENSCAD_UPDATER
@@ -203,11 +210,15 @@ void Preferences::init() {
   this->defaultmap["3dview/colorscheme"] = "Cornfield";
 
   // Advanced pane
-  const int absolute_max = (sizeof(void *) == 8) ? 1024 * 1024 : 2048; // 1TB for 64bit or 2GB for 32bit
-  QValidator *memvalidator = new QIntValidator(1, absolute_max, this);
-  auto *uintValidator = new QIntValidator(this);
+  const int absolute_max = (sizeof(void*) == 8)
+                               ? 1024 * 1024
+                               : 2048;  // 1TB for 64bit or 2GB for 32bit
+  QValidator* memvalidator = new QIntValidator(1, absolute_max, this);
+  auto* uintValidator = new QIntValidator(this);
   uintValidator->setBottom(0);
-  QValidator *validator1 = new QRegularExpressionValidator(QRegularExpression("[1-9][0-9]{0,1}"), this); // range between 1-99 both inclusive
+  QValidator* validator1 = new QRegularExpressionValidator(
+      QRegularExpression("[1-9][0-9]{0,1}"),
+      this);  // range between 1-99 both inclusive
 #ifdef ENABLE_CGAL
   this->cgalCacheSizeMBEdit->setValidator(memvalidator);
 #endif
@@ -231,36 +242,65 @@ void Preferences::init() {
 
   initComboBox(this->comboBoxIndentUsing, Settings::Settings::indentStyle);
   initComboBox(this->comboBoxLineWrap, Settings::Settings::lineWrap);
-  initComboBox(this->comboBoxLineWrapIndentationStyle, Settings::Settings::lineWrapIndentationStyle);
-  initComboBox(this->comboBoxLineWrapVisualizationEnd, Settings::Settings::lineWrapVisualizationEnd);
-  initComboBox(this->comboBoxLineWrapVisualizationStart, Settings::Settings::lineWrapVisualizationBegin);
-  initComboBox(this->comboBoxShowWhitespace, Settings::Settings::showWhitespace);
-  initComboBox(this->comboBoxModifierNumberScrollWheel, Settings::Settings::modifierNumberScrollWheel);
-  initIntSpinBox(this->spinBoxIndentationWidth, Settings::Settings::indentationWidth);
-  initIntSpinBox(this->spinBoxLineWrapIndentationIndent, Settings::Settings::lineWrapIndentation);
-  initIntSpinBox(this->spinBoxShowWhitespaceSize, Settings::Settings::showWhitespaceSize);
+  initComboBox(this->comboBoxLineWrapIndentationStyle,
+               Settings::Settings::lineWrapIndentationStyle);
+  initComboBox(this->comboBoxLineWrapVisualizationEnd,
+               Settings::Settings::lineWrapVisualizationEnd);
+  initComboBox(this->comboBoxLineWrapVisualizationStart,
+               Settings::Settings::lineWrapVisualizationBegin);
+  initComboBox(this->comboBoxShowWhitespace,
+               Settings::Settings::showWhitespace);
+  initComboBox(this->comboBoxModifierNumberScrollWheel,
+               Settings::Settings::modifierNumberScrollWheel);
+  initIntSpinBox(this->spinBoxIndentationWidth,
+                 Settings::Settings::indentationWidth);
+  initIntSpinBox(this->spinBoxLineWrapIndentationIndent,
+                 Settings::Settings::lineWrapIndentation);
+  initIntSpinBox(this->spinBoxShowWhitespaceSize,
+                 Settings::Settings::showWhitespaceSize);
   initIntSpinBox(this->spinBoxTabWidth, Settings::Settings::tabWidth);
 
-  initComboBox(this->comboBoxOctoPrintFileFormat, Settings::Settings::octoPrintFileFormat);
-  initComboBox(this->comboBoxOctoPrintAction, Settings::Settings::octoPrintAction);
-  initComboBox(this->comboBoxLocalAppFileFormat, Settings::Settings::localAppFileFormat);
-  initComboBox(this->comboBoxRenderBackend3D, Settings::Settings::renderBackend3D);
-  initComboBox(this->comboBoxToolbarExport3D, Settings::Settings::toolbarExport3D);
-  initComboBox(this->comboBoxToolbarExport2D, Settings::Settings::toolbarExport2D);
-
-  initListBox(this->listWidgetLocalAppParams, Settings::Settings::localAppParameterList);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::dataChanged, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::rowsInserted, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::rowsRemoved, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
+  initComboBox(this->comboBoxOctoPrintFileFormat,
+               Settings::Settings::octoPrintFileFormat);
+  initComboBox(this->comboBoxOctoPrintAction,
+               Settings::Settings::octoPrintAction);
+  initComboBox(this->comboBoxLocalAppFileFormat,
+               Settings::Settings::localAppFileFormat);
+  initComboBox(this->comboBoxRenderBackend3D,
+               Settings::Settings::renderBackend3D);
+  initComboBox(this->comboBoxToolbarExport3D,
+               Settings::Settings::toolbarExport3D);
+  initComboBox(this->comboBoxToolbarExport2D,
+               Settings::Settings::toolbarExport2D);
+
+  initListBox(this->listWidgetLocalAppParams,
+              Settings::Settings::localAppParameterList);
+  connect(this->listWidgetLocalAppParams->model(),
+          &QAbstractItemModel::dataChanged, this,
+          &Preferences::listWidgetLocalAppParamsModelDataChanged);
+  connect(this->listWidgetLocalAppParams->model(),
+          &QAbstractItemModel::rowsInserted, this,
+          &Preferences::listWidgetLocalAppParamsModelDataChanged);
+  connect(this->listWidgetLocalAppParams->model(),
+          &QAbstractItemModel::rowsRemoved, this,
+          &Preferences::listWidgetLocalAppParamsModelDataChanged);
 
   installIgnoreWheelWhenNotFocused(this);
 
-  const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-  const QString slicerDesc = QString::fromStdString(Settings::Settings::octoPrintSlicerEngineDesc.value());
-  const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
-  const QString profileDesc = QString::fromStdString(Settings::Settings::octoPrintSlicerProfileDesc.value());
-  BlockSignals<QLineEdit *>(this->lineEditLocalAppExecutable)->setText(QString::fromStdString(Settings::Settings::localAppExecutable.value()));
-  BlockSignals<QLineEdit *>(this->lineEditLocalAppTempDir)->setText(QString::fromStdString(Settings::Settings::localAppTempDir.value()));
+  const QString slicer =
+      QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
+  const QString slicerDesc = QString::fromStdString(
+      Settings::Settings::octoPrintSlicerEngineDesc.value());
+  const QString profile = QString::fromStdString(
+      Settings::Settings::octoPrintSlicerProfile.value());
+  const QString profileDesc = QString::fromStdString(
+      Settings::Settings::octoPrintSlicerProfileDesc.value());
+  BlockSignals<QLineEdit*>(this->lineEditLocalAppExecutable)
+      ->setText(QString::fromStdString(
+          Settings::Settings::localAppExecutable.value()));
+  BlockSignals<QLineEdit*>(this->lineEditLocalAppTempDir)
+      ->setText(
+          QString::fromStdString(Settings::Settings::localAppTempDir.value()));
   this->comboBoxOctoPrintSlicingEngine->clear();
   this->comboBoxOctoPrintSlicingEngine->addItem(_("<Default>"), QVariant{""});
   if (!slicer.isEmpty()) {
@@ -269,22 +309,24 @@ void Preferences::init() {
   this->comboBoxOctoPrintSlicingProfile->clear();
   this->comboBoxOctoPrintSlicingProfile->addItem(_("<Default>"), QVariant{""});
   if (!profile.isEmpty()) {
-    this->comboBoxOctoPrintSlicingProfile->addItem(profileDesc, QVariant{profile});
+    this->comboBoxOctoPrintSlicingProfile->addItem(profileDesc,
+                                                   QVariant{profile});
   }
 
   emit editorConfigChanged();
 }
 
-Preferences::~Preferences()
-{
+Preferences::~Preferences() {
   removeDefaultSettings();
 }
 
-void Preferences::update()
-{
-  this->checkBoxAlwaysShowExportPdfDialog->setChecked(Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.value());
-  this->checkBoxAlwaysShowExport3mfDialog->setChecked(Settings::SettingsExport3mf::export3mfAlwaysShowDialog.value());
-  this->checkBoxAlwaysShowPrintServiceDialog->setChecked(Settings::Settings::printServiceAlwaysShowDialog.value());
+void Preferences::update() {
+  this->checkBoxAlwaysShowExportPdfDialog->setChecked(
+      Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowExport3mfDialog->setChecked(
+      Settings::SettingsExport3mf::export3mfAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowPrintServiceDialog->setChecked(
+      Settings::Settings::printServiceAlwaysShowDialog.value());
 }
 
 /**
@@ -298,8 +340,9 @@ void Preferences::update()
  * @param widget The widget that should be shown when the action is triggered.
  *               This must be a child page of the stackedWidget.
  */
-void Preferences::addPrefPage(QActionGroup *group, QAction *action, QWidget *widget)
-{
+void Preferences::addPrefPage(QActionGroup* group,
+                              QAction* action,
+                              QWidget* widget) {
   group->addAction(action);
   prefPages[action] = widget;
 }
@@ -309,8 +352,7 @@ void Preferences::addPrefPage(QActionGroup *group, QAction *action, QWidget *wid
  *
  * @param action The action triggered by the user.
  */
-void Preferences::actionTriggered(QAction *action)
-{
+void Preferences::actionTriggered(QAction* action) {
   this->stackedWidget->setCurrentWidget(prefPages[action]);
 }
 
@@ -318,14 +360,13 @@ void Preferences::actionTriggered(QAction *action)
  * Called at least on showing / closing the Preferences dialog
  * and when switching tabs.
  */
-void Preferences::hidePasswords()
-{
+void Preferences::hidePasswords() {
   this->pushButtonOctoPrintApiKey->setChecked(false);
-  this->lineEditOctoPrintApiKey->setEchoMode(QLineEdit::EchoMode::PasswordEchoOnEdit);
+  this->lineEditOctoPrintApiKey->setEchoMode(
+      QLineEdit::EchoMode::PasswordEchoOnEdit);
 }
 
-void Preferences::on_stackedWidget_currentChanged(int)
-{
+void Preferences::on_stackedWidget_currentChanged(int) {
   hidePasswords();
   this->labelOctoPrintCheckConnection->setText("");
   this->AxisConfig->updateStates();
@@ -339,9 +380,8 @@ void Preferences::on_stackedWidget_currentChanged(int)
  *
  * @param state the state of the checkbox.
  */
-void Preferences::featuresCheckBoxToggled(bool state)
-{
-  const QObject *sender = QObject::sender();
+void Preferences::featuresCheckBoxToggled(bool state) {
+  const QObject* sender = QObject::sender();
   if (sender == nullptr) {
     return;
   }
@@ -349,10 +389,12 @@ void Preferences::featuresCheckBoxToggled(bool state)
   if (!v.isValid()) {
     return;
   }
-  auto *feature = v.value<Feature *>();
+  auto* feature = v.value<Feature*>();
   feature->enable(state);
   QSettingsCached settings;
-  settings.setValue(QString("feature/%1").arg(QString::fromStdString(feature->get_name())), state);
+  settings.setValue(
+      QString("feature/%1").arg(QString::fromStdString(feature->get_name())),
+      state);
   emit ExperimentalChanged();
 }
 
@@ -363,20 +405,23 @@ void Preferences::featuresCheckBoxToggled(bool state)
  * from commandline is ignored. This always uses the value coming from the
  * QSettings.
  */
-void Preferences::setupFeaturesPage()
-{
+void Preferences::setupFeaturesPage() {
   int row = 0;
   for (auto it = Feature::begin(); it != Feature::end(); ++it) {
-    Feature *feature = *it;
+    Feature* feature = *it;
 
-    QString featurekey = QString("feature/%1").arg(QString::fromStdString(feature->get_name()));
+    QString featurekey =
+        QString("feature/%1").arg(QString::fromStdString(feature->get_name()));
     this->defaultmap[featurekey] = false;
 
     // spacer item between the features, just for some optical separation
-    gridLayoutExperimentalFeatures->addItem(new QSpacerItem(1, 8, QSizePolicy::Expanding, QSizePolicy::Fixed), row, 1, 1, 1, Qt::AlignCenter);
+    gridLayoutExperimentalFeatures->addItem(
+        new QSpacerItem(1, 8, QSizePolicy::Expanding, QSizePolicy::Fixed), row,
+        1, 1, 1, Qt::AlignCenter);
     row++;
 
-    auto *cb = new QCheckBox(QString::fromStdString(feature->get_name()), pageFeatures);
+    auto* cb = new QCheckBox(QString::fromStdString(feature->get_name()),
+                             pageFeatures);
     QFont bold_font(cb->font());
     bold_font.setBold(true);
     cb->setFont(bold_font);
@@ -384,33 +429,42 @@ void Preferences::setupFeaturesPage()
     bool value = getValue(featurekey).toBool();
     feature->enable(value);
     cb->setChecked(value);
-    cb->setProperty(featurePropertyName, QVariant::fromValue<Feature *>(feature));
-    connect(cb, &QCheckBox::toggled, this, &Preferences::featuresCheckBoxToggled);
-    gridLayoutExperimentalFeatures->addWidget(cb, row, 0, 1, 2, Qt::AlignLeading);
+    cb->setProperty(featurePropertyName,
+                    QVariant::fromValue<Feature*>(feature));
+    connect(cb, &QCheckBox::toggled, this,
+            &Preferences::featuresCheckBoxToggled);
+    gridLayoutExperimentalFeatures->addWidget(cb, row, 0, 1, 2,
+                                              Qt::AlignLeading);
     row++;
 
-    auto *l = new QLabel(QString::fromStdString(feature->get_description()), pageFeatures);
+    auto* l = new QLabel(QString::fromStdString(feature->get_description()),
+                         pageFeatures);
     l->setTextFormat(Qt::RichText);
-    gridLayoutExperimentalFeatures->addWidget(l, row, 1, 1, 1, Qt::AlignLeading);
+    gridLayoutExperimentalFeatures->addWidget(l, row, 1, 1, 1,
+                                              Qt::AlignLeading);
     row++;
   }
   // Force fixed indentation, the checkboxes use column span of 2 so
   // first row is not constrained in size by the visible controls. The
   // fixed size space essentially gives the first row the width of the
   // spacer item itself.
-  gridLayoutExperimentalFeatures->addItem(new QSpacerItem(20, 0, QSizePolicy::Fixed, QSizePolicy::Fixed), 1, 0, 1, 1, Qt::AlignLeading);
-}
-
-void Preferences::setup3DPrintPage()
-{
-  const auto& currentPrintService = Settings::Settings::defaultPrintService.value();
-  const auto currentPrintServiceName = QString::fromStdString(Settings::Settings::printServiceName.value());
-  checkBoxEnableRemotePrintServices->setChecked(Settings::Settings::enableRemotePrintServices.value());
+  gridLayoutExperimentalFeatures->addItem(
+      new QSpacerItem(20, 0, QSizePolicy::Fixed, QSizePolicy::Fixed), 1, 0, 1,
+      1, Qt::AlignLeading);
+}
+
+void Preferences::setup3DPrintPage() {
+  const auto& currentPrintService =
+      Settings::Settings::defaultPrintService.value();
+  const auto currentPrintServiceName =
+      QString::fromStdString(Settings::Settings::printServiceName.value());
+  checkBoxEnableRemotePrintServices->setChecked(
+      Settings::Settings::enableRemotePrintServices.value());
   comboBoxDefaultPrintService->clear();
   const std::unordered_map<std::string, QString> services = {
-    {"NONE", _("NONE")},
-    {"OCTOPRINT", _("OctoPrint")},
-    {"LOCAL_APPLICATION", _("Local Application")},
+      {"NONE", _("NONE")},
+      {"OCTOPRINT", _("OctoPrint")},
+      {"LOCAL_APPLICATION", _("Local Application")},
   };
 
   comboBoxDefaultPrintService->addItem(services.at("NONE"),
@@ -418,12 +472,13 @@ void Preferences::setup3DPrintPage()
   for (const auto& printServiceItem : PrintService::getPrintServices()) {
     const auto& key = printServiceItem.first;
     const auto& printService = printServiceItem.second;
-    const auto settingValue = QStringList{"PRINT_SERVICE", QString::fromStdString(key)};
+    const auto settingValue =
+        QStringList{"PRINT_SERVICE", QString::fromStdString(key)};
     const auto displayName = QString(printService->getDisplayName());
     comboBoxDefaultPrintService->addItem(displayName, settingValue);
     if (key == currentPrintServiceName.toStdString()) {
       comboBoxDefaultPrintService->setCurrentText(
-        QString(printService->getDisplayName()));
+          QString(printService->getDisplayName()));
     }
   }
   comboBoxDefaultPrintService->addItem(services.at("OCTOPRINT"),
@@ -437,73 +492,64 @@ void Preferences::setup3DPrintPage()
   }
 }
 
-void Preferences::on_colorSchemeChooser_itemSelectionChanged()
-{
+void Preferences::on_colorSchemeChooser_itemSelectionChanged() {
   QString scheme = this->colorSchemeChooser->currentItem()->text();
   QSettingsCached settings;
   settings.setValue("3dview/colorscheme", scheme);
   emit colorSchemeChanged(scheme);
 }
 
-void Preferences::on_fontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_fontChooser_currentFontChanged(const QFont& font) {
   QSettingsCached settings;
   settings.setValue("editor/fontfamily", font.family());
   emit fontChanged(font.family(), getValue("editor/fontsize").toUInt());
 }
 
-void Preferences::on_fontSize_currentIndexChanged(int index)
-{
+void Preferences::on_fontSize_currentIndexChanged(int index) {
   uint intsize = this->fontSize->itemText(index).toUInt();
   QSettingsCached settings;
   settings.setValue("editor/fontsize", intsize);
   emit fontChanged(getValue("editor/fontfamily").toString(), intsize);
 }
 
-void Preferences::on_syntaxHighlight_currentTextChanged(const QString& s)
-{
+void Preferences::on_syntaxHighlight_currentTextChanged(const QString& s) {
   QSettingsCached settings;
   settings.setValue("editor/syntaxhighlight", s);
   emit syntaxHighlightChanged(s);
 }
 
-void unimplemented_msg()
-{
+void unimplemented_msg() {
   QMessageBox mbox;
-  mbox.setText("Sorry, this feature is not implemented on your Operating System");
+  mbox.setText(
+      "Sorry, this feature is not implemented on your Operating System");
   mbox.exec();
 }
 
-void Preferences::on_updateCheckBox_toggled(bool on)
-{
-  if (AutoUpdater *updater = AutoUpdater::updater()) {
+void Preferences::on_updateCheckBox_toggled(bool on) {
+  if (AutoUpdater* updater = AutoUpdater::updater()) {
     updater->setAutomaticallyChecksForUpdates(on);
   } else {
     unimplemented_msg();
   }
 }
 
-void Preferences::on_snapshotCheckBox_toggled(bool on)
-{
-  if (AutoUpdater *updater = AutoUpdater::updater()) {
+void Preferences::on_snapshotCheckBox_toggled(bool on) {
+  if (AutoUpdater* updater = AutoUpdater::updater()) {
     updater->setEnableSnapshots(on);
   } else {
     unimplemented_msg();
   }
 }
 
-void Preferences::on_checkNowButton_clicked()
-{
-  if (AutoUpdater *updater = AutoUpdater::updater()) {
+void Preferences::on_checkNowButton_clicked() {
+  if (AutoUpdater* updater = AutoUpdater::updater()) {
     updater->checkForUpdates();
   } else {
     unimplemented_msg();
   }
 }
 
-void
-Preferences::on_reorderCheckBox_toggled(bool state)
-{
+void Preferences::on_reorderCheckBox_toggled(bool state) {
   if (!state) {
     undockCheckBox->setChecked(false);
   }
@@ -513,194 +559,169 @@ Preferences::on_reorderCheckBox_toggled(bool state)
   emit updateReorderMode(state);
 }
 
-void
-Preferences::on_undockCheckBox_toggled(bool state)
-{
+void Preferences::on_undockCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/undockableWindows", state);
   emit updateUndockMode(state);
 }
 
-void
-Preferences::on_openCSGWarningBox_toggled(bool state)
-{
+void Preferences::on_openCSGWarningBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/opencsg_show_warning", state);
 }
 
-void Preferences::on_cgalCacheSizeMBEdit_textChanged(const QString& text)
-{
+void Preferences::on_cgalCacheSizeMBEdit_textChanged(const QString& text) {
   QSettingsCached settings;
   settings.setValue("advanced/cgalCacheSizeMB", text);
   CGALCache::instance()->setMaxSizeMB(text.toULong());
 }
 
-void Preferences::on_polysetCacheSizeMBEdit_textChanged(const QString& text)
-{
+void Preferences::on_polysetCacheSizeMBEdit_textChanged(const QString& text) {
   QSettingsCached settings;
   settings.setValue("advanced/polysetCacheSizeMB", text);
   GeometryCache::instance()->setMaxSizeMB(text.toULong());
 }
 
-void Preferences::on_opencsgLimitEdit_textChanged(const QString& text)
-{
+void Preferences::on_opencsgLimitEdit_textChanged(const QString& text) {
   QSettingsCached settings;
   settings.setValue("advanced/openCSGLimit", text);
   // FIXME: Set this globally?
 }
 
-void Preferences::on_localizationCheckBox_toggled(bool state)
-{
+void Preferences::on_localizationCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/localization", state);
 }
 
-void Preferences::on_autoReloadRaiseCheckBox_toggled(bool state)
-{
+void Preferences::on_autoReloadRaiseCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/autoReloadRaise", state);
 }
 
-void Preferences::on_forceGoldfeatherBox_toggled(bool state)
-{
+void Preferences::on_forceGoldfeatherBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/forceGoldfeather", state);
   emit openCSGSettingsChanged();
 }
 
-void Preferences::on_mouseWheelZoomBox_toggled(bool state)
-{
+void Preferences::on_mouseWheelZoomBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("editor/ctrlmousewheelzoom", state);
 }
 
-void Preferences::on_launcherBox_toggled(bool state)
-{
+void Preferences::on_launcherBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("launcher/showOnStartup", state);
 }
 
-void Preferences::on_checkBoxShowWarningsIn3dView_toggled(bool val)
-{
+void Preferences::on_checkBoxShowWarningsIn3dView_toggled(bool val) {
   Settings::Settings::showWarningsIn3dView.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxMouseCentricZoom_toggled(bool val)
-{
+void Preferences::on_checkBoxMouseCentricZoom_toggled(bool val) {
   Settings::Settings::mouseCentricZoom.setValue(val);
   writeSettings();
   emit updateMouseCentricZoom(val);
 }
 
-void Preferences::on_checkBoxMouseSwapButtons_toggled(bool val)
-{
+void Preferences::on_checkBoxMouseSwapButtons_toggled(bool val) {
   Settings::Settings::mouseSwapButtons.setValue(val);
   writeSettings();
   emit updateMouseSwapButtons(val);
 }
 
-void Preferences::on_spinBoxIndentationWidth_valueChanged(int val)
-{
+void Preferences::on_spinBoxIndentationWidth_valueChanged(int val) {
   Settings::Settings::indentationWidth.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_spinBoxTabWidth_valueChanged(int val)
-{
+void Preferences::on_spinBoxTabWidth_valueChanged(int val) {
   Settings::Settings::tabWidth.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_comboBoxLineWrap_activated(int val)
-{
+void Preferences::on_comboBoxLineWrap_activated(int val) {
   applyComboBox(comboBoxLineWrap, val, Settings::Settings::lineWrap);
 }
 
-void Preferences::on_comboBoxLineWrapIndentationStyle_activated(int val)
-{
-  //Next Line disables the Indent Spin-Box when 'Same' or 'Indented' is chosen from LineWrapIndentationStyle Combo-Box.
-  spinBoxLineWrapIndentationIndent->setDisabled(comboBoxLineWrapIndentationStyle->currentData() == "Same" || comboBoxLineWrapIndentationStyle->currentData() == "Indented");
+void Preferences::on_comboBoxLineWrapIndentationStyle_activated(int val) {
+  // Next Line disables the Indent Spin-Box when 'Same' or 'Indented' is chosen
+  // from LineWrapIndentationStyle Combo-Box.
+  spinBoxLineWrapIndentationIndent->setDisabled(
+      comboBoxLineWrapIndentationStyle->currentData() == "Same" ||
+      comboBoxLineWrapIndentationStyle->currentData() == "Indented");
 
-  applyComboBox(comboBoxLineWrapIndentationStyle, val, Settings::Settings::lineWrapIndentationStyle);
+  applyComboBox(comboBoxLineWrapIndentationStyle, val,
+                Settings::Settings::lineWrapIndentationStyle);
 }
 
-void Preferences::on_spinBoxLineWrapIndentationIndent_valueChanged(int val)
-{
+void Preferences::on_spinBoxLineWrapIndentationIndent_valueChanged(int val) {
   Settings::Settings::lineWrapIndentation.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_comboBoxLineWrapVisualizationStart_activated(int val)
-{
-  applyComboBox(comboBoxLineWrapVisualizationStart, val, Settings::Settings::lineWrapVisualizationBegin);
+void Preferences::on_comboBoxLineWrapVisualizationStart_activated(int val) {
+  applyComboBox(comboBoxLineWrapVisualizationStart, val,
+                Settings::Settings::lineWrapVisualizationBegin);
 }
 
-void Preferences::on_comboBoxLineWrapVisualizationEnd_activated(int val)
-{
-  applyComboBox(comboBoxLineWrapVisualizationEnd, val, Settings::Settings::lineWrapVisualizationEnd);
+void Preferences::on_comboBoxLineWrapVisualizationEnd_activated(int val) {
+  applyComboBox(comboBoxLineWrapVisualizationEnd, val,
+                Settings::Settings::lineWrapVisualizationEnd);
 }
 
-void Preferences::on_comboBoxShowWhitespace_activated(int val)
-{
-  applyComboBox(comboBoxShowWhitespace, val, Settings::Settings::showWhitespace);
+void Preferences::on_comboBoxShowWhitespace_activated(int val) {
+  applyComboBox(comboBoxShowWhitespace, val,
+                Settings::Settings::showWhitespace);
 }
 
-void Preferences::on_spinBoxShowWhitespaceSize_valueChanged(int val)
-{
+void Preferences::on_spinBoxShowWhitespaceSize_valueChanged(int val) {
   Settings::Settings::showWhitespaceSize.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxAutoIndent_toggled(bool val)
-{
+void Preferences::on_checkBoxAutoIndent_toggled(bool val) {
   Settings::Settings::autoIndent.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxBackspaceUnindents_toggled(bool val)
-{
+void Preferences::on_checkBoxBackspaceUnindents_toggled(bool val) {
   Settings::Settings::backspaceUnindents.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_comboBoxIndentUsing_activated(int val)
-{
+void Preferences::on_comboBoxIndentUsing_activated(int val) {
   applyComboBox(comboBoxIndentUsing, val, Settings::Settings::indentStyle);
 }
 
-void Preferences::on_comboBoxTabKeyFunction_activated(int val)
-{
-  applyComboBox(comboBoxTabKeyFunction, val, Settings::Settings::tabKeyFunction);
+void Preferences::on_comboBoxTabKeyFunction_activated(int val) {
+  applyComboBox(comboBoxTabKeyFunction, val,
+                Settings::Settings::tabKeyFunction);
 }
 
-void Preferences::on_checkBoxHighlightCurrentLine_toggled(bool val)
-{
+void Preferences::on_checkBoxHighlightCurrentLine_toggled(bool val) {
   Settings::Settings::highlightCurrentLine.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxEnableBraceMatching_toggled(bool val)
-{
+void Preferences::on_checkBoxEnableBraceMatching_toggled(bool val) {
   Settings::Settings::enableBraceMatching.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxEnableLineNumbers_toggled(bool val)
-{
+void Preferences::on_checkBoxEnableLineNumbers_toggled(bool val) {
   Settings::Settings::enableLineNumbers.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxEnableNumberScrollWheel_toggled(bool val)
-{
+void Preferences::on_checkBoxEnableNumberScrollWheel_toggled(bool val) {
   Settings::Settings::enableNumberScrollWheel.setValue(val);
   comboBoxModifierNumberScrollWheel->setDisabled(!val);
   writeSettings();
 }
 
-void Preferences::on_enableSoundOnRenderCompleteCheckBox_toggled(bool state)
-{
+void Preferences::on_enableSoundOnRenderCompleteCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableSoundNotification", state);
   this->timeThresholdOnRenderCompleteSoundLabel->setEnabled(state);
@@ -708,56 +729,54 @@ void Preferences::on_enableSoundOnRenderCompleteCheckBox_toggled(bool state)
   this->timeThresholdOnRenderCompleteSoundEdit->setEnabled(state);
 }
 
-void Preferences::on_timeThresholdOnRenderCompleteSoundEdit_textChanged(const QString& text)
-{
+void Preferences::on_timeThresholdOnRenderCompleteSoundEdit_textChanged(
+    const QString& text) {
   QSettingsCached settings;
   settings.setValue("advanced/timeThresholdOnRenderCompleteSound", text);
 }
 
-void Preferences::on_enableClearConsoleCheckBox_toggled(bool state)
-{
+void Preferences::on_enableClearConsoleCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/consoleAutoClear", state);
 }
 
-void Preferences::on_consoleMaxLinesEdit_textChanged(const QString& text)
-{
+void Preferences::on_consoleMaxLinesEdit_textChanged(const QString& text) {
   QSettingsCached settings;
   settings.setValue("advanced/consoleMaxLines", text);
 }
 
-void Preferences::on_consoleFontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_consoleFontChooser_currentFontChanged(const QFont& font) {
   QSettingsCached settings;
   settings.setValue("advanced/consoleFontFamily", font.family());
-  emit consoleFontChanged(font.family(), getValue("advanced/consoleFontSize").toUInt());
+  emit consoleFontChanged(font.family(),
+                          getValue("advanced/consoleFontSize").toUInt());
 }
 
-void Preferences::on_consoleFontSize_currentIndexChanged(int index)
-{
+void Preferences::on_consoleFontSize_currentIndexChanged(int index) {
   uint intsize = this->consoleFontSize->itemText(index).toUInt();
   QSettingsCached settings;
   settings.setValue("advanced/consoleFontSize", intsize);
-  emit consoleFontChanged(getValue("advanced/consoleFontFamily").toString(), intsize);
+  emit consoleFontChanged(getValue("advanced/consoleFontFamily").toString(),
+                          intsize);
 }
 
-void Preferences::on_customizerFontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_customizerFontChooser_currentFontChanged(
+    const QFont& font) {
   QSettingsCached settings;
   settings.setValue("advanced/customizerFontFamily", font.family());
-  emit customizerFontChanged(font.family(), getValue("advanced/customizerFontSize").toUInt());
+  emit customizerFontChanged(font.family(),
+                             getValue("advanced/customizerFontSize").toUInt());
 }
 
-void Preferences::on_customizerFontSize_currentIndexChanged(int index)
-{
+void Preferences::on_customizerFontSize_currentIndexChanged(int index) {
   uint intsize = this->customizerFontSize->itemText(index).toUInt();
   QSettingsCached settings;
   settings.setValue("advanced/customizerFontSize", intsize);
-  emit customizerFontChanged(getValue("advanced/customizerFontFamily").toString(), intsize);
+  emit customizerFontChanged(
+      getValue("advanced/customizerFontFamily").toString(), intsize);
 }
 
-void Preferences::on_checkBoxEnableAutocomplete_toggled(bool state)
-{
+void Preferences::on_checkBoxEnableAutocomplete_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("editor/enableAutocomplete", state);
   this->labelCharacterThreshold->setEnabled(state);
@@ -765,137 +784,129 @@ void Preferences::on_checkBoxEnableAutocomplete_toggled(bool state)
   emit autocompleteChanged(state);
 }
 
-void Preferences::on_lineEditCharacterThreshold_textChanged(const QString& text)
-{
+void Preferences::on_lineEditCharacterThreshold_textChanged(
+    const QString& text) {
   QSettingsCached settings;
   settings.setValue("editor/characterThreshold", text);
   emit characterThresholdChanged(text.toInt());
 }
 
-void Preferences::on_lineEditStepSize_textChanged(const QString& text)
-{
+void Preferences::on_lineEditStepSize_textChanged(const QString& text) {
   QSettingsCached settings;
   settings.setValue("editor/stepSize", text);
   emit stepSizeChanged(text.toInt());
 }
 
-void Preferences::on_comboBoxModifierNumberScrollWheel_activated(int val)
-{
-  applyComboBox(comboBoxModifierNumberScrollWheel, val, Settings::Settings::modifierNumberScrollWheel);
+void Preferences::on_comboBoxModifierNumberScrollWheel_activated(int val) {
+  applyComboBox(comboBoxModifierNumberScrollWheel, val,
+                Settings::Settings::modifierNumberScrollWheel);
 }
 
-void Preferences::on_enableHardwarningsCheckBox_toggled(bool state)
-{
+void Preferences::on_enableHardwarningsCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableHardwarnings", state);
 }
 
-void Preferences::on_traceDepthEdit_textChanged(const QString& text)
-{
+void Preferences::on_traceDepthEdit_textChanged(const QString& text) {
   QSettingsCached settings;
   settings.setValue("advanced/traceDepth", text);
 }
 
-void Preferences::on_enableTraceUsermoduleParametersCheckBox_toggled(bool state)
-{
+void Preferences::on_enableTraceUsermoduleParametersCheckBox_toggled(
+    bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableTraceUsermoduleParameters", state);
 }
 
-void Preferences::on_enableParameterCheckBox_toggled(bool state)
-{
+void Preferences::on_enableParameterCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableParameterCheck", state);
 }
 
-void Preferences::on_enableRangeCheckBox_toggled(bool state)
-{
+void Preferences::on_enableRangeCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableParameterRangeCheck", state);
 }
 
-void
-Preferences::on_comboBoxRenderBackend3D_activated(int val)
-{
-  applyComboBox(this->comboBoxRenderBackend3D, val, Settings::Settings::renderBackend3D);
+void Preferences::on_comboBoxRenderBackend3D_activated(int val) {
+  applyComboBox(this->comboBoxRenderBackend3D, val,
+                Settings::Settings::renderBackend3D);
   RenderSettings::inst()->backend3D =
-    renderBackend3DFromString(Settings::Settings::renderBackend3D.value());
+      renderBackend3DFromString(Settings::Settings::renderBackend3D.value());
 }
 
-void Preferences::on_comboBoxToolbarExport3D_activated(int val)
-{
-  applyComboBox(this->comboBoxToolbarExport3D, val, Settings::Settings::toolbarExport3D);
+void Preferences::on_comboBoxToolbarExport3D_activated(int val) {
+  applyComboBox(this->comboBoxToolbarExport3D, val,
+                Settings::Settings::toolbarExport3D);
   emit toolbarExportChanged();
 }
 
-void Preferences::on_comboBoxToolbarExport2D_activated(int val)
-{
-  applyComboBox(this->comboBoxToolbarExport2D, val, Settings::Settings::toolbarExport2D);
+void Preferences::on_comboBoxToolbarExport2D_activated(int val) {
+  applyComboBox(this->comboBoxToolbarExport2D, val,
+                Settings::Settings::toolbarExport2D);
   emit toolbarExportChanged();
 }
 
-void Preferences::on_checkBoxSummaryCamera_toggled(bool checked)
-{
+void Preferences::on_checkBoxSummaryCamera_toggled(bool checked) {
   Settings::Settings::summaryCamera.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_checkBoxSummaryArea_toggled(bool checked)
-{
+void Preferences::on_checkBoxSummaryArea_toggled(bool checked) {
   Settings::Settings::summaryArea.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_checkBoxSummaryBoundingBox_toggled(bool checked)
-{
+void Preferences::on_checkBoxSummaryBoundingBox_toggled(bool checked) {
   Settings::Settings::summaryBoundingBox.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_enableHidapiTraceCheckBox_toggled(bool checked)
-{
+void Preferences::on_enableHidapiTraceCheckBox_toggled(bool checked) {
   Settings::Settings::inputEnableDriverHIDAPILog.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_checkBoxEnableRemotePrintServices_toggled(bool checked)
-{
+void Preferences::on_checkBoxEnableRemotePrintServices_toggled(bool checked) {
   S::enableRemotePrintServices.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_comboBoxDefaultPrintService_activated(int)
-{
-  QStringList currentPrintServiceList = comboBoxDefaultPrintService->currentData().toStringList();
-  Settings::Settings::defaultPrintService.setValue(currentPrintServiceList[0].toStdString());
-  Settings::Settings::printServiceName.setValue(currentPrintServiceList[1].toStdString());
+void Preferences::on_comboBoxDefaultPrintService_activated(int) {
+  QStringList currentPrintServiceList =
+      comboBoxDefaultPrintService->currentData().toStringList();
+  Settings::Settings::defaultPrintService.setValue(
+      currentPrintServiceList[0].toStdString());
+  Settings::Settings::printServiceName.setValue(
+      currentPrintServiceList[1].toStdString());
   writeSettings();
 }
 
-void Preferences::on_comboBoxOctoPrintAction_activated(int val)
-{
-  applyComboBox(comboBoxOctoPrintAction, val, Settings::Settings::octoPrintAction);
+void Preferences::on_comboBoxOctoPrintAction_activated(int val) {
+  applyComboBox(comboBoxOctoPrintAction, val,
+                Settings::Settings::octoPrintAction);
 }
 
-void Preferences::on_lineEditOctoPrintURL_editingFinished()
-{
-  Settings::Settings::octoPrintUrl.setValue(this->lineEditOctoPrintURL->text().toStdString());
+void Preferences::on_lineEditOctoPrintURL_editingFinished() {
+  Settings::Settings::octoPrintUrl.setValue(
+      this->lineEditOctoPrintURL->text().toStdString());
   writeSettings();
 }
 
-void Preferences::on_lineEditOctoPrintApiKey_editingFinished()
-{
-  Settings::Settings::octoPrintApiKey.setValue(this->lineEditOctoPrintApiKey->text().toStdString());
+void Preferences::on_lineEditOctoPrintApiKey_editingFinished() {
+  Settings::Settings::octoPrintApiKey.setValue(
+      this->lineEditOctoPrintApiKey->text().toStdString());
   writeSettings();
 }
 
-void Preferences::on_pushButtonOctoPrintApiKey_clicked()
-{
-  this->lineEditOctoPrintApiKey->setEchoMode(this->pushButtonOctoPrintApiKey->isChecked() ? QLineEdit::EchoMode::Normal : QLineEdit::EchoMode::PasswordEchoOnEdit);
+void Preferences::on_pushButtonOctoPrintApiKey_clicked() {
+  this->lineEditOctoPrintApiKey->setEchoMode(
+      this->pushButtonOctoPrintApiKey->isChecked()
+          ? QLineEdit::EchoMode::Normal
+          : QLineEdit::EchoMode::PasswordEchoOnEdit);
 }
 
-void Preferences::on_pushButtonOctoPrintRequestApiKey_clicked()
-{
+void Preferences::on_pushButtonOctoPrintRequestApiKey_clicked() {
   OctoPrintApiKeyDialog dialog;
   if (dialog.exec() == QDialog::Accepted) {
     const auto& apiKey = dialog.getApiKey();
@@ -905,26 +916,26 @@ void Preferences::on_pushButtonOctoPrintRequestApiKey_clicked()
   }
 }
 
-void Preferences::on_comboBoxOctoPrintFileFormat_activated(int val)
-{
-  applyComboBox(this->comboBoxOctoPrintFileFormat, val, Settings::Settings::octoPrintFileFormat);
+void Preferences::on_comboBoxOctoPrintFileFormat_activated(int val) {
+  applyComboBox(this->comboBoxOctoPrintFileFormat, val,
+                Settings::Settings::octoPrintFileFormat);
 }
 
-void Preferences::on_comboBoxLocalAppFileFormat_activated(int val)
-{
-  applyComboBox(this->comboBoxLocalAppFileFormat, val, Settings::Settings::localAppFileFormat);
+void Preferences::on_comboBoxLocalAppFileFormat_activated(int val) {
+  applyComboBox(this->comboBoxLocalAppFileFormat, val,
+                Settings::Settings::localAppFileFormat);
   writeSettings();
 }
 
-void Preferences::on_lineEditLocalAppExecutable_editingFinished()
-{
-  Settings::Settings::localAppExecutable.setValue(this->lineEditLocalAppExecutable->text().toStdString());
+void Preferences::on_lineEditLocalAppExecutable_editingFinished() {
+  Settings::Settings::localAppExecutable.setValue(
+      this->lineEditLocalAppExecutable->text().toStdString());
   writeSettings();
 }
 
-void Preferences::on_toolButtonLocalAppSelectExecutable_clicked()
-{
-  const QString fileName = QFileDialog::getOpenFileName(this, "Select application");
+void Preferences::on_toolButtonLocalAppSelectExecutable_clicked() {
+  const QString fileName =
+      QFileDialog::getOpenFileName(this, "Select application");
   if (fileName.isEmpty()) {
     return;
   }
@@ -933,15 +944,15 @@ void Preferences::on_toolButtonLocalAppSelectExecutable_clicked()
   on_lineEditLocalAppExecutable_editingFinished();
 }
 
-void Preferences::on_lineEditLocalAppTempDir_editingFinished()
-{
-  Settings::Settings::localAppTempDir.setValue(this->lineEditLocalAppTempDir->text().toStdString());
+void Preferences::on_lineEditLocalAppTempDir_editingFinished() {
+  Settings::Settings::localAppTempDir.setValue(
+      this->lineEditLocalAppTempDir->text().toStdString());
   writeSettings();
 }
 
-void Preferences::on_toolButtonLocalAppSelectTempDir_clicked()
-{
-  const QString tempDir = QFileDialog::getExistingDirectory(this, "Select temporary directory");
+void Preferences::on_toolButtonLocalAppSelectTempDir_clicked() {
+  const QString tempDir =
+      QFileDialog::getExistingDirectory(this, "Select temporary directory");
   if (tempDir.isEmpty()) {
     return;
   }
@@ -950,8 +961,7 @@ void Preferences::on_toolButtonLocalAppSelectTempDir_clicked()
   on_lineEditLocalAppTempDir_editingFinished();
 }
 
-void Preferences::moveListBoxRow(QListWidget *listBox, int offset)
-{
+void Preferences::moveListBoxRow(QListWidget* listBox, int offset) {
   const auto& index = listBox->selectionModel()->currentIndex();
   int newRow = index.row() + offset;
   if (newRow >= 0 && newRow <= listBox->count()) {
@@ -961,135 +971,154 @@ void Preferences::moveListBoxRow(QListWidget *listBox, int offset)
   }
 }
 
-void Preferences::on_toolButtonLocalAppParameterUp_clicked()
-{
+void Preferences::on_toolButtonLocalAppParameterUp_clicked() {
   moveListBoxRow(this->listWidgetLocalAppParams, -1);
 }
 
-void Preferences::on_toolButtonLocalAppParameterDown_clicked()
-{
+void Preferences::on_toolButtonLocalAppParameterDown_clicked() {
   moveListBoxRow(this->listWidgetLocalAppParams, 1);
 }
 
-void Preferences::on_toolButtonLocalAppParameterRemove_clicked()
-{
-  const auto& index = this->listWidgetLocalAppParams->selectionModel()->currentIndex();
+void Preferences::on_toolButtonLocalAppParameterRemove_clicked() {
+  const auto& index =
+      this->listWidgetLocalAppParams->selectionModel()->currentIndex();
   if (index.row() >= 0) {
     auto item = this->listWidgetLocalAppParams->takeItem(index.row());
     delete item;
   }
 }
 
-void Preferences::insertListItem(QListWidget *listBox, QListWidgetItem *listItem) {
+void Preferences::insertListItem(QListWidget* listBox,
+                                 QListWidgetItem* listItem) {
   const auto hasSelection = listBox->selectionModel()->hasSelection();
-  const auto pos = hasSelection ? listBox->selectionModel()->currentIndex().row() + 1 : listBox->count();
+  const auto pos = hasSelection
+                       ? listBox->selectionModel()->currentIndex().row() + 1
+                       : listBox->count();
   listBox->insertItem(pos, listItem);
   listBox->setCurrentRow(pos);
   listBox->editItem(listItem);
 }
 
-void Preferences::on_toolButtonLocalAppParameterAdd_clicked()
-{
-  auto listItem = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::string), "", true);
+void Preferences::on_toolButtonLocalAppParameterAdd_clicked() {
+  auto listItem = createListItem(
+      Settings::LocalAppParameterType(Settings::LocalAppParameterType::string),
+      "", true);
   insertListItem(this->listWidgetLocalAppParams, listItem);
 }
 
-void Preferences::addLocalAppParameter(const Settings::LocalAppParameterType& type)
-{
+void Preferences::addLocalAppParameter(
+    const Settings::LocalAppParameterType& type) {
   auto listItem = createListItem(Settings::LocalAppParameterType(type));
   insertListItem(this->listWidgetLocalAppParams, listItem);
 }
 
-void Preferences::on_toolButtonLocalAppParameterAddFile_clicked()
-{
+void Preferences::on_toolButtonLocalAppParameterAddFile_clicked() {
   addLocalAppParameter(Settings::LocalAppParameterType::file);
 }
 
-void Preferences::on_listWidgetLocalAppParams_itemSelectionChanged()
-{
-  const auto hasSelection = this->listWidgetLocalAppParams->selectionModel()->hasSelection();
-  const auto& index = this->listWidgetLocalAppParams->selectionModel()->currentIndex();
+void Preferences::on_listWidgetLocalAppParams_itemSelectionChanged() {
+  const auto hasSelection =
+      this->listWidgetLocalAppParams->selectionModel()->hasSelection();
+  const auto& index =
+      this->listWidgetLocalAppParams->selectionModel()->currentIndex();
   this->toolButtonLocalAppParameterRemove->setEnabled(hasSelection);
-  this->toolButtonLocalAppParameterUp->setEnabled(hasSelection && index.row() > 0);
-  this->toolButtonLocalAppParameterDown->setEnabled(hasSelection && index.row() < this->listWidgetLocalAppParams->count() - 1);
+  this->toolButtonLocalAppParameterUp->setEnabled(hasSelection &&
+                                                  index.row() > 0);
+  this->toolButtonLocalAppParameterDown->setEnabled(
+      hasSelection &&
+      index.row() < this->listWidgetLocalAppParams->count() - 1);
 }
 
-void Preferences::updateLocalAppParams()
-{
+void Preferences::updateLocalAppParams() {
   std::vector<Settings::LocalAppParameter> items;
   for (int idx = 0; idx < this->listWidgetLocalAppParams->count(); ++idx) {
     const auto item = this->listWidgetLocalAppParams->item(idx);
-    if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::string)) {
-      items.emplace_back(Settings::LocalAppParameterType::string, item->text().toStdString());
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::file)) {
+    if (item->type() ==
+        static_cast<int>(QListWidgetItem::UserType) +
+            static_cast<int>(Settings::LocalAppParameterType::string)) {
+      items.emplace_back(Settings::LocalAppParameterType::string,
+                         item->text().toStdString());
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(Settings::LocalAppParameterType::file)) {
       items.emplace_back(Settings::LocalAppParameterType::file, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::dir)) {
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(Settings::LocalAppParameterType::dir)) {
       items.emplace_back(Settings::LocalAppParameterType::dir, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::extension)) {
-      items.emplace_back(Settings::LocalAppParameterType::extension, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::source)) {
-      items.emplace_back(Settings::LocalAppParameterType::source, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::sourcedir)) {
-      items.emplace_back(Settings::LocalAppParameterType::sourcedir, std::string{});
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(
+                       Settings::LocalAppParameterType::extension)) {
+      items.emplace_back(Settings::LocalAppParameterType::extension,
+                         std::string{});
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(Settings::LocalAppParameterType::source)) {
+      items.emplace_back(Settings::LocalAppParameterType::source,
+                         std::string{});
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(
+                       Settings::LocalAppParameterType::sourcedir)) {
+      items.emplace_back(Settings::LocalAppParameterType::sourcedir,
+                         std::string{});
     }
   }
   Settings::Settings::localAppParameterList.setValue(items);
   writeSettings();
 }
 
-void Preferences::on_listWidgetLocalAppParams_itemChanged(QListWidgetItem *) {
+void Preferences::on_listWidgetLocalAppParams_itemChanged(QListWidgetItem*) {
   // called when parameter values are edited
   updateLocalAppParams();
 }
 
-void Preferences::listWidgetLocalAppParamsModelDataChanged()
-{
+void Preferences::listWidgetLocalAppParamsModelDataChanged() {
   // called when rows are added or removed
   updateLocalAppParams();
 }
 
-void Preferences::on_actionLocalAppParameterFile_triggered()
-{
+void Preferences::on_actionLocalAppParameterFile_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::file);
 }
 
-void Preferences::on_actionLocalAppParameterDir_triggered()
-{
+void Preferences::on_actionLocalAppParameterDir_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::dir);
 }
 
-void Preferences::on_actionLocalAppParameterExtension_triggered()
-{
+void Preferences::on_actionLocalAppParameterExtension_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::extension);
 }
 
-void Preferences::on_actionLocalAppParameterSource_triggered()
-{
+void Preferences::on_actionLocalAppParameterSource_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::source);
 }
 
-void Preferences::on_actionLocalAppParameterSourceDir_triggered()
-{
+void Preferences::on_actionLocalAppParameterSourceDir_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::sourcedir);
 }
 
-void Preferences::on_pushButtonOctoPrintCheckConnection_clicked()
-{
+void Preferences::on_pushButtonOctoPrintCheckConnection_clicked() {
   OctoPrint octoPrint;
 
   try {
     QString api_version;
     QString server_version;
     std::tie(api_version, server_version) = octoPrint.getVersion();
-    this->labelOctoPrintCheckConnection->setText(QString{_("Success: Server Version = %2, API Version = %1")}.arg(api_version).arg(server_version));
+    this->labelOctoPrintCheckConnection->setText(
+        QString{_("Success: Server Version = %2, API Version = %1")}
+            .arg(api_version)
+            .arg(server_version));
   } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
+    QMessageBox::critical(this, _("Error"),
+                          QString::fromStdString(e.getErrorMessage()),
+                          QMessageBox::Ok);
     this->labelOctoPrintCheckConnection->setText("");
   }
 }
 
-void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked()
-{
+void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked() {
   OctoPrint octoPrint;
 
   const QString selection = this->comboBoxOctoPrintSlicingEngine->currentText();
@@ -1099,7 +1128,8 @@ void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked()
     this->comboBoxOctoPrintSlicingEngine->clear();
     this->comboBoxOctoPrintSlicingEngine->addItem(_("<Default>"), QVariant{""});
     for (const auto& entry : slicers) {
-      this->comboBoxOctoPrintSlicingEngine->addItem(entry.second, QVariant{entry.first});
+      this->comboBoxOctoPrintSlicingEngine->addItem(entry.second,
+                                                    QVariant{entry.first});
     }
 
     const int idx = this->comboBoxOctoPrintSlicingEngine->findText(selection);
@@ -1107,14 +1137,18 @@ void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked()
       this->comboBoxOctoPrintSlicingEngine->setCurrentIndex(idx);
     }
   } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
+    QMessageBox::critical(this, _("Error"),
+                          QString::fromStdString(e.getErrorMessage()),
+                          QMessageBox::Ok);
   }
 }
 
-void Preferences::on_comboBoxOctoPrintSlicingEngine_activated(int val)
-{
-  const QString text = this->comboBoxOctoPrintSlicingEngine->itemData(val).toString();
-  const QString desc = text.isEmpty() ? QString{} : this->comboBoxOctoPrintSlicingEngine->itemText(val);
+void Preferences::on_comboBoxOctoPrintSlicingEngine_activated(int val) {
+  const QString text =
+      this->comboBoxOctoPrintSlicingEngine->itemData(val).toString();
+  const QString desc =
+      text.isEmpty() ? QString{}
+                     : this->comboBoxOctoPrintSlicingEngine->itemText(val);
   Settings::Settings::octoPrintSlicerEngine.setValue(text.toStdString());
   Settings::Settings::octoPrintSlicerEngineDesc.setValue(desc.toStdString());
   Settings::Settings::octoPrintSlicerProfile.setValue("");
@@ -1123,19 +1157,24 @@ void Preferences::on_comboBoxOctoPrintSlicingEngine_activated(int val)
   this->comboBoxOctoPrintSlicingProfile->setCurrentIndex(0);
 }
 
-void Preferences::on_pushButtonOctoPrintSlicingProfile_clicked()
-{
+void Preferences::on_pushButtonOctoPrintSlicingProfile_clicked() {
   OctoPrint octoPrint;
 
-  const QString selection = this->comboBoxOctoPrintSlicingProfile->currentText();
-  const QString slicer = this->comboBoxOctoPrintSlicingEngine->itemData(this->comboBoxOctoPrintSlicingEngine->currentIndex()).toString();
+  const QString selection =
+      this->comboBoxOctoPrintSlicingProfile->currentText();
+  const QString slicer =
+      this->comboBoxOctoPrintSlicingEngine
+          ->itemData(this->comboBoxOctoPrintSlicingEngine->currentIndex())
+          .toString();
 
   try {
     const auto profiles = octoPrint.getProfiles(slicer);
     this->comboBoxOctoPrintSlicingProfile->clear();
-    this->comboBoxOctoPrintSlicingProfile->addItem(_("<Default>"), QVariant{""});
+    this->comboBoxOctoPrintSlicingProfile->addItem(_("<Default>"),
+                                                   QVariant{""});
     for (const auto& entry : profiles) {
-      this->comboBoxOctoPrintSlicingProfile->addItem(entry.second, QVariant{entry.first});
+      this->comboBoxOctoPrintSlicingProfile->addItem(entry.second,
+                                                     QVariant{entry.first});
     }
 
     const int idx = this->comboBoxOctoPrintSlicingProfile->findText(selection);
@@ -1143,69 +1182,65 @@ void Preferences::on_pushButtonOctoPrintSlicingProfile_clicked()
       this->comboBoxOctoPrintSlicingProfile->setCurrentIndex(idx);
     }
   } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
+    QMessageBox::critical(this, _("Error"),
+                          QString::fromStdString(e.getErrorMessage()),
+                          QMessageBox::Ok);
   }
 }
 
-void Preferences::on_comboBoxOctoPrintSlicingProfile_activated(int val)
-{
-  const QString text = this->comboBoxOctoPrintSlicingProfile->itemData(val).toString();
-  const QString desc = text.isEmpty() ? QString{} : this->comboBoxOctoPrintSlicingProfile->itemText(val);
+void Preferences::on_comboBoxOctoPrintSlicingProfile_activated(int val) {
+  const QString text =
+      this->comboBoxOctoPrintSlicingProfile->itemData(val).toString();
+  const QString desc =
+      text.isEmpty() ? QString{}
+                     : this->comboBoxOctoPrintSlicingProfile->itemText(val);
   Settings::Settings::octoPrintSlicerProfile.setValue(text.toStdString());
   Settings::Settings::octoPrintSlicerProfileDesc.setValue(desc.toStdString());
   writeSettings();
 }
 
-void Preferences::on_checkBoxAlwaysShowExportPdfDialog_toggled(bool state)
-{
+void Preferences::on_checkBoxAlwaysShowExportPdfDialog_toggled(bool state) {
   Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.setValue(state);
   writeSettings();
 }
 
-void Preferences::on_checkBoxAlwaysShowExport3mfDialog_toggled(bool state)
-{
+void Preferences::on_checkBoxAlwaysShowExport3mfDialog_toggled(bool state) {
   Settings::SettingsExport3mf::export3mfAlwaysShowDialog.setValue(state);
   writeSettings();
 }
 
-void Preferences::on_checkBoxAlwaysShowPrintServiceDialog_toggled(bool state)
-{
+void Preferences::on_checkBoxAlwaysShowPrintServiceDialog_toggled(bool state) {
   Settings::Settings::printServiceAlwaysShowDialog.setValue(state);
   writeSettings();
 }
 
-void Preferences::writeSettings()
-{
+void Preferences::writeSettings() {
   Settings::Settings::visit(SettingsWriter());
   fireEditorConfigChanged();
 }
 
-void Preferences::fireEditorConfigChanged() const
-{
+void Preferences::fireEditorConfigChanged() const {
   emit editorConfigChanged();
 }
 
-void Preferences::keyPressEvent(QKeyEvent *e)
-{
+void Preferences::keyPressEvent(QKeyEvent* e) {
 #ifdef Q_OS_MACOS
   if (e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_Period) {
     close();
   } else
 #endif
-  if ((e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_W) ||
-      e->key() == Qt::Key_Escape) {
+      if ((e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_W) ||
+          e->key() == Qt::Key_Escape) {
     close();
   }
 }
 
-void Preferences::showEvent(QShowEvent *e)
-{
+void Preferences::showEvent(QShowEvent* e) {
   QMainWindow::showEvent(e);
   hidePasswords();
 }
 
-void Preferences::closeEvent(QCloseEvent *e)
-{
+void Preferences::closeEvent(QCloseEvent* e) {
   hidePasswords();
   QMainWindow::closeEvent(e);
 }
@@ -1214,62 +1249,81 @@ void Preferences::closeEvent(QCloseEvent *e)
    Removes settings that are the same as the default settings to avoid
    overwriting future changes to default settings.
  */
-void Preferences::removeDefaultSettings()
-{
+void Preferences::removeDefaultSettings() {
   QSettingsCached settings;
   for (QSettings::SettingsMap::const_iterator iter = this->defaultmap.begin();
-       iter != this->defaultmap.end();
-       iter++) {
+       iter != this->defaultmap.end(); iter++) {
     if (settings.value(iter.key()) == iter.value()) {
       settings.remove(iter.key());
     }
   }
 }
 
-QVariant Preferences::getValue(const QString& key) const
-{
+QVariant Preferences::getValue(const QString& key) const {
   QSettingsCached settings;
   assert(settings.contains(key) || this->defaultmap.contains(key));
   return settings.value(key, this->defaultmap[key]);
 }
 
-void Preferences::updateGUI()
-{
-  const auto found = this->colorSchemeChooser->findItems(getValue("3dview/colorscheme").toString(), Qt::MatchExactly);
-  if (!found.isEmpty()) BlockSignals<QListWidget *>(this->colorSchemeChooser)->setCurrentItem(found.first());
+void Preferences::updateGUI() {
+  const auto found = this->colorSchemeChooser->findItems(
+      getValue("3dview/colorscheme").toString(), Qt::MatchExactly);
+  if (!found.isEmpty())
+    BlockSignals<QListWidget*>(this->colorSchemeChooser)
+        ->setCurrentItem(found.first());
 
   updateGUIFontFamily(fontChooser, "editor/fontfamily");
   updateGUIFontSize(fontSize, "editor/fontsize");
 
   const auto shighlight = getValue("editor/syntaxhighlight").toString();
   const auto shidx = this->syntaxHighlight->findText(shighlight);
-  const auto sheffidx = shidx >= 0 ? shidx : this->syntaxHighlight->findText("Off");
+  const auto sheffidx =
+      shidx >= 0 ? shidx : this->syntaxHighlight->findText("Off");
   if (sheffidx >= 0) {
-    BlockSignals<QComboBox *>(this->syntaxHighlight)->setCurrentIndex(sheffidx);
+    BlockSignals<QComboBox*>(this->syntaxHighlight)->setCurrentIndex(sheffidx);
   }
 
-  BlockSignals<QCheckBox *>(this->mouseWheelZoomBox)->setChecked(getValue("editor/ctrlmousewheelzoom").toBool());
+  BlockSignals<QCheckBox*>(this->mouseWheelZoomBox)
+      ->setChecked(getValue("editor/ctrlmousewheelzoom").toBool());
 
-  if (AutoUpdater *updater = AutoUpdater::updater()) {
-    BlockSignals<QCheckBox *>(this->updateCheckBox)->setChecked(updater->automaticallyChecksForUpdates());
-    BlockSignals<QCheckBox *>(this->snapshotCheckBox)->setChecked(updater->enableSnapshots());
-    BlockSignals<QLabel *>(this->lastCheckedLabel)->setText(updater->lastUpdateCheckDate());
+  if (AutoUpdater* updater = AutoUpdater::updater()) {
+    BlockSignals<QCheckBox*>(this->updateCheckBox)
+        ->setChecked(updater->automaticallyChecksForUpdates());
+    BlockSignals<QCheckBox*>(this->snapshotCheckBox)
+        ->setChecked(updater->enableSnapshots());
+    BlockSignals<QLabel*>(this->lastCheckedLabel)
+        ->setText(updater->lastUpdateCheckDate());
   }
 
-  BlockSignals<QCheckBox *>(this->openCSGWarningBox)->setChecked(getValue("advanced/opencsg_show_warning").toBool());
-  BlockSignals<QLineEdit *>(this->cgalCacheSizeMBEdit)->setText(getValue("advanced/cgalCacheSizeMB").toString());
-  BlockSignals<QLineEdit *>(this->polysetCacheSizeMBEdit)->setText(getValue("advanced/polysetCacheSizeMB").toString());
-  BlockSignals<QLineEdit *>(this->opencsgLimitEdit)->setText(getValue("advanced/openCSGLimit").toString());
-  BlockSignals<QCheckBox *>(this->localizationCheckBox)->setChecked(getValue("advanced/localization").toBool());
-  BlockSignals<QCheckBox *>(this->autoReloadRaiseCheckBox)->setChecked(getValue("advanced/autoReloadRaise").toBool());
-  BlockSignals<QCheckBox *>(this->forceGoldfeatherBox)->setChecked(getValue("advanced/forceGoldfeather").toBool());
-  BlockSignals<QCheckBox *>(this->reorderCheckBox)->setChecked(getValue("advanced/reorderWindows").toBool());
-  BlockSignals<QCheckBox *>(this->undockCheckBox)->setChecked(getValue("advanced/undockableWindows").toBool());
-  BlockSignals<QCheckBox *>(this->launcherBox)->setChecked(getValue("launcher/showOnStartup").toBool());
-  BlockSignals<QCheckBox *>(this->enableSoundOnRenderCompleteCheckBox)->setChecked(getValue("advanced/enableSoundNotification").toBool());
-  BlockSignals<QLineEdit *>(this->timeThresholdOnRenderCompleteSoundEdit)->setText(getValue("advanced/timeThresholdOnRenderCompleteSound").toString());
-  BlockSignals<QCheckBox *>(this->enableClearConsoleCheckBox)->setChecked(getValue("advanced/consoleAutoClear").toBool());
-  BlockSignals<QLineEdit *>(this->consoleMaxLinesEdit)->setText(getValue("advanced/consoleMaxLines").toString());
+  BlockSignals<QCheckBox*>(this->openCSGWarningBox)
+      ->setChecked(getValue("advanced/opencsg_show_warning").toBool());
+  BlockSignals<QLineEdit*>(this->cgalCacheSizeMBEdit)
+      ->setText(getValue("advanced/cgalCacheSizeMB").toString());
+  BlockSignals<QLineEdit*>(this->polysetCacheSizeMBEdit)
+      ->setText(getValue("advanced/polysetCacheSizeMB").toString());
+  BlockSignals<QLineEdit*>(this->opencsgLimitEdit)
+      ->setText(getValue("advanced/openCSGLimit").toString());
+  BlockSignals<QCheckBox*>(this->localizationCheckBox)
+      ->setChecked(getValue("advanced/localization").toBool());
+  BlockSignals<QCheckBox*>(this->autoReloadRaiseCheckBox)
+      ->setChecked(getValue("advanced/autoReloadRaise").toBool());
+  BlockSignals<QCheckBox*>(this->forceGoldfeatherBox)
+      ->setChecked(getValue("advanced/forceGoldfeather").toBool());
+  BlockSignals<QCheckBox*>(this->reorderCheckBox)
+      ->setChecked(getValue("advanced/reorderWindows").toBool());
+  BlockSignals<QCheckBox*>(this->undockCheckBox)
+      ->setChecked(getValue("advanced/undockableWindows").toBool());
+  BlockSignals<QCheckBox*>(this->launcherBox)
+      ->setChecked(getValue("launcher/showOnStartup").toBool());
+  BlockSignals<QCheckBox*>(this->enableSoundOnRenderCompleteCheckBox)
+      ->setChecked(getValue("advanced/enableSoundNotification").toBool());
+  BlockSignals<QLineEdit*>(this->timeThresholdOnRenderCompleteSoundEdit)
+      ->setText(
+          getValue("advanced/timeThresholdOnRenderCompleteSound").toString());
+  BlockSignals<QCheckBox*>(this->enableClearConsoleCheckBox)
+      ->setChecked(getValue("advanced/consoleAutoClear").toBool());
+  BlockSignals<QLineEdit*>(this->consoleMaxLinesEdit)
+      ->setText(getValue("advanced/consoleMaxLines").toString());
 
   updateGUIFontFamily(consoleFontChooser, "advanced/consoleFontFamily");
   updateGUIFontSize(consoleFontSize, "advanced/consoleFontSize");
@@ -1277,98 +1331,148 @@ void Preferences::updateGUI()
   updateGUIFontFamily(customizerFontChooser, "advanced/customizerFontFamily");
   updateGUIFontSize(customizerFontSize, "advanced/customizerFontSize");
 
-  BlockSignals<QCheckBox *>(this->enableHardwarningsCheckBox)->setChecked(getValue("advanced/enableHardwarnings").toBool());
-  BlockSignals<QLineEdit *>(this->traceDepthEdit)->setText(getValue("advanced/traceDepth").toString());
-  BlockSignals<QCheckBox *>(this->enableTraceUsermoduleParametersCheckBox)->setChecked(getValue("advanced/enableTraceUsermoduleParameters").toBool());
-  BlockSignals<QCheckBox *>(this->enableParameterCheckBox)->setChecked(getValue("advanced/enableParameterCheck").toBool());
-  BlockSignals<QCheckBox *>(this->enableRangeCheckBox)->setChecked(getValue("advanced/enableParameterRangeCheck").toBool());
-  updateComboBox(this->comboBoxToolbarExport3D, Settings::Settings::toolbarExport3D);
-  updateComboBox(this->comboBoxToolbarExport2D, Settings::Settings::toolbarExport2D);
-
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryCamera)->setChecked(Settings::Settings::summaryCamera.value());
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryArea)->setChecked(Settings::Settings::summaryArea.value());
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryBoundingBox)->setChecked(Settings::Settings::summaryBoundingBox.value());
-
-  BlockSignals<QCheckBox *>(this->enableHidapiTraceCheckBox)->setChecked(Settings::Settings::inputEnableDriverHIDAPILog.value());
-  BlockSignals<QCheckBox *>(this->checkBoxEnableAutocomplete)->setChecked(getValue("editor/enableAutocomplete").toBool());
-  BlockSignals<QLineEdit *>(this->lineEditCharacterThreshold)->setText(getValue("editor/characterThreshold").toString());
-  BlockSignals<QLineEdit *>(this->lineEditStepSize)->setText(getValue("editor/stepSize").toString());
-
-  this->secLabelOnRenderCompleteSound->setEnabled(getValue("advanced/enableSoundNotification").toBool());
+  BlockSignals<QCheckBox*>(this->enableHardwarningsCheckBox)
+      ->setChecked(getValue("advanced/enableHardwarnings").toBool());
+  BlockSignals<QLineEdit*>(this->traceDepthEdit)
+      ->setText(getValue("advanced/traceDepth").toString());
+  BlockSignals<QCheckBox*>(this->enableTraceUsermoduleParametersCheckBox)
+      ->setChecked(
+          getValue("advanced/enableTraceUsermoduleParameters").toBool());
+  BlockSignals<QCheckBox*>(this->enableParameterCheckBox)
+      ->setChecked(getValue("advanced/enableParameterCheck").toBool());
+  BlockSignals<QCheckBox*>(this->enableRangeCheckBox)
+      ->setChecked(getValue("advanced/enableParameterRangeCheck").toBool());
+  updateComboBox(this->comboBoxToolbarExport3D,
+                 Settings::Settings::toolbarExport3D);
+  updateComboBox(this->comboBoxToolbarExport2D,
+                 Settings::Settings::toolbarExport2D);
+
+  BlockSignals<QCheckBox*>(this->checkBoxSummaryCamera)
+      ->setChecked(Settings::Settings::summaryCamera.value());
+  BlockSignals<QCheckBox*>(this->checkBoxSummaryArea)
+      ->setChecked(Settings::Settings::summaryArea.value());
+  BlockSignals<QCheckBox*>(this->checkBoxSummaryBoundingBox)
+      ->setChecked(Settings::Settings::summaryBoundingBox.value());
+
+  BlockSignals<QCheckBox*>(this->enableHidapiTraceCheckBox)
+      ->setChecked(Settings::Settings::inputEnableDriverHIDAPILog.value());
+  BlockSignals<QCheckBox*>(this->checkBoxEnableAutocomplete)
+      ->setChecked(getValue("editor/enableAutocomplete").toBool());
+  BlockSignals<QLineEdit*>(this->lineEditCharacterThreshold)
+      ->setText(getValue("editor/characterThreshold").toString());
+  BlockSignals<QLineEdit*>(this->lineEditStepSize)
+      ->setText(getValue("editor/stepSize").toString());
+
+  this->secLabelOnRenderCompleteSound->setEnabled(
+      getValue("advanced/enableSoundNotification").toBool());
   this->undockCheckBox->setEnabled(this->reorderCheckBox->isChecked());
-  this->timeThresholdOnRenderCompleteSoundLabel->setEnabled(getValue("advanced/enableSoundNotification").toBool());
-  this->timeThresholdOnRenderCompleteSoundEdit->setEnabled(getValue("advanced/enableSoundNotification").toBool());
-  this->labelCharacterThreshold->setEnabled(getValue("editor/enableAutocomplete").toBool());
-  this->lineEditCharacterThreshold->setEnabled(getValue("editor/enableAutocomplete").toBool());
+  this->timeThresholdOnRenderCompleteSoundLabel->setEnabled(
+      getValue("advanced/enableSoundNotification").toBool());
+  this->timeThresholdOnRenderCompleteSoundEdit->setEnabled(
+      getValue("advanced/enableSoundNotification").toBool());
+  this->labelCharacterThreshold->setEnabled(
+      getValue("editor/enableAutocomplete").toBool());
+  this->lineEditCharacterThreshold->setEnabled(
+      getValue("editor/enableAutocomplete").toBool());
   this->lineEditStepSize->setEnabled(getValue("editor/stepSize").toBool());
 
-  updateComboBox(this->comboBoxRenderBackend3D, Settings::Settings::renderBackend3D);
+  updateComboBox(this->comboBoxRenderBackend3D,
+                 Settings::Settings::renderBackend3D);
   updateComboBox(this->comboBoxLineWrap, Settings::Settings::lineWrap);
-  updateComboBox(this->comboBoxLineWrapIndentationStyle, Settings::Settings::lineWrapIndentationStyle);
-  updateComboBox(this->comboBoxLineWrapVisualizationStart, Settings::Settings::lineWrapVisualizationBegin);
-  updateComboBox(this->comboBoxLineWrapVisualizationEnd, Settings::Settings::lineWrapVisualizationEnd);
-  updateComboBox(this->comboBoxShowWhitespace, Settings::Settings::showWhitespace);
+  updateComboBox(this->comboBoxLineWrapIndentationStyle,
+                 Settings::Settings::lineWrapIndentationStyle);
+  updateComboBox(this->comboBoxLineWrapVisualizationStart,
+                 Settings::Settings::lineWrapVisualizationBegin);
+  updateComboBox(this->comboBoxLineWrapVisualizationEnd,
+                 Settings::Settings::lineWrapVisualizationEnd);
+  updateComboBox(this->comboBoxShowWhitespace,
+                 Settings::Settings::showWhitespace);
   updateComboBox(this->comboBoxIndentUsing, Settings::Settings::indentStyle);
-  updateComboBox(this->comboBoxTabKeyFunction, Settings::Settings::tabKeyFunction);
-  updateComboBox(this->comboBoxModifierNumberScrollWheel, Settings::Settings::modifierNumberScrollWheel);
-  updateIntSpinBox(this->spinBoxIndentationWidth, Settings::Settings::indentationWidth);
+  updateComboBox(this->comboBoxTabKeyFunction,
+                 Settings::Settings::tabKeyFunction);
+  updateComboBox(this->comboBoxModifierNumberScrollWheel,
+                 Settings::Settings::modifierNumberScrollWheel);
+  updateIntSpinBox(this->spinBoxIndentationWidth,
+                   Settings::Settings::indentationWidth);
   updateIntSpinBox(this->spinBoxTabWidth, Settings::Settings::tabWidth);
-  updateIntSpinBox(this->spinBoxLineWrapIndentationIndent, Settings::Settings::lineWrapIndentation);
-  updateIntSpinBox(this->spinBoxShowWhitespaceSize, Settings::Settings::showWhitespaceSize);
+  updateIntSpinBox(this->spinBoxLineWrapIndentationIndent,
+                   Settings::Settings::lineWrapIndentation);
+  updateIntSpinBox(this->spinBoxShowWhitespaceSize,
+                   Settings::Settings::showWhitespaceSize);
   initUpdateCheckBox(this->checkBoxAutoIndent, Settings::Settings::autoIndent);
-  initUpdateCheckBox(this->checkBoxBackspaceUnindents, Settings::Settings::backspaceUnindents);
-  initUpdateCheckBox(this->checkBoxHighlightCurrentLine, Settings::Settings::highlightCurrentLine);
-  initUpdateCheckBox(this->checkBoxEnableBraceMatching, Settings::Settings::enableBraceMatching);
-  initUpdateCheckBox(this->checkBoxEnableNumberScrollWheel, Settings::Settings::enableNumberScrollWheel);
-  initUpdateCheckBox(this->checkBoxShowWarningsIn3dView, Settings::Settings::showWarningsIn3dView);
-  initUpdateCheckBox(this->checkBoxMouseCentricZoom, Settings::Settings::mouseCentricZoom);
-  initUpdateCheckBox(this->checkBoxMouseSwapButtons, Settings::Settings::mouseSwapButtons);
-  initUpdateCheckBox(this->checkBoxEnableLineNumbers, Settings::Settings::enableLineNumbers);
-
-
-
-  /* Next Line disables the Indent Spin-Box,for 'Same' and 'Indented' LineWrapStyle selection from LineWrapIndentationStyle Combo-box, just after launching the openscad application.
-     Removing this line will cause misbehaviour, and will not disable the Indent spin-box until you interact with the LineWrapStyle Combo-Box first-time and choose a style for which disabling has been handled.
-     For normal cases, a similar line, inside the function 'on_comboBoxLineWrapIndentationStyle_activated()' handles the disabling functionality.
+  initUpdateCheckBox(this->checkBoxBackspaceUnindents,
+                     Settings::Settings::backspaceUnindents);
+  initUpdateCheckBox(this->checkBoxHighlightCurrentLine,
+                     Settings::Settings::highlightCurrentLine);
+  initUpdateCheckBox(this->checkBoxEnableBraceMatching,
+                     Settings::Settings::enableBraceMatching);
+  initUpdateCheckBox(this->checkBoxEnableNumberScrollWheel,
+                     Settings::Settings::enableNumberScrollWheel);
+  initUpdateCheckBox(this->checkBoxShowWarningsIn3dView,
+                     Settings::Settings::showWarningsIn3dView);
+  initUpdateCheckBox(this->checkBoxMouseCentricZoom,
+                     Settings::Settings::mouseCentricZoom);
+  initUpdateCheckBox(this->checkBoxMouseSwapButtons,
+                     Settings::Settings::mouseSwapButtons);
+  initUpdateCheckBox(this->checkBoxEnableLineNumbers,
+                     Settings::Settings::enableLineNumbers);
+
+  /* Next Line disables the Indent Spin-Box,for 'Same' and 'Indented'
+     LineWrapStyle selection from LineWrapIndentationStyle Combo-box, just after
+     launching the openscad application. Removing this line will cause
+     misbehaviour, and will not disable the Indent spin-box until you interact
+     with the LineWrapStyle Combo-Box first-time and choose a style for which
+     disabling has been handled. For normal cases, a similar line, inside the
+     function 'on_comboBoxLineWrapIndentationStyle_activated()' handles the
+     disabling functionality.
    */
-  this->spinBoxLineWrapIndentationIndent->setDisabled(comboBoxLineWrapIndentationStyle->currentData() == "Same" || comboBoxLineWrapIndentationStyle->currentData() == "Indented");
-  this->comboBoxModifierNumberScrollWheel->setDisabled(!checkBoxEnableNumberScrollWheel->isChecked());
-  BlockSignals<QLineEdit *>(this->lineEditOctoPrintURL)->setText(QString::fromStdString(Settings::Settings::octoPrintUrl.value()));
-  BlockSignals<QLineEdit *>(this->lineEditOctoPrintApiKey)->setText(QString::fromStdString(Settings::Settings::octoPrintApiKey.value()));
-  updateComboBox(this->comboBoxOctoPrintAction, Settings::Settings::octoPrintAction);
-  updateComboBox(this->comboBoxOctoPrintSlicingEngine, Settings::Settings::octoPrintSlicerEngine.value());
-  updateComboBox(this->comboBoxOctoPrintSlicingProfile, Settings::Settings::octoPrintSlicerProfile.value());
-}
-
-void Preferences::applyComboBox(QComboBox * /*comboBox*/, int val, Settings::SettingsEntryEnum<std::string>& entry)
-{
+  this->spinBoxLineWrapIndentationIndent->setDisabled(
+      comboBoxLineWrapIndentationStyle->currentData() == "Same" ||
+      comboBoxLineWrapIndentationStyle->currentData() == "Indented");
+  this->comboBoxModifierNumberScrollWheel->setDisabled(
+      !checkBoxEnableNumberScrollWheel->isChecked());
+  BlockSignals<QLineEdit*>(this->lineEditOctoPrintURL)
+      ->setText(
+          QString::fromStdString(Settings::Settings::octoPrintUrl.value()));
+  BlockSignals<QLineEdit*>(this->lineEditOctoPrintApiKey)
+      ->setText(
+          QString::fromStdString(Settings::Settings::octoPrintApiKey.value()));
+  updateComboBox(this->comboBoxOctoPrintAction,
+                 Settings::Settings::octoPrintAction);
+  updateComboBox(this->comboBoxOctoPrintSlicingEngine,
+                 Settings::Settings::octoPrintSlicerEngine.value());
+  updateComboBox(this->comboBoxOctoPrintSlicingProfile,
+                 Settings::Settings::octoPrintSlicerProfile.value());
+}
+
+void Preferences::applyComboBox(
+    QComboBox* /*comboBox*/,
+    int val,
+    Settings::SettingsEntryEnum<std::string>& entry) {
   entry.setIndex(val);
   writeSettings();
 }
 
-void Preferences::apply_win() const
-{
+void Preferences::apply_win() const {
   emit requestRedraw();
   emit openCSGSettingsChanged();
 }
 
-bool Preferences::hasHighlightingColorScheme() const
-{
-  return BlockSignals<QComboBox *>(syntaxHighlight)->count() != 0;
+bool Preferences::hasHighlightingColorScheme() const {
+  return BlockSignals<QComboBox*>(syntaxHighlight)->count() != 0;
 }
 
-void Preferences::setHighlightingColorSchemes(const QStringList& colorSchemes)
-{
-  auto combobox = BlockSignals<QComboBox *>(syntaxHighlight);
+void Preferences::setHighlightingColorSchemes(const QStringList& colorSchemes) {
+  auto combobox = BlockSignals<QComboBox*>(syntaxHighlight);
   combobox->clear();
   combobox->addItems(colorSchemes);
 }
 
-void Preferences::createFontSizeMenu(QComboBox *boxarg, const QString& setting)
-{
+void Preferences::createFontSizeMenu(QComboBox* boxarg,
+                                     const QString& setting) {
   uint savedsize = getValue(setting).toUInt();
   const QFontDatabase db;
-  BlockSignals<QComboBox *> box{boxarg};
+  BlockSignals<QComboBox*> box{boxarg};
   for (auto size : db.standardSizes()) {
     box->addItem(QString::number(size));
     if (static_cast<uint>(size) == savedsize) {
@@ -1376,31 +1480,30 @@ void Preferences::createFontSizeMenu(QComboBox *boxarg, const QString& setting)
     }
   }
   // reset GUI fontsize if fontSize->addItem emitted signals that changed it.
-  box->setEditText(QString("%1").arg(savedsize) );
+  box->setEditText(QString("%1").arg(savedsize));
 }
 
-void Preferences::updateGUIFontFamily(QFontComboBox *ffSelector, const QString& setting)
-{
+void Preferences::updateGUIFontFamily(QFontComboBox* ffSelector,
+                                      const QString& setting) {
   const auto fontfamily = getValue(setting).toString();
   const auto fidx = ffSelector->findText(fontfamily, Qt::MatchContains);
   if (fidx >= 0) {
-    BlockSignals<QFontComboBox *>(ffSelector)->setCurrentIndex(fidx);
+    BlockSignals<QFontComboBox*>(ffSelector)->setCurrentIndex(fidx);
   }
 }
 
-void Preferences::updateGUIFontSize(QComboBox *fsSelector, const QString& setting)
-{
+void Preferences::updateGUIFontSize(QComboBox* fsSelector,
+                                    const QString& setting) {
   const auto fontsize = getValue(setting).toString();
   const auto sidx = fsSelector->findText(fontsize);
   if (sidx >= 0) {
-    BlockSignals<QComboBox *>(fsSelector)->setCurrentIndex(sidx);
+    BlockSignals<QComboBox*>(fsSelector)->setCurrentIndex(sidx);
   } else {
-    BlockSignals<QComboBox *>(fsSelector)->setEditText(fontsize);
+    BlockSignals<QComboBox*>(fsSelector)->setEditText(fontsize);
   }
 }
 
-Preferences *GlobalPreferences::inst()
-{
-  static auto *instance = new Preferences();
+Preferences* GlobalPreferences::inst() {
+  static auto* instance = new Preferences();
   return instance;
 }
diff --git a/src/gui/Preferences.h b/src/gui/Preferences.h
index bf70d6088..3c60aacbe 100644
--- a/src/gui/Preferences.h
+++ b/src/gui/Preferences.h
@@ -8,27 +8,28 @@
 #include <QFontComboBox>
 #include <QHash>
 #include <QKeyEvent>
+#include <QMainWindow>
+#include <QSettings>
 #include <QShowEvent>
 #include <QString>
 #include <QStringList>
 #include <QVariant>
 #include <QWidget>
-#include <QMainWindow>
-#include <QSettings>
 #include <string>
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
-#include "openscad_gui.h"
-#include "ui_Preferences.h"
 #include "core/Settings.h"
 #include "gui/InitConfigurator.h"
+#include "gui/qtgettext.h"  // IWYU pragma: keep
+#include "openscad_gui.h"
+#include "ui_Preferences.h"
 
 class GlobalPreferences;
-class Preferences : public QMainWindow, public Ui::Preferences, public InitConfigurator
-{
+class Preferences : public QMainWindow,
+                    public Ui::Preferences,
+                    public InitConfigurator {
   Q_OBJECT;
 
-public:
+ public:
   ~Preferences() override;
 
   QVariant getValue(const QString& key) const;
@@ -37,7 +38,7 @@ public:
   void apply_win() const;
   void updateGUI();
   void fireEditorConfigChanged() const;
-  void insertListItem(QListWidget *listBox, QListWidgetItem *listItem);
+  void insertListItem(QListWidget* listBox, QListWidgetItem* listItem);
 
   // Returns true if there is an higlightling color scheme configured.
   bool hasHighlightingColorScheme() const;
@@ -45,8 +46,8 @@ public:
   // Set a new colorScheme.
   void setHighlightingColorSchemes(const QStringList& colorSchemes);
 
-public slots:
-  void actionTriggered(class QAction *);
+ public slots:
+  void actionTriggered(class QAction*);
   void featuresCheckBoxToggled(bool);
   void on_stackedWidget_currentChanged(int);
   void on_colorSchemeChooser_itemSelectionChanged();
@@ -114,7 +115,6 @@ public slots:
   void on_comboBoxLineWrapVisualizationEnd_activated(int);
   void on_comboBoxModifierNumberScrollWheel_activated(int);
 
-
   // Display
   void on_checkBoxHighlightCurrentLine_toggled(bool);
   void on_checkBoxEnableBraceMatching_toggled(bool);
@@ -145,7 +145,7 @@ public slots:
   void on_toolButtonLocalAppParameterDown_clicked();
   void on_toolButtonLocalAppParameterAddFile_clicked();
   void on_listWidgetLocalAppParams_itemSelectionChanged();
-  void on_listWidgetLocalAppParams_itemChanged(QListWidgetItem *);
+  void on_listWidgetLocalAppParams_itemChanged(QListWidgetItem*);
   void on_actionLocalAppParameterFile_triggered();
   void on_actionLocalAppParameterDir_triggered();
   void on_actionLocalAppParameterExtension_triggered();
@@ -158,7 +158,7 @@ public slots:
   void on_checkBoxAlwaysShowExport3mfDialog_toggled(bool);
   void on_checkBoxAlwaysShowPrintServiceDialog_toggled(bool);
 
-signals:
+ signals:
   void requestRedraw() const;
   void updateUndockMode(bool undockMode) const;
   void updateReorderMode(bool undockMode) const;
@@ -177,39 +177,40 @@ signals:
   void stepSizeChanged(int val) const;
   void toolbarExportChanged() const;
 
-private slots:
+ private slots:
   void on_lineEditStepSize_textChanged(const QString& arg1);
 
   void on_checkBoxEnableNumberScrollWheel_toggled(bool checked);
 
-private:
+ private:
   friend GlobalPreferences;
-  Preferences(QWidget *parent = nullptr);
-  void keyPressEvent(QKeyEvent *e) override;
-  void showEvent(QShowEvent *e) override;
-  void closeEvent(QCloseEvent *e) override;
+  Preferences(QWidget* parent = nullptr);
+  void keyPressEvent(QKeyEvent* e) override;
+  void showEvent(QShowEvent* e) override;
+  void closeEvent(QCloseEvent* e) override;
   void removeDefaultSettings();
   void setupFeaturesPage();
   void setup3DPrintPage();
   void writeSettings();
   void hidePasswords();
-  void addPrefPage(QActionGroup *group, QAction *action, QWidget *widget);
-  void createFontSizeMenu(QComboBox *box, const QString& setting);
-  void updateGUIFontFamily(QFontComboBox *fontSelector, const QString& setting);
-  void updateGUIFontSize(QComboBox *fsSelector, const QString& setting);
+  void addPrefPage(QActionGroup* group, QAction* action, QWidget* widget);
+  void createFontSizeMenu(QComboBox* box, const QString& setting);
+  void updateGUIFontFamily(QFontComboBox* fontSelector, const QString& setting);
+  void updateGUIFontSize(QComboBox* fsSelector, const QString& setting);
   void updateLocalAppParams();
   void addLocalAppParameter(const Settings::LocalAppParameterType&);
-  void moveListBoxRow(QListWidget *listBox, int offset);
+  void moveListBoxRow(QListWidget* listBox, int offset);
 
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryEnum<std::string>& entry);
+  void applyComboBox(QComboBox* comboBox,
+                     int val,
+                     Settings::SettingsEntryEnum<std::string>& entry);
 
   QSettings::SettingsMap defaultmap;
-  QHash<const QAction *, QWidget *> prefPages;
+  QHash<const QAction*, QWidget*> prefPages;
 };
 
-class GlobalPreferences
-{
-public:
-  static Preferences *inst();
+class GlobalPreferences {
+ public:
+  static Preferences* inst();
 };
diff --git a/src/gui/PrintInitDialog.cc b/src/gui/PrintInitDialog.cc
index 197b8273b..10e907f20 100644
--- a/src/gui/PrintInitDialog.cc
+++ b/src/gui/PrintInitDialog.cc
@@ -26,16 +26,16 @@
 
 #include "gui/PrintInitDialog.h"
 
-#include <vector>
 #include <string>
+#include <vector>
 
 #include <QDialog>
-#include <QString>
 #include <QPushButton>
+#include <QString>
 
-#include "io/export.h"
 #include "core/Settings.h"
 #include "gui/PrintService.h"
+#include "io/export.h"
 
 using S = Settings::Settings;
 
@@ -43,14 +43,14 @@ namespace {
 
 QString toString(print_service_t printServiceType) {
   switch (printServiceType) {
-  case print_service_t::PRINT_SERVICE:
-    return "PRINT_SERVICE";
-  case print_service_t::OCTOPRINT:
-    return "OCTOPRINT";
-  case print_service_t::LOCAL_APPLICATION:
-    return "LOCAL_APPLICATION";
-  default:
-    return "NONE";
+    case print_service_t::PRINT_SERVICE:
+      return "PRINT_SERVICE";
+    case print_service_t::OCTOPRINT:
+      return "OCTOPRINT";
+    case print_service_t::LOCAL_APPLICATION:
+      return "LOCAL_APPLICATION";
+    default:
+      return "NONE";
   }
 }
 
@@ -61,13 +61,15 @@ print_service_t fromString(const std::string& printServiceType) {
     return print_service_t::OCTOPRINT;
   } else if (printServiceType == "LOCAL_APPLICATION") {
     return print_service_t::LOCAL_APPLICATION;
-  } else return print_service_t::NONE;
+  } else
+    return print_service_t::NONE;
 }
 
-} // namespace
+}  // namespace
 
 void PrintInitDialog::populateFileFormatComboBox(
-  const std::vector<FileFormat>& fileFormats, FileFormat currentFormat) {
+    const std::vector<FileFormat>& fileFormats,
+    FileFormat currentFormat) {
   this->comboBoxFileFormat->clear();
   for (const auto& fileFormat : fileFormats) {
     const FileFormatInfo& info = fileformat::info(fileFormat);
@@ -75,18 +77,18 @@ void PrintInitDialog::populateFileFormatComboBox(
                                       QString::fromStdString(info.identifier));
     if (fileFormat == currentFormat) {
       this->comboBoxFileFormat->setCurrentIndex(
-        this->comboBoxFileFormat->count() - 1);
+          this->comboBoxFileFormat->count() - 1);
     }
   }
 }
 
-PrintInitDialog::PrintInitDialog()
-{
+PrintInitDialog::PrintInitDialog() {
   setupUi(this);
 
   resetSelection();
 
-  this->checkBoxAlwaysShowDialog->setChecked(S::printServiceAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowDialog->setChecked(
+      S::printServiceAlwaysShowDialog.value());
 
   // triggers addRemotePrintServiceButtons() if config value is "true"
   const auto remoteServicesEnabled = S::enableRemotePrintServices.value();
@@ -104,31 +106,28 @@ PrintInitDialog::PrintInitDialog()
     this->selectedServiceName = QString::fromStdString(printServiceName);
 
     switch (printService) {
-    case print_service_t::PRINT_SERVICE:
-    {
-      for (const auto& button : this->buttonGroup->buttons()) {
-        const auto& name = button->property(PROPERTY_NAME);
-        if (this->selectedServiceName == name.toString()) {
-          button->click();
-          break;
+      case print_service_t::PRINT_SERVICE: {
+        for (const auto& button : this->buttonGroup->buttons()) {
+          const auto& name = button->property(PROPERTY_NAME);
+          if (this->selectedServiceName == name.toString()) {
+            button->click();
+            break;
+          }
         }
-      }
-    }
-    break;
-    case print_service_t::OCTOPRINT:
-      on_pushButtonOctoPrint_clicked();
-      break;
-    case print_service_t::LOCAL_APPLICATION:
-      on_pushButtonLocalApplication_clicked();
-      break;
-    default:
-      break;
+      } break;
+      case print_service_t::OCTOPRINT:
+        on_pushButtonOctoPrint_clicked();
+        break;
+      case print_service_t::LOCAL_APPLICATION:
+        on_pushButtonLocalApplication_clicked();
+        break;
+      default:
+        break;
     }
   }
 }
 
-void PrintInitDialog::resetSelection()
-{
+void PrintInitDialog::resetSelection() {
   this->textBrowser->setSource(QUrl{urlDialog});
   this->pushButtonOk->setEnabled(false);
   this->comboBoxFileFormat->setEnabled(false);
@@ -140,8 +139,7 @@ void PrintInitDialog::resetSelection()
   this->buttonGroup->setExclusive(true);
 }
 
-void PrintInitDialog::addRemotePrintServiceButtons()
-{
+void PrintInitDialog::addRemotePrintServiceButtons() {
   for (const auto& printServiceItem : PrintService::getPrintServices()) {
     const auto& key = printServiceItem.first;
     const auto& printService = printServiceItem.second;
@@ -152,12 +150,15 @@ void PrintInitDialog::addRemotePrintServiceButtons()
     button->setFocusPolicy(Qt::FocusPolicy::TabFocus);
     button->setProperty(PROPERTY_NAME, QVariant(QString::fromStdString(key)));
     buttonGroup->addButton(button);
-    this->printServiceLayout->insertWidget(this->printServiceLayout->count(), button);
+    this->printServiceLayout->insertWidget(this->printServiceLayout->count(),
+                                           button);
     connect(button, &QPushButton::clicked, this, [&]() {
       FileFormat currentFormat = FileFormat::ASCII_STL;
-      fileformat::fromIdentifier(S::printServiceFileFormat.value(), currentFormat);
+      fileformat::fromIdentifier(S::printServiceFileFormat.value(),
+                                 currentFormat);
       this->textBrowser->setHtml(printService->getInfoHtml());
-      this->populateFileFormatComboBox(printService->getFileFormats(), currentFormat);
+      this->populateFileFormatComboBox(printService->getFileFormats(),
+                                       currentFormat);
       this->selectedPrintService = print_service_t::PRINT_SERVICE;
       this->selectedServiceName = QString::fromStdString(key);
       this->comboBoxFileFormat->setEnabled(true);
@@ -166,8 +167,8 @@ void PrintInitDialog::addRemotePrintServiceButtons()
   }
 }
 
-void PrintInitDialog::on_checkBoxEnableRemotePrintServices_toggled(bool checked)
-{
+void PrintInitDialog::on_checkBoxEnableRemotePrintServices_toggled(
+    bool checked) {
   S::enableRemotePrintServices.setValue(checked);
   writeSettings();
 
@@ -187,40 +188,41 @@ void PrintInitDialog::on_checkBoxEnableRemotePrintServices_toggled(bool checked)
   resetSelection();
 }
 
-void PrintInitDialog::on_pushButtonOctoPrint_clicked()
-{
+void PrintInitDialog::on_pushButtonOctoPrint_clicked() {
   this->textBrowser->setSource(QUrl{urlOctoPrint});
   initComboBox(this->comboBoxFileFormat, S::octoPrintFileFormat);
-  this->on_comboBoxFileFormat_currentIndexChanged(this->comboBoxFileFormat->currentIndex());
+  this->on_comboBoxFileFormat_currentIndexChanged(
+      this->comboBoxFileFormat->currentIndex());
 
   this->selectedPrintService = print_service_t::OCTOPRINT;
   this->selectedServiceName = "";
 
   this->comboBoxFileFormat->setEnabled(true);
   this->pushButtonOk->setEnabled(true);
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
+  const auto fileFormatIdentifier =
+      fileformat::info(this->getFileFormat()).identifier;
   PRINTDB("OCTOPRINT: %s", fileFormatIdentifier);
 }
 
-void PrintInitDialog::on_pushButtonLocalApplication_clicked()
-{
+void PrintInitDialog::on_pushButtonLocalApplication_clicked() {
   // TODO: Instead of forcing people to use Preferences, we should add UI here
   // to select external program.
   this->textBrowser->setSource(QUrl{urlLocalApp});
 
   initComboBox(this->comboBoxFileFormat, S::localAppFileFormat);
-  this->on_comboBoxFileFormat_currentIndexChanged(this->comboBoxFileFormat->currentIndex());
+  this->on_comboBoxFileFormat_currentIndexChanged(
+      this->comboBoxFileFormat->currentIndex());
   this->selectedPrintService = print_service_t::LOCAL_APPLICATION;
   this->selectedServiceName = "";
 
   this->comboBoxFileFormat->setEnabled(true);
   this->pushButtonOk->setEnabled(true);
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
+  const auto fileFormatIdentifier =
+      fileformat::info(this->getFileFormat()).identifier;
   PRINTDB("LOCAL_APPLICATION: %s", fileFormatIdentifier);
 }
 
-void PrintInitDialog::setFileFormat(const std::string& id)
-{
+void PrintInitDialog::setFileFormat(const std::string& id) {
   FileFormat fileFormat = FileFormat::ASCII_STL;
   if (!fileformat::fromIdentifier(id, fileFormat)) {
     // FIXME: When would this error happen? Do we need to handle it?
@@ -229,46 +231,45 @@ void PrintInitDialog::setFileFormat(const std::string& id)
   this->selectedFileFormat = fileFormat;
 }
 
-void PrintInitDialog::on_comboBoxFileFormat_currentIndexChanged(int index)
-{
+void PrintInitDialog::on_comboBoxFileFormat_currentIndexChanged(int index) {
   if (index >= 0) {
-    const auto id = this->comboBoxFileFormat->currentData().toString().toStdString();
+    const auto id =
+        this->comboBoxFileFormat->currentData().toString().toStdString();
     this->setFileFormat(id);
   }
 }
 
-void PrintInitDialog::on_pushButtonOk_clicked()
-{
-  const QString defaultPrintServiceString = toString(this->selectedPrintService);
+void PrintInitDialog::on_pushButtonOk_clicked() {
+  const QString defaultPrintServiceString =
+      toString(this->selectedPrintService);
   S::defaultPrintService.setValue(defaultPrintServiceString.toStdString());
   S::printServiceName.setValue(this->selectedServiceName.toStdString());
 
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
+  const auto fileFormatIdentifier =
+      fileformat::info(this->getFileFormat()).identifier;
   switch (this->selectedPrintService) {
-  case print_service_t::PRINT_SERVICE:
-    S::printServiceFileFormat.setValue(fileFormatIdentifier);
-    break;
-  case print_service_t::OCTOPRINT:
-    S::octoPrintFileFormat.setValue(fileFormatIdentifier);
-    break;
-  case print_service_t::LOCAL_APPLICATION:
-    S::localAppFileFormat.setValue(fileFormatIdentifier);
-    break;
-  default:
-    break;
+    case print_service_t::PRINT_SERVICE:
+      S::printServiceFileFormat.setValue(fileFormatIdentifier);
+      break;
+    case print_service_t::OCTOPRINT:
+      S::octoPrintFileFormat.setValue(fileFormatIdentifier);
+      break;
+    case print_service_t::LOCAL_APPLICATION:
+      S::localAppFileFormat.setValue(fileFormatIdentifier);
+      break;
+    default:
+      break;
   }
   // FIXME: Add support for executable selection
   writeSettings();
   accept();
 }
 
-void PrintInitDialog::on_pushButtonCancel_clicked()
-{
+void PrintInitDialog::on_pushButtonCancel_clicked() {
   reject();
 }
 
-int PrintInitDialog::exec()
-{
+int PrintInitDialog::exec() {
   bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
   if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0 ||
       this->selectedPrintService == print_service_t::NONE) {
@@ -278,24 +279,22 @@ int PrintInitDialog::exec()
   const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
 
   if (showDialog && result == QDialog::Accepted) {
-    S::printServiceAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
+    S::printServiceAlwaysShowDialog.setValue(
+        this->checkBoxAlwaysShowDialog->isChecked());
     writeSettings();
   }
 
   return result;
 }
 
-print_service_t PrintInitDialog::getServiceType() const
-{
+print_service_t PrintInitDialog::getServiceType() const {
   return this->selectedPrintService;
 }
 
-QString PrintInitDialog::getServiceName() const
-{
+QString PrintInitDialog::getServiceName() const {
   return this->selectedServiceName;
 }
 
-FileFormat PrintInitDialog::getFileFormat() const
-{
+FileFormat PrintInitDialog::getFileFormat() const {
   return this->selectedFileFormat;
 }
diff --git a/src/gui/PrintInitDialog.h b/src/gui/PrintInitDialog.h
index 34e0c722c..167051e64 100644
--- a/src/gui/PrintInitDialog.h
+++ b/src/gui/PrintInitDialog.h
@@ -26,31 +26,38 @@
 
 #pragma once
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
-#include "ui_PrintInitDialog.h" // generated, but needs qtgettext.h
+#include "gui/qtgettext.h"       // IWYU pragma: keep
+#include "ui_PrintInitDialog.h"  // generated, but needs qtgettext.h
 
 #include <vector>
 
-#include <QList>
 #include <QDialog>
+#include <QList>
 #include <QPushButton>
 
-#include "io/export.h"
 #include "gui/InitConfigurator.h"
+#include "io/export.h"
 
 // Property name for remote print servive buttons
 constexpr inline auto PROPERTY_NAME = "printServiceName";
 
-enum class print_service_t : std::uint8_t { NONE, PRINT_SERVICE, OCTOPRINT, LOCAL_APPLICATION };
+enum class print_service_t : std::uint8_t {
+  NONE,
+  PRINT_SERVICE,
+  OCTOPRINT,
+  LOCAL_APPLICATION
+};
 
-class PrintInitDialog : public QDialog, public Ui::PrintInitDialog, public InitConfigurator
-{
+class PrintInitDialog : public QDialog,
+                        public Ui::PrintInitDialog,
+                        public InitConfigurator {
   constexpr static auto urlDialog = "qrc:/html/PrintInitDialog.html";
   constexpr static auto urlOctoPrint = "qrc:/html/OctoPrintInfo.html";
   constexpr static auto urlLocalApp = "qrc:/html/LocalApplicationInfo.html";
 
   Q_OBJECT;
-public:
+
+ public:
   PrintInitDialog();
   int exec() override;
 
@@ -58,14 +65,15 @@ public:
   QString getServiceName() const;
   FileFormat getFileFormat() const;
 
-public slots:
+ public slots:
   void on_pushButtonOctoPrint_clicked();
   void on_pushButtonLocalApplication_clicked();
   void on_comboBoxFileFormat_currentIndexChanged(int);
   void on_checkBoxEnableRemotePrintServices_toggled(bool);
   void on_pushButtonOk_clicked();
   void on_pushButtonCancel_clicked();
-private:
+
+ private:
   void resetSelection();
   void addRemotePrintServiceButtons();
   void populateFileFormatComboBox(const std::vector<FileFormat>& fileFormats,
@@ -76,5 +84,5 @@ private:
   print_service_t selectedPrintService = print_service_t::NONE;
   QString selectedServiceName = "";
   FileFormat selectedFileFormat = FileFormat::ASCII_STL;
-  QList<QPushButton *> remoteServiceButtons;
+  QList<QPushButton*> remoteServiceButtons;
 };
diff --git a/src/gui/PrintService.cc b/src/gui/PrintService.cc
index b9f703538..9c0b0938f 100644
--- a/src/gui/PrintService.cc
+++ b/src/gui/PrintService.cc
@@ -26,11 +26,11 @@
 
 #include "gui/PrintService.h"
 
-#include <mutex>
-#include <utility>
-#include <unordered_map>
 #include <memory>
+#include <mutex>
 #include <string>
+#include <unordered_map>
+#include <utility>
 
 #include <QJsonDocument>
 #include <QNetworkAccessManager>
@@ -38,8 +38,8 @@
 #include <QNetworkRequest>
 #include <QStringList>
 
-#include "io/export.h"
 #include "core/Settings.h"
+#include "io/export.h"
 #include "utils/printutils.h"
 
 using S = Settings::Settings;
@@ -49,10 +49,11 @@ PrintServices PrintService::printServices;
 
 namespace {
 
-std::unique_ptr<PrintService>
-createPrintService(const QJsonObject& serviceObject) {
+std::unique_ptr<PrintService> createPrintService(
+    const QJsonObject& serviceObject) {
   auto service = std::make_unique<PrintService>();
-  if (service->init(serviceObject))return service;
+  if (service->init(serviceObject))
+    return service;
   return nullptr;
 }
 
@@ -60,42 +61,43 @@ PrintServices createPrintServices() {
   PrintServices printServices;
   try {
     auto networkRequest = NetworkRequest<void>{
-      QUrl{"https://app.openscad.org/print-service.json"}, {200}, 30};
+        QUrl{"https://app.openscad.org/print-service.json"}, {200}, 30};
     networkRequest.execute(
-      [](QNetworkRequest& request) {
-        request.setHeader(QNetworkRequest::ContentTypeHeader,
-                          "application/json");
-      },
-      [](QNetworkAccessManager& nam, QNetworkRequest& request) {
-        return nam.get(request);
-      },
-      [&](QNetworkReply *reply) {
-        const auto doc = QJsonDocument::fromJson(reply->readAll());
-        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-        const QStringList services = doc.object().keys();
-        for (const auto& serviceName : services) {
-          auto printService =
-            createPrintService(doc.object().value(serviceName).toObject());
-          if (printService) {
-            printServices[serviceName.toStdString()] =
-              std::move(printService);
+        [](QNetworkRequest& request) {
+          request.setHeader(QNetworkRequest::ContentTypeHeader,
+                            "application/json");
+        },
+        [](QNetworkAccessManager& nam, QNetworkRequest& request) {
+          return nam.get(request);
+        },
+        [&](QNetworkReply* reply) {
+          const auto doc = QJsonDocument::fromJson(reply->readAll());
+          PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+          const QStringList services = doc.object().keys();
+          for (const auto& serviceName : services) {
+            auto printService =
+                createPrintService(doc.object().value(serviceName).toObject());
+            if (printService) {
+              printServices[serviceName.toStdString()] =
+                  std::move(printService);
+            }
           }
-        }
-      });
+        });
   } catch (const NetworkException& e) {
     LOG(message_group::Error, "%1$s", e.getErrorMessage());
   }
   for (const auto& printService : printServices) {
     const auto& name = printService.second->getDisplayName().toStdString();
     const auto& limit = printService.second->getFileSizeLimitMB();
-    PRINTDB("External print service available: %1$s (upload limit = %2$d MB)", name % limit);
+    PRINTDB("External print service available: %1$s (upload limit = %2$d MB)",
+            name % limit);
     // TODO: Log if wanted
   }
 
   return printServices;
 }
 
-} // namespace
+}  // namespace
 
 const PrintServices& PrintService::getPrintServices() {
   static PrintServices noPrintServices;
@@ -113,7 +115,7 @@ const PrintServices& PrintService::getPrintServices() {
   return printServices;
 }
 
-const PrintService *PrintService::getPrintService(const std::string& name) {
+const PrintService* PrintService::getPrintService(const std::string& name) {
   const auto& printServices = getPrintServices();
   if (const auto it = printServices.find(name); it != printServices.end()) {
     return it->second.get();
@@ -127,9 +129,11 @@ bool PrintService::init(const QJsonObject& serviceObject) {
   fileSizeLimitMB = serviceObject.value("fileSizeLimitMB").toInt();
   infoHtml = serviceObject.value("infoHtml").toString();
   infoUrl = serviceObject.value("infoUrl").toString();
-  for (const auto& variant : serviceObject.value("fileFormats").toArray().toVariantList()) {
+  for (const auto& variant :
+       serviceObject.value("fileFormats").toArray().toVariantList()) {
     FileFormat fileFormat;
-    if (fileformat::fromIdentifier(variant.toString().toStdString(), fileFormat)) {
+    if (fileformat::fromIdentifier(variant.toString().toStdString(),
+                                   fileFormat)) {
       fileFormats.push_back(fileFormat);
     }
     // TODO: else print warning?
@@ -155,9 +159,10 @@ bool PrintService::init(const QJsonObject& serviceObject) {
  * Outputs:
  *    The resulting url to go to next to continue the order process.
  */
-const QString
-PrintService::upload(const QString& fileName, const QString& contentBase64,
-                     const network_progress_func_t& progress_func) const {
+const QString PrintService::upload(
+    const QString& fileName,
+    const QString& contentBase64,
+    const network_progress_func_t& progress_func) const {
   QJsonObject jsonInput;
   jsonInput.insert("fileName", fileName);
   jsonInput.insert("file", contentBase64);
@@ -169,36 +174,36 @@ PrintService::upload(const QString& fileName, const QString& contentBase64,
   // about 96MB data.
   if (jsonInput.value("file") == QJsonValue::Undefined) {
     const QString msg =
-      "Could not encode STL into JSON. Perhaps it is too large of a file? "
-      "Maybe try reducing the model resolution.";
+        "Could not encode STL into JSON. Perhaps it is too large of a file? "
+        "Maybe try reducing the model resolution.";
     throw NetworkException(QNetworkReply::ProtocolFailure, msg);
   }
 
   auto networkRequest =
-    NetworkRequest<const QString>{QUrl{apiUrl}, {200, 201}, 180};
+      NetworkRequest<const QString>{QUrl{apiUrl}, {200, 201}, 180};
   networkRequest.set_progress_func(progress_func);
   return networkRequest.execute(
-    [](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader,
-                      "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-
-    // Extract cartUrl which gives the page to open in a webbrowser to view
-    // uploaded part
-    auto cartUrlValue =
-      doc.object().value("data").toObject().value("cartUrl");
-    auto cartUrl = cartUrlValue.toString();
-    if ((cartUrlValue == QJsonValue::Undefined) || (cartUrl.isEmpty())) {
-      const QString msg = "Could not get data.cartUrl field from response.";
-      throw NetworkException(QNetworkReply::ProtocolFailure, msg);
-    }
-    LOG("Upload finished, opening URL %1$s.", cartUrl.toStdString());
-    return cartUrl;
-  });
+      [](QNetworkRequest& request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+      },
+      [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
+        return nam.post(request, QJsonDocument(jsonInput).toJson());
+      },
+      [](QNetworkReply* reply) {
+        const auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+
+        // Extract cartUrl which gives the page to open in a webbrowser to view
+        // uploaded part
+        auto cartUrlValue =
+            doc.object().value("data").toObject().value("cartUrl");
+        auto cartUrl = cartUrlValue.toString();
+        if ((cartUrlValue == QJsonValue::Undefined) || (cartUrl.isEmpty())) {
+          const QString msg = "Could not get data.cartUrl field from response.";
+          throw NetworkException(QNetworkReply::ProtocolFailure, msg);
+        }
+        LOG("Upload finished, opening URL %1$s.", cartUrl.toStdString());
+        return cartUrl;
+      });
 }
diff --git a/src/gui/PrintService.h b/src/gui/PrintService.h
index 28f408c3b..d70553af8 100644
--- a/src/gui/PrintService.h
+++ b/src/gui/PrintService.h
@@ -27,24 +27,24 @@
 #pragma once
 
 #include <memory>
-#include <unordered_map>
+#include <mutex>
 #include <string>
+#include <unordered_map>
 #include <vector>
-#include <mutex>
 
+#include <QJsonDocument>
+#include <QJsonObject>
 #include <QString>
 #include <QStringList>
-#include <QJsonObject>
-#include <QJsonDocument>
 
-#include "io/export.h"
 #include "gui/Network.h"
+#include "io/export.h"
 
-using PrintServices = std::unordered_map<std::string, std::unique_ptr<class PrintService>>;
+using PrintServices =
+    std::unordered_map<std::string, std::unique_ptr<class PrintService>>;
 
-class PrintService
-{
-public:
+class PrintService {
+ public:
   const QString getService() const { return service; }
   const QString getDisplayName() const { return displayName; }
   const QString getApiUrl() const { return apiUrl; }
@@ -54,15 +54,16 @@ public:
   const QString getInfoUrl() const { return infoUrl; }
   const std::vector<FileFormat> getFileFormats() const { return fileFormats; }
 
-  const QString upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const;
+  const QString upload(const QString& exportFileName,
+                       const QString& fileName,
+                       const network_progress_func_t& progress_func) const;
 
   bool init(const QJsonObject& serviceObject);
 
-  static const PrintService *getPrintService(const std::string& name);
+  static const PrintService* getPrintService(const std::string& name);
   static const PrintServices& getPrintServices();
 
-private:
-
+ private:
   QString service;
   QString displayName;
   QString apiUrl;
diff --git a/src/gui/ProgressWidget.cc b/src/gui/ProgressWidget.cc
index 24229f9b6..08bb334c5 100644
--- a/src/gui/ProgressWidget.cc
+++ b/src/gui/ProgressWidget.cc
@@ -1,49 +1,42 @@
 #include "gui/ProgressWidget.h"
-#include <QWidget>
 #include <QTimer>
+#include <QWidget>
 
-ProgressWidget::ProgressWidget(QWidget *parent)
-  : QWidget(parent)
-{
+ProgressWidget::ProgressWidget(QWidget* parent) : QWidget(parent) {
   setupUi(this);
   setRange(0, 1000);
   setValue(0);
   this->wascanceled = false;
   this->starttime.start();
 
-  connect(this->stopButton, &QPushButton::clicked, this, &ProgressWidget::cancel);
+  connect(this->stopButton, &QPushButton::clicked, this,
+          &ProgressWidget::cancel);
   QTimer::singleShot(1000, this, &ProgressWidget::requestShow);
 }
 
-bool ProgressWidget::wasCanceled() const
-{
+bool ProgressWidget::wasCanceled() const {
   return this->wascanceled;
 }
 
 /*!
    Returns milliseconds since this widget was created
  */
-int ProgressWidget::elapsedTime() const
-{
+int ProgressWidget::elapsedTime() const {
   return this->starttime.elapsed();
 }
 
-void ProgressWidget::cancel()
-{
+void ProgressWidget::cancel() {
   this->wascanceled = true;
 }
 
-void ProgressWidget::setRange(int minimum, int maximum)
-{
+void ProgressWidget::setRange(int minimum, int maximum) {
   this->progressBar->setRange(minimum, maximum);
 }
 
-void ProgressWidget::setValue(int progress)
-{
+void ProgressWidget::setValue(int progress) {
   this->progressBar->setValue(progress);
 }
 
-int ProgressWidget::value() const
-{
+int ProgressWidget::value() const {
   return this->progressBar->value();
 }
diff --git a/src/gui/ProgressWidget.h b/src/gui/ProgressWidget.h
index 6f0723325..162277470 100644
--- a/src/gui/ProgressWidget.h
+++ b/src/gui/ProgressWidget.h
@@ -1,30 +1,29 @@
 #pragma once
 
+#include <QElapsedTimer>
+#include <QWidget>
 #include "gui/qtgettext.h"
 #include "ui_ProgressWidget.h"
-#include <QWidget>
-#include <QElapsedTimer>
 
-class ProgressWidget : public QWidget, public Ui::ProgressWidget
-{
+class ProgressWidget : public QWidget, public Ui::ProgressWidget {
   Q_OBJECT;
   Q_PROPERTY(bool wasCanceled READ wasCanceled);
 
-public:
-  ProgressWidget(QWidget *parent = nullptr);
+ public:
+  ProgressWidget(QWidget* parent = nullptr);
   bool wasCanceled() const;
   int elapsedTime() const;
 
-public slots:
+ public slots:
   void setRange(int minimum, int maximum);
   void setValue(int progress);
   int value() const;
   void cancel();
 
-signals:
+ signals:
   void requestShow();
 
-private:
+ private:
   bool wascanceled;
   QElapsedTimer starttime;
 };
diff --git a/src/gui/QGLView.cc b/src/gui/QGLView.cc
index d8da76924..60c9c2268 100644
--- a/src/gui/QGLView.cc
+++ b/src/gui/QGLView.cc
@@ -28,30 +28,30 @@
 #include <QtCore/qpoint.h>
 
 #include "geometry/linalg.h"
-#include "gui/qtgettext.h"
-#include "gui/Preferences.h"
 #include "glview/Renderer.h"
+#include "gui/Preferences.h"
+#include "gui/qtgettext.h"
 #include "utils/degree_trig.h"
 #include "utils/scope_guard.hpp"
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
 #include "glview/glew-utils.h"
 #endif
 
-#include <QImage>
-#include <QOpenGLWidget>
-#include <QWidget>
-#include <iostream>
 #include <QApplication>
-#include <QWheelEvent>
 #include <QCheckBox>
 #include <QDialogButtonBox>
-#include <QMouseEvent>
+#include <QErrorMessage>
+#include <QImage>
 #include <QMessageBox>
+#include <QMouseEvent>
+#include <QOpenGLWidget>
 #include <QPushButton>
-#include <QTimer>
 #include <QTextEdit>
+#include <QTimer>
 #include <QVBoxLayout>
-#include <QErrorMessage>
+#include <QWheelEvent>
+#include <QWidget>
+#include <iostream>
 #ifdef USE_GLAD
 #include <QOpenGLContext>
 #endif
@@ -63,25 +63,22 @@
 #include <vector>
 
 #ifdef ENABLE_OPENCSG
-#  include <opencsg.h>
+#include <opencsg.h>
 #endif
 
-#include "gui/qt-obsolete.h"
 #include "gui/Measurement.h"
+#include "gui/qt-obsolete.h"
 
-QGLView::QGLView(QWidget *parent) : QOpenGLWidget(parent)
-{
+QGLView::QGLView(QWidget* parent) : QOpenGLWidget(parent) {
   init();
 }
 
-QGLView::~QGLView()
-{
+QGLView::~QGLView() {
   // Just to make sure we can call GL functions in the supertype destructor
   makeCurrent();
 }
 
-void QGLView::init()
-{
+void QGLView::init() {
   resetView();
 
   this->mouse_drag_active = false;
@@ -90,13 +87,11 @@ void QGLView::init()
   setMouseTracking(true);
 }
 
-void QGLView::resetView()
-{
+void QGLView::resetView() {
   cam.resetView();
 }
 
-void QGLView::viewAll()
-{
+void QGLView::viewAll() {
   if (auto renderer = this->getRenderer()) {
     auto bbox = renderer->getBoundingBox();
     cam.autocenter = true;
@@ -104,8 +99,7 @@ void QGLView::viewAll()
   }
 }
 
-void QGLView::initializeGL()
-{
+void QGLView::initializeGL() {
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
   // Since OpenCSG requires glew, we need to initialize it.
   // ..in a separate compilation unit to avoid duplicate symbols with x.
@@ -113,22 +107,24 @@ void QGLView::initializeGL()
 #endif
 #ifdef USE_GLAD
   // We could ask for gladLoadGLES2UserPtr() here if we want to use GLES2+
-  const auto version = gladLoadGLUserPtr([](void *ctx, const char *name) -> GLADapiproc {
-    return reinterpret_cast<QOpenGLContext *>(ctx)->getProcAddress(name);
-  }, this->context());
+  const auto version = gladLoadGLUserPtr(
+      [](void* ctx, const char* name) -> GLADapiproc {
+        return reinterpret_cast<QOpenGLContext*>(ctx)->getProcAddress(name);
+      },
+      this->context());
   if (version == 0) {
     std::cerr << "Unable to init GLAD" << std::endl;
     return;
   }
-  PRINTDB("GLAD: Loaded OpenGL %d.%d", GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
-#endif // ifdef USE_GLAD
+  PRINTDB("GLAD: Loaded OpenGL %d.%d",
+          GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
+#endif  // ifdef USE_GLAD
   GLView::initializeGL();
 
   this->selector = std::make_unique<MouseSelector>(this);
 }
 
-std::string QGLView::getRendererInfo() const
-{
+std::string QGLView::getRendererInfo() const {
   std::ostringstream info;
   info << gl_dump();
   // Don't translate as translated text in the Library Info dialog is not wanted
@@ -140,68 +136,69 @@ std::string QGLView::getRendererInfo() const
   auto abits = qsf.alphaBufferSize();
   auto dbits = qsf.depthBufferSize();
   auto sbits = qsf.stencilBufferSize();
-  info << boost::format("\nQSurfaceFormat: RGBA(%d%d%d%d), depth(%d), stencil(%d)\n\n") %
-    rbits % gbits % bbits % abits % dbits % sbits;
+  info << boost::format(
+              "\nQSurfaceFormat: RGBA(%d%d%d%d), depth(%d), stencil(%d)\n\n") %
+              rbits % gbits % bbits % abits % dbits % sbits;
   info << gl_extensions_dump();
   return info.str();
 }
 
 #ifdef ENABLE_OPENCSG
-void QGLView::display_opencsg_warning()
-{
-  if (GlobalPreferences::inst()->getValue("advanced/opencsg_show_warning").toBool()) {
+void QGLView::display_opencsg_warning() {
+  if (GlobalPreferences::inst()
+          ->getValue("advanced/opencsg_show_warning")
+          .toBool()) {
     QTimer::singleShot(0, this, &QGLView::display_opencsg_warning_dialog);
   }
 }
 
-void QGLView::display_opencsg_warning_dialog()
-{
+void QGLView::display_opencsg_warning_dialog() {
   auto dialog = new OpenCSGWarningDialog(this);
 
-  QString message = _("Warning: Missing OpenGL capabilities for OpenCSG - OpenCSG has been disabled.\n\n");
-  message += _("It is highly recommended to use OpenSCAD on a system with "
-               "OpenGL 2.0 or later.\n"
-               "Your renderer information is as follows:\n");
+  QString message =
+      _("Warning: Missing OpenGL capabilities for OpenCSG - OpenCSG has been "
+        "disabled.\n\n");
+  message +=
+      _("It is highly recommended to use OpenSCAD on a system with "
+        "OpenGL 2.0 or later.\n"
+        "Your renderer information is as follows:\n");
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
   QString rendererinfo(_("GLEW version %1\n%2 (%3)\nOpenGL version %4\n"));
-  message += rendererinfo.arg((const char *)glewGetString(GLEW_VERSION),
-                              (const char *)glGetString(GL_RENDERER),
-                              (const char *)glGetString(GL_VENDOR),
-                              (const char *)glGetString(GL_VERSION));
+  message += rendererinfo.arg((const char*)glewGetString(GLEW_VERSION),
+                              (const char*)glGetString(GL_RENDERER),
+                              (const char*)glGetString(GL_VENDOR),
+                              (const char*)glGetString(GL_VERSION));
 #endif
 #ifdef USE_GLAD
   QString rendererinfo(_("GLAD version %1\n%2 (%3)\nOpenGL version %4\n"));
   message += rendererinfo.arg(GLAD_GENERATOR_VERSION,
-                              (const char *)glGetString(GL_RENDERER),
-                              (const char *)glGetString(GL_VENDOR),
-                              (const char *)glGetString(GL_VERSION));
+                              (const char*)glGetString(GL_RENDERER),
+                              (const char*)glGetString(GL_VENDOR),
+                              (const char*)glGetString(GL_VERSION));
 #endif
   dialog->setText(message);
   dialog->exec();
 }
-#endif // ifdef ENABLE_OPENCSG
+#endif  // ifdef ENABLE_OPENCSG
 
-void QGLView::resizeGL(int w, int h)
-{
+void QGLView::resizeGL(int w, int h) {
   GLView::resizeGL(w, h);
   emit resized();
 }
 
-void QGLView::paintGL()
-{
+void QGLView::paintGL() {
   GLView::paintGL();
 
   if (statusLabel) {
     auto status = QString("%1 (%2x%3)")
-      .arg(QString::fromStdString(cam.statusText()))
-      .arg(size().rwidth())
-      .arg(size().rheight());
+                      .arg(QString::fromStdString(cam.statusText()))
+                      .arg(size().rwidth())
+                      .arg(size().rheight());
     statusLabel->setText(status);
   }
 }
 
-void QGLView::mousePressEvent(QMouseEvent *event)
-{
+void QGLView::mousePressEvent(QMouseEvent* event) {
   if (!mouse_drag_active) {
     mouse_drag_moved = false;
   }
@@ -214,43 +211,50 @@ void QGLView::mousePressEvent(QMouseEvent *event)
  * Voodoo warning...
  *
  * This function selects the widget's OpenGL context (via this->makeCurrent()).
- * Because it's changing the OpenGL context, it seems polite to save and restore it.
- * That resolution seems correct, independent of the mysteries below.
+ * Because it's changing the OpenGL context, it seems polite to save and restore
+ * it. That resolution seems correct, independent of the mysteries below.
  *
- * Let's call the widget's context W, and the alternate context that we are called with A.
+ * Let's call the widget's context W, and the alternate context that we are
+ * called with A.
  *
- * It's important that A is selected when we return (as it is when we enter), because
- * if it isn't then sometimes the subsequent mouseReleaseEvent is called with W, when it
- * is normally called with A.  When that happens, the object-selection magic in selectObject
- * messes up W, and rendering is forever after broken in that window.
+ * It's important that A is selected when we return (as it is when we enter),
+ * because if it isn't then sometimes the subsequent mouseReleaseEvent is called
+ * with W, when it is normally called with A.  When that happens, the
+ * object-selection magic in selectObject messes up W, and rendering is forever
+ * after broken in that window.
  *
- * However, as hygienic as saving-and-restoring seems, the picture is still unsatisfying.
+ * However, as hygienic as saving-and-restoring seems, the picture is still
+ * unsatisfying.
  *
  * Open questions:
- * - Why are these mouse event functions called with A, rather than being called with W?
- *   It's unsurprising that the selection magic needs its own GL context, but it seems like
- *   it should be the one that needs to explicitly select it, not this function.
+ * - Why are these mouse event functions called with A, rather than being called
+ * with W? It's unsurprising that the selection magic needs its own GL context,
+ * but it seems like it should be the one that needs to explicitly select it,
+ * not this function.
  * - Where did A come from?
  * - Why does a subsequent mouseReleaseEvent call get called with W?
- * - Why does it only sometimes get called with W, and sometimes (correctly) with A?
- * - Why do later mouseReleaseEvent calls revert to being (correctly) called with A?
- * - Why does this only happen with right clicks?  With left clicks, this function
- *   changes the context, but it's OK again on the following mouseReleaseEvent.
- * - Why does this only happen when you click on empty space, and not when you click
- *   on the model?  Double clicks on the model are not detected as double clicks.
- *   Perhaps this is because the first click pops a menu and the second click is
- *   on the menu, not this widget.
+ * - Why does it only sometimes get called with W, and sometimes (correctly)
+ * with A?
+ * - Why do later mouseReleaseEvent calls revert to being (correctly) called
+ * with A?
+ * - Why does this only happen with right clicks?  With left clicks, this
+ * function changes the context, but it's OK again on the following
+ * mouseReleaseEvent.
+ * - Why does this only happen when you click on empty space, and not when you
+ * click on the model?  Double clicks on the model are not detected as double
+ * clicks. Perhaps this is because the first click pops a menu and the second
+ * click is on the menu, not this widget.
  *
- * getGLContext() and setGLContext() are in a separate file, QGLView2.cc, so that this
- * file doesn't need a full declaration of QOpenGLContext.  <QOpenGLContext> is
- * incompatible with GLEW and causes compilation warnings.
+ * getGLContext() and setGLContext() are in a separate file, QGLView2.cc, so
+ * that this file doesn't need a full declaration of QOpenGLContext.
+ * <QOpenGLContext> is incompatible with GLEW and causes compilation warnings.
  *
  * For future attention:
- * - This function should probably only react to left double clicks.  Right double clicks
- *   should probably be ignored.
+ * - This function should probably only react to left double clicks.  Right
+ * double clicks should probably be ignored.
  */
-void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
-  QOpenGLContext *oldContext = getGLContext();
+void QGLView::mouseDoubleClickEvent(QMouseEvent* event) {
+  QOpenGLContext* oldContext = getGLContext();
   this->makeCurrent();
   setupCamera();
 
@@ -267,12 +271,13 @@ void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
   const double y = viewport[3] - event->pos().y() * dpi;
   GLfloat z = 0;
 
-  glGetError(); // clear error state so we don't pick up previous errors
+  glGetError();  // clear error state so we don't pick up previous errors
   glReadPixels(x, y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &z);
   if (const auto glError = glGetError(); glError != GL_NO_ERROR) {
     if (statusLabel) {
       auto status = QString("Center View: OpenGL Error reading Pixel: %s")
-        .arg(QString::fromLocal8Bit((const char *)gluErrorString(glError)));
+                        .arg(QString::fromLocal8Bit(
+                            (const char*)gluErrorString(glError)));
       statusLabel->setText(status);
     }
     setGLContext(oldContext);
@@ -281,12 +286,13 @@ void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
 
   if (z == 1) {
     setGLContext(oldContext);
-    return; // outside object
+    return;  // outside object
   }
 
   GLdouble px, py, pz;
 
-  auto success = gluUnProject(x, y, z, modelview, projection, viewport, &px, &py, &pz);
+  auto success =
+      gluUnProject(x, y, z, modelview, projection, viewport, &px, &py, &pz);
 
   if (success == GL_TRUE) {
     cam.object_trans -= Vector3d(px, py, pz);
@@ -296,14 +302,14 @@ void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
   setGLContext(oldContext);
 }
 
-void QGLView::normalizeAngle(GLdouble& angle)
-{
-  while (angle < 0) angle += 360;
-  while (angle > 360) angle -= 360;
+void QGLView::normalizeAngle(GLdouble& angle) {
+  while (angle < 0)
+    angle += 360;
+  while (angle > 360)
+    angle -= 360;
 }
 
-void QGLView::mouseMoveEvent(QMouseEvent *event)
-{
+void QGLView::mouseMoveEvent(QMouseEvent* event) {
   auto this_mouse = event->globalPos();
   if (measure_state != MEASURE_IDLE) {
     QPoint pt = event->pos();
@@ -314,12 +320,13 @@ void QGLView::mouseMoveEvent(QMouseEvent *event)
   double dy = (this_mouse.y() - last_mouse.y()) * 0.7;
   if (mouse_drag_active) {
     mouse_drag_moved = true;
-    auto button_compare = this->mouseSwapButtons?Qt::RightButton : Qt::LeftButton;
+    auto button_compare =
+        this->mouseSwapButtons ? Qt::RightButton : Qt::LeftButton;
     if (event->buttons() & button_compare
 #ifdef Q_OS_MACOS
         && !(event->modifiers() & Qt::MetaModifier)
 #endif
-        ) {
+    ) {
       // Left button rotates in xz, Shift-left rotates in xy
       // On Mac, Ctrl-Left is handled as right button on other platforms
       if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
@@ -356,13 +363,12 @@ void QGLView::mouseMoveEvent(QMouseEvent *event)
   last_mouse = this_mouse;
 }
 
-void QGLView::mouseReleaseEvent(QMouseEvent *event)
-{
+void QGLView::mouseReleaseEvent(QMouseEvent* event) {
   mouse_drag_active = false;
   releaseMouse();
 
-  auto button_right = this->mouseSwapButtons?Qt::LeftButton : Qt::RightButton;
-  auto button_left = this->mouseSwapButtons?Qt::RightButton : Qt::LeftButton;
+  auto button_right = this->mouseSwapButtons ? Qt::LeftButton : Qt::RightButton;
+  auto button_left = this->mouseSwapButtons ? Qt::RightButton : Qt::LeftButton;
   if (!mouse_drag_moved) {
     if (event->button() == button_right) {
       QPoint point = event->pos();
@@ -376,21 +382,19 @@ void QGLView::mouseReleaseEvent(QMouseEvent *event)
   mouse_drag_moved = false;
 }
 
-const QImage& QGLView::grabFrame()
-{
-  // Force reading from front buffer. Some configurations will read from the back buffer here.
+const QImage& QGLView::grabFrame() {
+  // Force reading from front buffer. Some configurations will read from the
+  // back buffer here.
   glReadBuffer(GL_FRONT);
   this->frame = grabFramebuffer();
   return this->frame;
 }
 
-bool QGLView::save(const char *filename) const
-{
+bool QGLView::save(const char* filename) const {
   return this->frame.save(filename, "PNG");
 }
 
-void QGLView::wheelEvent(QWheelEvent *event)
-{
+void QGLView::wheelEvent(QWheelEvent* event) {
   const auto pos = Q_WHEEL_EVENT_POSITION(event);
   const int v = event->angleDelta().y();
   if (QApplication::keyboardModifiers() & Qt::ShiftModifier) {
@@ -402,32 +406,27 @@ void QGLView::wheelEvent(QWheelEvent *event)
   }
 }
 
-void QGLView::ZoomIn()
-{
+void QGLView::ZoomIn() {
   zoom(120, true);
 }
 
-void QGLView::ZoomOut()
-{
+void QGLView::ZoomOut() {
   zoom(-120, true);
 }
 
-void QGLView::zoom(double v, bool relative)
-{
+void QGLView::zoom(double v, bool relative) {
   this->cam.zoom(v, relative);
   update();
   emit cameraChanged();
 }
 
-void QGLView::zoomFov(double v)
-{
+void QGLView::zoomFov(double v) {
   this->cam.setVpf(this->cam.fovValue() * pow(0.9, v / 120.0));
   update();
   emit cameraChanged();
 }
 
-void QGLView::zoomCursor(int x, int y, int zoom)
-{
+void QGLView::zoomCursor(int x, int y, int zoom) {
   const auto old_dist = cam.zoomValue();
   this->cam.zoom(zoom, true);
   const auto dist = cam.zoomValue();
@@ -441,14 +440,18 @@ void QGLView::zoomCursor(int x, int y, int zoom)
   translate(-mx, 0, -mz, true);
 }
 
-void QGLView::setOrthoMode(bool enabled)
-{
-  if (enabled) this->cam.setProjection(Camera::ProjectionType::ORTHOGONAL);
-  else this->cam.setProjection(Camera::ProjectionType::PERSPECTIVE);
+void QGLView::setOrthoMode(bool enabled) {
+  if (enabled)
+    this->cam.setProjection(Camera::ProjectionType::ORTHOGONAL);
+  else
+    this->cam.setProjection(Camera::ProjectionType::PERSPECTIVE);
 }
 
-void QGLView::translate(double x, double y, double z, bool relative, bool viewPortRelative)
-{
+void QGLView::translate(double x,
+                        double y,
+                        double z,
+                        bool relative,
+                        bool viewPortRelative) {
   Matrix3d aax, aay, aaz;
   aax = angle_axis_degrees(-cam.object_rot.x(), Vector3d::UnitX());
   aay = angle_axis_degrees(-cam.object_rot.y(), Vector3d::UnitY());
@@ -465,12 +468,7 @@ void QGLView::translate(double x, double y, double z, bool relative, bool viewPo
   }
 
   Matrix4d vec;
-  vec <<
-    0, 0, 0, x,
-    0, 0, 0, y,
-    0, 0, 0, z,
-    0, 0, 0, 1
-  ;
+  vec << 0, 0, 0, x, 0, 0, 0, y, 0, 0, 0, z, 0, 0, 0, 1;
   tm = tm * vec;
   double f = relative ? 1 : 0;
   cam.object_trans.x() = f * cam.object_trans.x() + tm(0, 3);
@@ -480,8 +478,7 @@ void QGLView::translate(double x, double y, double z, bool relative, bool viewPo
   emit cameraChanged();
 }
 
-void QGLView::rotate(double x, double y, double z, bool relative)
-{
+void QGLView::rotate(double x, double y, double z, bool relative) {
   double f = relative ? 1 : 0;
   cam.object_rot.x() = f * cam.object_rot.x() + x;
   cam.object_rot.y() = f * cam.object_rot.y() + y;
@@ -493,8 +490,7 @@ void QGLView::rotate(double x, double y, double z, bool relative)
   emit cameraChanged();
 }
 
-void QGLView::rotate2(double x, double y, double z)
-{
+void QGLView::rotate2(double x, double y, double z) {
   // This vector describes the rotation.
   // The direction of the vector is the angle around which to rotate, and
   // the length of the vector is the angle by which to rotate
@@ -515,8 +511,10 @@ void QGLView::rotate2(double x, double y, double z)
   double theta, psi, phi;
   if (abs(rmx(2, 0)) != 1) {
     theta = -asin_degrees(rmx(2, 0));
-    psi = atan2_degrees(rmx(2, 1) / cos_degrees(theta), rmx(2, 2) / cos_degrees(theta));
-    phi = atan2_degrees(rmx(1, 0) / cos_degrees(theta), rmx(0, 0) / cos_degrees(theta));
+    psi = atan2_degrees(rmx(2, 1) / cos_degrees(theta),
+                        rmx(2, 2) / cos_degrees(theta));
+    phi = atan2_degrees(rmx(1, 0) / cos_degrees(theta),
+                        rmx(0, 0) / cos_degrees(theta));
   } else {
     phi = 0;
     if (rmx(2, 0) == -1) {
@@ -540,8 +538,7 @@ void QGLView::rotate2(double x, double y, double z)
   emit cameraChanged();
 }
 
-std::vector<SelectedObject> QGLView::findObject(int mouse_x, int mouse_y)
-{
+std::vector<SelectedObject> QGLView::findObject(int mouse_x, int mouse_y) {
   int viewport[4] = {0, 0, 0, 0};
   double posXF, posYF, posZF;
   double posXN, posYN, posZN;
@@ -551,21 +548,24 @@ std::vector<SelectedObject> QGLView::findObject(int mouse_x, int mouse_y)
   GLdouble winX = mouse_x;
   GLdouble winY = viewport[3] - mouse_y;
 
-  gluUnProject(winX, winY, 1, this->modelview, this->projection, viewport, &posXF, &posYF, &posZF);
-  gluUnProject(winX, winY, -1, this->modelview, this->projection, viewport, &posXN, &posYN, &posZN);
+  gluUnProject(winX, winY, 1, this->modelview, this->projection, viewport,
+               &posXF, &posYF, &posZF);
+  gluUnProject(winX, winY, -1, this->modelview, this->projection, viewport,
+               &posXN, &posYN, &posZN);
   Vector3d far_pt(posXF, posYF, posZF);
   Vector3d near_pt(posXN, posYN, posZN);
 
   Vector3d testpt(0, 0, 0);
   std::vector<SelectedObject> result;
   auto renderer = this->getRenderer();
-  if (renderer == nullptr)return result;
-  result = renderer->findModelObject(near_pt, far_pt, mouse_x, mouse_y, cam.zoomValue() / 300);
+  if (renderer == nullptr)
+    return result;
+  result = renderer->findModelObject(near_pt, far_pt, mouse_x, mouse_y,
+                                     cam.zoomValue() / 300);
   return result;
 }
 
-void QGLView::selectPoint(int mouse_x, int mouse_y)
-{
+void QGLView::selectPoint(int mouse_x, int mouse_y) {
   std::vector<SelectedObject> obj = findObject(mouse_x, mouse_y);
   if (obj.size() == 1) {
     this->selected_obj.push_back(obj[0]);
@@ -573,20 +573,19 @@ void QGLView::selectPoint(int mouse_x, int mouse_y)
   }
 }
 
-int QGLView::pickObject(QPoint position)
-{
-  if (!isValid()) return -1;
+int QGLView::pickObject(QPoint position) {
+  if (!isValid())
+    return -1;
 
   if (this->getRenderer()) {
     this->makeCurrent();
-    auto guard = sg::make_scope_guard([this]() {
-      this->doneCurrent();
-    });
+    auto guard = sg::make_scope_guard([this]() { this->doneCurrent(); });
 
     // Update the selector with the right image size
     this->selector->reset(this);
 
-    return this->selector->select(this->getRenderer(), position.x(), position.y());
+    return this->selector->select(this->getRenderer(), position.x(),
+                                  position.y());
   }
   return -1;
 }
diff --git a/src/gui/QGLView.h b/src/gui/QGLView.h
index df118f067..57d52f4dc 100644
--- a/src/gui/QGLView.h
+++ b/src/gui/QGLView.h
@@ -4,13 +4,13 @@
 #include "gui/MouseSelector.h"
 
 #include <QImage>
+#include <QLabel>
 #include <QMouseEvent>
+#include <QOpenGLWidget>
 #include <QPoint>
 #include <QWheelEvent>
 #include <QWidget>
 #include <QtGlobal>
-#include <QOpenGLWidget>
-#include <QLabel>
 #include <string>
 #include <vector>
 
@@ -18,23 +18,25 @@
 #include <Eigen/Geometry>
 #include "glview/GLView.h"
 
-class QGLView : public QOpenGLWidget, public GLView
-{
+class QGLView : public QOpenGLWidget, public GLView {
   Q_OBJECT
   Q_PROPERTY(bool showEdges READ showEdges WRITE setShowEdges);
   Q_PROPERTY(bool showAxes READ showAxes WRITE setShowAxes);
   Q_PROPERTY(bool showCrosshairs READ showCrosshairs WRITE setShowCrosshairs);
   Q_PROPERTY(bool orthoMode READ orthoMode WRITE setOrthoMode);
-  Q_PROPERTY(double showScaleProportional READ showScaleProportional WRITE setShowScaleProportional);
+  Q_PROPERTY(double showScaleProportional READ showScaleProportional WRITE
+                 setShowScaleProportional);
 
-public:
-  QGLView(QWidget *parent = nullptr);
+ public:
+  QGLView(QWidget* parent = nullptr);
   ~QGLView() override;
 #ifdef ENABLE_OPENCSG
   bool hasOpenCSGSupport() { return this->is_opencsg_capable; }
 #endif
   // Properties
-  bool orthoMode() const { return (this->cam.projection == Camera::ProjectionType::ORTHOGONAL); }
+  bool orthoMode() const {
+    return (this->cam.projection == Camera::ProjectionType::ORTHOGONAL);
+  }
   void setOrthoMode(bool enabled);
   bool showScaleProportional() const { return this->showscale; }
   void setShowScaleProportional(bool enabled) { this->showscale = enabled; }
@@ -42,7 +44,7 @@ public:
   float getDPI() override { return this->devicePixelRatio(); }
 
   const QImage& grabFrame();
-  bool save(const char *filename) const override;
+  bool save(const char* filename) const override;
   void resetView();
   void viewAll();
   void selectPoint(int x, int y);
@@ -51,27 +53,27 @@ public:
 
   int pickObject(QPoint position);
 
-public slots:
+ public slots:
   void ZoomIn();
   void ZoomOut();
-  void setMouseCentricZoom(bool var){
-    this->mouseCentricZoom = var;
-  }
-  void setMouseSwapButtons(bool var){
-    this->mouseSwapButtons = var;
-  }
+  void setMouseCentricZoom(bool var) { this->mouseCentricZoom = var; }
+  void setMouseSwapButtons(bool var) { this->mouseSwapButtons = var; }
 
-public:
-  QLabel *statusLabel;
+ public:
+  QLabel* statusLabel;
 
   void zoom(double v, bool relative);
   void zoomFov(double v);
   void zoomCursor(int x, int y, int zoom);
   void rotate(double x, double y, double z, bool relative);
   void rotate2(double x, double y, double z);
-  void translate(double x, double y, double z, bool relative, bool viewPortRelative = true);
+  void translate(double x,
+                 double y,
+                 double z,
+                 bool relative,
+                 bool viewPortRelative = true);
 
-private:
+ private:
   void init();
 
   bool mouse_drag_active;
@@ -79,13 +81,13 @@ private:
   bool mouseCentricZoom = true;
   bool mouseSwapButtons = false;
   QPoint last_mouse;
-  QImage frame; // Used by grabFrame() and save()
+  QImage frame;  // Used by grabFrame() and save()
 
-  void wheelEvent(QWheelEvent *event) override;
-  void mousePressEvent(QMouseEvent *event) override;
-  void mouseMoveEvent(QMouseEvent *event) override;
-  void mouseReleaseEvent(QMouseEvent *event) override;
-  void mouseDoubleClickEvent(QMouseEvent *event) override;
+  void wheelEvent(QWheelEvent* event) override;
+  void mousePressEvent(QMouseEvent* event) override;
+  void mouseMoveEvent(QMouseEvent* event) override;
+  void mouseReleaseEvent(QMouseEvent* event) override;
+  void mouseDoubleClickEvent(QMouseEvent* event) override;
 
   void initializeGL() override;
   void resizeGL(int w, int h) override;
@@ -96,11 +98,11 @@ private:
 #ifdef ENABLE_OPENCSG
   void display_opencsg_warning() override;
   std::unique_ptr<MouseSelector> selector;
-private slots:
+ private slots:
   void display_opencsg_warning_dialog();
 #endif
 
-signals:
+ signals:
   void cameraChanged();
   void resized();
   void doRightClick(QPoint screen_coordinate);
@@ -110,5 +112,5 @@ signals:
 /* These are defined in QLGView2.cc.  See the commentary there. */
 // Can't include <QOpenGLContext>, as it will clash with glew. Forward declare.
 class QOpenGLContext;
-QOpenGLContext *getGLContext();
-void setGLContext(QOpenGLContext *);
+QOpenGLContext* getGLContext();
+void setGLContext(QOpenGLContext*);
diff --git a/src/gui/QGLView2.cc b/src/gui/QGLView2.cc
index d3ba9f488..883a6a73a 100644
--- a/src/gui/QGLView2.cc
+++ b/src/gui/QGLView2.cc
@@ -24,30 +24,27 @@
  */
 
 /*
- * This file defines two helper functions for saving and restoring OpenGL contexts.
- * They are in a separate file (rather than in the more obvious QGLView.cc) because
- * <QOpenGLContext> is incompatible with GLEW and produces compilation warning messages.
- * Putting them in a separate file in helper functions allows the main file to need
- * only an incomplete declaration of QOpenGLContext, which it already has.
+ * This file defines two helper functions for saving and restoring OpenGL
+ * contexts. They are in a separate file (rather than in the more obvious
+ * QGLView.cc) because <QOpenGLContext> is incompatible with GLEW and produces
+ * compilation warning messages. Putting them in a separate file in helper
+ * functions allows the main file to need only an incomplete declaration of
+ * QOpenGLContext, which it already has.
  *
  * See also the discussion at QGLView::mouseDoubleClickEvent().
  */
 #include <QOpenGLContext>
 
-QOpenGLContext *
-getGLContext()
-{
+QOpenGLContext* getGLContext() {
   return (QOpenGLContext::currentContext());
 }
 
-void
-setGLContext(QOpenGLContext *ctx)
-{
+void setGLContext(QOpenGLContext* ctx) {
   /*
    * This seems like the simplest way to select QOpenGLContext.
    *
-   * Why isn't there a QOpenGLContext::makeCurrent() that uses the context's assigned
-   * surface?
+   * Why isn't there a QOpenGLContext::makeCurrent() that uses the context's
+   * assigned surface?
    */
   ctx->makeCurrent(ctx->surface());
 }
diff --git a/src/gui/QSettingsCached.cc b/src/gui/QSettingsCached.cc
index a1bcfefdd..9e4e7150b 100644
--- a/src/gui/QSettingsCached.cc
+++ b/src/gui/QSettingsCached.cc
@@ -1,8 +1,8 @@
 #include "gui/QSettingsCached.h"
 
-#include <mutex>
 #include <QSettings>
 #include <memory>
+#include <mutex>
 
 std::unique_ptr<QSettings> QSettingsCached::qsettingsPointer;
 std::mutex QSettingsCached::ctor_mutex;
diff --git a/src/gui/QSettingsCached.h b/src/gui/QSettingsCached.h
index f9f8b3cf0..74d1a24e3 100644
--- a/src/gui/QSettingsCached.h
+++ b/src/gui/QSettingsCached.h
@@ -1,17 +1,15 @@
 #pragma once
 
+#include <QSettings>
 #include <QString>
 #include <QVariant>
-#include <QSettings>
 #include <memory>
 #include <mutex>
 
 #include "utils/printutils.h"
 
-class QSettingsCached
-{
-public:
-
+class QSettingsCached {
+ public:
   QSettingsCached() {
     if (qsettingsPointer.get() == nullptr) {
       std::lock_guard<std::mutex> lock{ctor_mutex};
@@ -22,33 +20,34 @@ public:
   }
 
   inline void setValue(const QString& key, const QVariant& value) {
-    PRINTDB("QSettings::setValue(): %s = '%s'", key.toStdString() % value.toString().toStdString());
-    qsettingsPointer->setValue(key, value); // It is safe to access qsettings from Multiple sources. it is thread safe
-    // Disabling forced sync to persisted storage on write. Will rely on automatic behavior of QSettings
-    // qsettingsPointer->sync(); // force write to file system on each modification of open scad settings
+    PRINTDB("QSettings::setValue(): %s = '%s'",
+            key.toStdString() % value.toString().toStdString());
+    qsettingsPointer->setValue(key,
+                               value);  // It is safe to access qsettings from
+                                        // Multiple sources. it is thread safe
+    // Disabling forced sync to persisted storage on write. Will rely on
+    // automatic behavior of QSettings qsettingsPointer->sync(); // force write
+    // to file system on each modification of open scad settings
   }
 
-  inline QVariant value(const QString& key, const QVariant& defaultValue = QVariant()) const {
+  inline QVariant value(const QString& key,
+                        const QVariant& defaultValue = QVariant()) const {
     return qsettingsPointer->value(key, defaultValue);
   }
 
   inline void remove(const QString& key) {
     qsettingsPointer->remove(key);
-    // Disabling forced sync to persisted storage on write. Will rely on automatic behavior of QSettings
-    // qsettingsPointer->sync();
+    // Disabling forced sync to persisted storage on write. Will rely on
+    // automatic behavior of QSettings qsettingsPointer->sync();
   }
 
   inline bool contains(const QString& key) const {
     return qsettingsPointer->contains(key);
   }
 
-  void release() {
-    delete qsettingsPointer.release();
-  }
-
+  void release() { delete qsettingsPointer.release(); }
 
-private:
+ private:
   static std::unique_ptr<QSettings> qsettingsPointer;
   static std::mutex ctor_mutex;
-
 };
diff --git a/src/gui/QWordSearchField.cc b/src/gui/QWordSearchField.cc
index a7439538c..edf532cb1 100644
--- a/src/gui/QWordSearchField.cc
+++ b/src/gui/QWordSearchField.cc
@@ -6,8 +6,7 @@
 #include <QString>
 #include <QStyle>
 
-QWordSearchField::QWordSearchField(QFrame *parent) : QLineEdit(parent)
-{
+QWordSearchField::QWordSearchField(QFrame* parent) : QLineEdit(parent) {
   findcount = 0;
   fieldLabel = new QLabel(this);
   fieldLabel->setTextFormat(Qt::PlainText);
@@ -15,34 +14,37 @@ QWordSearchField::QWordSearchField(QFrame *parent) : QLineEdit(parent)
   fieldLabel->setCursor(Qt::ArrowCursor);
   fieldLabel->setStyleSheet("QLabel { border: none; padding: 0px; }");
   fieldLabel->hide();
-  connect(this, &QWordSearchField::findCountChanged, this, &QWordSearchField::updateFieldLabel);
+  connect(this, &QWordSearchField::findCountChanged, this,
+          &QWordSearchField::updateFieldLabel);
   auto frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
-  setStyleSheet(QString("QLineEdit { padding-right: %1px; } ").arg(fieldLabel->sizeHint().width() + frameWidth + 1));
+  setStyleSheet(QString("QLineEdit { padding-right: %1px; } ")
+                    .arg(fieldLabel->sizeHint().width() + frameWidth + 1));
   auto minsize = minimumSizeHint();
-  setMinimumSize(qMax(minsize.width(), fieldLabel->sizeHint().height() + frameWidth * 2 + 2),
-                 qMax(minsize.height(), fieldLabel->sizeHint().height() + frameWidth * 2 + 2));
+  setMinimumSize(qMax(minsize.width(),
+                      fieldLabel->sizeHint().height() + frameWidth * 2 + 2),
+                 qMax(minsize.height(),
+                      fieldLabel->sizeHint().height() + frameWidth * 2 + 2));
   fieldLabel->setAlignment(Qt::AlignRight);
 }
 
-void QWordSearchField::resizeEvent(QResizeEvent *)
-{
+void QWordSearchField::resizeEvent(QResizeEvent*) {
   resizeSearchField();
 }
 
-void QWordSearchField::resizeSearchField()
-{
+void QWordSearchField::resizeSearchField() {
   auto size = fieldLabel->sizeHint();
   auto frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
-  fieldLabel->move(rect().right() - frameWidth - size.width(), (rect().bottom() + 1 - size.height()) / 2);
+  fieldLabel->move(rect().right() - frameWidth - size.width(),
+                   (rect().bottom() + 1 - size.height()) / 2);
 }
 
-
-void QWordSearchField::updateFieldLabel()
-{
+void QWordSearchField::updateFieldLabel() {
   if (findcount > 0) {
     fieldLabel->setText(QString::number(findcount));
-    //Fixes issue #2962 : Due to that fieldLabel->setText above does not seem to change the size of the field correct (seems to always be to short field to accommodate all digits)
-    //when the field changes many times during several searches, we need to work around that by setting minimum size.
+    // Fixes issue #2962 : Due to that fieldLabel->setText above does not seem
+    // to change the size of the field correct (seems to always be to short
+    // field to accommodate all digits) when the field changes many times during
+    // several searches, we need to work around that by setting minimum size.
     fieldLabel->setMinimumSize(fieldLabel->minimumSizeHint());
     fieldLabel->setVisible(true);
   } else {
@@ -52,8 +54,7 @@ void QWordSearchField::updateFieldLabel()
   resizeSearchField();
 }
 
-void QWordSearchField::setFindCount(int value)
-{
+void QWordSearchField::setFindCount(int value) {
   if (value != findcount) {
     findcount = value;
     emit findCountChanged();
diff --git a/src/gui/QWordSearchField.h b/src/gui/QWordSearchField.h
index ea4ba90f9..3af16e92b 100644
--- a/src/gui/QWordSearchField.h
+++ b/src/gui/QWordSearchField.h
@@ -2,35 +2,33 @@
 #define QWORDSEARCHFIELD_H
 
 #include <QFrame>
-#include <QResizeEvent>
-#include <QLineEdit>
 #include <QLabel>
+#include <QLineEdit>
+#include <QResizeEvent>
 
-class QWordSearchField : public QLineEdit
-{
+class QWordSearchField : public QLineEdit {
   Q_OBJECT
 
-public:
-  QWordSearchField(QFrame *parent = nullptr);
+ public:
+  QWordSearchField(QFrame* parent = nullptr);
   int findCount() const { return findcount; }
 
-protected:
-  void resizeEvent(QResizeEvent *) override;
+ protected:
+  void resizeEvent(QResizeEvent*) override;
   void resizeSearchField();
 
-private slots:
+ private slots:
   void updateFieldLabel();
 
-public slots:
+ public slots:
   void setFindCount(int value);
 
-signals:
+ signals:
   void findCountChanged();
 
-private:
-  QLabel *fieldLabel;
+ private:
+  QLabel* fieldLabel;
   int findcount;
 };
 
 #endif /* QWORDSEARCHFIELD_H */
-
diff --git a/src/gui/RubberBandManager.cc b/src/gui/RubberBandManager.cc
index 2bcd4eba2..56c11bd4a 100644
--- a/src/gui/RubberBandManager.cc
+++ b/src/gui/RubberBandManager.cc
@@ -1,29 +1,28 @@
 #include "RubberBandManager.h"
 
-#include "MainWindow.h"
 #include "Dock.h"
+#include "MainWindow.h"
 
-RubberBandManager::RubberBandManager(MainWindow *w) :
-  rubberBand(QRubberBand::Rectangle)
-{
+RubberBandManager::RubberBandManager(MainWindow* w)
+    : rubberBand(QRubberBand::Rectangle) {
   setParent(w);
   emphasizedDock = nullptr;
 }
 
-void RubberBandManager::hide(){
+void RubberBandManager::hide() {
   rubberBand.hide();
   emphasizedDock = nullptr;
 }
 
-bool RubberBandManager::isEmphasized(Dock *dock){
+bool RubberBandManager::isEmphasized(Dock* dock) {
   return rubberBand.isVisible() && emphasizedDock == dock;
 }
 
-bool RubberBandManager::isVisible(){
+bool RubberBandManager::isVisible() {
   return rubberBand.isVisible();
 }
 
-void RubberBandManager::emphasize(Dock *dock){
+void RubberBandManager::emphasize(Dock* dock) {
   rubberBand.setParent(dock);
   rubberBand.setGeometry(dock->widget()->geometry());
   rubberBand.show();
diff --git a/src/gui/RubberBandManager.h b/src/gui/RubberBandManager.h
index 21dec6f48..7241414e3 100644
--- a/src/gui/RubberBandManager.h
+++ b/src/gui/RubberBandManager.h
@@ -9,19 +9,18 @@ class MainWindow;
 /// A rubberband is a qt concept to draw an overlay over widgets.
 /// In our case it is used to emphasize which doc is currently selected
 ///
-class RubberBandManager : QObject
-{
+class RubberBandManager : QObject {
   Q_OBJECT
 
-public:
-  RubberBandManager(MainWindow *w);
+ public:
+  RubberBandManager(MainWindow* w);
 
   void hide();
-  void emphasize(Dock *w);
-  bool isEmphasized(Dock *w);
+  void emphasize(Dock* w);
+  bool isEmphasized(Dock* w);
   bool isVisible();
 
-private:
+ private:
   QRubberBand rubberBand;
-  Dock *emphasizedDock;
+  Dock* emphasizedDock;
 };
diff --git a/src/gui/ScadApi.cc b/src/gui/ScadApi.cc
index a9d80644f..9df297e4a 100644
--- a/src/gui/ScadApi.cc
+++ b/src/gui/ScadApi.cc
@@ -1,38 +1,38 @@
 #include "gui/ScadApi.h"
 
+#include <QDir>
+#include <QFileInfo>
 #include <QList>
+#include <QRegularExpression>
 #include <QString>
 #include <QStringList>
 #include <string>
-#include <QDir>
-#include <QFileInfo>
-#include <QRegularExpression>
 
 #include "core/Builtins.h"
-#include "gui/ScintillaEditor.h"
 #include "core/parsersettings.h"
+#include "gui/ScintillaEditor.h"
 
 namespace {
 
-bool isInString(const std::u32string& text, const int col)
-{
-  //first see if we are in a string literal. if so, don't allow auto complete
+bool isInString(const std::u32string& text, const int col) {
+  // first see if we are in a string literal. if so, don't allow auto complete
   bool lastWasEscape = false;
   bool inString = false;
   int dx = 0;
   int count = col;
   while (count-- > 0) {
     const char32_t ch = text.at(dx++);
-    if (ch == '\\') lastWasEscape = true; //next character will be literal handle \"
-    else if (lastWasEscape) lastWasEscape = false;
-    else if (ch == '"') //string toggle
+    if (ch == '\\')
+      lastWasEscape = true;  // next character will be literal handle \"
+    else if (lastWasEscape)
+      lastWasEscape = false;
+    else if (ch == '"')  // string toggle
       inString = !inString;
   }
   return inString;
 }
 
-bool isUseOrInclude(const QString& text, const int col)
-{
+bool isUseOrInclude(const QString& text, const int col) {
   const QRegularExpression re("\\s*(use|include)\\s*<[^>]*$");
   const QRegularExpressionMatch match = re.match(text.left(col));
   return match.hasMatch();
@@ -50,10 +50,10 @@ QStringList getSorted(const QFileInfoList& list, C cond) {
   return result;
 }
 
-} // namespace
+}  // namespace
 
-ScadApi::ScadApi(ScintillaEditor *editor, QsciLexer *lexer) : QsciAbstractAPIs(lexer), editor(editor)
-{
+ScadApi::ScadApi(ScintillaEditor* editor, QsciLexer* lexer)
+    : QsciAbstractAPIs(lexer), editor(editor) {
   for (const auto& iter : Builtins::keywordList) {
     QStringList calltipList;
     for (const auto& it : iter.second)
@@ -63,8 +63,8 @@ ScadApi::ScadApi(ScintillaEditor *editor, QsciLexer *lexer) : QsciAbstractAPIs(l
   }
 }
 
-void ScadApi::updateAutoCompletionList(const QStringList& context, QStringList& list)
-{
+void ScadApi::updateAutoCompletionList(const QStringList& context,
+                                       QStringList& list) {
   int line, col;
   editor->qsci->getCursorPosition(&line, &col);
   const auto& text = editor->qsci->text(line);
@@ -78,8 +78,10 @@ void ScadApi::updateAutoCompletionList(const QStringList& context, QStringList&
   }
 }
 
-void ScadApi::autoCompleteFolder(const QStringList& context, const QString& text, const int col, QStringList& list)
-{
+void ScadApi::autoCompleteFolder(const QStringList& context,
+                                 const QString& text,
+                                 const int col,
+                                 QStringList& list) {
   const QRegularExpression re(R"(\s*(use|include)\s*<\s*)");
   const auto useDir = QFileInfo{text.left(col).replace(re, "")}.dir().path();
 
@@ -97,25 +99,23 @@ void ScadApi::autoCompleteFolder(const QStringList& context, const QString& text
 
     QFileInfoList result;
     const auto& prefix = context.last();
-    const auto& infoList = dir.entryInfoList(QDir::Dirs | QDir::Files | QDir::Readable | QDir::NoDotAndDotDot);
+    const auto& infoList = dir.entryInfoList(
+        QDir::Dirs | QDir::Files | QDir::Readable | QDir::NoDotAndDotDot);
     for (const auto& info : infoList) {
-      if (info.fileName().startsWith(prefix) && (info.isDir() || info.suffix().toLower() == "scad")) {
+      if (info.fileName().startsWith(prefix) &&
+          (info.isDir() || info.suffix().toLower() == "scad")) {
         result << info;
       }
     }
 
-    list << getSorted(result, [](const QFileInfo& i){
-      return i.isDir();
-    });
-    list << getSorted(result, [](const QFileInfo& i){
-      return i.isFile();
-    });
+    list << getSorted(result, [](const QFileInfo& i) { return i.isDir(); });
+    list << getSorted(result, [](const QFileInfo& i) { return i.isFile(); });
     list.removeDuplicates();
   }
 }
 
-void ScadApi::autoCompleteFunctions(const QStringList& context, QStringList& list)
-{
+void ScadApi::autoCompleteFunctions(const QStringList& context,
+                                    QStringList& list) {
   const QString& c = context.last();
   // for now we only auto-complete functions and modules
   if (c.isEmpty()) {
@@ -132,12 +132,12 @@ void ScadApi::autoCompleteFunctions(const QStringList& context, QStringList& lis
   }
 }
 
-void ScadApi::autoCompletionSelected(const QString& /*selection*/)
-{
-}
+void ScadApi::autoCompletionSelected(const QString& /*selection*/) {}
 
-QStringList ScadApi::callTips(const QStringList& context, int /*commas*/, QsciScintilla::CallTipsStyle /*style*/, QList<int>& /*shifts*/)
-{
+QStringList ScadApi::callTips(const QStringList& context,
+                              int /*commas*/,
+                              QsciScintilla::CallTipsStyle /*style*/,
+                              QList<int>& /*shifts*/) {
   QStringList callTips;
   for (const auto& func : funcs) {
     if (func.get_name() == context.at(context.size() - 2)) {
diff --git a/src/gui/ScadApi.h b/src/gui/ScadApi.h
index 412a7b51a..946afa10b 100644
--- a/src/gui/ScadApi.h
+++ b/src/gui/ScadApi.h
@@ -1,36 +1,31 @@
 #pragma once
 
 #include <QList>
-#include <utility>
 #include <QObject>
 #include <QString>
 #include <QStringList>
+#include <utility>
 
 #include <Qsci/qsciapis.h>
 
-class ApiFunc
-{
-private:
+class ApiFunc {
+ private:
   QString name;
   QStringList params;
 
-public:
-  ApiFunc(QString name, QString param) : name(std::move(name)), params{std::move(param)} { }
-  ApiFunc(QString name, QString param1, QString param2) : name(std::move(name)), params{std::move(param1), std::move(param2)} { }
-  ApiFunc(QString name, QStringList params) : name(std::move(name)), params(std::move(params)) { }
+ public:
+  ApiFunc(QString name, QString param)
+      : name(std::move(name)), params{std::move(param)} {}
+  ApiFunc(QString name, QString param1, QString param2)
+      : name(std::move(name)), params{std::move(param1), std::move(param2)} {}
+  ApiFunc(QString name, QStringList params)
+      : name(std::move(name)), params(std::move(params)) {}
 
-  const QString& get_name() const
-  {
-    return name;
-  }
+  const QString& get_name() const { return name; }
 
-  const QStringList& get_params() const
-  {
-    return params;
-  }
+  const QStringList& get_params() const { return params; }
 
-  ApiFunc& operator=(const ApiFunc& other)
-  {
+  ApiFunc& operator=(const ApiFunc& other) {
     if (this != &other) {
       this->name = other.name;
       this->params = other.params;
@@ -39,20 +34,19 @@ public:
   }
 };
 
-class ScadTemplate
-{
-private:
+class ScadTemplate {
+ private:
   QString text;
   int cursor_offset;
-public:
 
-  ScadTemplate() : text(""), cursor_offset(0) { }
-  ScadTemplate(QString text, int cursor_offset) : text(std::move(text)), cursor_offset(cursor_offset) { }
+ public:
+  ScadTemplate() : text(""), cursor_offset(0) {}
+  ScadTemplate(QString text, int cursor_offset)
+      : text(std::move(text)), cursor_offset(cursor_offset) {}
   const QString& get_text() const { return text; }
   int get_cursor_offset() const { return cursor_offset; }
 
-  ScadTemplate& operator=(const ScadTemplate& other)
-  {
+  ScadTemplate& operator=(const ScadTemplate& other) {
     if (this != &other) {
       this->text = other.text;
       this->cursor_offset = other.cursor_offset;
@@ -63,22 +57,28 @@ public:
 
 class ScintillaEditor;
 
-class ScadApi : public QsciAbstractAPIs
-{
+class ScadApi : public QsciAbstractAPIs {
   Q_OBJECT
 
-private:
-  ScintillaEditor *editor;
+ private:
+  ScintillaEditor* editor;
   QList<ApiFunc> funcs;
 
-protected:
-  void autoCompleteFolder(const QStringList& context, const QString& text, const int col, QStringList& list);
+ protected:
+  void autoCompleteFolder(const QStringList& context,
+                          const QString& text,
+                          const int col,
+                          QStringList& list);
   void autoCompleteFunctions(const QStringList& context, QStringList& list);
 
-public:
-  ScadApi(ScintillaEditor *editor, QsciLexer *lexer);
+ public:
+  ScadApi(ScintillaEditor* editor, QsciLexer* lexer);
 
-  void updateAutoCompletionList(const QStringList& context, QStringList& list) override;
+  void updateAutoCompletionList(const QStringList& context,
+                                QStringList& list) override;
   void autoCompletionSelected(const QString& selection) override;
-  QStringList callTips(const QStringList& context, int commas, QsciScintilla::CallTipsStyle style, QList<int>& shifts) override;
+  QStringList callTips(const QStringList& context,
+                       int commas,
+                       QsciScintilla::CallTipsStyle style,
+                       QList<int>& shifts) override;
 };
diff --git a/src/gui/ScadLexer.cc b/src/gui/ScadLexer.cc
index f78caff91..d8433bc6b 100644
--- a/src/gui/ScadLexer.cc
+++ b/src/gui/ScadLexer.cc
@@ -11,48 +11,44 @@
 #include <boost/algorithm/string.hpp>
 #include <boost/algorithm/string/split.hpp>
 
-
 #if !ENABLE_LEXERTL
 
-ScadLexer::ScadLexer(QObject *parent) : QsciLexerCPP(parent)
-{
+ScadLexer::ScadLexer(QObject* parent) : QsciLexerCPP(parent) {
   // -> Style: Keyword (lexer.l)
   keywordSet[0] =
-    "if else let for each module function true false undef "
-    "include use assert";
+      "if else let for each module function true false undef "
+      "include use assert";
 
   // -> Style: KeywordSet2 (func.cc)
   keywordSet[1] =
-    "abs sign rands min max sin cos asin acos tan atan atan2 "
-    "round ceil floor pow sqrt exp len log ln str chr ord concat "
-    "is_undef is_list is_num is_bool is_string is_function "
-    "lookup search version version_num norm cross parent_module "
-    "dxf_dim dxf_cross";
+      "abs sign rands min max sin cos asin acos tan atan atan2 "
+      "round ceil floor pow sqrt exp len log ln str chr ord concat "
+      "is_undef is_list is_num is_bool is_string is_function "
+      "lookup search version version_num norm cross parent_module "
+      "dxf_dim dxf_cross";
 
   // -> used in comments only like /*! \cube */
   keywordSet[2] =
-    "struct union enum fn var def typedef file namespace package "
-    "interface param see return class brief";
+      "struct union enum fn var def typedef file namespace package "
+      "interface param see return class brief";
 
   // -> Style: GlobalClass
   keywordSet[3] =
-    "cube sphere cylinder polyhedron square circle polygon text "
-    "minkowski hull resize child children echo union difference "
-    "intersection linear_extrude rotate_extrude import group "
-    "projection render surface scale rotate mirror translate "
-    "multmatrix color offset intersection_for roof fill";
+      "cube sphere cylinder polyhedron square circle polygon text "
+      "minkowski hull resize child children echo union difference "
+      "intersection linear_extrude rotate_extrude import group "
+      "projection render surface scale rotate mirror translate "
+      "multmatrix color offset intersection_for roof fill";
 
   setFoldComments(true);
   setFoldAtElse(true);
 }
 
-const char *ScadLexer::language() const
-{
+const char* ScadLexer::language() const {
   return "SCAD";
 }
 
-void ScadLexer::setKeywords(int set, const std::string& keywords)
-{
+void ScadLexer::setKeywords(int set, const std::string& keywords) {
   if ((set < 1) || (set > 4)) {
     return;
   }
@@ -66,24 +62,22 @@ void ScadLexer::setKeywords(int set, const std::string& keywords)
   keywordSet[set - 1] = trimmedKeywords;
 }
 
-const char *ScadLexer::keywords(int set) const
-{
+const char* ScadLexer::keywords(int set) const {
   if ((set < 1) || (set > 4)) {
     return nullptr;
   }
   return keywordSet[set - 1].c_str();
 }
 
-QStringList ScadLexer::autoCompletionWordSeparators() const
-{
+QStringList ScadLexer::autoCompletionWordSeparators() const {
   QStringList wl;
-  wl << "."; // dot notation, not used yet, but preparation for object support
-  wl << "<"; // for include/use auto complete
-  wl << "/"; // for include/use directory auto complete
+  wl << ".";  // dot notation, not used yet, but preparation for object support
+  wl << "<";  // for include/use auto complete
+  wl << "/";  // for include/use directory auto complete
   return wl;
 }
 
-#endif // if !ENABLE_LEXERTL
+#endif  // if !ENABLE_LEXERTL
 
 /***************************************************************/
 /***************************************************************/
@@ -97,47 +91,54 @@ QStringList ScadLexer::autoCompletionWordSeparators() const
 #include "lexertl/generator.hpp"
 #include "lexertl/lookup.hpp"
 
-//#define DEBUG_LEXERTL   1
+// #define DEBUG_LEXERTL   1
 
 #if DEBUG_LEXERTL
-#include "lexertl/debug.hpp"
 #include <fstream>
 #include <iostream>
+#include "lexertl/debug.hpp"
 #endif
 
-/// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
+/// See original attempt at
+/// https://github.com/openscad/openscad/tree/lexertl/src
 
-void Lex::default_rules()
-{
+void Lex::default_rules() {
   rules_.push_state("PATH");
   rules_.push_state("COMMENT");
 
-  std::string keywords("module function echo import projection render "
-                       "return if else let for each assert");
+  std::string keywords(
+      "module function echo import projection render "
+      "return if else let for each assert");
   defineRules(keywords, ekeyword);
 
-  //include and use have a unique syntax
+  // include and use have a unique syntax
   rules_.push("INITIAL", "use", ekeyword, "PATH");
   rules_.push("INITIAL", "include", ekeyword, "PATH");
-  rules_.push("PATH", ".|\n", etext, "INITIAL"); //leave this state; "use" and "include" can also be used as variable names
+  rules_.push("PATH", ".|\n", etext,
+              "INITIAL");  // leave this state; "use" and "include" can also be
+                           // used as variable names
   rules_.push("PATH", "[ \t\r\n]*<[^>]*>", eQuotedString, "INITIAL");
 
-  std::string transformations("translate rotate scale linear_extrude "
-                              "rotate_extrude resize mirror multmatrix color "
-                              "offset hull minkowski children");
+  std::string transformations(
+      "translate rotate scale linear_extrude "
+      "rotate_extrude resize mirror multmatrix color "
+      "offset hull minkowski children");
   defineRules(transformations, etransformation);
 
   std::string booleans("union difference intersection intersection_for");
   defineRules(booleans, eboolean);
 
-  std::string functions("abs sign rands min max sin cos asin acos tan atan atan2 round "
-                        "ceil floor pow sqrt exp len log ln str chr ord concat lookup "
-                        "search version version_num norm cross parent_module dxf_dim "
-                        "dxf_cross is_undef is_list is_num is_bool is_string "
-                        "is_function is_object");
+  std::string functions(
+      "abs sign rands min max sin cos asin acos tan atan atan2 round "
+      "ceil floor pow sqrt exp len log ln str chr ord concat lookup "
+      "search version version_num norm cross parent_module dxf_dim "
+      "dxf_cross is_undef is_list is_num is_bool is_string "
+      "is_function is_object");
   defineRules(functions, efunction);
 
-  std::string models("sphere cube cylinder polyhedron square polygon text circle surface roof");
+  std::string models(
+      "sphere cube cylinder polyhedron square polygon text circle surface "
+      "roof");
   defineRules(models, emodel);
 
   // Operators and Modifier Characters
@@ -148,16 +149,17 @@ void Lex::default_rules()
 
   std::string values("true false undef PI");
   defineRules(values, enumber);
-  rules_.push("([-+]?((([0-9]+[.]?|([0-9]*[.][0-9]+))([eE][-+]?[0-9]+)?)))", enumber);
+  rules_.push("([-+]?((([0-9]+[.]?|([0-9]*[.][0-9]+))([eE][-+]?[0-9]+)?)))",
+              enumber);
 
   // comments and variables come later, after any custom keywords are added
 }
 
-void Lex::defineRules(const std::string& keyword_list, int id)
-{
+void Lex::defineRules(const std::string& keyword_list, int id) {
   std::string trimmedKeywords(keyword_list);
   boost::algorithm::trim(trimmedKeywords);
-  if (trimmedKeywords.empty()) return;
+  if (trimmedKeywords.empty())
+    return;
 
   std::vector<std::string> words;
   boost::split(words, trimmedKeywords, boost::is_any_of(" "));
@@ -167,15 +169,14 @@ void Lex::defineRules(const std::string& keyword_list, int id)
 }
 
 // default and custom rules must be set before this
-void Lex::finalize_rules()
-{
+void Lex::finalize_rules() {
   // These need to come after keywords, so they don't accidentally match.
   // Sadly, order of definition matters, as well as enum.
   rules_.push("[a-zA-Z0-9_]+", evariable);
   rules_.push("[$][a-zA-Z0-9_]+", especialVariable);
 
-  rules_.push("INITIAL", "\"/*\"",  ecomment, "COMMENT");
-  rules_.push("COMMENT", "[^*]+|.", ecomment,  "COMMENT");
+  rules_.push("INITIAL", "\"/*\"", ecomment, "COMMENT");
+  rules_.push("COMMENT", "[^*]+|.", ecomment, "COMMENT");
   rules_.push("COMMENT", "\"*/\"", ecomment, "INITIAL");
   rules_.push("[/][/].*$", ecomment);
 
@@ -190,22 +191,24 @@ void Lex::finalize_rules()
 #endif
 }
 
-void Lex::lex_results(const std::string& input, int start, LexInterface *const obj)
-{
+void Lex::lex_results(const std::string& input,
+                      int start,
+                      LexInterface* const obj) {
 #if DEBUG_LEXERTL
   std::cout << "called lexer" << std::endl;
 #endif
   lexertl::smatch results(input.begin(), input.end());
 
-  //The editor can ask to only lex from a starting point.
-  //This can be faster the lexing the whole text,
-  //but requires the lexer to try to restore the lexer state.
-  //We currently handle comments (COMMENT State) pretty well.
-  //We currently do not handle include/use (PATH State).
+  // The editor can ask to only lex from a starting point.
+  // This can be faster the lexing the whole text,
+  // but requires the lexer to try to restore the lexer state.
+  // We currently handle comments (COMMENT State) pretty well.
+  // We currently do not handle include/use (PATH State).
   int isstyle = obj->getStyleAt(start - 1);
-  if (isstyle == ecomment) results.state = rules_.state("COMMENT");
+  if (isstyle == ecomment)
+    results.state = rules_.state("COMMENT");
 
-  char *styles = new char[input.size()];
+  char* styles = new char[input.size()];
   lexertl::lookup(sm, results);
   while (results.id != eEOF) {
     size_t s = std::distance(input.begin(), results.first);
@@ -214,30 +217,29 @@ void Lex::lex_results(const std::string& input, int start, LexInterface *const o
     lexertl::lookup(sm, results);
   }
   obj->highlightingMultiple(start, input.size(), styles);
-  delete [] styles;
+  delete[] styles;
 }
 
 /***************************************************************/
 
-ScadLexer2::ScadLexer2(QObject *parent) : QsciLexerCustom(parent), LexInterface()
-{
+ScadLexer2::ScadLexer2(QObject* parent)
+    : QsciLexerCustom(parent), LexInterface() {
   my_lexer = new Lex();
   my_lexer->default_rules();
 }
 
-ScadLexer2::~ScadLexer2()
-{
+ScadLexer2::~ScadLexer2() {
   delete my_lexer;
 }
 
-void ScadLexer2::styleText(int start, int end)
-{
+void ScadLexer2::styleText(int start, int end) {
 #if DEBUG_LEXERTL
   std::cout << "start: " << start << std::endl;
 #endif
-  if (!editor()) return;
+  if (!editor())
+    return;
 
-  char *data = new char[end - start + 1];
+  char* data = new char[end - start + 1];
   editor()->SendScintilla(QsciScintilla::SCI_GETTEXTRANGE, start, end, data);
   QString source(data);
   const std::string input(source.toStdString());
@@ -250,21 +252,23 @@ void ScadLexer2::styleText(int start, int end)
   my_lexer->lex_results(input, start, this);
   this->fold(start, end);
 
-  delete [] data;
-  if (source.isEmpty()) return;
+  delete[] data;
+  if (source.isEmpty())
+    return;
 }
 
-void ScadLexer2::autoScroll(int error_pos)
-{
+void ScadLexer2::autoScroll(int error_pos) {
   editor()->SendScintilla(QsciScintilla::SCI_GOTOPOS, error_pos);
   editor()->SendScintilla(QsciScintilla::SCI_SCROLLCARET);
 }
 
-void ScadLexer2::fold(int start, int end)
-{
+void ScadLexer2::fold(int start, int end) {
   char chNext = editor()->SendScintilla(QsciScintilla::SCI_GETCHARAT, start);
-  int lineCurrent = editor()->SendScintilla(QsciScintilla::SCI_LINEFROMPOSITION, start);
-  int levelPrev = editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) & QsciScintilla::SC_FOLDLEVELNUMBERMASK;
+  int lineCurrent =
+      editor()->SendScintilla(QsciScintilla::SCI_LINEFROMPOSITION, start);
+  int levelPrev =
+      editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) &
+      QsciScintilla::SC_FOLDLEVELNUMBERMASK;
   int levelCurrent = levelPrev;
   for (int i = start; i < end; i++) {
     char ch = chNext;
@@ -272,19 +276,19 @@ void ScadLexer2::fold(int start, int end)
 
     bool atEOL = ((ch == '\r' && chNext != '\n') || (ch == '\n'));
 
-    int prevStyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, i - 1);
+    int prevStyle =
+        editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, i - 1);
     int currStyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, i);
 
     bool currStyleIsOtherText = (currStyle == OtherText);
     if (currStyleIsOtherText) {
-      if ((ch == '{') || (ch == '[') ) {
+      if ((ch == '{') || (ch == '[')) {
         levelCurrent++;
-      } else if ((ch == '}') || (ch == ']') ) {
+      } else if ((ch == '}') || (ch == ']')) {
         levelCurrent--;
       }
     }
 
-
     bool prevStyleIsComment = (prevStyle == Comment);
     bool currStyleIsComment = (currStyle == Comment);
     bool isStartOfComment = (!prevStyleIsComment) && (currStyleIsComment);
@@ -304,8 +308,10 @@ void ScadLexer2::fold(int start, int end)
         lev |= QsciScintilla::SC_FOLDLEVELHEADERFLAG;
       }
 
-      if (lev != editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent)) {
-        editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent, lev);
+      if (lev != editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL,
+                                         lineCurrent)) {
+        editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent,
+                                lev);
       }
 
       lineCurrent++;
@@ -313,108 +319,105 @@ void ScadLexer2::fold(int start, int end)
     }
   }
 
-  int flagsNext = editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) & QsciScintilla::SC_FOLDLEVELNUMBERMASK;
-  editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent, levelPrev | flagsNext);
+  int flagsNext =
+      editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) &
+      QsciScintilla::SC_FOLDLEVELNUMBERMASK;
+  editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent,
+                          levelPrev | flagsNext);
 }
 
-
-int ScadLexer2::getStyleAt(int pos)
-{
+int ScadLexer2::getStyleAt(int pos) {
   int sstyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, pos);
   return sstyle;
 }
 
-void ScadLexer2::highlightingMultiple(int start, int length, char *styles) {
+void ScadLexer2::highlightingMultiple(int start, int length, char* styles) {
   editor()->SendScintilla(QsciScintilla::SCI_STARTSTYLING, start);
   editor()->SendScintilla(QsciScintilla::SCI_SETSTYLINGEX, length, styles);
 }
 
-QColor ScadLexer2::defaultColor(int style) const
-{
+QColor ScadLexer2::defaultColor(int style) const {
   switch (style) {
-  case Keyword:
-    return Qt::blue;
-  case Comment:
-    return Qt::green;
-  case Number:
-    return Qt::red;
-  case Transformation:
-    return "#f32222";
-  case Boolean:
-    return "#22f322";
-  case Function:
-    return "#2222f3";
-  case Model:
-    return Qt::blue;
-  case Default:
-    return Qt::black;
+    case Keyword:
+      return Qt::blue;
+    case Comment:
+      return Qt::green;
+    case Number:
+      return Qt::red;
+    case Transformation:
+      return "#f32222";
+    case Boolean:
+      return "#22f322";
+    case Function:
+      return "#2222f3";
+    case Model:
+      return Qt::blue;
+    case Default:
+      return Qt::black;
   }
   return Qt::black;
 }
 
-QString ScadLexer2::description(int style) const
-{
+QString ScadLexer2::description(int style) const {
   switch (style) {
-  case Default:
-    return "Default";
-  case Keyword:
-    return "Keyword";
-  case Transformation:
-    return "Transformation";
-  case Boolean:
-    return "Boolean";
-  case Function:
-    return "Function";
-  case Model:
-    return "Model";
-  case Operator:
-    return "Operator";
-  case String:
-    return "String";
-  case Number:
-    return "Number";
-  case Custom1:
-    return "Custom1";
-  case Custom2:
-    return "Custom2";
-  case Custom3:
-    return "Custom3";
-  case Custom4:
-    return "Custom4";
-  case Custom5:
-    return "Custom5";
-  case Custom6:
-    return "Custom6";
-  case Custom7:
-    return "Custom7";
-  case Custom8:
-    return "Custom8";
-  case Custom9:
-    return "Custom9";
-  case Custom10:
-    return "Custom10";
-  case Variable:
-    return "Variable";
-  case SpecialVariable:
-    return "SpecialVariable";
-  case Comment:
-    return "Comment";
+    case Default:
+      return "Default";
+    case Keyword:
+      return "Keyword";
+    case Transformation:
+      return "Transformation";
+    case Boolean:
+      return "Boolean";
+    case Function:
+      return "Function";
+    case Model:
+      return "Model";
+    case Operator:
+      return "Operator";
+    case String:
+      return "String";
+    case Number:
+      return "Number";
+    case Custom1:
+      return "Custom1";
+    case Custom2:
+      return "Custom2";
+    case Custom3:
+      return "Custom3";
+    case Custom4:
+      return "Custom4";
+    case Custom5:
+      return "Custom5";
+    case Custom6:
+      return "Custom6";
+    case Custom7:
+      return "Custom7";
+    case Custom8:
+      return "Custom8";
+    case Custom9:
+      return "Custom9";
+    case Custom10:
+      return "Custom10";
+    case Variable:
+      return "Variable";
+    case SpecialVariable:
+      return "SpecialVariable";
+    case Comment:
+      return "Comment";
   }
   return {QString::number(style)};
 }
 
-const char *ScadLexer2::language() const
-{
+const char* ScadLexer2::language() const {
   return "SCAD";
 }
 
-QStringList ScadLexer2::autoCompletionWordSeparators() const
-{
+QStringList ScadLexer2::autoCompletionWordSeparators() const {
   QStringList wl;
-  wl << "."; // dot notation, not used yet, but preparation for object support
-  wl << "<"; // for include/use auto complete
-  wl << "/"; // for include/use directory auto complete
+  wl << ".";  // dot notation, not used yet, but preparation for object support
+  wl << "<";  // for include/use auto complete
+  wl << "/";  // for include/use directory auto complete
   return wl;
 }
 
-#endif // if ENABLE_LEXERTL
+#endif  // if ENABLE_LEXERTL
diff --git a/src/gui/ScadLexer.h b/src/gui/ScadLexer.h
index f39504740..a456d0d08 100644
--- a/src/gui/ScadLexer.h
+++ b/src/gui/ScadLexer.h
@@ -1,11 +1,11 @@
 #pragma once
 
-#include <QStringList>
-#include <QObject>
 #include <Qsci/qsciglobal.h>
+#include <QObject>
+#include <QStringList>
 #include <string>
 
-#define ENABLE_LEXERTL  1
+#define ENABLE_LEXERTL 1
 
 /***************************************************************/
 
@@ -13,24 +13,23 @@
 
 #include <Qsci/qscilexercpp.h>
 
-class ScadLexer : public QsciLexerCPP
-{
-public:
-  ScadLexer(QObject *parent);
+class ScadLexer : public QsciLexerCPP {
+ public:
+  ScadLexer(QObject* parent);
   virtual ~ScadLexer() = default;
-  const char *language() const override;
-  const char *keywords(int set) const override;
+  const char* language() const override;
+  const char* keywords(int set) const override;
 
   void setKeywords(int set, const std::string& keywords);
 
-private:
+ private:
   std::string keywordSet[4];
   ScadLexer(const ScadLexer&);
   ScadLexer& operator=(const ScadLexer&);
   QStringList autoCompletionWordSeparators() const override;
 };
 
-#endif // if !ENABLE_LEXERTL
+#endif  // if !ENABLE_LEXERTL
 
 /***************************************************************/
 /***************************************************************/
@@ -38,7 +37,8 @@ private:
 
 #if ENABLE_LEXERTL
 
-/// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
+/// See original attempt at
+/// https://github.com/openscad/openscad/tree/lexertl/src
 
 #include "lexertl/dot.hpp"
 #include "lexertl/generator.hpp"
@@ -47,22 +47,42 @@ private:
 #include <Qsci/qscilexercustom.h>
 #include <Qsci/qsciscintilla.h>
 
-class LexInterface
-{
-public:
-  virtual void highlightingMultiple(int start, int length, char *styles) = 0;
+class LexInterface {
+ public:
+  virtual void highlightingMultiple(int start, int length, char* styles) = 0;
   virtual int getStyleAt(int position) = 0;
 };
 
-class Lex
-{
-public:
+class Lex {
+ public:
   lexertl::state_machine sm;
   lexertl::rules rules_;
 
-  enum { eEOF, ekeyword, etransformation, eboolean, efunction, emodel, eoperator, eQuotedString, enumber,
-         ecustom1, ecustom2, ecustom3, ecustom4, ecustom5, ecustom6, ecustom7, ecustom8, ecustom9, ecustom10,
-         evariable, especialVariable, ecomment, etext };
+  enum {
+    eEOF,
+    ekeyword,
+    etransformation,
+    eboolean,
+    efunction,
+    emodel,
+    eoperator,
+    eQuotedString,
+    enumber,
+    ecustom1,
+    ecustom2,
+    ecustom3,
+    ecustom4,
+    ecustom5,
+    ecustom6,
+    ecustom7,
+    ecustom8,
+    ecustom9,
+    ecustom10,
+    evariable,
+    especialVariable,
+    ecomment,
+    etext
+  };
 
   Lex() = default;
 
@@ -70,12 +90,13 @@ public:
   void defineRules(const std::string& keyword_list, int id);
   void finalize_rules();
 
-  void lex_results(const std::string& input, int start, LexInterface *const obj);
+  void lex_results(const std::string& input,
+                   int start,
+                   LexInterface* const obj);
 };
 
-class ScadLexer2 : public QsciLexerCustom, public LexInterface
-{
-public:
+class ScadLexer2 : public QsciLexerCustom, public LexInterface {
+ public:
   enum {
     Default = 0,
     Keyword = 1,
@@ -102,14 +123,14 @@ public:
     OtherText = 22,
   };
 
-  Lex *my_lexer;
+  Lex* my_lexer;
 
-  ScadLexer2(QObject *parent);
+  ScadLexer2(QObject* parent);
   ScadLexer2(const ScadLexer2&) = delete;
   ScadLexer2& operator=(const ScadLexer2&) = delete;
   ~ScadLexer2() override;
 
-  const char *language() const override;
+  const char* language() const override;
 
   void styleText(int start, int end) override;
   void autoScroll(int error_pos);
@@ -118,17 +139,14 @@ public:
 
   QColor defaultColor(int style) const override;
 
-  void highlightingMultiple(int start, int length, char *styles) override;
+  void highlightingMultiple(int start, int length, char* styles) override;
   QString description(int style) const override;
   QStringList autoCompletionWordSeparators() const override;
 
   void addKeywords(const std::string& keywords, int id) {
     my_lexer->defineRules(keywords, id);
   }
-  void finalizeLexer() {
-    my_lexer->finalize_rules();
-  }
-
+  void finalizeLexer() { my_lexer->finalize_rules(); }
 };
 
-#endif // if ENABLE_LEXERTL
+#endif  // if ENABLE_LEXERTL
diff --git a/src/gui/ScintillaEditor.cc b/src/gui/ScintillaEditor.cc
index 83616c816..310eb527b 100644
--- a/src/gui/ScintillaEditor.cc
+++ b/src/gui/ScintillaEditor.cc
@@ -1,58 +1,57 @@
 #include "gui/ScintillaEditor.h"
 
+#include <Qsci/qscicommandset.h>
+#include <QChar>
 #include <QColor>
 #include <QCursor>
 #include <QEvent>
 #include <QGuiApplication>
 #include <QMenu>
 #include <QObject>
+#include <QRegularExpression>
+#include <QShortcut>
+#include <QString>
 #include <QTimer>
 #include <QVBoxLayout>
 #include <QWidget>
-#include <functional>
+#include <algorithm>
+#include <boost/property_tree/json_parser.hpp>
+#include <boost/property_tree/ptree.hpp>
+#include <cstdlib>
 #include <exception>
+#include <filesystem>
+#include <functional>
 #include <memory>
-#include <cstdlib>
 #include <string>
 #include <vector>
-#include <algorithm>
-#include <filesystem>
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/json_parser.hpp>
-#include <QString>
-#include <QChar>
-#include <QRegularExpression>
-#include <QShortcut>
-#include <Qsci/qscicommandset.h>
 
-#include "gui/Preferences.h"
-#include "platform/PlatformUtils.h"
 #include "core/Settings.h"
+#include "gui/Preferences.h"
 #include "gui/ScadLexer.h"
+#include "platform/PlatformUtils.h"
 
-#include <QWheelEvent>
 #include <QPoint>
 #include <QToolTip>
+#include <QWheelEvent>
 
 namespace fs = std::filesystem;
 
 const QString ScintillaEditor::cursorPlaceHolder = "^~^";
 
-// In setCursorPosition, how many lines should be visible above and below the cursor
+// In setCursorPosition, how many lines should be visible above and below the
+// cursor
 const int setCursorPositionVisibleLines = 3;
 
-
-class SettingsConverter
-{
-public:
+class SettingsConverter {
+ public:
   QsciScintilla::WrapMode toWrapMode(const std::string& val);
   QsciScintilla::WrapVisualFlag toLineWrapVisualization(const std::string& val);
-  QsciScintilla::WrapIndentMode toLineWrapIndentationStyle(const std::string& val);
+  QsciScintilla::WrapIndentMode toLineWrapIndentationStyle(
+      const std::string& val);
   QsciScintilla::WhitespaceVisibility toShowWhitespaces(const std::string& val);
 };
 
-QsciScintilla::WrapMode SettingsConverter::toWrapMode(const std::string& val)
-{
+QsciScintilla::WrapMode SettingsConverter::toWrapMode(const std::string& val) {
   if (val == "Char") {
     return QsciScintilla::WrapCharacter;
   } else if (val == "Word") {
@@ -62,8 +61,8 @@ QsciScintilla::WrapMode SettingsConverter::toWrapMode(const std::string& val)
   }
 }
 
-QsciScintilla::WrapVisualFlag SettingsConverter::toLineWrapVisualization(const std::string& val)
-{
+QsciScintilla::WrapVisualFlag SettingsConverter::toLineWrapVisualization(
+    const std::string& val) {
   if (val == "Text") {
     return QsciScintilla::WrapFlagByText;
   } else if (val == "Border") {
@@ -77,8 +76,8 @@ QsciScintilla::WrapVisualFlag SettingsConverter::toLineWrapVisualization(const s
   }
 }
 
-QsciScintilla::WrapIndentMode SettingsConverter::toLineWrapIndentationStyle(const std::string& val)
-{
+QsciScintilla::WrapIndentMode SettingsConverter::toLineWrapIndentationStyle(
+    const std::string& val) {
   if (val == "Same") {
     return QsciScintilla::WrapIndentSame;
   } else if (val == "Indented") {
@@ -88,8 +87,8 @@ QsciScintilla::WrapIndentMode SettingsConverter::toLineWrapIndentationStyle(cons
   }
 }
 
-QsciScintilla::WhitespaceVisibility SettingsConverter::toShowWhitespaces(const std::string& val)
-{
+QsciScintilla::WhitespaceVisibility SettingsConverter::toShowWhitespaces(
+    const std::string& val) {
   if (val == "Always") {
     return QsciScintilla::WsVisible;
   } else if (val == "AfterIndentation") {
@@ -99,48 +98,43 @@ QsciScintilla::WhitespaceVisibility SettingsConverter::toShowWhitespaces(const s
   }
 }
 
-EditorColorScheme::EditorColorScheme(const fs::path& path) : path(path)
-{
+EditorColorScheme::EditorColorScheme(const fs::path& path) : path(path) {
   try {
     boost::property_tree::read_json(path.generic_string(), pt);
     _name = QString::fromStdString(pt.get<std::string>("name"));
     _index = pt.get<int>("index");
   } catch (const std::exception& e) {
-    LOG("Error reading color scheme file '%1$s': %2$s", path.generic_string(), e.what());
+    LOG("Error reading color scheme file '%1$s': %2$s", path.generic_string(),
+        e.what());
     _name = "";
     _index = 0;
   }
 }
 
-bool EditorColorScheme::valid() const
-{
+bool EditorColorScheme::valid() const {
   return !_name.isEmpty();
 }
 
-const QString& EditorColorScheme::name() const
-{
+const QString& EditorColorScheme::name() const {
   return _name;
 }
 
-int EditorColorScheme::index() const
-{
+int EditorColorScheme::index() const {
   return _index;
 }
 
-const boost::property_tree::ptree& EditorColorScheme::propertyTree() const
-{
+const boost::property_tree::ptree& EditorColorScheme::propertyTree() const {
   return pt;
 }
 
-ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
-{
+ScintillaEditor::ScintillaEditor(QWidget* parent) : EditorInterface(parent) {
   api = nullptr;
   lexer = nullptr;
   scintillaLayout = new QVBoxLayout(this);
   qsci = new QsciScintilla(this);
 
   contentsRendered = false;
-  findState = 0; //FIND_HIDDEN
+  findState = 0;  // FIND_HIDDEN
   filepath = "";
 
   // Force EOL mode to Unix, since QTextStream will manage local EOL modes.
@@ -150,10 +144,11 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   // Remapping some scintilla key binding which conflict with OpenSCAD global
   // key bindings, as well as some minor scintilla bugs
   //
-  QsciCommand *c;
+  QsciCommand* c;
   // NOLINTBEGIN(bugprone-suspicious-enum-usage)
 #ifdef Q_OS_MACOS
-  // Alt-Backspace should delete left word (Alt-Delete already deletes right word)
+  // Alt-Backspace should delete left word (Alt-Delete already deletes right
+  // word)
   c = qsci->standardCommands()->find(QsciCommand::DeleteWordLeft);
   c->setKey(Qt::Key_Backspace | Qt::ALT);
 #endif
@@ -174,17 +169,14 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   const unsigned long modifier = Qt::CTRL;
 #endif
 
-  QShortcut *shortcutCalltip;
+  QShortcut* shortcutCalltip;
   shortcutCalltip = new QShortcut(modifier | Qt::SHIFT | Qt::Key_Space, this);
-  connect(shortcutCalltip, &QShortcut::activated, [ = ]() {
-    qsci->callTip();
-  });
+  connect(shortcutCalltip, &QShortcut::activated, [=]() { qsci->callTip(); });
 
-  QShortcut *shortcutAutocomplete;
+  QShortcut* shortcutAutocomplete;
   shortcutAutocomplete = new QShortcut(modifier | Qt::Key_Space, this);
-  connect(shortcutAutocomplete, &QShortcut::activated, [ = ]() {
-    qsci->autoCompleteFromAPIs();
-  });
+  connect(shortcutAutocomplete, &QShortcut::activated,
+          [=]() { qsci->autoCompleteFromAPIs(); });
   // NOLINTEND(bugprone-suspicious-enum-usage)
 
   scintillaLayout->setContentsMargins(0, 0, 0, 0);
@@ -196,11 +188,16 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
 
   qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, errorIndicatorNumber);
   qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, findIndicatorNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsActiveNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsActiveNumber + 1);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber + 1);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber + 2);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsActiveNumber);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsActiveNumber + 1);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsImpactedNumber);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsImpactedNumber + 1);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsImpactedNumber + 2);
 
   qsci->markerDefine(QsciScintilla::Circle, errMarkerNumber);
   qsci->markerDefine(QsciScintilla::Bookmark, bmMarkerNumber);
@@ -212,7 +209,6 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   qsci->markerDefine('5', selectionMarkerLevelNumber + 4);
   qsci->markerDefine('+', selectionMarkerLevelNumber + 5);
 
-
   qsci->setMarginType(numberMargin, QsciScintilla::NumberMargin);
   qsci->setMarginLineNumbers(numberMargin, true);
   qsci->setMarginMarkerMask(numberMargin, 0);
@@ -220,7 +216,14 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   qsci->setMarginType(symbolMargin, QsciScintilla::SymbolMargin);
   qsci->setMarginLineNumbers(symbolMargin, false);
   qsci->setMarginWidth(symbolMargin, 0);
-  qsci->setMarginMarkerMask(symbolMargin, 1 << errMarkerNumber | 1 << bmMarkerNumber | 1 << selectionMarkerLevelNumber | 1 << (selectionMarkerLevelNumber + 1) | 1 << (selectionMarkerLevelNumber + 2) | 1 << (selectionMarkerLevelNumber + 3) | 1 << (selectionMarkerLevelNumber + 4) | 1 << (selectionMarkerLevelNumber + 5));
+  qsci->setMarginMarkerMask(symbolMargin,
+                            1 << errMarkerNumber | 1 << bmMarkerNumber |
+                                1 << selectionMarkerLevelNumber |
+                                1 << (selectionMarkerLevelNumber + 1) |
+                                1 << (selectionMarkerLevelNumber + 2) |
+                                1 << (selectionMarkerLevelNumber + 3) |
+                                1 << (selectionMarkerLevelNumber + 4) |
+                                1 << (selectionMarkerLevelNumber + 5));
 
 #if ENABLE_LEXERTL
   auto newLexer = new ScadLexer2(this);
@@ -232,22 +235,31 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
 
   initMargin();
 
-  connect(qsci, &QsciScintilla::textChanged, this, &ScintillaEditor::contentsChanged);
-  connect(qsci, &QsciScintilla::modificationChanged, this, &ScintillaEditor::fireModificationChanged);
-  connect(qsci, &QsciScintilla::userListActivated, this, &ScintillaEditor::onUserListSelected);
+  connect(qsci, &QsciScintilla::textChanged, this,
+          &ScintillaEditor::contentsChanged);
+  connect(qsci, &QsciScintilla::modificationChanged, this,
+          &ScintillaEditor::fireModificationChanged);
+  connect(qsci, &QsciScintilla::userListActivated, this,
+          &ScintillaEditor::onUserListSelected);
   qsci->installEventFilter(this);
   qsci->viewport()->installEventFilter(this);
 
   qsci->setContextMenuPolicy(Qt::CustomContextMenu);
-  connect(qsci, &QsciScintilla::customContextMenuRequested, this, &ScintillaEditor::showContextMenuEvent);
-
-  qsci->indicatorDefine(QsciScintilla::ThinCompositionIndicator, hyperlinkIndicatorNumber);
-  qsci->SendScintilla(QsciScintilla::SCI_INDICSETSTYLE, hyperlinkIndicatorNumber, QsciScintilla::INDIC_HIDDEN);
-  connect(qsci, &QsciScintilla::indicatorClicked, this, &ScintillaEditor::onIndicatorClicked);
-  connect(qsci, &QsciScintilla::indicatorReleased, this, &ScintillaEditor::onIndicatorReleased);
+  connect(qsci, &QsciScintilla::customContextMenuRequested, this,
+          &ScintillaEditor::showContextMenuEvent);
+
+  qsci->indicatorDefine(QsciScintilla::ThinCompositionIndicator,
+                        hyperlinkIndicatorNumber);
+  qsci->SendScintilla(QsciScintilla::SCI_INDICSETSTYLE,
+                      hyperlinkIndicatorNumber, QsciScintilla::INDIC_HIDDEN);
+  connect(qsci, &QsciScintilla::indicatorClicked, this,
+          &ScintillaEditor::onIndicatorClicked);
+  connect(qsci, &QsciScintilla::indicatorReleased, this,
+          &ScintillaEditor::onIndicatorReleased);
 
 #if QSCINTILLA_VERSION >= 0x020b00
-  connect(qsci, &QsciScintilla::SCN_URIDROPPED, this, &ScintillaEditor::uriDropped);
+  connect(qsci, &QsciScintilla::SCN_URIDROPPED, this,
+          &ScintillaEditor::uriDropped);
 #endif
   connect(qsci, &QsciScintilla::SCN_FOCUSIN, this, &ScintillaEditor::focusIn);
 
@@ -255,58 +267,57 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   qsci->SendScintilla(QsciScintillaBase::SCI_SETBUFFEREDDRAW, false);
 }
 
-QPoint ScintillaEditor::mapToGlobal(const QPoint& pos)
-{
+QPoint ScintillaEditor::mapToGlobal(const QPoint& pos) {
   return qsci->mapToGlobal(pos);
 }
 
-QMenu *ScintillaEditor::createStandardContextMenu()
-{
+QMenu* ScintillaEditor::createStandardContextMenu() {
   return qsci->createStandardContextMenu();
 }
 
-void ScintillaEditor::addTemplate()
-{
+void ScintillaEditor::addTemplate() {
   addTemplate(PlatformUtils::resourceBasePath());
   addTemplate(PlatformUtils::userConfigPath());
-  for (const auto& key: templateMap.keys()) {
+  for (const auto& key : templateMap.keys()) {
     userList.append(key);
   }
 }
 
-void ScintillaEditor::addTemplate(const fs::path& path)
-{
+void ScintillaEditor::addTemplate(const fs::path& path) {
   const auto template_path = path / "templates";
 
   if (fs::exists(template_path) && fs::is_directory(template_path)) {
-    for (const auto& dirEntry : boost::make_iterator_range(fs::directory_iterator{template_path}, {})) {
-      if (!fs::is_regular_file(dirEntry.status())) continue;
+    for (const auto& dirEntry : boost::make_iterator_range(
+             fs::directory_iterator{template_path}, {})) {
+      if (!fs::is_regular_file(dirEntry.status()))
+        continue;
 
       const auto& path = dirEntry.path();
-      if (!(path.extension() == ".json")) continue;
+      if (!(path.extension() == ".json"))
+        continue;
 
       boost::property_tree::ptree pt;
       try {
         boost::property_tree::read_json(path.generic_string().c_str(), pt);
         const QString key = QString::fromStdString(pt.get<std::string>("key"));
-        const QString content = QString::fromStdString(pt.get<std::string>("content"));
+        const QString content =
+            QString::fromStdString(pt.get<std::string>("content"));
         const int cursor_offset = pt.get<int>("offset", -1);
 
         templateMap.insert(key, ScadTemplate(content, cursor_offset));
       } catch (const std::exception& e) {
-        LOG("Error reading template file '%1$s': %2$s", path.generic_string(), e.what());
+        LOG("Error reading template file '%1$s': %2$s", path.generic_string(),
+            e.what());
       }
     }
   }
 }
 
-void ScintillaEditor::displayTemplates()
-{
+void ScintillaEditor::displayTemplates() {
   qsci->showUserList(1, userList);
 }
 
-void ScintillaEditor::foldUnfold()
-{
+void ScintillaEditor::foldUnfold() {
   qsci->foldAll();
 }
 
@@ -314,18 +325,22 @@ void ScintillaEditor::foldUnfold()
  * Apply the settings that are changeable in the preferences. This is also
  * called in the event handler from the preferences.
  */
-void ScintillaEditor::applySettings()
-{
+void ScintillaEditor::applySettings() {
   SettingsConverter conv;
 
   qsci->setIndentationWidth(Settings::Settings::indentationWidth.value());
   qsci->setTabWidth(Settings::Settings::tabWidth.value());
   qsci->setWrapMode(conv.toWrapMode(Settings::Settings::lineWrap.value()));
-  qsci->setWrapIndentMode(conv.toLineWrapIndentationStyle(Settings::Settings::lineWrapIndentationStyle.value()));
-  qsci->setWrapVisualFlags(conv.toLineWrapVisualization(Settings::Settings::lineWrapVisualizationEnd.value()),
-                           conv.toLineWrapVisualization(Settings::Settings::lineWrapVisualizationBegin.value()),
-                           Settings::Settings::lineWrapIndentation.value());
-  qsci->setWhitespaceVisibility(conv.toShowWhitespaces(Settings::Settings::showWhitespace.value()));
+  qsci->setWrapIndentMode(conv.toLineWrapIndentationStyle(
+      Settings::Settings::lineWrapIndentationStyle.value()));
+  qsci->setWrapVisualFlags(
+      conv.toLineWrapVisualization(
+          Settings::Settings::lineWrapVisualizationEnd.value()),
+      conv.toLineWrapVisualization(
+          Settings::Settings::lineWrapVisualizationBegin.value()),
+      Settings::Settings::lineWrapIndentation.value());
+  qsci->setWhitespaceVisibility(
+      conv.toShowWhitespaces(Settings::Settings::showWhitespace.value()));
   qsci->setWhitespaceSize(Settings::Settings::showWhitespaceSize.value());
   qsci->setAutoIndent(Settings::Settings::autoIndent.value());
   qsci->setBackspaceUnindents(Settings::Settings::backspaceUnindents.value());
@@ -335,15 +350,16 @@ void ScintillaEditor::applySettings()
   const auto& tabKeyFunction = Settings::Settings::tabKeyFunction.value();
   qsci->setTabIndents(tabKeyFunction == "Indent");
 
-  qsci->setBraceMatching(Settings::Settings::enableBraceMatching.value() ? QsciScintilla::SloppyBraceMatch : QsciScintilla::NoBraceMatch);
+  qsci->setBraceMatching(Settings::Settings::enableBraceMatching.value()
+                             ? QsciScintilla::SloppyBraceMatch
+                             : QsciScintilla::NoBraceMatch);
   qsci->setCaretLineVisible(Settings::Settings::highlightCurrentLine.value());
   onTextChanged();
 
   setupAutoComplete(false);
 }
 
-void ScintillaEditor::setupAutoComplete(const bool forceOff)
-{
+void ScintillaEditor::setupAutoComplete(const bool forceOff) {
   if (qsci->isListActive()) {
     qsci->cancelList();
   }
@@ -352,7 +368,8 @@ void ScintillaEditor::setupAutoComplete(const bool forceOff)
     qsci->SendScintilla(QsciScintilla::SCI_CALLTIPCANCEL);
   }
 
-  const bool configValue = GlobalPreferences::inst()->getValue("editor/enableAutocomplete").toBool();
+  const bool configValue =
+      GlobalPreferences::inst()->getValue("editor/enableAutocomplete").toBool();
   const bool enable = configValue && !forceOff;
 
   if (enable) {
@@ -367,40 +384,36 @@ void ScintillaEditor::setupAutoComplete(const bool forceOff)
     qsci->setCallTipsStyle(QsciScintilla::CallTipsNone);
   }
 
-  int val = GlobalPreferences::inst()->getValue("editor/characterThreshold").toInt();
+  int val =
+      GlobalPreferences::inst()->getValue("editor/characterThreshold").toInt();
   qsci->setAutoCompletionThreshold(val <= 0 ? 1 : val);
 }
 
-void ScintillaEditor::fireModificationChanged()
-{
+void ScintillaEditor::fireModificationChanged() {
   emit modificationChanged(this);
 }
 
-void ScintillaEditor::setPlainText(const QString& text)
-{
+void ScintillaEditor::setPlainText(const QString& text) {
   qsci->setText(text);
   setContentModified(false);
 }
 
-QString ScintillaEditor::toPlainText()
-{
+QString ScintillaEditor::toPlainText() {
   return qsci->text();
 }
 
-void ScintillaEditor::setContentModified(bool modified)
-{
-  // FIXME: Due to an issue with QScintilla, we need to do this on the document itself.
+void ScintillaEditor::setContentModified(bool modified) {
+  // FIXME: Due to an issue with QScintilla, we need to do this on the document
+  // itself.
   qsci->SCN_SAVEPOINTLEFT();
   qsci->setModified(modified);
 }
 
-bool ScintillaEditor::isContentModified()
-{
+bool ScintillaEditor::isContentModified() {
   return qsci->isModified();
 }
 
-void ScintillaEditor::highlightError(int error_pos)
-{
+void ScintillaEditor::highlightError(int error_pos) {
   int line, index;
   qsci->lineIndexFromPosition(error_pos, &line, &index);
   qsci->fillIndicatorRange(line, index, line, index + 1, errorIndicatorNumber);
@@ -408,8 +421,7 @@ void ScintillaEditor::highlightError(int error_pos)
   updateSymbolMarginVisibility();
 }
 
-void ScintillaEditor::unhighlightLastError()
-{
+void ScintillaEditor::unhighlightLastError() {
   auto totalLength = qsci->length();
   int line, index;
   qsci->lineIndexFromPosition(totalLength, &line, &index);
@@ -418,8 +430,9 @@ void ScintillaEditor::unhighlightLastError()
   updateSymbolMarginVisibility();
 }
 
-QColor ScintillaEditor::readColor(const boost::property_tree::ptree& pt, const std::string& name, const QColor& defaultColor)
-{
+QColor ScintillaEditor::readColor(const boost::property_tree::ptree& pt,
+                                  const std::string& name,
+                                  const QColor& defaultColor) {
   try {
     const auto val = pt.get<std::string>(name);
     return {val.c_str()};
@@ -428,8 +441,9 @@ QColor ScintillaEditor::readColor(const boost::property_tree::ptree& pt, const s
   }
 }
 
-std::string ScintillaEditor::readString(const boost::property_tree::ptree& pt, const std::string& name, const std::string& defaultValue)
-{
+std::string ScintillaEditor::readString(const boost::property_tree::ptree& pt,
+                                        const std::string& name,
+                                        const std::string& defaultValue) {
   try {
     return pt.get<std::string>(name);
   } catch (const std::exception& e) {
@@ -437,8 +451,9 @@ std::string ScintillaEditor::readString(const boost::property_tree::ptree& pt, c
   }
 }
 
-int ScintillaEditor::readInt(const boost::property_tree::ptree& pt, const std::string& name, const int defaultValue)
-{
+int ScintillaEditor::readInt(const boost::property_tree::ptree& pt,
+                             const std::string& name,
+                             const int defaultValue) {
   try {
     const auto val = pt.get<int>(name);
     return val;
@@ -448,8 +463,7 @@ int ScintillaEditor::readInt(const boost::property_tree::ptree& pt, const std::s
 }
 
 #if ENABLE_LEXERTL
-void ScintillaEditor::setLexer(ScadLexer2 *newLexer)
-{
+void ScintillaEditor::setLexer(ScadLexer2* newLexer) {
   delete this->api;
   this->qsci->setLexer(newLexer);
   this->api = new ScadApi(this, newLexer);
@@ -457,18 +471,16 @@ void ScintillaEditor::setLexer(ScadLexer2 *newLexer)
   this->lexer = newLexer;
 }
 #else
-void ScintillaEditor::setLexer(ScadLexer *newLexer)
-{
+void ScintillaEditor::setLexer(ScadLexer* newLexer) {
   delete this->api;
   this->qsci->setLexer(newLexer);
   this->api = new ScadApi(this, newLexer);
   delete this->lexer;
   this->lexer = newLexer;
 }
-#endif // if ENABLE_LEXERTL
+#endif  // if ENABLE_LEXERTL
 
-void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
-{
+void ScintillaEditor::setColormap(const EditorColorScheme* colorScheme) {
   const auto& pt = colorScheme->propertyTree();
 
   try {
@@ -478,23 +490,35 @@ void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
 
 #if ENABLE_LEXERTL
 
-/// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
+    /// See original attempt at
+    /// https://github.com/openscad/openscad/tree/lexertl/src
 
-    auto *newLexer = new ScadLexer2(this);
+    auto* newLexer = new ScadLexer2(this);
 
     // Custom keywords must be set before the lexer is constructed/finalized
-    boost::optional<const boost::property_tree::ptree&> keywords = pt.get_child_optional("keywords");
+    boost::optional<const boost::property_tree::ptree&> keywords =
+        pt.get_child_optional("keywords");
     if (keywords.is_initialized()) {
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom1", ""), ScadLexer2::Custom1);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom2", ""), ScadLexer2::Custom2);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom3", ""), ScadLexer2::Custom3);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom4", ""), ScadLexer2::Custom4);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom5", ""), ScadLexer2::Custom5);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom6", ""), ScadLexer2::Custom6);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom7", ""), ScadLexer2::Custom7);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom8", ""), ScadLexer2::Custom8);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom9", ""), ScadLexer2::Custom9);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom10", ""), ScadLexer2::Custom10);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom1", ""),
+                            ScadLexer2::Custom1);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom2", ""),
+                            ScadLexer2::Custom2);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom3", ""),
+                            ScadLexer2::Custom3);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom4", ""),
+                            ScadLexer2::Custom4);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom5", ""),
+                            ScadLexer2::Custom5);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom6", ""),
+                            ScadLexer2::Custom6);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom7", ""),
+                            ScadLexer2::Custom7);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom8", ""),
+                            ScadLexer2::Custom8);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom9", ""),
+                            ScadLexer2::Custom9);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom10", ""),
+                            ScadLexer2::Custom10);
     }
 
     newLexer->finalizeLexer();
@@ -508,44 +532,70 @@ void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
 
     const auto& colors = pt.get_child("colors");
 
-    newLexer->setColor(readColor(colors, "operator", textColor), ScadLexer2::Operator);
-    newLexer->setColor(readColor(colors, "comment", textColor), ScadLexer2::Comment);
-    newLexer->setColor(readColor(colors, "number", textColor), ScadLexer2::Number);
-    newLexer->setColor(readColor(colors, "string", textColor), ScadLexer2::String);
-    newLexer->setColor(readColor(colors, "variables", textColor), ScadLexer2::Variable);
-    newLexer->setColor(readColor(colors, "keywords", textColor), ScadLexer2::Keyword); // formerly keyword1
-    newLexer->setColor(readColor(colors, "transformations", textColor), ScadLexer2::Transformation); // formerly keyword3
-    newLexer->setColor(readColor(colors, "booleans", textColor), ScadLexer2::Boolean); // formerly keyword3
-    newLexer->setColor(readColor(colors, "functions", textColor), ScadLexer2::Function); // formerly keyword2
-    newLexer->setColor(readColor(colors, "models", textColor), ScadLexer2::Model); // formerly keyword3
-    newLexer->setColor(readColor(colors, "special-variables", textColor), ScadLexer2::SpecialVariable); // formerly keyword1
-
-    newLexer->setColor(readColor(colors, "keyword-custom1", textColor), ScadLexer2::Custom1);
-    newLexer->setColor(readColor(colors, "keyword-custom2", textColor), ScadLexer2::Custom2);
-    newLexer->setColor(readColor(colors, "keyword-custom3", textColor), ScadLexer2::Custom3);
-    newLexer->setColor(readColor(colors, "keyword-custom4", textColor), ScadLexer2::Custom4);
-    newLexer->setColor(readColor(colors, "keyword-custom5", textColor), ScadLexer2::Custom5);
-    newLexer->setColor(readColor(colors, "keyword-custom6", textColor), ScadLexer2::Custom6);
-    newLexer->setColor(readColor(colors, "keyword-custom7", textColor), ScadLexer2::Custom7);
-    newLexer->setColor(readColor(colors, "keyword-custom8", textColor), ScadLexer2::Custom8);
-    newLexer->setColor(readColor(colors, "keyword-custom9", textColor), ScadLexer2::Custom9);
-    newLexer->setColor(readColor(colors, "keyword-custom10", textColor), ScadLexer2::Custom10);
+    newLexer->setColor(readColor(colors, "operator", textColor),
+                       ScadLexer2::Operator);
+    newLexer->setColor(readColor(colors, "comment", textColor),
+                       ScadLexer2::Comment);
+    newLexer->setColor(readColor(colors, "number", textColor),
+                       ScadLexer2::Number);
+    newLexer->setColor(readColor(colors, "string", textColor),
+                       ScadLexer2::String);
+    newLexer->setColor(readColor(colors, "variables", textColor),
+                       ScadLexer2::Variable);
+    newLexer->setColor(readColor(colors, "keywords", textColor),
+                       ScadLexer2::Keyword);  // formerly keyword1
+    newLexer->setColor(readColor(colors, "transformations", textColor),
+                       ScadLexer2::Transformation);  // formerly keyword3
+    newLexer->setColor(readColor(colors, "booleans", textColor),
+                       ScadLexer2::Boolean);  // formerly keyword3
+    newLexer->setColor(readColor(colors, "functions", textColor),
+                       ScadLexer2::Function);  // formerly keyword2
+    newLexer->setColor(readColor(colors, "models", textColor),
+                       ScadLexer2::Model);  // formerly keyword3
+    newLexer->setColor(readColor(colors, "special-variables", textColor),
+                       ScadLexer2::SpecialVariable);  // formerly keyword1
+
+    newLexer->setColor(readColor(colors, "keyword-custom1", textColor),
+                       ScadLexer2::Custom1);
+    newLexer->setColor(readColor(colors, "keyword-custom2", textColor),
+                       ScadLexer2::Custom2);
+    newLexer->setColor(readColor(colors, "keyword-custom3", textColor),
+                       ScadLexer2::Custom3);
+    newLexer->setColor(readColor(colors, "keyword-custom4", textColor),
+                       ScadLexer2::Custom4);
+    newLexer->setColor(readColor(colors, "keyword-custom5", textColor),
+                       ScadLexer2::Custom5);
+    newLexer->setColor(readColor(colors, "keyword-custom6", textColor),
+                       ScadLexer2::Custom6);
+    newLexer->setColor(readColor(colors, "keyword-custom7", textColor),
+                       ScadLexer2::Custom7);
+    newLexer->setColor(readColor(colors, "keyword-custom8", textColor),
+                       ScadLexer2::Custom8);
+    newLexer->setColor(readColor(colors, "keyword-custom9", textColor),
+                       ScadLexer2::Custom9);
+    newLexer->setColor(readColor(colors, "keyword-custom10", textColor),
+                       ScadLexer2::Custom10);
 
 #else
-    auto *newLexer = new ScadLexer(this);
+    auto* newLexer = new ScadLexer(this);
 
     // Keywords must be set before the lexer is attached to QScintilla
     // as they seem to be read and cached at attach time.
-    boost::optional<const boost::property_tree::ptree&> keywords = pt.get_child_optional("keywords");
+    boost::optional<const boost::property_tree::ptree&> keywords =
+        pt.get_child_optional("keywords");
     if (keywords.is_initialized()) {
       newLexer->setKeywords(1, readString(keywords.get(), "keyword-set1", ""));
       newLexer->setKeywords(2, readString(keywords.get(), "keyword-set2", ""));
-      newLexer->setKeywords(3, readString(keywords.get(), "keyword-set-doc", ""));
+      newLexer->setKeywords(3,
+                            readString(keywords.get(), "keyword-set-doc", ""));
       newLexer->setKeywords(4, readString(keywords.get(), "keyword-set3", ""));
     }
 
-    // See https://github.com/openscad/openscad/issues/1172 for details about why we can't do syntax coloring with # lines
-    newLexer->setStylePreprocessor(true); // does not work on first word, but allows remaining words to be syntax colored
+    // See https://github.com/openscad/openscad/issues/1172 for details about
+    // why we can't do syntax coloring with # lines
+    newLexer->setStylePreprocessor(
+        true);  // does not work on first word, but allows remaining words to be
+                // syntax colored
 
     setLexer(newLexer);
 
@@ -556,17 +606,28 @@ void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
     newLexer->setPaper(paperColor);
 
     const auto& colors = pt.get_child("colors");
-    newLexer->setColor(readColor(colors, "keyword1", textColor), QsciLexerCPP::Keyword);
-    newLexer->setColor(readColor(colors, "keyword2", textColor), QsciLexerCPP::KeywordSet2);
-    newLexer->setColor(readColor(colors, "keyword3", textColor), QsciLexerCPP::GlobalClass);
-    newLexer->setColor(readColor(colors, "number", textColor), QsciLexerCPP::Number);
-    newLexer->setColor(readColor(colors, "string", textColor), QsciLexerCPP::DoubleQuotedString);
-    newLexer->setColor(readColor(colors, "operator", textColor), QsciLexerCPP::Operator);
-    newLexer->setColor(readColor(colors, "comment", textColor), QsciLexerCPP::Comment);
-    newLexer->setColor(readColor(colors, "commentline", textColor), QsciLexerCPP::CommentLine);
-    newLexer->setColor(readColor(colors, "commentdoc", textColor), QsciLexerCPP::CommentDoc);
-    newLexer->setColor(readColor(colors, "commentdoc", textColor), QsciLexerCPP::CommentLineDoc);
-    newLexer->setColor(readColor(colors, "commentdockeyword", textColor), QsciLexerCPP::CommentDocKeyword);
+    newLexer->setColor(readColor(colors, "keyword1", textColor),
+                       QsciLexerCPP::Keyword);
+    newLexer->setColor(readColor(colors, "keyword2", textColor),
+                       QsciLexerCPP::KeywordSet2);
+    newLexer->setColor(readColor(colors, "keyword3", textColor),
+                       QsciLexerCPP::GlobalClass);
+    newLexer->setColor(readColor(colors, "number", textColor),
+                       QsciLexerCPP::Number);
+    newLexer->setColor(readColor(colors, "string", textColor),
+                       QsciLexerCPP::DoubleQuotedString);
+    newLexer->setColor(readColor(colors, "operator", textColor),
+                       QsciLexerCPP::Operator);
+    newLexer->setColor(readColor(colors, "comment", textColor),
+                       QsciLexerCPP::Comment);
+    newLexer->setColor(readColor(colors, "commentline", textColor),
+                       QsciLexerCPP::CommentLine);
+    newLexer->setColor(readColor(colors, "commentdoc", textColor),
+                       QsciLexerCPP::CommentDoc);
+    newLexer->setColor(readColor(colors, "commentdoc", textColor),
+                       QsciLexerCPP::CommentLineDoc);
+    newLexer->setColor(readColor(colors, "commentdockeyword", textColor),
+                       QsciLexerCPP::CommentDocKeyword);
 
 #endif  // ENABLE_LEXERTL
 
@@ -576,84 +637,184 @@ void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
     const auto& caret = pt.get_child("caret");
     qsci->setCaretWidth(readInt(caret, "width", 1));
     qsci->setCaretForegroundColor(readColor(caret, "foreground", textColor));
-    qsci->setCaretLineBackgroundColor(readColor(caret, "line-background", paperColor));
-
-    qsci->setMarkerBackgroundColor(readColor(colors, "error-marker", QColor(255, 0, 0, 100)), errMarkerNumber);
-    qsci->setMarkerBackgroundColor(readColor(colors, "bookmark-marker", QColor(150, 200, 255, 100)), bmMarkerNumber); // light blue
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker1", QColor(11, 156, 49, 100)), selectionMarkerLevelNumber);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker2", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 1);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker3", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 2);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker4", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 3);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker5", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 4);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker6", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 5);
-    qsci->setMarkerBackgroundColor(readColor(colors, "bookmark-marker", QColor(150, 200, 255, 50)), bmMarkerNumber); // light blue
-    qsci->setIndicatorForegroundColor(readColor(colors, "selected-highlight-indicator", QColor(11, 156, 49, 100)), selectionIndicatorIsActiveNumber); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "selected-highlight-indicator-outline", QColor(11, 156, 49, 100)), selectionIndicatorIsActiveNumber); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "selected-highlight1-indicator", QColor(11, 156, 49, 50)), selectionIndicatorIsActiveNumber + 1); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "selected-highlight1-indicator-outline", QColor(11, 156, 49, 50)), selectionIndicatorIsActiveNumber + 1); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight0-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight0-indicator-outline", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight1-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber + 1); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight1-indicator-outline", QColor(255, 128, 128, 80)), selectionIndicatorIsImpactedNumber + 1); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight2-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber + 2); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight2-indicator-outline", QColor(255, 128, 128, 60)), selectionIndicatorIsImpactedNumber + 2); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "error-indicator", QColor(255, 0, 0, 100)), errorIndicatorNumber); //red
-    qsci->setIndicatorOutlineColor(readColor(colors, "error-indicator-outline", QColor(255, 0, 0, 100)), errorIndicatorNumber); //red
-    qsci->setIndicatorForegroundColor(readColor(colors, "find-indicator", QColor(255, 255, 0, 100)), findIndicatorNumber); //yellow
-    qsci->setIndicatorOutlineColor(readColor(colors, "find-indicator-outline", QColor(255, 255, 0, 100)), findIndicatorNumber); //yellow
-    qsci->setIndicatorForegroundColor(readColor(colors, "hyperlink-indicator", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setIndicatorOutlineColor(readColor(colors, "hyperlink-indicator-outline", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setIndicatorHoverForegroundColor(readColor(colors, "hyperlink-indicator-hover", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setWhitespaceForegroundColor(readColor(colors, "whitespace-foreground", textColor));
-    qsci->setMarginsBackgroundColor(readColor(colors, "margin-background", paperColor));
-    qsci->setMarginsForegroundColor(readColor(colors, "margin-foreground", textColor));
-    qsci->setFoldMarginColors(readColor(colors, "margin-background", paperColor),
-                              readColor(colors, "margin-background", paperColor));
-    qsci->setMatchedBraceBackgroundColor(readColor(colors, "matched-brace-background", paperColor));
-    qsci->setMatchedBraceForegroundColor(readColor(colors, "matched-brace-foreground", textColor));
-    qsci->setUnmatchedBraceBackgroundColor(readColor(colors, "unmatched-brace-background", paperColor));
-    qsci->setUnmatchedBraceForegroundColor(readColor(colors, "unmatched-brace-foreground", textColor));
-    qsci->setSelectionForegroundColor(readColor(colors, "selection-foreground", paperColor));
-    qsci->setSelectionBackgroundColor(readColor(colors, "selection-background", textColor));
+    qsci->setCaretLineBackgroundColor(
+        readColor(caret, "line-background", paperColor));
+
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "error-marker", QColor(255, 0, 0, 100)),
+        errMarkerNumber);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "bookmark-marker", QColor(150, 200, 255, 100)),
+        bmMarkerNumber);  // light blue
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker1", QColor(11, 156, 49, 100)),
+        selectionMarkerLevelNumber);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker2", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 1);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker3", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 2);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker4", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 3);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker5", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 4);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker6", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 5);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "bookmark-marker", QColor(150, 200, 255, 50)),
+        bmMarkerNumber);  // light blue
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "selected-highlight-indicator",
+                  QColor(11, 156, 49, 100)),
+        selectionIndicatorIsActiveNumber);  // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "selected-highlight-indicator-outline",
+                  QColor(11, 156, 49, 100)),
+        selectionIndicatorIsActiveNumber);  // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "selected-highlight1-indicator",
+                  QColor(11, 156, 49, 50)),
+        selectionIndicatorIsActiveNumber + 1);  // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "selected-highlight1-indicator-outline",
+                  QColor(11, 156, 49, 50)),
+        selectionIndicatorIsActiveNumber + 1);  // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "referenced-highlight0-indicator",
+                  QColor(255, 128, 128, 100)),
+        selectionIndicatorIsImpactedNumber);  // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "referenced-highlight0-indicator-outline",
+                  QColor(255, 128, 128, 100)),
+        selectionIndicatorIsImpactedNumber);  // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "referenced-highlight1-indicator",
+                  QColor(255, 128, 128, 100)),
+        selectionIndicatorIsImpactedNumber + 1);  // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "referenced-highlight1-indicator-outline",
+                  QColor(255, 128, 128, 80)),
+        selectionIndicatorIsImpactedNumber + 1);  // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "referenced-highlight2-indicator",
+                  QColor(255, 128, 128, 100)),
+        selectionIndicatorIsImpactedNumber + 2);  // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "referenced-highlight2-indicator-outline",
+                  QColor(255, 128, 128, 60)),
+        selectionIndicatorIsImpactedNumber + 2);  // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "error-indicator", QColor(255, 0, 0, 100)),
+        errorIndicatorNumber);  // red
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "error-indicator-outline", QColor(255, 0, 0, 100)),
+        errorIndicatorNumber);  // red
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "find-indicator", QColor(255, 255, 0, 100)),
+        findIndicatorNumber);  // yellow
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "find-indicator-outline", QColor(255, 255, 0, 100)),
+        findIndicatorNumber);  // yellow
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "hyperlink-indicator", QColor(139, 24, 168, 100)),
+        hyperlinkIndicatorNumber);  // violet
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "hyperlink-indicator-outline",
+                  QColor(139, 24, 168, 100)),
+        hyperlinkIndicatorNumber);  // violet
+    qsci->setIndicatorHoverForegroundColor(
+        readColor(colors, "hyperlink-indicator-hover",
+                  QColor(139, 24, 168, 100)),
+        hyperlinkIndicatorNumber);  // violet
+    qsci->setWhitespaceForegroundColor(
+        readColor(colors, "whitespace-foreground", textColor));
+    qsci->setMarginsBackgroundColor(
+        readColor(colors, "margin-background", paperColor));
+    qsci->setMarginsForegroundColor(
+        readColor(colors, "margin-foreground", textColor));
+    qsci->setFoldMarginColors(
+        readColor(colors, "margin-background", paperColor),
+        readColor(colors, "margin-background", paperColor));
+    qsci->setMatchedBraceBackgroundColor(
+        readColor(colors, "matched-brace-background", paperColor));
+    qsci->setMatchedBraceForegroundColor(
+        readColor(colors, "matched-brace-foreground", textColor));
+    qsci->setUnmatchedBraceBackgroundColor(
+        readColor(colors, "unmatched-brace-background", paperColor));
+    qsci->setUnmatchedBraceForegroundColor(
+        readColor(colors, "unmatched-brace-foreground", textColor));
+    qsci->setSelectionForegroundColor(
+        readColor(colors, "selection-foreground", paperColor));
+    qsci->setSelectionBackgroundColor(
+        readColor(colors, "selection-background", textColor));
     qsci->setEdgeColor(readColor(colors, "edge", textColor));
   } catch (const std::exception& e) {
     noColor();
   }
 }
 
-void ScintillaEditor::noColor()
-{
+void ScintillaEditor::noColor() {
   this->lexer->setPaper(Qt::white);
   this->lexer->setColor(Qt::black);
   qsci->setCaretWidth(2);
   qsci->setCaretForegroundColor(Qt::black);
   qsci->setMarkerBackgroundColor(QColor(255, 0, 0, 100), errMarkerNumber);
-  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100), bmMarkerNumber); // light blue
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 100), selectionMarkerLevelNumber);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 1);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 2);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 3);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 4);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 5);
-  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100), bmMarkerNumber); // light blue
-  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 100), selectionIndicatorIsActiveNumber);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsActiveNumber);
-  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 50), selectionIndicatorIsActiveNumber + 1);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsActiveNumber + 1);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 100), selectionIndicatorIsImpactedNumber);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 80), selectionIndicatorIsImpactedNumber + 1);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber + 1);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 60), selectionIndicatorIsImpactedNumber + 2);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber + 2);
-
-  qsci->setIndicatorForegroundColor(QColor(255, 0, 0, 128), errorIndicatorNumber); //red
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), errorIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorForegroundColor(QColor(255, 255, 0, 128), findIndicatorNumber); //yellow
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), findIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorForegroundColor(QColor(139, 24, 168, 128), hyperlinkIndicatorNumber); //violet
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), hyperlinkIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorHoverForegroundColor(QColor(139, 24, 168, 128), hyperlinkIndicatorNumber); //violet
+  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100),
+                                 bmMarkerNumber);  // light blue
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 100),
+                                 selectionMarkerLevelNumber);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 1);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 2);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 3);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 4);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 5);
+  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100),
+                                 bmMarkerNumber);  // light blue
+  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 100),
+                                    selectionIndicatorIsActiveNumber);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsActiveNumber);
+  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 50),
+                                    selectionIndicatorIsActiveNumber + 1);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsActiveNumber + 1);
+  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 100),
+                                    selectionIndicatorIsImpactedNumber);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsImpactedNumber);
+  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 80),
+                                    selectionIndicatorIsImpactedNumber + 1);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsImpactedNumber + 1);
+  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 60),
+                                    selectionIndicatorIsImpactedNumber + 2);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsImpactedNumber + 2);
+
+  qsci->setIndicatorForegroundColor(QColor(255, 0, 0, 128),
+                                    errorIndicatorNumber);  // red
+  qsci->setIndicatorOutlineColor(
+      QColor(0, 0, 0, 255), errorIndicatorNumber);  // only alpha part is used
+  qsci->setIndicatorForegroundColor(QColor(255, 255, 0, 128),
+                                    findIndicatorNumber);  // yellow
+  qsci->setIndicatorOutlineColor(
+      QColor(0, 0, 0, 255), findIndicatorNumber);  // only alpha part is used
+  qsci->setIndicatorForegroundColor(QColor(139, 24, 168, 128),
+                                    hyperlinkIndicatorNumber);  // violet
+  qsci->setIndicatorOutlineColor(
+      QColor(0, 0, 0, 255),
+      hyperlinkIndicatorNumber);  // only alpha part is used
+  qsci->setIndicatorHoverForegroundColor(QColor(139, 24, 168, 128),
+                                         hyperlinkIndicatorNumber);  // violet
   qsci->setCaretLineBackgroundColor(Qt::white);
   qsci->setWhitespaceForegroundColor(Qt::black);
   qsci->setSelectionForegroundColor(Qt::black);
@@ -668,16 +829,20 @@ void ScintillaEditor::noColor()
   qsci->setEdgeColor(Qt::black);
 }
 
-void ScintillaEditor::enumerateColorSchemesInPath(ScintillaEditor::colorscheme_set_t& result_set, const fs::path& path)
-{
+void ScintillaEditor::enumerateColorSchemesInPath(
+    ScintillaEditor::colorscheme_set_t& result_set,
+    const fs::path& path) {
   const auto color_schemes = path / "color-schemes" / "editor";
 
   if (fs::exists(color_schemes) && fs::is_directory(color_schemes)) {
-    for (const auto& dirEntry : boost::make_iterator_range(fs::directory_iterator{color_schemes}, {})) {
-      if (!fs::is_regular_file(dirEntry.status())) continue;
+    for (const auto& dirEntry : boost::make_iterator_range(
+             fs::directory_iterator{color_schemes}, {})) {
+      if (!fs::is_regular_file(dirEntry.status()))
+        continue;
 
       const auto& path = dirEntry.path();
-      if (!(path.extension() == ".json")) continue;
+      if (!(path.extension() == ".json"))
+        continue;
 
       auto colorScheme = std::make_shared<EditorColorScheme>(path);
       if (colorScheme->valid()) {
@@ -687,8 +852,7 @@ void ScintillaEditor::enumerateColorSchemesInPath(ScintillaEditor::colorscheme_s
   }
 }
 
-ScintillaEditor::colorscheme_set_t ScintillaEditor::enumerateColorSchemes()
-{
+ScintillaEditor::colorscheme_set_t ScintillaEditor::enumerateColorSchemes() {
   colorscheme_set_t result_set;
 
   enumerateColorSchemesInPath(result_set, PlatformUtils::resourceBasePath());
@@ -697,8 +861,7 @@ ScintillaEditor::colorscheme_set_t ScintillaEditor::enumerateColorSchemes()
   return result_set;
 }
 
-QStringList ScintillaEditor::colorSchemes()
-{
+QStringList ScintillaEditor::colorSchemes() {
   QStringList colorSchemes;
   for (const auto& colorSchemeEntry : enumerateColorSchemes()) {
     colorSchemes << colorSchemeEntry.second.get()->name();
@@ -708,13 +871,11 @@ QStringList ScintillaEditor::colorSchemes()
   return colorSchemes;
 }
 
-bool ScintillaEditor::canUndo()
-{
+bool ScintillaEditor::canUndo() {
   return qsci->isUndoAvailable();
 }
 
-void ScintillaEditor::setHighlightScheme(const QString& name)
-{
+void ScintillaEditor::setHighlightScheme(const QString& name) {
   for (const auto& colorSchemeEntry : enumerateColorSchemes()) {
     const auto colorScheme = colorSchemeEntry.second.get();
     if (colorScheme->name() == name) {
@@ -726,82 +887,73 @@ void ScintillaEditor::setHighlightScheme(const QString& name)
   noColor();
 }
 
-void ScintillaEditor::insert(const QString& text)
-{
+void ScintillaEditor::insert(const QString& text) {
   qsci->insert(text);
 }
 
-void ScintillaEditor::setText(const QString& text)
-{
+void ScintillaEditor::setText(const QString& text) {
   qsci->selectAll(true);
   qsci->replaceSelectedText(text);
 }
 
-void ScintillaEditor::undo()
-{
+void ScintillaEditor::undo() {
   qsci->undo();
 }
 
-void ScintillaEditor::redo()
-{
+void ScintillaEditor::redo() {
   qsci->redo();
 }
 
-void ScintillaEditor::cut()
-{
+void ScintillaEditor::cut() {
   qsci->cut();
 }
 
-void ScintillaEditor::copy()
-{
+void ScintillaEditor::copy() {
   qsci->copy();
 }
 
-void ScintillaEditor::paste()
-{
+void ScintillaEditor::paste() {
   qsci->paste();
 }
 
-void ScintillaEditor::zoomIn()
-{
+void ScintillaEditor::zoomIn() {
   qsci->zoomIn();
 }
 
-void ScintillaEditor::zoomOut()
-{
+void ScintillaEditor::zoomOut() {
   qsci->zoomOut();
 }
 
-void ScintillaEditor::initFont(const QString& fontName, uint size)
-{
+void ScintillaEditor::initFont(const QString& fontName, uint size) {
   this->currentFont = QFont(fontName, size);
   this->currentFont.setFixedPitch(true);
   this->lexer->setFont(this->currentFont);
   qsci->setMarginsFont(this->currentFont);
-  onTextChanged(); // Update margin width
+  onTextChanged();  // Update margin width
 }
 
-void ScintillaEditor::initMargin()
-{
-  connect(qsci, &QsciScintilla::textChanged, this, &ScintillaEditor::onTextChanged);
+void ScintillaEditor::initMargin() {
+  connect(qsci, &QsciScintilla::textChanged, this,
+          &ScintillaEditor::onTextChanged);
 }
 
-void ScintillaEditor::onTextChanged()
-{
+void ScintillaEditor::onTextChanged() {
   auto enableLineNumbers = Settings::Settings::enableLineNumbers.value();
   if (enableLineNumbers) {
-    qsci->setMarginWidth(numberMargin, QString(trunc(log10(qsci->lines()) + 2), '0'));
+    qsci->setMarginWidth(numberMargin,
+                         QString(trunc(log10(qsci->lines()) + 2), '0'));
   } else {
     qsci->setMarginWidth(numberMargin, 6);
   }
   qsci->setMarginLineNumbers(numberMargin, enableLineNumbers);
 }
 
-int ScintillaEditor::updateFindIndicators(const QString& findText, bool visibility)
-{
+int ScintillaEditor::updateFindIndicators(const QString& findText,
+                                          bool visibility) {
   int findwordcount{0};
 
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, findIndicatorNumber);
+  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT,
+                      findIndicatorNumber);
   qsci->SendScintilla(qsci->SCI_INDICATORCLEARRANGE, 0, qsci->length());
 
   const auto txt = qsci->text().toUtf8();
@@ -819,8 +971,9 @@ int ScintillaEditor::updateFindIndicators(const QString& findText, bool visibili
   return findwordcount;
 }
 
-bool ScintillaEditor::find(const QString& expr, bool findNext, bool findBackwards)
-{
+bool ScintillaEditor::find(const QString& expr,
+                           bool findNext,
+                           bool findBackwards) {
   int startline = -1, startindex = -1;
 
   // If findNext, start from the end of the current selection
@@ -828,40 +981,41 @@ bool ScintillaEditor::find(const QString& expr, bool findNext, bool findBackward
     int lineFrom, indexFrom, lineTo, indexTo;
     qsci->getSelection(&lineFrom, &indexFrom, &lineTo, &indexTo);
 
-    startline = !(findBackwards xor findNext) ? std::min(lineFrom, lineTo) : std::max(lineFrom, lineTo);
-    startindex = !(findBackwards xor findNext) ? std::min(indexFrom, indexTo) : std::max(indexFrom, indexTo);
+    startline = !(findBackwards xor findNext) ? std::min(lineFrom, lineTo)
+                                              : std::max(lineFrom, lineTo);
+    startindex = !(findBackwards xor findNext) ? std::min(indexFrom, indexTo)
+                                               : std::max(indexFrom, indexTo);
   }
 
-  return qsci->findFirst(expr, false, false, false, true,
-                         !findBackwards, startline, startindex);
+  return qsci->findFirst(expr, false, false, false, true, !findBackwards,
+                         startline, startindex);
 }
 
-void ScintillaEditor::replaceSelectedText(const QString& newText)
-{
-  if ((qsci->selectedText() != newText)&&(qsci->hasSelectedText())) qsci->replaceSelectedText(newText);
+void ScintillaEditor::replaceSelectedText(const QString& newText) {
+  if ((qsci->selectedText() != newText) && (qsci->hasSelectedText()))
+    qsci->replaceSelectedText(newText);
 }
 
-void ScintillaEditor::replaceAll(const QString& findText, const QString& replaceText)
-{
+void ScintillaEditor::replaceAll(const QString& findText,
+                                 const QString& replaceText) {
   // We need to issue a Select All first due to a bug in QScintilla:
-  // It doesn't update the find range when just doing findFirst() + findNext() causing the search
-  // to end prematurely if the replaced string is larger than the selected string.
+  // It doesn't update the find range when just doing findFirst() + findNext()
+  // causing the search to end prematurely if the replaced string is larger than
+  // the selected string.
 #if QSCINTILLA_VERSION >= 0x020903
   // QScintilla bug seems to be fixed in 2.9.3
-  if (qsci->findFirst(findText,
-                      false /*re*/, false /*cs*/, false /*wo*/,
+  if (qsci->findFirst(findText, false /*re*/, false /*cs*/, false /*wo*/,
                       false /*wrap*/, true /*forward*/, 0, 0)) {
 #elif QSCINTILLA_VERSION >= 0x020700
   qsci->selectAll();
-  if (qsci->findFirstInSelection(findText,
-                                 false /*re*/, false /*cs*/, false /*wo*/,
-                                 false /*wrap*/, true /*forward*/)) {
+  if (qsci->findFirstInSelection(findText, false /*re*/, false /*cs*/,
+                                 false /*wo*/, false /*wrap*/,
+                                 true /*forward*/)) {
 #else
   // findFirstInSelection() was introduced in QScintilla 2.7
-  if (qsci->findFirst(findText,
-                      false /*re*/, false /*cs*/, false /*wo*/,
+  if (qsci->findFirst(findText, false /*re*/, false /*cs*/, false /*wo*/,
                       false /*wrap*/, true /*forward*/, 0, 0)) {
-#endif // if QSCINTILLA_VERSION >= 0x020903
+#endif  // if QSCINTILLA_VERSION >= 0x020903
     qsci->replace(replaceText);
     while (qsci->findNext()) {
       qsci->replace(replaceText);
@@ -869,9 +1023,7 @@ void ScintillaEditor::replaceAll(const QString& findText, const QString& replace
   }
 }
 
-
-void ScintillaEditor::getRange(int *lineFrom, int *lineTo)
-{
+void ScintillaEditor::getRange(int* lineFrom, int* lineTo) {
   int indexFrom, indexTo;
   if (qsci->hasSelectedText()) {
     qsci->getSelection(lineFrom, &indexFrom, lineTo, &indexTo);
@@ -884,20 +1036,25 @@ void ScintillaEditor::getRange(int *lineFrom, int *lineTo)
   }
 }
 
-void ScintillaEditor::indentSelection()
-{
+void ScintillaEditor::indentSelection() {
   int lineFrom, lineTo;
   qsci->beginUndoAction();
   getRange(&lineFrom, &lineTo);
   for (int line = lineFrom; line <= lineTo; ++line) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) == 0) {
+    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) -
+            qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) ==
+        0) {
       continue;
     }
     qsci->indent(line);
   }
   int nextLine = lineTo + 1;
-  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) == 0) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, nextLine) == 0) {
+  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) ==
+         0) {
+    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) -
+            qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE,
+                                nextLine) ==
+        0) {
       nextLine++;
       continue;
     }
@@ -907,20 +1064,25 @@ void ScintillaEditor::indentSelection()
   qsci->endUndoAction();
 }
 
-void ScintillaEditor::unindentSelection()
-{
+void ScintillaEditor::unindentSelection() {
   int lineFrom, lineTo;
   qsci->beginUndoAction();
   getRange(&lineFrom, &lineTo);
   for (int line = lineFrom; line <= lineTo; ++line) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) == 0) {
+    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) -
+            qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) ==
+        0) {
       continue;
     }
     qsci->unindent(line);
   }
   int nextLine = lineTo + 1;
-  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) == 0) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, nextLine) == 0) {
+  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) ==
+         0) {
+    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) -
+            qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE,
+                                nextLine) ==
+        0) {
       nextLine++;
       continue;
     }
@@ -930,8 +1092,7 @@ void ScintillaEditor::unindentSelection()
   qsci->endUndoAction();
 }
 
-void ScintillaEditor::commentSelection()
-{
+void ScintillaEditor::commentSelection() {
   auto hasSelection = qsci->hasSelectedText();
 
   int lineFrom, lineTo;
@@ -941,12 +1102,12 @@ void ScintillaEditor::commentSelection()
   }
 
   if (hasSelection) {
-    qsci->setSelection(lineFrom, 0, lineTo, std::max(0, qsci->lineLength(lineTo) - 1));
+    qsci->setSelection(lineFrom, 0, lineTo,
+                       std::max(0, qsci->lineLength(lineTo) - 1));
   }
 }
 
-void ScintillaEditor::uncommentSelection()
-{
+void ScintillaEditor::uncommentSelection() {
   auto hasSelection = qsci->hasSelectedText();
 
   int lineFrom, lineTo;
@@ -959,41 +1120,47 @@ void ScintillaEditor::uncommentSelection()
     }
   }
   if (hasSelection) {
-    qsci->setSelection(lineFrom, 0, lineTo, std::max(0, qsci->lineLength(lineTo) - 1));
+    qsci->setSelection(lineFrom, 0, lineTo,
+                       std::max(0, qsci->lineLength(lineTo) - 1));
   }
 }
 
-QString ScintillaEditor::selectedText()
-{
+QString ScintillaEditor::selectedText() {
   return qsci->selectedText();
 }
 
-bool ScintillaEditor::eventFilter(QObject *obj, QEvent *e)
-{
+bool ScintillaEditor::eventFilter(QObject* obj, QEvent* e) {
   if (e->type() == QEvent::KeyPress) {
-    auto keyEvent = static_cast<QKeyEvent *>(e);
+    auto keyEvent = static_cast<QKeyEvent*>(e);
     if (keyEvent->key() == Qt::Key_Escape) {
       emit escapePressed();
     }
   }
-  if (QGuiApplication::keyboardModifiers().testFlag(Qt::ControlModifier) || QGuiApplication::keyboardModifiers().testFlag(Qt::AltModifier)) {
+  if (QGuiApplication::keyboardModifiers().testFlag(Qt::ControlModifier) ||
+      QGuiApplication::keyboardModifiers().testFlag(Qt::AltModifier)) {
     if (!this->indicatorsActive) {
       this->indicatorsActive = true;
-      qsci->setIndicatorHoverStyle(QsciScintilla::PlainIndicator, hyperlinkIndicatorNumber);
+      qsci->setIndicatorHoverStyle(QsciScintilla::PlainIndicator,
+                                   hyperlinkIndicatorNumber);
     }
   } else {
     if (this->indicatorsActive) {
       this->indicatorsActive = false;
-      qsci->setIndicatorHoverStyle(QsciScintilla::HiddenIndicator, hyperlinkIndicatorNumber);
+      qsci->setIndicatorHoverStyle(QsciScintilla::HiddenIndicator,
+                                   hyperlinkIndicatorNumber);
     }
   }
 
-  bool enableNumberScrollWheel = Settings::Settings::enableNumberScrollWheel.value();
+  bool enableNumberScrollWheel =
+      Settings::Settings::enableNumberScrollWheel.value();
 
   if (obj == qsci->viewport() && enableNumberScrollWheel) {
     if (e->type() == QEvent::Wheel) {
-      auto *wheelEvent = static_cast<QWheelEvent *>(e);
-      PRINTDB("%s - modifier: %s", (e->type() == QEvent::Wheel?"Wheel Event":"") % (wheelEvent->modifiers() & Qt::AltModifier?"Alt":"Other Button"));
+      auto* wheelEvent = static_cast<QWheelEvent*>(e);
+      PRINTDB("%s - modifier: %s",
+              (e->type() == QEvent::Wheel ? "Wheel Event" : "") %
+                  (wheelEvent->modifiers() & Qt::AltModifier ? "Alt"
+                                                             : "Other Button"));
       if (handleWheelEventNavigateNumber(wheelEvent)) {
         qsci->SendScintilla(QsciScintilla::SCI_SETCARETWIDTH, 1);
         return true;
@@ -1002,16 +1169,19 @@ bool ScintillaEditor::eventFilter(QObject *obj, QEvent *e)
     return false;
   } else if (obj == qsci) {
     if (e->type() == QEvent::KeyPress || e->type() == QEvent::KeyRelease) {
-      auto *keyEvent = static_cast<QKeyEvent *>(e);
+      auto* keyEvent = static_cast<QKeyEvent*>(e);
 
-      PRINTDB("%10s - modifiers: %s %s %s %s %s %s",
-              (e->type() == QEvent::KeyPress ? "KeyPress" : "KeyRelease") %
+      PRINTDB(
+          "%10s - modifiers: %s %s %s %s %s %s",
+          (e->type() == QEvent::KeyPress ? "KeyPress" : "KeyRelease") %
               (keyEvent->modifiers() & Qt::ShiftModifier ? "SHIFT" : "shift") %
               (keyEvent->modifiers() & Qt::ControlModifier ? "CTRL" : "ctrl") %
               (keyEvent->modifiers() & Qt::AltModifier ? "ALT" : "alt") %
               (keyEvent->modifiers() & Qt::MetaModifier ? "META" : "meta") %
-              (keyEvent->modifiers() & Qt::KeypadModifier ? "KEYPAD" : "keypad") %
-              (keyEvent->modifiers() & Qt::GroupSwitchModifier ? "GROUP" : "group"));
+              (keyEvent->modifiers() & Qt::KeypadModifier ? "KEYPAD"
+                                                          : "keypad") %
+              (keyEvent->modifiers() & Qt::GroupSwitchModifier ? "GROUP"
+                                                               : "group"));
 
       if (handleKeyEventNavigateNumber(keyEvent)) {
         return true;
@@ -1024,13 +1194,13 @@ bool ScintillaEditor::eventFilter(QObject *obj, QEvent *e)
       }
     }
     return false;
-  } else return EditorInterface::eventFilter(obj, e);
+  } else
+    return EditorInterface::eventFilter(obj, e);
 
   return false;
 }
 
-bool ScintillaEditor::handleKeyEventBlockMove(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventBlockMove(QKeyEvent* keyEvent) {
   unsigned int modifiers = Qt::ControlModifier | Qt::GroupSwitchModifier;
 
   if (keyEvent->type() != QEvent::KeyRelease) {
@@ -1075,16 +1245,17 @@ bool ScintillaEditor::handleKeyEventBlockMove(QKeyEvent *keyEvent)
     textToMove.append('\n');
   }
   text.insert(up ? text.length() : 0, textToMove);
-  qsci->setSelection(std::min(lineToMove, lineFrom), 0, std::max(lineToMove, lineTo) + 1, 0);
+  qsci->setSelection(std::min(lineToMove, lineFrom), 0,
+                     std::max(lineToMove, lineTo) + 1, 0);
   qsci->replaceSelectedText(text);
   qsci->setCursorPosition(line + directionOffset, index);
-  qsci->setSelection(lineFrom + directionOffset, indexFrom, selectionLineTo + directionOffset, indexTo);
+  qsci->setSelection(lineFrom + directionOffset, indexFrom,
+                     selectionLineTo + directionOffset, indexTo);
   qsci->endUndoAction();
   return true;
 }
 
-bool ScintillaEditor::handleKeyEventBlockCopy(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventBlockCopy(QKeyEvent* keyEvent) {
   unsigned int modifiers = Qt::ControlModifier | Qt::ShiftModifier;
 
   if (keyEvent->type() != QEvent::KeyRelease) {
@@ -1133,49 +1304,52 @@ bool ScintillaEditor::handleKeyEventBlockCopy(QKeyEvent *keyEvent)
   return true;
 }
 
-bool ScintillaEditor::handleKeyEventNavigateNumber(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventNavigateNumber(QKeyEvent* keyEvent) {
   static bool previewAfterUndo = false;
 
 #ifdef Q_OS_MACOS
-  unsigned int navigateOnNumberModifiers = Qt::AltModifier | Qt::ShiftModifier | Qt::KeypadModifier;
+  unsigned int navigateOnNumberModifiers =
+      Qt::AltModifier | Qt::ShiftModifier | Qt::KeypadModifier;
 #else
   unsigned int navigateOnNumberModifiers = Qt::AltModifier;
 #endif
   if (keyEvent->modifiers() == navigateOnNumberModifiers) {
     switch (keyEvent->key()) {
-    case Qt::Key_Left:
-    case Qt::Key_Right:
-      if (keyEvent->type() == QEvent::KeyPress) {
-        navigateOnNumber(keyEvent->key());
-      }
-      return true;
+      case Qt::Key_Left:
+      case Qt::Key_Right:
+        if (keyEvent->type() == QEvent::KeyPress) {
+          navigateOnNumber(keyEvent->key());
+        }
+        return true;
 
-    case Qt::Key_Up:
-    case Qt::Key_Down:
-      if (keyEvent->type() == QEvent::KeyPress) {
-        if (modifyNumber(keyEvent->key())) {
-          previewAfterUndo = true;
+      case Qt::Key_Up:
+      case Qt::Key_Down:
+        if (keyEvent->type() == QEvent::KeyPress) {
+          if (modifyNumber(keyEvent->key())) {
+            previewAfterUndo = true;
+          }
         }
-      }
-      return true;
+        return true;
     }
   }
   if (previewAfterUndo && keyEvent->type() == QEvent::KeyPress) {
     int k = keyEvent->key() | keyEvent->modifiers();
-    auto *cmd = qsci->standardCommands()->boundTo(k);
-    if (cmd && (cmd->command() == QsciCommand::Undo || cmd->command() == QsciCommand::Redo)) QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
+    auto* cmd = qsci->standardCommands()->boundTo(k);
+    if (cmd && (cmd->command() == QsciCommand::Undo ||
+                cmd->command() == QsciCommand::Redo))
+      QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
     else if (cmd || !keyEvent->text().isEmpty()) {
-      // any insert or command (but not undo/redo) cancels the preview after undo
+      // any insert or command (but not undo/redo) cancels the preview after
+      // undo
       previewAfterUndo = false;
     }
   }
   return false;
 }
 
-bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
-{
-  const auto& modifierNumberScrollWheel = Settings::Settings::modifierNumberScrollWheel.value();
+bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent* wheelEvent) {
+  const auto& modifierNumberScrollWheel =
+      Settings::Settings::modifierNumberScrollWheel.value();
   bool modifier;
   static bool previewAfterUndo = false;
 
@@ -1184,13 +1358,14 @@ bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
   } else if (modifierNumberScrollWheel == "Left Mouse Button") {
     modifier = wheelEvent->buttons() & Qt::LeftButton;
   } else {
-    modifier = (wheelEvent->buttons() & Qt::LeftButton) | (wheelEvent->modifiers() & Qt::AltModifier);
+    modifier = (wheelEvent->buttons() & Qt::LeftButton) |
+               (wheelEvent->modifiers() & Qt::AltModifier);
   }
 
   if (modifier) {
     int delta = wheelEvent->angleDelta().y() != 0
-      ? wheelEvent->angleDelta().y()
-      : wheelEvent->angleDelta().x();
+                    ? wheelEvent->angleDelta().y()
+                    : wheelEvent->angleDelta().x();
 
     if (delta < 0) {
       if (modifyNumber(Qt::Key_Down)) {
@@ -1208,18 +1383,20 @@ bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
 
   if (previewAfterUndo) {
     int k = wheelEvent->buttons() & Qt::LeftButton;
-    auto *cmd = qsci->standardCommands()->boundTo(k);
-    if (cmd && (cmd->command() == QsciCommand::Undo || cmd->command() == QsciCommand::Redo)) QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
+    auto* cmd = qsci->standardCommands()->boundTo(k);
+    if (cmd && (cmd->command() == QsciCommand::Undo ||
+                cmd->command() == QsciCommand::Redo))
+      QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
     else if (cmd || wheelEvent->angleDelta().y()) {
-      // any insert or command (but not undo/redo) cancels the preview after undo
+      // any insert or command (but not undo/redo) cancels the preview after
+      // undo
       previewAfterUndo = false;
     }
   }
   return false;
 }
 
-void ScintillaEditor::navigateOnNumber(int key)
-{
+void ScintillaEditor::navigateOnNumber(int key) {
   int line, index;
   qsci->getCursorPosition(&line, &index);
   auto text = qsci->text(line);
@@ -1227,32 +1404,34 @@ void ScintillaEditor::navigateOnNumber(int key)
   auto dotOnLeft = left.contains(QRegularExpression("\\.\\d*$"));
   auto dotJustLeft = index > 1 && text[index - 2] == '.';
   auto dotJustRight = text[index] == '.';
-  auto numOnLeft = left.contains(QRegularExpression("\\d\\.?$")) || left.endsWith("-.");
+  auto numOnLeft =
+      left.contains(QRegularExpression("\\d\\.?$")) || left.endsWith("-.");
   auto numOnRight = text.indexOf(QRegularExpression("\\.?\\d"), index) == index;
 
   switch (key) {
-  case Qt::Key_Left:
-    if (numOnLeft) qsci->setCursorPosition(line, index - (dotJustLeft?2:1));
-    break;
-
-  case Qt::Key_Right:
-    if (numOnRight) qsci->setCursorPosition(line, index + (dotJustRight?2:1));
-    else if (numOnLeft) {
-      // add trailing zero
-      if (!dotOnLeft) {
-        qsci->insert(".0");
-        index++;
-      } else {
-        qsci->insert("0");
+    case Qt::Key_Left:
+      if (numOnLeft)
+        qsci->setCursorPosition(line, index - (dotJustLeft ? 2 : 1));
+      break;
+
+    case Qt::Key_Right:
+      if (numOnRight)
+        qsci->setCursorPosition(line, index + (dotJustRight ? 2 : 1));
+      else if (numOnLeft) {
+        // add trailing zero
+        if (!dotOnLeft) {
+          qsci->insert(".0");
+          index++;
+        } else {
+          qsci->insert("0");
+        }
+        qsci->setCursorPosition(line, index + 1);
       }
-      qsci->setCursorPosition(line, index + 1);
-    }
-    break;
+      break;
   }
 }
 
-bool ScintillaEditor::modifyNumber(int key)
-{
+bool ScintillaEditor::modifyNumber(int key) {
   int line, index;
   qsci->getCursorPosition(&line, &index);
   auto text = qsci->text(line);
@@ -1262,44 +1441,64 @@ bool ScintillaEditor::modifyNumber(int key)
   qsci->SendScintilla(QsciScintilla::SCI_SETEMPTYSELECTION);
   qsci->setCursorPosition(line, index);
 
-  auto begin = text.left(index).indexOf(QRegularExpression(R"([-+]?\d*\.?\d*$)"));
+  auto begin =
+      text.left(index).indexOf(QRegularExpression(R"([-+]?\d*\.?\d*$)"));
 
-  QRegularExpression rx(QRegularExpression::anchoredPattern(QString("[_a-zA-Z]")));
+  QRegularExpression rx(
+      QRegularExpression::anchoredPattern(QString("[_a-zA-Z]")));
   auto check = text.mid(begin - 1, 1);
-  if (rx.match(check).hasMatch()) return false;
+  if (rx.match(check).hasMatch())
+    return false;
 
   auto end = text.indexOf(QRegularExpression("[^0-9.]"), index);
-  if (end < 0) end = text.length();
+  if (end < 0)
+    end = text.length();
   auto nr = text.mid(begin, end - begin);
-  if (!(nr.contains(QRegularExpression(R"(^[-+]?\d*\.?\d+$)")) && nr.contains(QRegularExpression("\\d"))) ) return false;
-  auto sign = nr[0] == '+'||nr[0] == '-';
-  if (nr.endsWith('.')) nr = nr.left(nr.length() - 1);
+  if (!(nr.contains(QRegularExpression(R"(^[-+]?\d*\.?\d+$)")) &&
+        nr.contains(QRegularExpression("\\d"))))
+    return false;
+  auto sign = nr[0] == '+' || nr[0] == '-';
+  if (nr.endsWith('.'))
+    nr = nr.left(nr.length() - 1);
   auto curpos = index - begin;
-  if (curpos == 0 || (curpos == 1 && (nr[0] == '+' || nr[0] == '-'))) return false;
+  if (curpos == 0 || (curpos == 1 && (nr[0] == '+' || nr[0] == '-')))
+    return false;
   auto dotpos = nr.indexOf('.');
-  auto decimals = dotpos < 0?0:nr.length() - dotpos - 1;
-  auto number = (dotpos < 0)?nr.toLongLong():(nr.left(dotpos) + nr.mid(dotpos + 1)).toLongLong();
+  auto decimals = dotpos < 0 ? 0 : nr.length() - dotpos - 1;
+  auto number = (dotpos < 0)
+                    ? nr.toLongLong()
+                    : (nr.left(dotpos) + nr.mid(dotpos + 1)).toLongLong();
   auto tail = nr.length() - curpos;
-  auto exponent = tail - ((dotpos >= curpos)?1:0);
-  long long int step = GlobalPreferences::inst()->getValue("editor/stepSize").toInt();
-  for (int i = exponent; i > 0; i--) step *= 10;
+  auto exponent = tail - ((dotpos >= curpos) ? 1 : 0);
+  long long int step =
+      GlobalPreferences::inst()->getValue("editor/stepSize").toInt();
+  for (int i = exponent; i > 0; i--)
+    step *= 10;
 
   switch (key) {
-  case Qt::Key_Up:   number += step; break;
-  case Qt::Key_Down: number -= step; break;
+    case Qt::Key_Up:
+      number += step;
+      break;
+    case Qt::Key_Down:
+      number -= step;
+      break;
   }
   auto negative = number < 0;
-  if (negative) number = -number;
+  if (negative)
+    number = -number;
   auto newnr = QString::number(number);
   if (decimals) {
-    if (newnr.length() <= decimals) newnr.prepend(QString(decimals - newnr.length() + 1, '0'));
+    if (newnr.length() <= decimals)
+      newnr.prepend(QString(decimals - newnr.length() + 1, '0'));
     newnr = newnr.left(newnr.length() - decimals) + "." + newnr.right(decimals);
   }
   if (tail > newnr.length()) {
     newnr.prepend(QString(tail - newnr.length(), '0'));
   }
-  if (negative) newnr.prepend('-');
-  else if (sign) newnr.prepend('+');
+  if (negative)
+    newnr.prepend('-');
+  else if (sign)
+    newnr.prepend('+');
   qsci->beginUndoAction();
   qsci->setSelection(line, begin, line, end);
   qsci->replaceSelectedText(newnr);
@@ -1314,8 +1513,7 @@ bool ScintillaEditor::modifyNumber(int key)
   return true;
 }
 
-void ScintillaEditor::onUserListSelected(const int, const QString& text)
-{
+void ScintillaEditor::onUserListSelected(const int, const QString& text) {
   if (!templateMap.contains(text)) {
     return;
   }
@@ -1331,12 +1529,14 @@ void ScintillaEditor::onUserListSelected(const int, const QString& text)
   int cursor_offset = t.get_cursor_offset();
 
   if (cursor_offset < 0) {
-    if (tabReplace.size() != 0) content.replace("\t", tabReplace);
+    if (tabReplace.size() != 0)
+      content.replace("\t", tabReplace);
 
     cursor_offset = content.indexOf(ScintillaEditor::cursorPlaceHolder);
     content.remove(cursorPlaceHolder);
 
-    if (cursor_offset == -1) cursor_offset = content.size();
+    if (cursor_offset == -1)
+      cursor_offset = content.size();
   } else {
     if (tabReplace.size() != 0) {
       int tbCount = content.left(cursor_offset).count("\t");
@@ -1359,15 +1559,15 @@ void ScintillaEditor::onUserListSelected(const int, const QString& text)
 
   int lines = t.get_text().count("\n");
   QString indent_char = " ";
-  if (Settings::Settings::indentStyle.value() == "Tabs") indent_char = "\t";
+  if (Settings::Settings::indentStyle.value() == "Tabs")
+    indent_char = "\t";
 
   for (int a = 0; a < lines; ++a) {
     qsci->insertAt(indent_char.repeated(indent_width), indent_line + a + 1, 0);
   }
 }
 
-void ScintillaEditor::onAutocompleteChanged(bool state)
-{
+void ScintillaEditor::onAutocompleteChanged(bool state) {
   if (state) {
     qsci->setAutoCompletionSource(QsciScintilla::AcsAPIs);
     qsci->setAutoCompletionFillupsEnabled(true);
@@ -1380,109 +1580,131 @@ void ScintillaEditor::onAutocompleteChanged(bool state)
   }
 }
 
-void ScintillaEditor::onCharacterThresholdChanged(int val)
-{
+void ScintillaEditor::onCharacterThresholdChanged(int val) {
   qsci->setAutoCompletionThreshold(val <= 0 ? 1 : val);
 }
 
-void ScintillaEditor::resetHighlighting(){
-  qsci->recolor(); //lex and restyle the whole text
+void ScintillaEditor::resetHighlighting() {
+  qsci->recolor();  // lex and restyle the whole text
 
-  //remove all indicators
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
-  qsci->SendScintilla(QsciScintilla::SCI_INDICATORCLEARRANGE, 0, qsci->length());
+  // remove all indicators
+  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT,
+                      hyperlinkIndicatorNumber);
+  qsci->SendScintilla(QsciScintilla::SCI_INDICATORCLEARRANGE, 0,
+                      qsci->length());
 }
 
-void ScintillaEditor::setIndicator(const std::vector<IndicatorData>& indicatorData)
-{
+void ScintillaEditor::setIndicator(
+    const std::vector<IndicatorData>& indicatorData) {
   this->indicatorData = indicatorData;
 
   int idx = 0;
   for (const auto& data : indicatorData) {
-    int startPos = qsci->positionFromLineIndex(data.first_line - 1, data.first_col - 1);
-    int stopPos = qsci->positionFromLineIndex(data.last_line - 1, data.last_col - 1);
+    int startPos =
+        qsci->positionFromLineIndex(data.first_line - 1, data.first_col - 1);
+    int stopPos =
+        qsci->positionFromLineIndex(data.last_line - 1, data.last_col - 1);
 
     int nrOfChars = stopPos - startPos;
-    qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORVALUE, idx + hyperlinkIndicatorOffset);
+    qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORVALUE,
+                        idx + hyperlinkIndicatorOffset);
 
-    qsci->SendScintilla(QsciScintilla::SCI_INDICATORFILLRANGE, startPos, nrOfChars);
+    qsci->SendScintilla(QsciScintilla::SCI_INDICATORFILLRANGE, startPos,
+                        nrOfChars);
 
     idx++;
   }
 }
 
-void ScintillaEditor::onIndicatorClicked(int line, int col, Qt::KeyboardModifiers /*state*/)
-{
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
+void ScintillaEditor::onIndicatorClicked(int line,
+                                         int col,
+                                         Qt::KeyboardModifiers /*state*/) {
+  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT,
+                      hyperlinkIndicatorNumber);
 
   int pos = qsci->positionFromLineIndex(line, col);
-  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT, ScintillaEditor::hyperlinkIndicatorNumber, pos);
+  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT,
+                                ScintillaEditor::hyperlinkIndicatorNumber, pos);
 
   // checking if indicator clicked is hyperlinkIndicator
-  if (val >= hyperlinkIndicatorOffset && val <= hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
+  if (val >= hyperlinkIndicatorOffset &&
+      val <=
+          hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
     if (indicatorsActive) {
       emit hyperlinkIndicatorClicked(val - hyperlinkIndicatorOffset);
     }
   }
 }
 
-void ScintillaEditor::onIndicatorReleased(int line, int col, Qt::KeyboardModifiers /*state*/)
-{
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
+void ScintillaEditor::onIndicatorReleased(int line,
+                                          int col,
+                                          Qt::KeyboardModifiers /*state*/) {
+  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT,
+                      hyperlinkIndicatorNumber);
 
   int pos = qsci->positionFromLineIndex(line, col);
-  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT, ScintillaEditor::hyperlinkIndicatorNumber, pos);
+  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT,
+                                ScintillaEditor::hyperlinkIndicatorNumber, pos);
 
   // checking if indicator clicked is hyperlinkIndicator
-  if (val >= hyperlinkIndicatorOffset && val <= hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
+  if (val >= hyperlinkIndicatorOffset &&
+      val <=
+          hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
     if (!indicatorsActive) {
       QTimer::singleShot(0, this, [this] {
-        QToolTip::showText(QCursor::pos(), "Use <b>CTRL + Click</b> to open the file", this, rect(), toolTipDuration());
+        QToolTip::showText(QCursor::pos(),
+                           "Use <b>CTRL + Click</b> to open the file", this,
+                           rect(), toolTipDuration());
       });
     }
   }
 }
 
-void ScintillaEditor::setCursorPosition(int line, int col)
-{
+void ScintillaEditor::setCursorPosition(int line, int col) {
   qsci->ensureLineVisible(std::max(line - setCursorPositionVisibleLines, 0));
-  qsci->ensureLineVisible(std::min(line + setCursorPositionVisibleLines, qsci->lines() - 1));
+  qsci->ensureLineVisible(
+      std::min(line + setCursorPositionVisibleLines, qsci->lines() - 1));
 
   qsci->setCursorPosition(line, col);
 }
 
-void ScintillaEditor::updateSymbolMarginVisibility()
-{
-  if (qsci->markerFindNext(0, 1 << bmMarkerNumber | 1 << errMarkerNumber | 1 << selectionMarkerLevelNumber |
-                           1 << (selectionMarkerLevelNumber + 1) | 1 << (selectionMarkerLevelNumber + 2) |
-                           1 << (selectionMarkerLevelNumber + 3) | 1 << (selectionMarkerLevelNumber + 4) |
-                           1 << (selectionMarkerLevelNumber + 5)) < 0) {
+void ScintillaEditor::updateSymbolMarginVisibility() {
+  if (qsci->markerFindNext(0, 1 << bmMarkerNumber | 1 << errMarkerNumber |
+                                  1 << selectionMarkerLevelNumber |
+                                  1 << (selectionMarkerLevelNumber + 1) |
+                                  1 << (selectionMarkerLevelNumber + 2) |
+                                  1 << (selectionMarkerLevelNumber + 3) |
+                                  1 << (selectionMarkerLevelNumber + 4) |
+                                  1 << (selectionMarkerLevelNumber + 5)) < 0) {
     qsci->setMarginWidth(symbolMargin, 0);
   } else {
     qsci->setMarginWidth(symbolMargin, "0");
   }
 }
 
-void ScintillaEditor::toggleBookmark()
-{
+void ScintillaEditor::toggleBookmark() {
   int line, index;
   qsci->getCursorPosition(&line, &index);
 
   unsigned int state = qsci->markersAtLine(line);
 
-  if ((state & (1 << bmMarkerNumber)) == 0) qsci->markerAdd(line, bmMarkerNumber);
-  else qsci->markerDelete(line, bmMarkerNumber);
+  if ((state & (1 << bmMarkerNumber)) == 0)
+    qsci->markerAdd(line, bmMarkerNumber);
+  else
+    qsci->markerDelete(line, bmMarkerNumber);
 
   updateSymbolMarginVisibility();
 }
 
-void ScintillaEditor::findMarker(int findStartOffset, int wrapStart, const std::function<int(int)>& findMarkerFunc)
-{
+void ScintillaEditor::findMarker(
+    int findStartOffset,
+    int wrapStart,
+    const std::function<int(int)>& findMarkerFunc) {
   int line, index;
   qsci->getCursorPosition(&line, &index);
   line = findMarkerFunc(line + findStartOffset);
   if (line == -1) {
-    line = findMarkerFunc(wrapStart); // wrap around
+    line = findMarkerFunc(wrapStart);  // wrap around
   }
   if (line != -1) {
     // make sure we don't wrap into new line
@@ -1492,38 +1714,40 @@ void ScintillaEditor::findMarker(int findStartOffset, int wrapStart, const std::
   }
 }
 
-void ScintillaEditor::nextBookmark()
-{
-  findMarker(1, 0, [this](int line){
+void ScintillaEditor::nextBookmark() {
+  findMarker(1, 0, [this](int line) {
     return qsci->markerFindNext(line, 1 << bmMarkerNumber);
   });
 }
 
-void ScintillaEditor::prevBookmark()
-{
-  findMarker(-1, qsci->lines() - 1, [this](int line){
+void ScintillaEditor::prevBookmark() {
+  findMarker(-1, qsci->lines() - 1, [this](int line) {
     return qsci->markerFindPrevious(line, 1 << bmMarkerNumber);
   });
 }
 
-void ScintillaEditor::jumpToNextError()
-{
-  findMarker(1, 0, [this](int line){
+void ScintillaEditor::jumpToNextError() {
+  findMarker(1, 0, [this](int line) {
     return qsci->markerFindNext(line, 1 << errMarkerNumber);
   });
 }
 
-void ScintillaEditor::setFocus()
-{
+void ScintillaEditor::setFocus() {
   qsci->setFocus();
   qsci->SendScintilla(QsciScintilla::SCI_SETFOCUS, true);
 }
 
 /**
- * @brief Highlights a part of the text according to the limits described in the parameters
+ * @brief Highlights a part of the text according to the limits described in the
+ * parameters
  */
-void ScintillaEditor::setSelectionIndicatorStatus(EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom, int lineTo, int colTo)
-{
+void ScintillaEditor::setSelectionIndicatorStatus(
+    EditorSelectionIndicatorStatus status,
+    int level,
+    int lineFrom,
+    int colFrom,
+    int lineTo,
+    int colTo) {
   // replace all the indicators at given lines/column with the new one
   clearSelectionIndicators(lineFrom, colFrom, lineTo, colTo);
 
@@ -1532,19 +1756,22 @@ void ScintillaEditor::setSelectionIndicatorStatus(EditorSelectionIndicatorStatus
   int mark_level = 0;
   if (status == EditorSelectionIndicatorStatus::SELECTED) {
     indicator_base_index = selectionIndicatorIsActiveNumber;
-    mark_level = (level > 5)?5:level;
-    indicator_level = (level > 1)?1:level;
+    mark_level = (level > 5) ? 5 : level;
+    indicator_level = (level > 1) ? 1 : level;
   } else {
     indicator_base_index = selectionIndicatorIsImpactedNumber;
-    indicator_level = (level > 2)?2:level;
+    indicator_level = (level > 2) ? 2 : level;
   }
 
   clearSelectionIndicators(lineFrom, colFrom, lineTo, colTo);
-  qsci->fillIndicatorRange(lineFrom, colFrom, lineTo, colTo,  indicator_base_index + indicator_level);
+  qsci->fillIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                           indicator_base_index + indicator_level);
 
   if (status == EditorSelectionIndicatorStatus::SELECTED) {
-    qsci->ensureLineVisible(std::max(lineFrom - setCursorPositionVisibleLines, 0));
-    qsci->ensureLineVisible(std::min(lineFrom + setCursorPositionVisibleLines, qsci->lines() - 1));
+    qsci->ensureLineVisible(
+        std::max(lineFrom - setCursorPositionVisibleLines, 0));
+    qsci->ensureLineVisible(
+        std::min(lineFrom + setCursorPositionVisibleLines, qsci->lines() - 1));
 
     // replace the marker at provide line with a new one.
     qsci->markerDelete(lineFrom);
@@ -1557,8 +1784,7 @@ void ScintillaEditor::setSelectionIndicatorStatus(EditorSelectionIndicatorStatus
 /**
  * @brief Unhighlight all the selection indicators.
  */
-void ScintillaEditor::clearAllSelectionIndicators()
-{
+void ScintillaEditor::clearAllSelectionIndicators() {
   // remove all the indicator in the document.
   int line, column;
   qsci->lineIndexFromPosition(qsci->length(), &line, &column);
@@ -1576,12 +1802,19 @@ void ScintillaEditor::clearAllSelectionIndicators()
 /**
  * @brief Unhighlight all the texts for DM
  */
-void ScintillaEditor::clearSelectionIndicators(int lineFrom, int colFrom, int lineTo, int colTo)
-{
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber + 1);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber + 2);
-
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsActiveNumber);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsActiveNumber + 1);
+void ScintillaEditor::clearSelectionIndicators(int lineFrom,
+                                               int colFrom,
+                                               int lineTo,
+                                               int colTo) {
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsImpactedNumber);
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsImpactedNumber + 1);
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsImpactedNumber + 2);
+
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsActiveNumber);
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsActiveNumber + 1);
 }
diff --git a/src/gui/ScintillaEditor.h b/src/gui/ScintillaEditor.h
index 1dde96618..2011dcdac 100644
--- a/src/gui/ScintillaEditor.h
+++ b/src/gui/ScintillaEditor.h
@@ -2,22 +2,21 @@
 
 #include <QStringList>
 #include <filesystem>
-#include <map>
 #include <functional>
+#include <map>
 #include <memory>
 #include <string>
 #include <vector>
 
-#include <boost/property_tree/ptree.hpp>
 #include <boost/property_tree/json_parser.hpp>
+#include <boost/property_tree/ptree.hpp>
 
+#include <Qsci/qsciscintilla.h>
 #include <QMap>
 #include <QObject>
 #include <QString>
-#include <QWidget>
-#include <QVBoxLayout>
 #include <QVBoxLayout>
-#include <Qsci/qsciscintilla.h>
+#include <QWidget>
 
 #include "gui/Editor.h"
 #include "gui/ScadApi.h"
@@ -26,19 +25,17 @@
 class ScadLexer;
 class ScadLexer2;
 
-#define ENABLE_LEXERTL  1
-
+#define ENABLE_LEXERTL 1
 
-class EditorColorScheme
-{
-private:
+class EditorColorScheme {
+ private:
   const fs::path path;
 
   boost::property_tree::ptree pt;
   QString _name;
   int _index;
 
-public:
+ public:
   EditorColorScheme(const fs::path& path);
   virtual ~EditorColorScheme() = default;
 
@@ -48,22 +45,25 @@ public:
   const boost::property_tree::ptree& propertyTree() const;
 };
 
-class ScintillaEditor : public EditorInterface
-{
+class ScintillaEditor : public EditorInterface {
   Q_OBJECT;
 
-  using colorscheme_set_t = std::multimap<int, std::shared_ptr<EditorColorScheme>, std::less<>>;
+  using colorscheme_set_t =
+      std::multimap<int, std::shared_ptr<EditorColorScheme>, std::less<>>;
 
-public:
-  ScintillaEditor(QWidget *parent);
-  QsciScintilla *qsci;
+ public:
+  ScintillaEditor(QWidget* parent);
+  QsciScintilla* qsci;
   QString toPlainText() override;
   void initMargin();
   void initLexer();
 
   QString selectedText() override;
-  int updateFindIndicators(const QString& findText, bool visibility = true) override;
-  bool find(const QString&, bool findNext = false, bool findBackwards = false) override;
+  int updateFindIndicators(const QString& findText,
+                           bool visibility = true) override;
+  bool find(const QString&,
+            bool findNext = false,
+            bool findBackwards = false) override;
   void replaceSelectedText(const QString&) override;
   void replaceAll(const QString& findText, const QString& replaceText) override;
   QStringList colorSchemes() override;
@@ -71,54 +71,66 @@ public:
   void addTemplate() override;
   void resetHighlighting() override;
   void setIndicator(const std::vector<IndicatorData>& indicatorData) override;
-  QMenu *createStandardContextMenu() override;
+  QMenu* createStandardContextMenu() override;
   QPoint mapToGlobal(const QPoint&) override;
 
   void setCursorPosition(int line, int col) override;
-  void setSelectionIndicatorStatus(EditorSelectionIndicatorStatus satuts, int level, int lineFrom, int colFrom, int lineTo, int colTo) override;
+  void setSelectionIndicatorStatus(EditorSelectionIndicatorStatus satuts,
+                                   int level,
+                                   int lineFrom,
+                                   int colFrom,
+                                   int lineTo,
+                                   int colTo) override;
   void clearAllSelectionIndicators() override;
-  void clearSelectionIndicators(int lineFrom, int colFrom, int lineTo, int colTo);
+  void clearSelectionIndicators(int lineFrom,
+                                int colFrom,
+                                int lineTo,
+                                int colTo);
 
   void setFocus() override;
   void setupAutoComplete(const bool forceOff = false);
 
-private:
-  void getRange(int *lineFrom, int *lineTo);
-  void setColormap(const EditorColorScheme *colorScheme);
-  int readInt(const boost::property_tree::ptree& pt, const std::string& name,
+ private:
+  void getRange(int* lineFrom, int* lineTo);
+  void setColormap(const EditorColorScheme* colorScheme);
+  int readInt(const boost::property_tree::ptree& pt,
+              const std::string& name,
               const int defaultValue);
-  std::string readString(const boost::property_tree::ptree& pt, const std::string& name,
+  std::string readString(const boost::property_tree::ptree& pt,
+                         const std::string& name,
                          const std::string& defaultValue);
-  QColor readColor(const boost::property_tree::ptree& pt, const std::string& name,
+  QColor readColor(const boost::property_tree::ptree& pt,
+                   const std::string& name,
                    const QColor& defaultColor);
-  void enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& path);
+  void enumerateColorSchemesInPath(colorscheme_set_t& result_set,
+                                   const fs::path& path);
   colorscheme_set_t enumerateColorSchemes();
 
-  bool eventFilter(QObject *obj, QEvent *event) override;
-  bool handleKeyEventNavigateNumber(QKeyEvent *);
-  bool handleWheelEventNavigateNumber(QWheelEvent *);
-  bool handleKeyEventBlockCopy(QKeyEvent *);
-  bool handleKeyEventBlockMove(QKeyEvent *);
+  bool eventFilter(QObject* obj, QEvent* event) override;
+  bool handleKeyEventNavigateNumber(QKeyEvent*);
+  bool handleWheelEventNavigateNumber(QWheelEvent*);
+  bool handleKeyEventBlockCopy(QKeyEvent*);
+  bool handleKeyEventBlockMove(QKeyEvent*);
   void navigateOnNumber(int key);
   bool modifyNumber(int key);
   void noColor();
 
 #if ENABLE_LEXERTL
-  void setLexer(ScadLexer2 *lexer);
+  void setLexer(ScadLexer2* lexer);
 #else
-  void setLexer(ScadLexer *lexer);
+  void setLexer(ScadLexer* lexer);
 #endif
   void replaceSelectedText(QString&);
   void addTemplate(const fs::path& path);
   void updateSymbolMarginVisibility();
   void findMarker(int, int, const std::function<int(int)>&);
 
-signals:
+ signals:
   void previewRequest();
   void hyperlinkIndicatorClicked(int val);
   void uriDropped(const QUrl&);
 
-public slots:
+ public slots:
   void zoomIn() override;
   void zoomOut() override;
   void setPlainText(const QString&) override;
@@ -149,36 +161,39 @@ public slots:
   void onAutocompleteChanged(bool state);
   void onCharacterThresholdChanged(int val);
 
-private slots:
+ private slots:
   void onTextChanged();
   void onUserListSelected(const int id, const QString& text);
   void fireModificationChanged();
   void onIndicatorClicked(int line, int col, Qt::KeyboardModifiers state);
   void onIndicatorReleased(int line, int col, Qt::KeyboardModifiers state);
 
-private:
-  QVBoxLayout *scintillaLayout;
+ private:
+  QVBoxLayout* scintillaLayout;
   static const int symbolMargin = 1;
   static const int numberMargin = 0;
-  static const int errorIndicatorNumber = 8; // first 8 are used by lexers
+  static const int errorIndicatorNumber = 8;  // first 8 are used by lexers
   static const int findIndicatorNumber = 9;
   static const int hyperlinkIndicatorNumber = 10;
   static const int hyperlinkIndicatorOffset = 100;
   static const int errMarkerNumber = 2;
   static const int bmMarkerNumber = 3;
-  static const int selectionMarkerLevelNumber = 20; //20 - 25, there is at max 5 level of depth
-  static const int selectionIndicatorIsActiveNumber = 11; //Represents the active selected area text 11 - 12
-  static const int selectionIndicatorIsImpactedNumber = 14; //Represents the impacted selected area text 14-15-16
+  static const int selectionMarkerLevelNumber =
+      20;  // 20 - 25, there is at max 5 level of depth
+  static const int selectionIndicatorIsActiveNumber =
+      11;  // Represents the active selected area text 11 - 12
+  static const int selectionIndicatorIsImpactedNumber =
+      14;  // Represents the impacted selected area text 14-15-16
 
   bool indicatorsActive = false;
 
 #if ENABLE_LEXERTL
-  ScadLexer2 *lexer;
+  ScadLexer2* lexer;
 #else
-  ScadLexer *lexer;
+  ScadLexer* lexer;
 #endif
   QFont currentFont;
-  ScadApi *api;
+  ScadApi* api;
   QStringList userList;
   QMap<QString, ScadTemplate> templateMap;
   static const QString cursorPlaceHolder;
diff --git a/src/gui/SettingsWriter.cc b/src/gui/SettingsWriter.cc
index 4b7f3e9bd..086199183 100644
--- a/src/gui/SettingsWriter.cc
+++ b/src/gui/SettingsWriter.cc
@@ -38,7 +38,8 @@ void SettingsWriter::handle(Settings::SettingsEntryBase& entry) const {
     PRINTDB("SettingsWriter D: %s", key.c_str());
   } else {
     const auto encoded = entry.encode();
-    settings.setValue(QString::fromStdString(key), QString::fromStdString(encoded));
+    settings.setValue(QString::fromStdString(key),
+                      QString::fromStdString(encoded));
     PRINTDB("SettingsWriter W: %s = '%s'", key.c_str() % encoded.c_str());
   }
 }
diff --git a/src/gui/SettingsWriter.h b/src/gui/SettingsWriter.h
index 25e7e3d99..94715cdda 100644
--- a/src/gui/SettingsWriter.h
+++ b/src/gui/SettingsWriter.h
@@ -27,8 +27,7 @@
 
 #include "core/Settings.h"
 
-class SettingsWriter : public Settings::SettingsVisitor
-{
-public:
+class SettingsWriter : public Settings::SettingsVisitor {
+ public:
   void handle(Settings::SettingsEntryBase& entry) const override;
 };
diff --git a/src/gui/SparkleAutoUpdater.h b/src/gui/SparkleAutoUpdater.h
index 297621bdb..9addde71b 100644
--- a/src/gui/SparkleAutoUpdater.h
+++ b/src/gui/SparkleAutoUpdater.h
@@ -8,10 +8,10 @@
 
 #include "gui/AutoUpdater.h"
 
-class SparkleAutoUpdater : public AutoUpdater
-{
+class SparkleAutoUpdater : public AutoUpdater {
   Q_OBJECT;
-public:
+
+ public:
   SparkleAutoUpdater();
   ~SparkleAutoUpdater();
 
@@ -22,9 +22,9 @@ public:
   bool enableSnapshots();
   QString lastUpdateCheckDate();
 
-private:
+ private:
   void updateFeed();
 
   class Private;
-  Private *d;
+  Private* d;
 };
diff --git a/src/gui/TabManager.cc b/src/gui/TabManager.cc
index d262057ed..667d1ee3d 100644
--- a/src/gui/TabManager.cc
+++ b/src/gui/TabManager.cc
@@ -1,35 +1,34 @@
 #include "gui/TabManager.h"
 
+#include <Qsci/qscicommand.h>
+#include <Qsci/qscicommandset.h>
 #include <QApplication>
+#include <QClipboard>
+#include <QDesktopServices>
+#include <QDir>
+#include <QFile>
+#include <QFileDialog>
+#include <QFileInfo>
+#include <QMessageBox>
 #include <QPoint>
+#include <QSaveFile>
+#include <QShortcut>
 #include <QTabBar>
+#include <QTextStream>
 #include <QWidget>
 #include <cassert>
-#include <functional>
 #include <exception>
-#include <QFileInfo>
-#include <QFile>
-#include <QDir>
-#include <QSaveFile>
-#include <QShortcut>
-#include <QTextStream>
-#include <QMessageBox>
-#include <QFileDialog>
-#include <QClipboard>
-#include <QDesktopServices>
-#include <Qsci/qscicommand.h>
-#include <Qsci/qscicommandset.h>
+#include <functional>
 
 #include "gui/Editor.h"
 #include "gui/ImportUtils.h"
-#include "gui/ScintillaEditor.h"
-#include "gui/Preferences.h"
 #include "gui/MainWindow.h"
+#include "gui/Preferences.h"
+#include "gui/ScintillaEditor.h"
 
 #include <cstddef>
 
-TabManager::TabManager(MainWindow *o, const QString& filename)
-{
+TabManager::TabManager(MainWindow* o, const QString& filename) {
   par = o;
 
   tabWidget = new QTabWidget();
@@ -37,12 +36,17 @@ TabManager::TabManager(MainWindow *o, const QString& filename)
   tabWidget->setMovable(true);
   tabWidget->setContextMenuPolicy(Qt::CustomContextMenu);
 
-  connect(tabWidget, &QTabWidget::tabCloseRequested, this, &TabManager::closeTabRequested);
-  connect(tabWidget, &QTabWidget::customContextMenuRequested, this, &TabManager::showTabHeaderContextMenu);
+  connect(tabWidget, &QTabWidget::tabCloseRequested, this,
+          &TabManager::closeTabRequested);
+  connect(tabWidget, &QTabWidget::customContextMenuRequested, this,
+          &TabManager::showTabHeaderContextMenu);
 
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::stopAnimation);
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::updateFindState);
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::tabSwitched);
+  connect(tabWidget, &QTabWidget::currentChanged, this,
+          &TabManager::stopAnimation);
+  connect(tabWidget, &QTabWidget::currentChanged, this,
+          &TabManager::updateFindState);
+  connect(tabWidget, &QTabWidget::currentChanged, this,
+          &TabManager::tabSwitched);
 
   createTab(filename);
 
@@ -50,31 +54,30 @@ TabManager::TabManager(MainWindow *o, const QString& filename)
   setTabsCloseButtonVisibility(0, false);
 }
 
-QTabBar::ButtonPosition TabManager::getClosingButtonPosition()
-{
+QTabBar::ButtonPosition TabManager::getClosingButtonPosition() {
   auto bar = tabWidget->tabBar();
-  return (QTabBar::ButtonPosition)bar->style()->styleHint(QStyle::SH_TabBar_CloseButtonPosition, nullptr, bar);
+  return (QTabBar::ButtonPosition)bar->style()->styleHint(
+      QStyle::SH_TabBar_CloseButtonPosition, nullptr, bar);
 }
 
-void TabManager::setTabsCloseButtonVisibility(int indice, bool isVisible)
-{
+void TabManager::setTabsCloseButtonVisibility(int indice, bool isVisible) {
   // Depending on the system the closing button can be on the right or left side
   // of the tab header.
-  auto button = tabWidget->tabBar()->tabButton(indice, getClosingButtonPosition());
-  if (button) button->setVisible(isVisible);
+  auto button =
+      tabWidget->tabBar()->tabButton(indice, getClosingButtonPosition());
+  if (button)
+    button->setVisible(isVisible);
 }
 
-QWidget *TabManager::getTabContent()
-{
+QWidget* TabManager::getTabContent() {
   assert(tabWidget != nullptr);
   return tabWidget;
 }
 
-void TabManager::tabSwitched(int x)
-{
+void TabManager::tabSwitched(int x) {
   assert(tabWidget != nullptr);
 
-  editor = (EditorInterface *)tabWidget->widget(x);
+  editor = (EditorInterface*)tabWidget->widget(x);
 
   auto numberOfOpenTabs = tabWidget->count();
   // Hides all the closing button except the one on the currently focused editor
@@ -86,12 +89,12 @@ void TabManager::tabSwitched(int x)
   emit currentEditorChanged(editor);
 }
 
-void TabManager::closeTabRequested(int x)
-{
+void TabManager::closeTabRequested(int x) {
   assert(tabWidget != nullptr);
-  if (!maybeSave(x)) return;
+  if (!maybeSave(x))
+    return;
 
-  auto *closingEditor = qobject_cast<EditorInterface *>(tabWidget->widget(x));
+  auto* closingEditor = qobject_cast<EditorInterface*>(tabWidget->widget(x));
   assert(closingEditor != nullptr);
 
   emit editorAboutToClose(closingEditor);
@@ -104,99 +107,117 @@ void TabManager::closeTabRequested(int x)
   delete closingEditor;
 }
 
-void TabManager::closeCurrentTab()
-{
+void TabManager::closeCurrentTab() {
   assert(tabWidget != nullptr);
 
   /* Close tab or close the current window if only one tab is open. */
-  if (tabWidget->count() > 1) this->closeTabRequested(tabWidget->currentIndex());
-  else par->close();
+  if (tabWidget->count() > 1)
+    this->closeTabRequested(tabWidget->currentIndex());
+  else
+    par->close();
 }
 
-void TabManager::nextTab()
-{
+void TabManager::nextTab() {
   assert(tabWidget != nullptr);
-  tabWidget->setCurrentIndex((tabWidget->currentIndex() + 1) % tabWidget->count());
+  tabWidget->setCurrentIndex((tabWidget->currentIndex() + 1) %
+                             tabWidget->count());
 }
 
-void TabManager::prevTab()
-{
+void TabManager::prevTab() {
   assert(tabWidget != nullptr);
-  tabWidget->setCurrentIndex((tabWidget->currentIndex() + tabWidget->count() - 1) % tabWidget->count());
+  tabWidget->setCurrentIndex(
+      (tabWidget->currentIndex() + tabWidget->count() - 1) %
+      tabWidget->count());
 }
 
-void TabManager::actionNew()
-{
-  if (!par->editorDock->isVisible()) par->editorDock->setVisible(true);   //if editor hidden, make it visible
+void TabManager::actionNew() {
+  if (!par->editorDock->isVisible())
+    par->editorDock->setVisible(true);  // if editor hidden, make it visible
   createTab("");
 }
 
-void TabManager::open(const QString& filename)
-{
+void TabManager::open(const QString& filename) {
   assert(!filename.isEmpty());
 
-  for (auto edt: editorList) {
+  for (auto edt : editorList) {
     if (filename == edt->filepath) {
       tabWidget->setCurrentWidget(edt);
       return;
     }
   }
 
-  if (editor->filepath.isEmpty() && !editor->isContentModified() && !editor->parameterWidget->isModified()) {
+  if (editor->filepath.isEmpty() && !editor->isContentModified() &&
+      !editor->parameterWidget->isModified()) {
     openTabFile(filename);
   } else {
     createTab(filename);
   }
 }
 
-void TabManager::createTab(const QString& filename)
-{
+void TabManager::createTab(const QString& filename) {
   assert(par != nullptr);
 
   auto scintillaEditor = new ScintillaEditor(tabWidget);
   editor = scintillaEditor;
   par->activeEditor = editor;
   editor->parameterWidget = new ParameterWidget(par->parameterDock);
-  connect(editor->parameterWidget, &ParameterWidget::parametersChanged, par, &MainWindow::actionRenderPreview);
+  connect(editor->parameterWidget, &ParameterWidget::parametersChanged, par,
+          &MainWindow::actionRenderPreview);
   par->parameterDock->setWidget(editor->parameterWidget);
 
   // clearing default mapping of keyboard shortcut for font size
-  QsciCommandSet *qcmdset = scintillaEditor->qsci->standardCommands();
-  QsciCommand *qcmd = qcmdset->boundTo(Qt::ControlModifier | Qt::Key_Plus);
+  QsciCommandSet* qcmdset = scintillaEditor->qsci->standardCommands();
+  QsciCommand* qcmd = qcmdset->boundTo(Qt::ControlModifier | Qt::Key_Plus);
   qcmd->setKey(0);
   qcmd = qcmdset->boundTo(Qt::ControlModifier | Qt::Key_Minus);
   qcmd->setKey(0);
 
-  connect(scintillaEditor, &ScintillaEditor::uriDropped, par, &MainWindow::handleFileDrop);
-  connect(scintillaEditor, &ScintillaEditor::previewRequest, par, &MainWindow::actionRenderPreview);
-  connect(editor, &EditorInterface::showContextMenuEvent, this, &TabManager::showContextMenuEvent);
-  connect(editor, &EditorInterface::focusIn, this, [ this ]() {
-    par->setLastFocus(editor);
-  });
-
-  connect(GlobalPreferences::inst(), &Preferences::editorConfigChanged, scintillaEditor, &ScintillaEditor::applySettings);
-  connect(GlobalPreferences::inst(), &Preferences::autocompleteChanged, scintillaEditor, &ScintillaEditor::onAutocompleteChanged);
-  connect(GlobalPreferences::inst(), &Preferences::characterThresholdChanged, scintillaEditor, &ScintillaEditor::onCharacterThresholdChanged);
+  connect(scintillaEditor, &ScintillaEditor::uriDropped, par,
+          &MainWindow::handleFileDrop);
+  connect(scintillaEditor, &ScintillaEditor::previewRequest, par,
+          &MainWindow::actionRenderPreview);
+  connect(editor, &EditorInterface::showContextMenuEvent, this,
+          &TabManager::showContextMenuEvent);
+  connect(editor, &EditorInterface::focusIn, this,
+          [this]() { par->setLastFocus(editor); });
+
+  connect(GlobalPreferences::inst(), &Preferences::editorConfigChanged,
+          scintillaEditor, &ScintillaEditor::applySettings);
+  connect(GlobalPreferences::inst(), &Preferences::autocompleteChanged,
+          scintillaEditor, &ScintillaEditor::onAutocompleteChanged);
+  connect(GlobalPreferences::inst(), &Preferences::characterThresholdChanged,
+          scintillaEditor, &ScintillaEditor::onCharacterThresholdChanged);
   scintillaEditor->applySettings();
   editor->addTemplate();
 
-  connect(par->editActionZoomTextIn, &QAction::triggered, editor, &EditorInterface::zoomIn);
-  connect(par->editActionZoomTextOut, &QAction::triggered, editor, &EditorInterface::zoomOut);
-
-  connect(editor, &EditorInterface::contentsChanged, this, &TabManager::updateActionUndoState);
-  connect(editor, &EditorInterface::contentsChanged, par,  &MainWindow::editorContentChanged);
-  connect(editor, &EditorInterface::contentsChanged, this, &TabManager::setContentRenderState);
-  connect(editor, &EditorInterface::modificationChanged, this, &TabManager::onTabModified);
-  connect(editor->parameterWidget, &ParameterWidget::modificationChanged, [editor = this->editor, this] {
-    onTabModified(editor);
-  });
-
-  connect(GlobalPreferences::inst(), &Preferences::fontChanged, editor, &EditorInterface::initFont);
-  connect(GlobalPreferences::inst(), &Preferences::syntaxHighlightChanged, editor, &EditorInterface::setHighlightScheme);
-  editor->initFont(GlobalPreferences::inst()->getValue("editor/fontfamily").toString(), GlobalPreferences::inst()->getValue("editor/fontsize").toUInt());
-  editor->setHighlightScheme(GlobalPreferences::inst()->getValue("editor/syntaxhighlight").toString());
-
-  connect(scintillaEditor, &ScintillaEditor::hyperlinkIndicatorClicked, this, &TabManager::onHyperlinkIndicatorClicked);
+  connect(par->editActionZoomTextIn, &QAction::triggered, editor,
+          &EditorInterface::zoomIn);
+  connect(par->editActionZoomTextOut, &QAction::triggered, editor,
+          &EditorInterface::zoomOut);
+
+  connect(editor, &EditorInterface::contentsChanged, this,
+          &TabManager::updateActionUndoState);
+  connect(editor, &EditorInterface::contentsChanged, par,
+          &MainWindow::editorContentChanged);
+  connect(editor, &EditorInterface::contentsChanged, this,
+          &TabManager::setContentRenderState);
+  connect(editor, &EditorInterface::modificationChanged, this,
+          &TabManager::onTabModified);
+  connect(editor->parameterWidget, &ParameterWidget::modificationChanged,
+          [editor = this->editor, this] { onTabModified(editor); });
+
+  connect(GlobalPreferences::inst(), &Preferences::fontChanged, editor,
+          &EditorInterface::initFont);
+  connect(GlobalPreferences::inst(), &Preferences::syntaxHighlightChanged,
+          editor, &EditorInterface::setHighlightScheme);
+  editor->initFont(
+      GlobalPreferences::inst()->getValue("editor/fontfamily").toString(),
+      GlobalPreferences::inst()->getValue("editor/fontsize").toUInt());
+  editor->setHighlightScheme(
+      GlobalPreferences::inst()->getValue("editor/syntaxhighlight").toString());
+
+  connect(scintillaEditor, &ScintillaEditor::hyperlinkIndicatorClicked, this,
+          &TabManager::onHyperlinkIndicatorClicked);
 
   // Fill the editor with the content of the file
   if (filename.isEmpty()) {
@@ -215,105 +236,88 @@ void TabManager::createTab(const QString& filename)
   emit tabCountChanged(editorList.size());
 }
 
-size_t TabManager::count()
-{
+size_t TabManager::count() {
   return tabWidget->count();
 }
 
-void TabManager::highlightError(int i)
-{
+void TabManager::highlightError(int i) {
   editor->highlightError(i);
 }
 
-void TabManager::unhighlightLastError()
-{
+void TabManager::unhighlightLastError() {
   editor->unhighlightLastError();
 }
 
-void TabManager::undo()
-{
+void TabManager::undo() {
   editor->undo();
 }
 
-void TabManager::redo()
-{
+void TabManager::redo() {
   editor->redo();
 }
 
-void TabManager::cut()
-{
+void TabManager::cut() {
   editor->cut();
 }
 
-void TabManager::copy()
-{
+void TabManager::copy() {
   editor->copy();
 }
 
-void TabManager::paste()
-{
+void TabManager::paste() {
   editor->paste();
 }
 
-void TabManager::indentSelection()
-{
+void TabManager::indentSelection() {
   editor->indentSelection();
 }
 
-void TabManager::unindentSelection()
-{
+void TabManager::unindentSelection() {
   editor->unindentSelection();
 }
 
-void TabManager::commentSelection()
-{
+void TabManager::commentSelection() {
   editor->commentSelection();
 }
 
-void TabManager::uncommentSelection()
-{
+void TabManager::uncommentSelection() {
   editor->uncommentSelection();
 }
 
-void TabManager::toggleBookmark()
-{
+void TabManager::toggleBookmark() {
   editor->toggleBookmark();
 }
 
-void TabManager::nextBookmark()
-{
+void TabManager::nextBookmark() {
   editor->nextBookmark();
 }
 
-void TabManager::prevBookmark()
-{
+void TabManager::prevBookmark() {
   editor->prevBookmark();
 }
 
-void TabManager::jumpToNextError()
-{
+void TabManager::jumpToNextError() {
   editor->jumpToNextError();
 }
 
-void TabManager::setFocus()
-{
+void TabManager::setFocus() {
   editor->setFocus();
 }
 
-void TabManager::updateActionUndoState()
-{
+void TabManager::updateActionUndoState() {
   par->editActionUndo->setEnabled(editor->canUndo());
 }
 
-void TabManager::onHyperlinkIndicatorClicked(int val)
-{
-  const QString filename = QString::fromStdString(editor->indicatorData[val].path);
+void TabManager::onHyperlinkIndicatorClicked(int val) {
+  const QString filename =
+      QString::fromStdString(editor->indicatorData[val].path);
   this->open(filename);
 }
 
-void TabManager::applyAction(QObject *object, const std::function<void(int, EditorInterface *)>& func)
-{
-  auto *action = dynamic_cast<QAction *>(object);
+void TabManager::applyAction(
+    QObject* object,
+    const std::function<void(int, EditorInterface*)>& func) {
+  auto* action = dynamic_cast<QAction*>(object);
   if (action == nullptr) {
     return;
   }
@@ -323,7 +327,7 @@ void TabManager::applyAction(QObject *object, const std::function<void(int, Edit
     return;
   }
 
-  auto *edt = (EditorInterface *)tabWidget->widget(idx);
+  auto* edt = (EditorInterface*)tabWidget->widget(idx);
   if (edt == nullptr) {
     return;
   }
@@ -331,25 +335,22 @@ void TabManager::applyAction(QObject *object, const std::function<void(int, Edit
   func(idx, edt);
 }
 
-void TabManager::copyFileName()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
-    QClipboard *clipboard = QApplication::clipboard();
+void TabManager::copyFileName() {
+  applyAction(QObject::sender(), [](int, EditorInterface* edt) {
+    QClipboard* clipboard = QApplication::clipboard();
     clipboard->setText(QFileInfo(edt->filepath).fileName());
   });
 }
 
-void TabManager::copyFilePath()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
-    QClipboard *clipboard = QApplication::clipboard();
+void TabManager::copyFilePath() {
+  applyAction(QObject::sender(), [](int, EditorInterface* edt) {
+    QClipboard* clipboard = QApplication::clipboard();
     clipboard->setText(edt->filepath);
   });
 }
 
-void TabManager::openFolder()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
+void TabManager::openFolder() {
+  applyAction(QObject::sender(), [](int, EditorInterface* edt) {
     auto dir = QFileInfo(edt->filepath).dir();
     if (dir.exists()) {
       QDesktopServices::openUrl(QUrl::fromLocalFile(dir.absolutePath()));
@@ -357,15 +358,12 @@ void TabManager::openFolder()
   });
 }
 
-void TabManager::closeTab()
-{
-  applyAction(QObject::sender(), [this](int idx, EditorInterface *){
-    closeTabRequested(idx);
-  });
+void TabManager::closeTab() {
+  applyAction(QObject::sender(),
+              [this](int idx, EditorInterface*) { closeTabRequested(idx); });
 }
 
-void TabManager::showContextMenuEvent(const QPoint& pos)
-{
+void TabManager::showContextMenuEvent(const QPoint& pos) {
   auto menu = editor->createStandardContextMenu();
 
   menu->addSeparator();
@@ -380,39 +378,42 @@ void TabManager::showContextMenuEvent(const QPoint& pos)
   delete menu;
 }
 
-void TabManager::showTabHeaderContextMenu(const QPoint& pos)
-{
+void TabManager::showTabHeaderContextMenu(const QPoint& pos) {
   int idx = tabWidget->tabBar()->tabAt(pos);
-  if (idx < 0) return;
+  if (idx < 0)
+    return;
 
   QMenu menu;
-  auto *edt = (EditorInterface *)tabWidget->widget(idx);
+  auto* edt = (EditorInterface*)tabWidget->widget(idx);
 
-  auto *copyFileNameAction = new QAction(tabWidget);
+  auto* copyFileNameAction = new QAction(tabWidget);
   copyFileNameAction->setData(idx);
   copyFileNameAction->setEnabled(!edt->filepath.isEmpty());
   copyFileNameAction->setText(_("Copy file name"));
-  connect(copyFileNameAction, &QAction::triggered, this, &TabManager::copyFileName);
+  connect(copyFileNameAction, &QAction::triggered, this,
+          &TabManager::copyFileName);
 
-  auto *copyFilePathAction = new QAction(tabWidget);
+  auto* copyFilePathAction = new QAction(tabWidget);
   copyFilePathAction->setData(idx);
   copyFilePathAction->setEnabled(!edt->filepath.isEmpty());
   copyFilePathAction->setText(_("Copy full path"));
-  connect(copyFilePathAction, &QAction::triggered, this, &TabManager::copyFilePath);
+  connect(copyFilePathAction, &QAction::triggered, this,
+          &TabManager::copyFilePath);
 
-  auto *openFolderAction = new QAction(tabWidget);
+  auto* openFolderAction = new QAction(tabWidget);
   openFolderAction->setData(idx);
   openFolderAction->setEnabled(!edt->filepath.isEmpty());
   openFolderAction->setText(_("Open Folder"));
   connect(openFolderAction, &QAction::triggered, this, &TabManager::openFolder);
 
-  auto *closeAction = new QAction(tabWidget);
+  auto* closeAction = new QAction(tabWidget);
   closeAction->setData(idx);
   closeAction->setText(_("Close Tab"));
   connect(closeAction, &QAction::triggered, this, &TabManager::closeTab);
 
   // Don't allow to close the last tab.
-  if (tabWidget->count() <= 1) closeAction->setDisabled(true);
+  if (tabWidget->count() <= 1)
+    closeAction->setDisabled(true);
 
   menu.addAction(copyFileNameAction);
   menu.addAction(copyFilePathAction);
@@ -425,27 +426,27 @@ void TabManager::showTabHeaderContextMenu(const QPoint& pos)
   menu.exec(globalCursorPos);
 }
 
-void TabManager::setContentRenderState() //since last render
+void TabManager::setContentRenderState()  // since last render
 {
-  editor->contentsRendered = false;   //since last render
+  editor->contentsRendered = false;  // since last render
   editor->parameterWidget->setEnabled(false);
 }
 
-void TabManager::stopAnimation()
-{
+void TabManager::stopAnimation() {
   par->animateWidget->pauseAnimation();
   par->animateWidget->e_tval->setText("");
 }
 
-void TabManager::updateFindState()
-{
-  if (editor->findState == TabManager::FIND_REPLACE_VISIBLE) par->showFind(true);
-  else if (editor->findState == TabManager::FIND_VISIBLE) par->showFind(false);
-  else par->hideFind();
+void TabManager::updateFindState() {
+  if (editor->findState == TabManager::FIND_REPLACE_VISIBLE)
+    par->showFind(true);
+  else if (editor->findState == TabManager::FIND_VISIBLE)
+    par->showFind(false);
+  else
+    par->hideFind();
 }
 
-void TabManager::onTabModified(EditorInterface *edt)
-{
+void TabManager::onTabModified(EditorInterface* edt) {
   // Get the name of the editor and its filepath with the status modifier
   auto [fname, fpath] = getEditorTabNameWithModifier(edt);
 
@@ -453,19 +454,19 @@ void TabManager::onTabModified(EditorInterface *edt)
   setEditorTabName(fname, fpath, edt);
 }
 
-void TabManager::openTabFile(const QString& filename)
-{
+void TabManager::openTabFile(const QString& filename) {
 #ifdef ENABLE_PYTHON
   if (boost::algorithm::ends_with(filename, ".py")) {
     std::string templ = "from openscad import *\n";
   } else
 #endif
-  editor->setPlainText("");
+    editor->setPlainText("");
 
   QFileInfo fileinfo(filename);
   const auto suffix = fileinfo.suffix().toLower();
   const auto knownFileType = Importer::knownFileExtensions.contains(suffix);
-  if (!knownFileType)return;
+  if (!knownFileType)
+    return;
 
   const auto cmd = Importer::knownFileExtensions[suffix];
   if (cmd.isEmpty()) {
@@ -485,8 +486,8 @@ void TabManager::openTabFile(const QString& filename)
   emit editorContentReloaded(editor);
 }
 
-std::tuple<QString, QString> TabManager::getEditorTabName(EditorInterface *edt)
-{
+std::tuple<QString, QString> TabManager::getEditorTabName(
+    EditorInterface* edt) {
   QString fname = edt->filepath;
   QString fpath = edt->filepath;
   QFileInfo fileinfo(edt->filepath);
@@ -500,35 +501,35 @@ std::tuple<QString, QString> TabManager::getEditorTabName(EditorInterface *edt)
   return {fname, fpath};
 }
 
-std::tuple<QString, QString> TabManager::getEditorTabNameWithModifier(EditorInterface *edt)
-{
+std::tuple<QString, QString> TabManager::getEditorTabNameWithModifier(
+    EditorInterface* edt) {
   auto [fname, fpath] = getEditorTabName(edt);
 
   // Add the "modification" star if it was changed.
-  bool isDirty = edt->isContentModified()
-    || edt->parameterWidget->isModified();
+  bool isDirty = edt->isContentModified() || edt->parameterWidget->isModified();
 
-  if (isDirty) fname += "*";
+  if (isDirty)
+    fname += "*";
 
   return {fname, fpath};
 }
 
-void TabManager::setEditorTabName(const QString& tabName, const QString& tabToolTip,
-                                  EditorInterface *edt)
-{
+void TabManager::setEditorTabName(const QString& tabName,
+                                  const QString& tabToolTip,
+                                  EditorInterface* edt) {
   int index = tabWidget->indexOf(edt);
   tabWidget->setTabText(index, QString(tabName).replace("&", "&&"));
   tabWidget->setTabToolTip(index, tabToolTip);
 }
 
-bool TabManager::refreshDocument()
-{
+bool TabManager::refreshDocument() {
   bool file_opened = false;
   if (!editor->filepath.isEmpty()) {
     QFile file(editor->filepath);
     if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
       LOG("Failed to open file %1$s: %2$s",
-          editor->filepath.toLocal8Bit().constData(), file.errorString().toLocal8Bit().constData());
+          editor->filepath.toLocal8Bit().constData(),
+          file.errorString().toLocal8Bit().constData());
     } else {
       QTextStream reader(&file);
 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
@@ -538,7 +539,7 @@ bool TabManager::refreshDocument()
       LOG("Loaded design '%1$s'.", editor->filepath.toLocal8Bit().constData());
       if (editor->toPlainText() != text) {
         editor->setPlainText(text);
-        setContentRenderState();         // since last render
+        setContentRenderState();  // since last render
       }
       file_opened = true;
     }
@@ -546,14 +547,14 @@ bool TabManager::refreshDocument()
   return file_opened;
 }
 
-bool TabManager::maybeSave(int x)
-{
-  auto *edt = (EditorInterface *) tabWidget->widget(x);
+bool TabManager::maybeSave(int x) {
+  auto* edt = (EditorInterface*)tabWidget->widget(x);
   if (edt->isContentModified() || edt->parameterWidget->isModified()) {
     QMessageBox box(par);
     box.setText(_("The document has been modified."));
     box.setInformativeText(_("Do you want to save your changes?"));
-    box.setStandardButtons(QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);
+    box.setStandardButtons(QMessageBox::Save | QMessageBox::Discard |
+                           QMessageBox::Cancel);
     box.setDefaultButton(QMessageBox::Save);
     box.setIcon(QMessageBox::Warning);
     box.setWindowModality(Qt::ApplicationModal);
@@ -562,7 +563,7 @@ bool TabManager::maybeSave(int x)
     box.button(QMessageBox::Discard)->setShortcut(QKeySequence("Ctrl+D"));
     box.button(QMessageBox::Discard)->setShortcutEnabled(true);
 #endif
-    auto ret = (QMessageBox::StandardButton) box.exec();
+    auto ret = (QMessageBox::StandardButton)box.exec();
 
     if (ret == QMessageBox::Save) {
       return save(edt);
@@ -577,15 +578,16 @@ bool TabManager::maybeSave(int x)
  * Called for whole window close, returning false will abort the close
  * operation.
  */
-bool TabManager::shouldClose()
-{
-  foreach(EditorInterface * edt, editorList) {
-    if (!(edt->isContentModified() || edt->parameterWidget->isModified())) continue;
+bool TabManager::shouldClose() {
+  foreach (EditorInterface* edt, editorList) {
+    if (!(edt->isContentModified() || edt->parameterWidget->isModified()))
+      continue;
 
     QMessageBox box(par);
     box.setText(_("Some tabs have unsaved changes."));
     box.setInformativeText(_("Do you want to save all your changes?"));
-    box.setStandardButtons(QMessageBox::SaveAll | QMessageBox::Discard | QMessageBox::Cancel);
+    box.setStandardButtons(QMessageBox::SaveAll | QMessageBox::Discard |
+                           QMessageBox::Cancel);
     box.setDefaultButton(QMessageBox::SaveAll);
     box.setIcon(QMessageBox::Warning);
     box.setWindowModality(Qt::ApplicationModal);
@@ -594,7 +596,7 @@ bool TabManager::shouldClose()
     box.button(QMessageBox::Discard)->setShortcut(QKeySequence("Ctrl+D"));
     box.button(QMessageBox::Discard)->setShortcutEnabled(true);
 #endif
-    auto ret = (QMessageBox::StandardButton) box.exec();
+    auto ret = (QMessageBox::StandardButton)box.exec();
 
     if (ret == QMessageBox::Cancel) {
       return false;
@@ -607,14 +609,17 @@ bool TabManager::shouldClose()
   return true;
 }
 
-void TabManager::saveError(const QIODevice& file, const std::string& msg, const QString& filepath)
-{
+void TabManager::saveError(const QIODevice& file,
+                           const std::string& msg,
+                           const QString& filepath) {
   const std::string fileName = filepath.toStdString();
-  LOG("%1$s %2$s (%3$s)", msg.c_str(), fileName, file.errorString().toStdString());
+  LOG("%1$s %2$s (%3$s)", msg.c_str(), fileName,
+      file.errorString().toStdString());
 
   const std::string dialogFormatStr = msg + "\n\"%1\"\n(%2)";
   const QString dialogFormat(dialogFormatStr.c_str());
-  QMessageBox::warning(par, par->windowTitle(), dialogFormat.arg(filepath).arg(file.errorString()));
+  QMessageBox::warning(par, par->windowTitle(),
+                       dialogFormat.arg(filepath).arg(file.errorString()));
 }
 
 /*!
@@ -622,8 +627,7 @@ void TabManager::saveError(const QIODevice& file, const std::string& msg, const
  * Should _always_ write to disk, since this is called by SaveAs - i.e. don't
  * try to be smart and check for document modification here.
  */
-bool TabManager::save(EditorInterface *edt)
-{
+bool TabManager::save(EditorInterface* edt) {
   assert(edt != nullptr);
 
   if (edt->filepath.isEmpty()) {
@@ -633,8 +637,7 @@ bool TabManager::save(EditorInterface *edt)
   }
 }
 
-bool TabManager::save(EditorInterface *edt, const QString& path)
-{
+bool TabManager::save(EditorInterface* edt, const QString& path) {
   par->setCurrentOutput();
 
   // If available (>= Qt 5.1), use QSaveFile to ensure the file is not
@@ -644,7 +647,8 @@ bool TabManager::save(EditorInterface *edt, const QString& path)
   // Checking the QTextStream status flag after flush() seems to catch
   // this condition.
   QSaveFile file(path);
-  if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text)) {
+  if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate |
+                 QIODevice::Text)) {
     saveError(file, _("Failed to open file for writing"), path);
     return false;
   }
@@ -674,12 +678,12 @@ bool TabManager::save(EditorInterface *edt, const QString& path)
   return saveOk;
 }
 
-bool TabManager::saveAs(EditorInterface *edt)
-{
+bool TabManager::saveAs(EditorInterface* edt) {
   assert(edt != nullptr);
 
   const auto dir = edt->filepath.isEmpty() ? _("Untitled.scad") : edt->filepath;
-  auto filename = QFileDialog::getSaveFileName(par, _("Save File"), dir, _("OpenSCAD Designs (*.scad)"));
+  auto filename = QFileDialog::getSaveFileName(par, _("Save File"), dir,
+                                               _("OpenSCAD Designs (*.scad)"));
   if (filename.isEmpty()) {
     return false;
   }
@@ -691,8 +695,12 @@ bool TabManager::saveAs(EditorInterface *edt)
     // defaultSuffix property
     const QFileInfo info(filename);
     if (info.exists()) {
-      const auto text = QString(_("%1 already exists.\nDo you want to replace it?")).arg(info.fileName());
-      if (QMessageBox::warning(par, par->windowTitle(), text, QMessageBox::Yes | QMessageBox::No, QMessageBox::No) != QMessageBox::Yes) {
+      const auto text =
+          QString(_("%1 already exists.\nDo you want to replace it?"))
+              .arg(info.fileName());
+      if (QMessageBox::warning(par, par->windowTitle(), text,
+                               QMessageBox::Yes | QMessageBox::No,
+                               QMessageBox::No) != QMessageBox::Yes) {
         return false;
       }
     }
@@ -701,8 +709,7 @@ bool TabManager::saveAs(EditorInterface *edt)
   return saveAs(edt, filename);
 }
 
-bool TabManager::saveAs(EditorInterface *edt, const QString& filepath)
-{
+bool TabManager::saveAs(EditorInterface* edt, const QString& filepath) {
   bool saveOk = save(edt, filepath);
   if (saveOk) {
     auto [fname, fpath] = getEditorTabNameWithModifier(edt);
@@ -712,12 +719,12 @@ bool TabManager::saveAs(EditorInterface *edt, const QString& filepath)
   return saveOk;
 }
 
-bool TabManager::saveACopy(EditorInterface *edt)
-{
+bool TabManager::saveACopy(EditorInterface* edt) {
   assert(edt != nullptr);
 
   const auto dir = edt->filepath.isEmpty() ? _("Untitled.scad") : edt->filepath;
-  auto filename = QFileDialog::getSaveFileName(par, _("Save a Copy"), dir, _("OpenSCAD Designs (*.scad)"));
+  auto filename = QFileDialog::getSaveFileName(par, _("Save a Copy"), dir,
+                                               _("OpenSCAD Designs (*.scad)"));
   if (filename.isEmpty()) {
     return false;
   }
@@ -729,9 +736,8 @@ bool TabManager::saveACopy(EditorInterface *edt)
   return save(edt, filename);
 }
 
-bool TabManager::saveAll()
-{
-  foreach(EditorInterface * edt, editorList) {
+bool TabManager::saveAll() {
+  foreach (EditorInterface* edt, editorList) {
     if (edt->isContentModified() || edt->parameterWidget->isModified()) {
       if (!save(edt)) {
         return false;
diff --git a/src/gui/TabManager.h b/src/gui/TabManager.h
index 3447829b7..bb11a33e3 100644
--- a/src/gui/TabManager.h
+++ b/src/gui/TabManager.h
@@ -1,23 +1,22 @@
 #pragma once
 
+#include <QObject>
+#include <QSet>
 #include <cstddef>
 #include <functional>
 #include <string>
-#include <QObject>
-#include <QSet>
 #include "gui/Editor.h"
 
-class MainWindow; // for circular dependency
+class MainWindow;  // for circular dependency
 
-class TabManager : public QObject
-{
+class TabManager : public QObject {
   Q_OBJECT
 
-public:
-  TabManager(MainWindow *o, const QString& filename);
-  QWidget *getTabContent();
-  EditorInterface *editor;
-  QSet<EditorInterface *> editorList;
+ public:
+  TabManager(MainWindow* o, const QString& filename);
+  QWidget* getTabContent();
+  EditorInterface* editor;
+  QSet<EditorInterface*> editorList;
 
   void createTab(const QString& filename);
   void openTabFile(const QString& filename);
@@ -25,54 +24,58 @@ public:
   // returns the name and tooltip of the tab for the given provided editor
   // if there is a path associated with an editor this is the filepath
   // otherwise Untitled.scad
-  std::tuple<QString, QString> getEditorTabName(EditorInterface *edt);
+  std::tuple<QString, QString> getEditorTabName(EditorInterface* edt);
 
   // returns the name and tooltip of the tab for the given provided editor with
   // the extra symbols used to indicate the file has changed.
-  std::tuple<QString, QString> getEditorTabNameWithModifier(EditorInterface *edt);
+  std::tuple<QString, QString> getEditorTabNameWithModifier(
+      EditorInterface* edt);
 
   void setEditorTabName(const QString& tabName,
                         const QString& tabTooltip,
-                        EditorInterface *edt = nullptr);
-  bool refreshDocument(); // returns false if the file could not be opened
+                        EditorInterface* edt = nullptr);
+  bool refreshDocument();  // returns false if the file could not be opened
   bool shouldClose();
-  bool save(EditorInterface *edt);
-  bool saveAs(EditorInterface *edt);
-  bool saveAs(EditorInterface *edt, const QString& filepath);
-  bool saveACopy(EditorInterface *edt);
+  bool save(EditorInterface* edt);
+  bool saveAs(EditorInterface* edt);
+  bool saveAs(EditorInterface* edt, const QString& filepath);
+  bool saveACopy(EditorInterface* edt);
   void open(const QString& filename);
   size_t count();
 
-public:
+ public:
   static constexpr const int FIND_HIDDEN = 0;
   static constexpr const int FIND_VISIBLE = 1;
   static constexpr const int FIND_REPLACE_VISIBLE = 2;
 
-signals:
-  // emitted when the currently displayed editor is changed and a new one is one focus.
-  // the passed parameter can be nullptr, when the editor changed because of closing of the last
-  // opened on.
-  void currentEditorChanged(EditorInterface *editor);
-  void editorAboutToClose(EditorInterface *editor);
+ signals:
+  // emitted when the currently displayed editor is changed and a new one is one
+  // focus. the passed parameter can be nullptr, when the editor changed because
+  // of closing of the last opened on.
+  void currentEditorChanged(EditorInterface* editor);
+  void editorAboutToClose(EditorInterface* editor);
 
   void tabCountChanged(int);
 
   // emitted when the content of an editor is reloaded
-  void editorContentReloaded(EditorInterface *editor);
+  void editorContentReloaded(EditorInterface* editor);
 
-private:
-  MainWindow *par;
-  QTabWidget *tabWidget;
+ private:
+  MainWindow* par;
+  QTabWidget* tabWidget;
 
   bool maybeSave(int);
-  bool save(EditorInterface *edt, const QString& path);
-  void saveError(const QIODevice& file, const std::string& msg, const QString& filepath);
-  void applyAction(QObject *object, const std::function<void(int, EditorInterface *)>& func);
+  bool save(EditorInterface* edt, const QString& path);
+  void saveError(const QIODevice& file,
+                 const std::string& msg,
+                 const QString& filepath);
+  void applyAction(QObject* object,
+                   const std::function<void(int, EditorInterface*)>& func);
   void setTabsCloseButtonVisibility(int tabIndice, bool isVisible);
 
   QTabBar::ButtonPosition getClosingButtonPosition();
 
-private slots:
+ private slots:
   void tabSwitched(int);
   void closeTabRequested(int);
   void updateActionUndoState();
@@ -89,11 +92,11 @@ private slots:
 
   void onHyperlinkIndicatorClicked(int pos);
 
-public slots:
+ public slots:
   void actionNew();
   void copy();
-  void setContentRenderState(); // since last render
-  void onTabModified(EditorInterface *);
+  void setContentRenderState();  // since last render
+  void onTabModified(EditorInterface*);
   bool saveAll();
   void closeCurrentTab();
   void nextTab();
diff --git a/src/gui/UIUtils.cc b/src/gui/UIUtils.cc
index e9fa41827..cca4492de 100644
--- a/src/gui/UIUtils.cc
+++ b/src/gui/UIUtils.cc
@@ -26,25 +26,25 @@
 
 #include "gui/UIUtils.h"
 
-#include <filesystem>
-#include <QString>
-#include <QStringList>
-#include <QWidget>
-#include <exception>
+#include <QDesktopServices>
 #include <QDir>
-#include <QList>
+#include <QFileDialog>
 #include <QFileInfo>
 #include <QFileInfoList>
-#include <QUrl>
-#include <QFileDialog>
-#include <QDesktopServices>
-#include <QRegularExpression>
-#include <QJsonObject>
 #include <QJsonDocument>
+#include <QJsonObject>
+#include <QList>
+#include <QRegularExpression>
+#include <QString>
+#include <QStringList>
+#include <QUrl>
+#include <QWidget>
+#include <exception>
+#include <filesystem>
 
-#include "version.h"
-#include "platform/PlatformUtils.h"
 #include "gui/QSettingsCached.h"
+#include "platform/PlatformUtils.h"
+#include "version.h"
 
 #include <cstdlib>
 #include <filesystem>
@@ -52,8 +52,7 @@
 
 namespace {
 
-QString fileOpenFilter(const QString& pattern, QStringList extensions)
-{
+QString fileOpenFilter(const QString& pattern, QStringList extensions) {
   if (extensions.isEmpty()) {
     extensions << "scad" << "csg";
 #ifdef ENABLE_PYTHON
@@ -67,8 +66,7 @@ QString fileOpenFilter(const QString& pattern, QStringList extensions)
 QList<UIUtils::ExampleCategory> _exampleCategories;
 QMap<QString, QList<UIUtils::ExampleEntry>> _examples;
 
-bool hasCategory(const QString& name)
-{
+bool hasCategory(const QString& name) {
   for (const auto& category : _exampleCategories) {
     if (category.name == name) {
       return true;
@@ -77,9 +75,9 @@ bool hasCategory(const QString& name)
   return false;
 }
 
-void readExamplesDir(const QJsonObject& obj, const fs::path& dir)
-{
-  QString name = obj["name"].toString(QString::fromStdString(dir.filename().generic_string()));
+void readExamplesDir(const QJsonObject& obj, const fs::path& dir) {
+  QString name = obj["name"].toString(
+      QString::fromStdString(dir.filename().generic_string()));
 
   if (!hasCategory(name)) {
     _exampleCategories.append(UIUtils::ExampleCategory{
@@ -99,16 +97,14 @@ void readExamplesDir(const QJsonObject& obj, const fs::path& dir)
     }
     examples.append(UIUtils::ExampleEntry{
         .name = QString::fromStdString(path.filename().generic_string()),
-        .fileInfo = QFileInfo(QString::fromStdString(path.generic_string()))
-      });
+        .fileInfo = QFileInfo(QString::fromStdString(path.generic_string()))});
   }
-  std::sort(examples.begin(), examples.end(), [](const UIUtils::ExampleEntry& e1, const UIUtils::ExampleEntry& e2) -> bool {
-      return e1.name < e2.name;
-    });
+  std::sort(examples.begin(), examples.end(),
+            [](const UIUtils::ExampleEntry& e1, const UIUtils::ExampleEntry& e2)
+                -> bool { return e1.name < e2.name; });
 }
 
-void enumerateExamples(const fs::path& dir)
-{
+void enumerateExamples(const fs::path& dir) {
   if (!fs::is_directory(dir)) {
     return;
   }
@@ -116,7 +112,9 @@ void enumerateExamples(const fs::path& dir)
     if (!entry.is_directory()) {
       continue;
     }
-    auto fileInfo = QFileInfo{QDir{QString::fromStdString(entry.path().generic_string())}, "example-dir.json"};
+    auto fileInfo =
+        QFileInfo{QDir{QString::fromStdString(entry.path().generic_string())},
+                  "example-dir.json"};
     QJsonObject obj;
     if (fileInfo.isReadable()) {
       QFile file;
@@ -126,13 +124,14 @@ void enumerateExamples(const fs::path& dir)
     }
     readExamplesDir(obj, entry.path());
   }
-  std::sort(_exampleCategories.begin(), _exampleCategories.end(), [](const UIUtils::ExampleCategory& c1, const UIUtils::ExampleCategory& c2) -> bool {
-      return c2.sort > c1.sort;
-    });
+  std::sort(_exampleCategories.begin(), _exampleCategories.end(),
+            [](const UIUtils::ExampleCategory& c1,
+               const UIUtils::ExampleCategory& c2) -> bool {
+              return c2.sort > c1.sort;
+            });
 }
 
-const QList<UIUtils::ExampleCategory>& readExamples()
-{
+const QList<UIUtils::ExampleCategory>& readExamples() {
   if (_exampleCategories.empty()) {
     enumerateExamples(fs::path{PlatformUtils::resourceBasePath()} / "examples");
     enumerateExamples(PlatformUtils::userExamplesPath());
@@ -140,15 +139,15 @@ const QList<UIUtils::ExampleCategory>& readExamples()
   return _exampleCategories;
 }
 
-} // namespace
+}  // namespace
 
-QFileInfo UIUtils::openFile(QWidget *parent, QStringList extensions)
-{
+QFileInfo UIUtils::openFile(QWidget* parent, QStringList extensions) {
   QSettingsCached settings;
   const auto last_dirname = settings.value("lastOpenDirName").toString();
-  const auto filter = fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
-  const auto filename = QFileDialog::getOpenFileName(parent, "Open File",
-                                                     last_dirname, filter);
+  const auto filter =
+      fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
+  const auto filename =
+      QFileDialog::getOpenFileName(parent, "Open File", last_dirname, filter);
 
   if (filename.isEmpty()) {
     return {};
@@ -159,16 +158,16 @@ QFileInfo UIUtils::openFile(QWidget *parent, QStringList extensions)
   return fileInfo;
 }
 
-QFileInfoList UIUtils::openFiles(QWidget *parent, QStringList extensions)
-{
+QFileInfoList UIUtils::openFiles(QWidget* parent, QStringList extensions) {
   QSettingsCached settings;
   const auto last_dirname = settings.value("lastOpenDirName").toString();
-  const auto filter = fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
-  const auto filenames = QFileDialog::getOpenFileNames(parent, "Open File",
-                                                       last_dirname, filter);
+  const auto filter =
+      fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
+  const auto filenames =
+      QFileDialog::getOpenFileNames(parent, "Open File", last_dirname, filter);
 
   QFileInfoList fileInfoList;
-  for (const QString& filename: filenames) {
+  for (const QString& filename : filenames) {
     if (filename.isEmpty()) {
       continue;
     }
@@ -183,9 +182,8 @@ QFileInfoList UIUtils::openFiles(QWidget *parent, QStringList extensions)
   return fileInfoList;
 }
 
-QStringList UIUtils::recentFiles()
-{
-  QSettingsCached settings; // set up project and program properly in main.cpp
+QStringList UIUtils::recentFiles() {
+  QSettingsCached settings;  // set up project and program properly in main.cpp
   QStringList files = settings.value("recentFileList").toStringList();
 
   // Remove any duplicate or empty entries from the list
@@ -194,7 +192,8 @@ QStringList UIUtils::recentFiles()
   // Now remove any entries which do not exist
   for (int i = files.size() - 1; i >= 0; --i) {
     QFileInfo fileInfo(files[i]);
-    if (!QFile(fileInfo.absoluteFilePath()).exists()) files.removeAt(i);
+    if (!QFile(fileInfo.absoluteFilePath()).exists())
+      files.removeAt(i);
   }
 
   while (files.size() > UIUtils::maxRecentFiles) {
@@ -205,13 +204,11 @@ QStringList UIUtils::recentFiles()
   return files;
 }
 
-const QList<UIUtils::ExampleCategory>& UIUtils::exampleCategories()
-{
+const QList<UIUtils::ExampleCategory>& UIUtils::exampleCategories() {
   return readExamples();
 }
 
-QFileInfoList UIUtils::exampleFiles(const QString& category)
-{
+QFileInfoList UIUtils::exampleFiles(const QString& category) {
   QFileInfoList examples;
   if (!_examples.contains(category)) {
     return examples;
@@ -222,35 +219,30 @@ QFileInfoList UIUtils::exampleFiles(const QString& category)
   return examples;
 }
 
-void UIUtils::openURL(const QString& url)
-{
+void UIUtils::openURL(const QString& url) {
   QDesktopServices::openUrl(QUrl(url));
 }
 
-void UIUtils::openHomepageURL()
-{
+void UIUtils::openHomepageURL() {
   QDesktopServices::openUrl(QUrl("https://www.openscad.org/"));
 }
 
-static void openVersionedURL(const QString& url)
-{
+static void openVersionedURL(const QString& url) {
   QDesktopServices::openUrl(QUrl(url.arg(openscad_shortversionnumber.c_str())));
 }
 
-void UIUtils::openUserManualURL()
-{
+void UIUtils::openUserManualURL() {
   openVersionedURL("https://www.openscad.org/documentation.html?version=%1");
 }
 
-fs::path UIUtils::returnOfflineUserManualPath()
-{
+fs::path UIUtils::returnOfflineUserManualPath() {
   fs::path resPath = PlatformUtils::resourcePath("resources");
-  fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" / "OpenSCAD_User_Manual.html";
+  fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" /
+                      "OpenSCAD_User_Manual.html";
   return fullPath;
 }
 
-bool UIUtils::hasOfflineUserManual()
-{
+bool UIUtils::hasOfflineUserManual() {
   fs::path fullPath = returnOfflineUserManualPath();
   if (fs::exists(fullPath) && fs::is_regular_file(fullPath)) {
     return true;
@@ -258,8 +250,7 @@ bool UIUtils::hasOfflineUserManual()
   return false;
 }
 
-void UIUtils::openOfflineUserManual()
-{
+void UIUtils::openOfflineUserManual() {
   fs::path fullPath = returnOfflineUserManualPath();
   if (UIUtils::hasOfflineUserManual()) {
     QString docPath = QString::fromStdString(fullPath.string());
@@ -267,24 +258,23 @@ void UIUtils::openOfflineUserManual()
   }
 }
 
-void UIUtils::openCheatSheetURL()
-{
+void UIUtils::openCheatSheetURL() {
 #ifdef OPENSCAD_SNAPSHOT
-  openVersionedURL("https://www.openscad.org/cheatsheet/snapshot.html?version=%1");
+  openVersionedURL(
+      "https://www.openscad.org/cheatsheet/snapshot.html?version=%1");
 #else
   openVersionedURL("https://www.openscad.org/cheatsheet/index.html?version=%1");
 #endif
 }
 
-fs::path UIUtils::returnOfflineCheatSheetPath()
-{
+fs::path UIUtils::returnOfflineCheatSheetPath() {
   fs::path resPath = PlatformUtils::resourcePath("resources");
-  fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" / "CheatSheet.html";
+  fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" /
+                      "CheatSheet.html";
   return fullPath;
 }
 
-bool UIUtils::hasOfflineCheatSheet()
-{
+bool UIUtils::hasOfflineCheatSheet() {
   fs::path fullPath = returnOfflineCheatSheetPath();
   if (fs::exists(fullPath) && fs::is_regular_file(fullPath)) {
     return true;
@@ -292,8 +282,7 @@ bool UIUtils::hasOfflineCheatSheet()
   return false;
 }
 
-void UIUtils::openOfflineCheatSheet()
-{
+void UIUtils::openOfflineCheatSheet() {
   fs::path fullPath = returnOfflineCheatSheetPath();
   if (UIUtils::hasOfflineCheatSheet()) {
     QString docPath = QString::fromStdString(fullPath.string());
@@ -301,16 +290,18 @@ void UIUtils::openOfflineCheatSheet()
   }
 }
 
-QString UIUtils::getBackgroundColorStyleSheet(const QColor& color)
-{
+QString UIUtils::getBackgroundColorStyleSheet(const QColor& color) {
   return QString("background-color:%1;").arg(color.toRgb().name());
 }
 
-QString UIUtils::blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend, float transparency)
-{
+QString UIUtils::blendForBackgroundColorStyleSheet(const QColor& input,
+                                                   const QColor& blend,
+                                                   float transparency) {
   const auto result = QColor(
-    255.0 * (transparency * blend.redF() + (1 - transparency) * input.redF()),
-    255.0 * (transparency * blend.greenF() + (1 - transparency) * input.greenF()),
-    255.0 * (transparency * blend.blueF() + (1 - transparency) * input.blueF()));
+      255.0 * (transparency * blend.redF() + (1 - transparency) * input.redF()),
+      255.0 *
+          (transparency * blend.greenF() + (1 - transparency) * input.greenF()),
+      255.0 *
+          (transparency * blend.blueF() + (1 - transparency) * input.blueF()));
   return getBackgroundColorStyleSheet(result);
 }
diff --git a/src/gui/UIUtils.h b/src/gui/UIUtils.h
index bb59eba5a..5ca308beb 100644
--- a/src/gui/UIUtils.h
+++ b/src/gui/UIUtils.h
@@ -26,18 +26,17 @@
 #pragma once
 
 #include <QColor>
+#include <QFileInfoList>
 #include <QString>
-#include <QWidget>
 #include <QStringList>
-#include <QFileInfoList>
+#include <QWidget>
 #include <filesystem>
 
 namespace fs = std::filesystem;
 
 namespace UIUtils {
 
-struct ExampleCategory
-{
+struct ExampleCategory {
   constexpr static int DEFAULT_SORT = 10000;
 
   int sort = DEFAULT_SORT;
@@ -45,8 +44,7 @@ struct ExampleCategory
   QString tooltip;
 };
 
-struct ExampleEntry
-{
+struct ExampleEntry {
   constexpr static int DEFAULT_SORT = 10000;
 
   int sort = DEFAULT_SORT;
@@ -56,9 +54,9 @@ struct ExampleEntry
 
 static const int maxRecentFiles = 10;
 
-QFileInfo openFile(QWidget *parent = nullptr, QStringList extensions = {});
+QFileInfo openFile(QWidget* parent = nullptr, QStringList extensions = {});
 
-QFileInfoList openFiles(QWidget *parent = nullptr, QStringList extensions = {});
+QFileInfoList openFiles(QWidget* parent = nullptr, QStringList extensions = {});
 
 QStringList recentFiles();
 
@@ -88,6 +86,8 @@ void openOfflineCheatSheet();
 
 QString getBackgroundColorStyleSheet(const QColor& color);
 
-QString blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend, float transparency = 0.2);
+QString blendForBackgroundColorStyleSheet(const QColor& input,
+                                          const QColor& blend,
+                                          float transparency = 0.2);
 
-} // namespace UIUtils
+}  // namespace UIUtils
diff --git a/src/gui/ViewportControl.cc b/src/gui/ViewportControl.cc
index b985b31c2..094427a78 100644
--- a/src/gui/ViewportControl.cc
+++ b/src/gui/ViewportControl.cc
@@ -1,76 +1,80 @@
 #include "gui/ViewportControl.h"
 #include <QBoxLayout>
+#include <QDoubleSpinBox>
 #include <QGridLayout>
 #include <QLayoutItem>
 #include <QObject>
 #include <QResizeEvent>
 #include <QString>
 #include <QWidget>
-#include <iostream>
-#include <filesystem>
 #include <cfloat>
-#include <QDoubleSpinBox>
+#include <filesystem>
+#include <iostream>
 
-#include "utils/printutils.h"
 #include "gui/MainWindow.h"
 #include "gui/QGLView.h"
 #include "openscad_gui.h"
+#include "utils/printutils.h"
 
-ViewportControl::ViewportControl(QWidget *parent) : QWidget(parent)
-{
+ViewportControl::ViewportControl(QWidget* parent) : QWidget(parent) {
   setupUi(this);
   initGUI();
   const auto width = scrollAreaWidgetContents->minimumSizeHint().width();
   const auto margins = layout()->contentsMargins();
-  const auto scrollMargins = scrollAreaWidgetContents->layout()->contentsMargins();
-  initMinWidth = width + margins.left() + margins.right() + scrollMargins.left() + scrollMargins.right();
+  const auto scrollMargins =
+      scrollAreaWidgetContents->layout()->contentsMargins();
+  initMinWidth = width + margins.left() + margins.right() +
+                 scrollMargins.left() + scrollMargins.right();
 }
 
-void ViewportControl::initGUI()
-{
-  auto spinDoubleBoxes = this->groupBoxAbsoluteCamera->findChildren<QDoubleSpinBox *>();
+void ViewportControl::initGUI() {
+  auto spinDoubleBoxes =
+      this->groupBoxAbsoluteCamera->findChildren<QDoubleSpinBox*>();
   for (auto spinDoubleBox : spinDoubleBoxes) {
     spinDoubleBox->setMinimum(-DBL_MAX);
     spinDoubleBox->setMaximum(+DBL_MAX);
-    connect(spinDoubleBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ViewportControl::updateCamera);
+    connect(spinDoubleBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged),
+            this, &ViewportControl::updateCamera);
   }
 
   spinBoxWidth->setMinimum(1);
   spinBoxHeight->setMinimum(1);
   spinBoxWidth->setMaximum(8192);
   spinBoxHeight->setMaximum(8192);
-  connect(spinBoxWidth, QOverload<int>::of(&QSpinBox::valueChanged), this, &ViewportControl::requestResize);
-  connect(spinBoxHeight, QOverload<int>::of(&QSpinBox::valueChanged), this, &ViewportControl::requestResize);
+  connect(spinBoxWidth, QOverload<int>::of(&QSpinBox::valueChanged), this,
+          &ViewportControl::requestResize);
+  connect(spinBoxHeight, QOverload<int>::of(&QSpinBox::valueChanged), this,
+          &ViewportControl::requestResize);
 }
 
-void ViewportControl::setMainWindow(MainWindow *mainWindow)
-{
+void ViewportControl::setMainWindow(MainWindow* mainWindow) {
   this->mainWindow = mainWindow;
   this->qglview = mainWindow->qglview;
 }
 
-QString ViewportControl::yellowHintBackground()
-{
+QString ViewportControl::yellowHintBackground() {
   QPalette defaultPalette;
   const auto bgColor = defaultPalette.base().color().toRgb();
-  QString styleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, warnBlendColor);
+  QString styleSheet =
+      UIUtils::blendForBackgroundColorStyleSheet(bgColor, warnBlendColor);
   return styleSheet;
 }
 
-QString ViewportControl::redHintBackground()
-{
+QString ViewportControl::redHintBackground() {
   QPalette defaultPalette;
   const auto bgColor = defaultPalette.base().color().toRgb();
-  QString styleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
+  QString styleSheet =
+      UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
   return styleSheet;
 }
 
-void ViewportControl::resizeEvent(QResizeEvent *event)
-{
-  auto layoutAspectRatio = dynamic_cast<QBoxLayout *>(groupBoxAspectRatio->layout());
-  auto gridLayout = dynamic_cast<QGridLayout *>(groupBoxAbsoluteCamera->layout());
+void ViewportControl::resizeEvent(QResizeEvent* event) {
+  auto layoutAspectRatio =
+      dynamic_cast<QBoxLayout*>(groupBoxAspectRatio->layout());
+  auto gridLayout =
+      dynamic_cast<QGridLayout*>(groupBoxAbsoluteCamera->layout());
 
-  QLayoutItem *child;
+  QLayoutItem* child;
   if (layoutAspectRatio && gridLayout) {
     if (layoutAspectRatio->direction() == QBoxLayout::LeftToRight) {
       if (event->size().width() < initMinWidth) {
@@ -122,8 +126,9 @@ void ViewportControl::resizeEvent(QResizeEvent *event)
   QWidget::resizeEvent(event);
 }
 
-void ViewportControl::cameraChanged(){
-  if (!inputMutex.try_lock()) return;
+void ViewportControl::cameraChanged() {
+  if (!inputMutex.try_lock())
+    return;
 
   const auto vpt = qglview->cam.getVpt();
   doubleSpinBox_tx->setValue(vpt.x());
@@ -142,28 +147,23 @@ void ViewportControl::cameraChanged(){
   inputMutex.unlock();
 }
 
-void ViewportControl::updateCamera(){
-  if (!inputMutex.try_lock()) return;
+void ViewportControl::updateCamera() {
+  if (!inputMutex.try_lock())
+    return;
 
-  //viewport translation
-  qglview->cam.setVpt(
-    doubleSpinBox_tx->value(),
-    doubleSpinBox_ty->value(),
-    doubleSpinBox_tz->value()
-    );
+  // viewport translation
+  qglview->cam.setVpt(doubleSpinBox_tx->value(), doubleSpinBox_ty->value(),
+                      doubleSpinBox_tz->value());
 
-  //viewport rotation angles in degrees
-  qglview->cam.setVpr(
-    doubleSpinBox_rx->value(),
-    doubleSpinBox_ry->value(),
-    doubleSpinBox_rz->value()
-    );
+  // viewport rotation angles in degrees
+  qglview->cam.setVpr(doubleSpinBox_rx->value(), doubleSpinBox_ry->value(),
+                      doubleSpinBox_rz->value());
 
-  //viewport camera field of view
+  // viewport camera field of view
   double fov = doubleSpinBox_fov->value();
   qglview->cam.setVpf(fov);
 
-  //camera distance
+  // camera distance
   double d = doubleSpinBox_d->value();
   qglview->cam.setVpd(d);
 
@@ -172,36 +172,38 @@ void ViewportControl::updateCamera(){
   inputMutex.unlock();
 }
 
-void ViewportControl::updateViewportControlHints(){
-  //viewport camera field of view
+void ViewportControl::updateViewportControlHints() {
+  // viewport camera field of view
   double fov = doubleSpinBox_fov->value();
   if (fov < 0 || fov > 180) {
-    doubleSpinBox_fov->setToolTip(_("extreme values might may lead to strange behavior"));
+    doubleSpinBox_fov->setToolTip(
+        _("extreme values might may lead to strange behavior"));
     doubleSpinBox_fov->setStyleSheet(redHintBackground());
   } else if (fov < 5 || fov > 175) {
-    doubleSpinBox_fov->setToolTip(_("extreme values might may lead to strange behavior"));
+    doubleSpinBox_fov->setToolTip(
+        _("extreme values might may lead to strange behavior"));
     doubleSpinBox_fov->setStyleSheet(yellowHintBackground());
   } else {
     doubleSpinBox_fov->setToolTip("");
     doubleSpinBox_fov->setStyleSheet("");
   }
 
-  //camera distance
+  // camera distance
   double d = doubleSpinBox_d->value();
   if (d < 0) {
     doubleSpinBox_d->setToolTip(_("negative distances are not supported"));
     doubleSpinBox_d->setStyleSheet(redHintBackground());
   } else if (d < 5) {
-    doubleSpinBox_d->setToolTip(_("extreme values might may lead to strange behavior"));
+    doubleSpinBox_d->setToolTip(
+        _("extreme values might may lead to strange behavior"));
     doubleSpinBox_d->setStyleSheet(yellowHintBackground());
   } else {
     doubleSpinBox_d->setToolTip("");
     doubleSpinBox_d->setStyleSheet("");
   }
-
 }
 
-void ViewportControl::resizeToRatio(){
+void ViewportControl::resizeToRatio() {
   int w0 = spinBoxWidth->value();
   int h0 = spinBoxHeight->value();
 
@@ -216,8 +218,9 @@ void ViewportControl::resizeToRatio(){
   }
 }
 
-void ViewportControl::viewResized(){
-  if (!resizeMutex.try_lock()) return;
+void ViewportControl::viewResized() {
+  if (!resizeMutex.try_lock())
+    return;
 
   this->maxW = qglview->size().rwidth();
   this->maxH = qglview->size().rheight();
@@ -231,24 +234,25 @@ void ViewportControl::viewResized(){
   resizeMutex.unlock();
 }
 
-void ViewportControl::requestResize(){
-  if (!resizeMutex.try_lock()) return;
+void ViewportControl::requestResize() {
+  if (!resizeMutex.try_lock())
+    return;
 
   resizeToRatio();
 
   resizeMutex.unlock();
 }
 
-bool ViewportControl::focusNextPrevChild(bool next){
-  QWidget::focusNextPrevChild(next);   //tab order is set in the UI File
+bool ViewportControl::focusNextPrevChild(bool next) {
+  QWidget::focusNextPrevChild(next);  // tab order is set in the UI File
 
   bool bChildHasFocus = false;
-  for (auto child : QObject::findChildren<QWidget *>()) {
+  for (auto child : QObject::findChildren<QWidget*>()) {
     if (child->hasFocus()) {
       bChildHasFocus = true;
     }
   }
-  //do not let the focus leave this widget
+  // do not let the focus leave this widget
   if (!bChildHasFocus) {
     if (next) {
       spinBoxWidth->setFocus();
diff --git a/src/gui/ViewportControl.h b/src/gui/ViewportControl.h
index f2a758e97..3d6b7cc5c 100644
--- a/src/gui/ViewportControl.h
+++ b/src/gui/ViewportControl.h
@@ -1,45 +1,44 @@
 #pragma once
 
-#include "gui/qtgettext.h"
-#include "ui_ViewportControl.h"
 #include <QResizeEvent>
-#include <QWidget>
 #include <QStandardItemModel>
+#include <QWidget>
 #include <mutex>
+#include "gui/qtgettext.h"
+#include "ui_ViewportControl.h"
 
 class MainWindow;
 class QGLView;
 
-class ViewportControl : public QWidget, public Ui::ViewportControlWidget
-{
+class ViewportControl : public QWidget, public Ui::ViewportControlWidget {
   Q_OBJECT
 
-public:
-  ViewportControl(QWidget *parent = nullptr);
+ public:
+  ViewportControl(QWidget* parent = nullptr);
   ViewportControl(const ViewportControl& source) = delete;
   ViewportControl(ViewportControl&& source) = delete;
   ViewportControl& operator=(const ViewportControl& source) = delete;
   ViewportControl& operator=(ViewportControl&& source) = delete;
   ~ViewportControl() override = default;
   void initGUI();
-  void setMainWindow(MainWindow *mainWindow);
+  void setMainWindow(MainWindow* mainWindow);
 
-public slots:
+ public slots:
   void cameraChanged();
   void viewResized();
 
-private slots:
+ private slots:
   void updateCamera();
   void updateViewportControlHints();
   void requestResize();
 
-protected:
-  void resizeEvent(QResizeEvent *event) override;
+ protected:
+  void resizeEvent(QResizeEvent* event) override;
   bool focusNextPrevChild(bool next) override;
 
-private:
-  MainWindow *mainWindow;
-  QGLView *qglview;
+ private:
+  MainWindow* mainWindow;
+  QGLView* qglview;
   std::mutex inputMutex;
   std::mutex resizeMutex;
   QString yellowHintBackground();
@@ -47,10 +46,10 @@ private:
   QColor warnBlendColor{"yellow"};
   QColor errorBlendColor{"red"};
 
-signals:
+ signals:
   void openFile(const QString, int);
 
-private:
+ private:
   void resizeToRatio();
   int maxH;
   int maxW;
diff --git a/src/gui/WindowManager.cc b/src/gui/WindowManager.cc
index 4f13c8d67..870a00ebb 100644
--- a/src/gui/WindowManager.cc
+++ b/src/gui/WindowManager.cc
@@ -2,17 +2,14 @@
 #include <QSet>
 #include "gui/MainWindow.h"
 
-void WindowManager::add(MainWindow *mainwin)
-{
+void WindowManager::add(MainWindow* mainwin) {
   this->windows.insert(mainwin);
 }
 
-void WindowManager::remove(MainWindow *mainwin)
-{
+void WindowManager::remove(MainWindow* mainwin) {
   this->windows.remove(mainwin);
 }
 
-const QSet<MainWindow *>& WindowManager::getWindows() const
-{
+const QSet<MainWindow*>& WindowManager::getWindows() const {
   return this->windows;
 }
diff --git a/src/gui/WindowManager.h b/src/gui/WindowManager.h
index 2e7da614d..da7f97e11 100644
--- a/src/gui/WindowManager.h
+++ b/src/gui/WindowManager.h
@@ -3,16 +3,16 @@
 #include <QObject>
 #include <QSet>
 
-class WindowManager : public QObject
-{
+class WindowManager : public QObject {
   Q_OBJECT
 
-public:
+ public:
   WindowManager() = default;
 
-  void add(class MainWindow *mainwin);
-  void remove(class MainWindow *mainwin);
-  const QSet<MainWindow *>& getWindows() const;
-private:
-  QSet<MainWindow *> windows;
+  void add(class MainWindow* mainwin);
+  void remove(class MainWindow* mainwin);
+  const QSet<MainWindow*>& getWindows() const;
+
+ private:
+  QSet<MainWindow*> windows;
 };
diff --git a/src/gui/input/AxisConfigWidget.cc b/src/gui/input/AxisConfigWidget.cc
index b234af46b..c03c58958 100644
--- a/src/gui/input/AxisConfigWidget.cc
+++ b/src/gui/input/AxisConfigWidget.cc
@@ -30,40 +30,41 @@
 #include <QDoubleSpinBox>
 #include <QFont>
 #include <QProgressBar>
-#include <cmath>
 #include <QWidget>
+#include <cmath>
 #include <cstddef>
 #include <string>
 
-
 #include "core/Settings.h"
-#include "gui/input/InputDriverManager.h"
-#include "gui/SettingsWriter.h"
 #include "gui/IgnoreWheelWhenNotFocused.h"
 #include "gui/InitConfigurator.h"
+#include "gui/SettingsWriter.h"
+#include "gui/input/InputDriverManager.h"
 #include "gui/input/InputEventMapper.h"
 
-AxisConfigWidget::AxisConfigWidget(QWidget *parent) : QWidget(parent)
-{
+AxisConfigWidget::AxisConfigWidget(QWidget* parent) : QWidget(parent) {
   setupUi(this);
 }
 
 void AxisConfigWidget::AxesChanged(int nr, double val) const {
-  auto *progressBar = this->findChild<QProgressBar *>(QString("progressBarAxis%1").arg(nr));
-  if (progressBar == nullptr) return;
+  auto* progressBar =
+      this->findChild<QProgressBar*>(QString("progressBarAxis%1").arg(nr));
+  if (progressBar == nullptr)
+    return;
 
   int value = val * 100;
-  progressBar->setValue(value); //set where the bar is
+  progressBar->setValue(value);  // set where the bar is
 
-  //QProgressBar generates the shown string from the format string.
-  //By setting a format string without a place holder,
-  //we can set arbitrary text, like a custom formatted double.
-  //(Note: QProgressBar internally works on int, so has no formatting for double values)
-  //(Note: The text of a QProgressBar can not be set directly)
+  // QProgressBar generates the shown string from the format string.
+  // By setting a format string without a place holder,
+  // we can set arbitrary text, like a custom formatted double.
+  //(Note: QProgressBar internally works on int, so has no formatting for double
+  //values) (Note: The text of a QProgressBar can not be set directly)
   QString s = QString::number(val, 'f', 2);
   progressBar->setFormat(s);
 
-  auto *deadzone = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxDeadzone%1").arg(nr));
+  auto* deadzone = this->findChild<QDoubleSpinBox*>(
+      QString("doubleSpinBoxDeadzone%1").arg(nr));
   if (deadzone) {
     bool active = deadzone->value() < std::abs(val);
     QString style;
@@ -77,22 +78,34 @@ void AxisConfigWidget::AxesChanged(int nr, double val) const {
 }
 
 void AxisConfigWidget::init() {
-  connect(this->pushButtonAxisTrim, &QPushButton::clicked, this, &AxisConfigWidget::on_AxisTrim);
-  connect(this->pushButtonAxisTrimReset, &QPushButton::clicked, this, &AxisConfigWidget::on_AxisTrimReset);
-  connect(this->pushButtonUpdate, &QPushButton::clicked, this, &AxisConfigWidget::updateStates);
-
-  initComboBox(this->comboBoxTranslationX, Settings::Settings::inputTranslationX);
-  initComboBox(this->comboBoxTranslationY, Settings::Settings::inputTranslationY);
-  initComboBox(this->comboBoxTranslationZ, Settings::Settings::inputTranslationZ);
-  initComboBox(this->comboBoxTranslationXVPRel, Settings::Settings::inputTranslationXVPRel);
-  initComboBox(this->comboBoxTranslationYVPRel, Settings::Settings::inputTranslationYVPRel);
-  initComboBox(this->comboBoxTranslationZVPRel, Settings::Settings::inputTranslationZVPRel);
+  connect(this->pushButtonAxisTrim, &QPushButton::clicked, this,
+          &AxisConfigWidget::on_AxisTrim);
+  connect(this->pushButtonAxisTrimReset, &QPushButton::clicked, this,
+          &AxisConfigWidget::on_AxisTrimReset);
+  connect(this->pushButtonUpdate, &QPushButton::clicked, this,
+          &AxisConfigWidget::updateStates);
+
+  initComboBox(this->comboBoxTranslationX,
+               Settings::Settings::inputTranslationX);
+  initComboBox(this->comboBoxTranslationY,
+               Settings::Settings::inputTranslationY);
+  initComboBox(this->comboBoxTranslationZ,
+               Settings::Settings::inputTranslationZ);
+  initComboBox(this->comboBoxTranslationXVPRel,
+               Settings::Settings::inputTranslationXVPRel);
+  initComboBox(this->comboBoxTranslationYVPRel,
+               Settings::Settings::inputTranslationYVPRel);
+  initComboBox(this->comboBoxTranslationZVPRel,
+               Settings::Settings::inputTranslationZVPRel);
   initComboBox(this->comboBoxRotationX, Settings::Settings::inputRotateX);
   initComboBox(this->comboBoxRotationY, Settings::Settings::inputRotateY);
   initComboBox(this->comboBoxRotationZ, Settings::Settings::inputRotateZ);
-  initComboBox(this->comboBoxRotationXVPRel, Settings::Settings::inputRotateXVPRel);
-  initComboBox(this->comboBoxRotationYVPRel, Settings::Settings::inputRotateYVPRel);
-  initComboBox(this->comboBoxRotationZVPRel, Settings::Settings::inputRotateZVPRel);
+  initComboBox(this->comboBoxRotationXVPRel,
+               Settings::Settings::inputRotateXVPRel);
+  initComboBox(this->comboBoxRotationYVPRel,
+               Settings::Settings::inputRotateYVPRel);
+  initComboBox(this->comboBoxRotationZVPRel,
+               Settings::Settings::inputRotateZVPRel);
   initComboBox(this->comboBoxZoom, Settings::Settings::inputZoom);
   initComboBox(this->comboBoxZoom2, Settings::Settings::inputZoom2);
 
@@ -100,70 +113,90 @@ void AxisConfigWidget::init() {
   this->checkBoxHIDAPI->setEnabled(true);
   this->checkBoxHIDAPI->setToolTip(HidApiInputDriverDescription);
 #else
-  this->checkBoxHIDAPI->setToolTip(HidApiInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxHIDAPI->setToolTip(HidApiInputDriverDescription + "\n\r" +
+                                   NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_SPNAV
   this->checkBoxSpaceNav->setEnabled(true);
   this->checkBoxSpaceNav->setToolTip(SpaceNavInputDriverDescription);
 #else
-  this->checkBoxSpaceNav->setToolTip(SpaceNavInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxSpaceNav->setToolTip(SpaceNavInputDriverDescription + "\n\r" +
+                                     NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_JOYSTICK
   this->checkBoxJoystick->setEnabled(true);
   this->checkBoxJoystick->setToolTip(JoystickInputDriverDescription);
 #else
-  this->checkBoxJoystick->setToolTip(JoystickInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxJoystick->setToolTip(JoystickInputDriverDescription + "\n\r" +
+                                     NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_QGAMEPAD
   this->checkBoxQGamepad->setEnabled(true);
   this->checkBoxQGamepad->setToolTip(QGamepadInputDriverDescription);
 #else
-  this->checkBoxQGamepad->setToolTip(QGamepadInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxQGamepad->setToolTip(QGamepadInputDriverDescription + "\n\r" +
+                                     NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_DBUS
   this->checkBoxDBus->setEnabled(true);
   this->checkBoxDBus->setToolTip(DBusInputDriverDescription);
 #else
-  this->checkBoxDBus->setToolTip(DBusInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxDBus->setToolTip(DBusInputDriverDescription + "\n\r" +
+                                 NotEnabledDuringBuild);
 #endif
 
-  initUpdateCheckBox(this->checkBoxHIDAPI,   Settings::Settings::inputEnableDriverHIDAPI);
-  initUpdateCheckBox(this->checkBoxSpaceNav, Settings::Settings::inputEnableDriverSPNAV);
-  initUpdateCheckBox(this->checkBoxJoystick, Settings::Settings::inputEnableDriverJOYSTICK);
-  initUpdateCheckBox(this->checkBoxQGamepad, Settings::Settings::inputEnableDriverQGAMEPAD);
-  initUpdateCheckBox(this->checkBoxDBus,     Settings::Settings::inputEnableDriverDBUS);
+  initUpdateCheckBox(this->checkBoxHIDAPI,
+                     Settings::Settings::inputEnableDriverHIDAPI);
+  initUpdateCheckBox(this->checkBoxSpaceNav,
+                     Settings::Settings::inputEnableDriverSPNAV);
+  initUpdateCheckBox(this->checkBoxJoystick,
+                     Settings::Settings::inputEnableDriverJOYSTICK);
+  initUpdateCheckBox(this->checkBoxQGamepad,
+                     Settings::Settings::inputEnableDriverQGAMEPAD);
+  initUpdateCheckBox(this->checkBoxDBus,
+                     Settings::Settings::inputEnableDriverDBUS);
 
   installIgnoreWheelWhenNotFocused(this);
 
   for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spinTrim = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+    auto spinTrim =
+        this->findChild<QDoubleSpinBox*>(QString("doubleSpinBoxTrim%1").arg(i));
     if (spinTrim) {
       initUpdateDoubleSpinBox(spinTrim, InputEventMapper::axisTrimSettings(i));
     }
-    auto spinDeadZone = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxDeadzone%1").arg(i));
+    auto spinDeadZone = this->findChild<QDoubleSpinBox*>(
+        QString("doubleSpinBoxDeadzone%1").arg(i));
     if (spinDeadZone) {
-      initUpdateDoubleSpinBox(spinDeadZone, InputEventMapper::axisDeadzoneSettings(i));
+      initUpdateDoubleSpinBox(spinDeadZone,
+                              InputEventMapper::axisDeadzoneSettings(i));
     }
   }
 
-  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationGain, Settings::Settings::inputTranslationGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationVPRelGain, Settings::Settings::inputTranslationVPRelGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateGain, Settings::Settings::inputRotateGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateVPRelGain, Settings::Settings::inputRotateVPRelGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxZoomGain, Settings::Settings::inputZoomGain);
-
-  //use a custom style for the axis indicators,
-  //to prevent getting operating system specific
+  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationGain,
+                          Settings::Settings::inputTranslationGain);
+  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationVPRelGain,
+                          Settings::Settings::inputTranslationVPRelGain);
+  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateGain,
+                          Settings::Settings::inputRotateGain);
+  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateVPRelGain,
+                          Settings::Settings::inputRotateVPRelGain);
+  initUpdateDoubleSpinBox(this->doubleSpinBoxZoomGain,
+                          Settings::Settings::inputZoomGain);
+
+  // use a custom style for the axis indicators,
+  // to prevent getting operating system specific
   //(potentially animated) ProgressBars
-  int textLightness = this->progressBarAxis0->palette().text().color().lightness();
+  int textLightness =
+      this->progressBarAxis0->palette().text().color().lightness();
   this->darkModeDetected = textLightness > 165;
-  QString style = (this->darkModeDetected) ? ProgressbarStyleDark : ProgressbarStyleLight;
+  QString style =
+      (this->darkModeDetected) ? ProgressbarStyleDark : ProgressbarStyleLight;
 
-  auto progressbars = this->findChildren<QProgressBar *>();
+  auto progressbars = this->findChildren<QProgressBar*>();
   for (auto progressbar : progressbars) {
     progressbar->setStyleSheet(style);
     progressbar->setAlignment(Qt::AlignCenter);
@@ -172,256 +205,231 @@ void AxisConfigWidget::init() {
   initialized = true;
 }
 
-void AxisConfigWidget::on_comboBoxTranslationX_activated(int val)
-{
-  applyComboBox(comboBoxTranslationX, val, Settings::Settings::inputTranslationX);
+void AxisConfigWidget::on_comboBoxTranslationX_activated(int val) {
+  applyComboBox(comboBoxTranslationX, val,
+                Settings::Settings::inputTranslationX);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationY_activated(int val)
-{
-  applyComboBox(comboBoxTranslationY, val, Settings::Settings::inputTranslationY);
+void AxisConfigWidget::on_comboBoxTranslationY_activated(int val) {
+  applyComboBox(comboBoxTranslationY, val,
+                Settings::Settings::inputTranslationY);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationZ_activated(int val)
-{
-  applyComboBox(comboBoxTranslationZ, val, Settings::Settings::inputTranslationZ);
+void AxisConfigWidget::on_comboBoxTranslationZ_activated(int val) {
+  applyComboBox(comboBoxTranslationZ, val,
+                Settings::Settings::inputTranslationZ);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationXVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationXVPRel, val, Settings::Settings::inputTranslationXVPRel);
+void AxisConfigWidget::on_comboBoxTranslationXVPRel_activated(int val) {
+  applyComboBox(comboBoxTranslationXVPRel, val,
+                Settings::Settings::inputTranslationXVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationYVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationYVPRel, val, Settings::Settings::inputTranslationYVPRel);
+void AxisConfigWidget::on_comboBoxTranslationYVPRel_activated(int val) {
+  applyComboBox(comboBoxTranslationYVPRel, val,
+                Settings::Settings::inputTranslationYVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationZVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationZVPRel, val, Settings::Settings::inputTranslationZVPRel);
+void AxisConfigWidget::on_comboBoxTranslationZVPRel_activated(int val) {
+  applyComboBox(comboBoxTranslationZVPRel, val,
+                Settings::Settings::inputTranslationZVPRel);
   emit inputMappingChanged();
 }
-void AxisConfigWidget::on_comboBoxRotationX_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxRotationX_activated(int val) {
   applyComboBox(comboBoxRotationX, val, Settings::Settings::inputRotateX);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationY_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxRotationY_activated(int val) {
   applyComboBox(comboBoxRotationY, val, Settings::Settings::inputRotateY);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationZ_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxRotationZ_activated(int val) {
   applyComboBox(comboBoxRotationZ, val, Settings::Settings::inputRotateZ);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationXVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationXVPRel, val, Settings::Settings::inputRotateXVPRel);
+void AxisConfigWidget::on_comboBoxRotationXVPRel_activated(int val) {
+  applyComboBox(comboBoxRotationXVPRel, val,
+                Settings::Settings::inputRotateXVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationYVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationYVPRel, val, Settings::Settings::inputRotateYVPRel);
+void AxisConfigWidget::on_comboBoxRotationYVPRel_activated(int val) {
+  applyComboBox(comboBoxRotationYVPRel, val,
+                Settings::Settings::inputRotateYVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationZVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationZVPRel, val, Settings::Settings::inputRotateZVPRel);
+void AxisConfigWidget::on_comboBoxRotationZVPRel_activated(int val) {
+  applyComboBox(comboBoxRotationZVPRel, val,
+                Settings::Settings::inputRotateZVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxZoom_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxZoom_activated(int val) {
   applyComboBox(comboBoxZoom, val, Settings::Settings::inputZoom);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxZoom2_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxZoom2_activated(int val) {
   applyComboBox(comboBoxZoom2, val, Settings::Settings::inputZoom2);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim0_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim0_valueChanged(double val) {
   Settings::Settings::axisTrim0.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim1_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim1_valueChanged(double val) {
   Settings::Settings::axisTrim1.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim2_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim2_valueChanged(double val) {
   Settings::Settings::axisTrim2.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim3_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim3_valueChanged(double val) {
   Settings::Settings::axisTrim3.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim4_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim4_valueChanged(double val) {
   Settings::Settings::axisTrim4.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim5_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim5_valueChanged(double val) {
   Settings::Settings::axisTrim5.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim6_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim6_valueChanged(double val) {
   Settings::Settings::axisTrim6.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim7_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim7_valueChanged(double val) {
   Settings::Settings::axisTrim7.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim8_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim8_valueChanged(double val) {
   Settings::Settings::axisTrim8.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone0_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone0_valueChanged(double val) {
   Settings::Settings::axisDeadzone0.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone1_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone1_valueChanged(double val) {
   Settings::Settings::axisDeadzone1.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone2_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone2_valueChanged(double val) {
   Settings::Settings::axisDeadzone2.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone3_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone3_valueChanged(double val) {
   Settings::Settings::axisDeadzone3.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone4_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone4_valueChanged(double val) {
   Settings::Settings::axisDeadzone4.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone5_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone5_valueChanged(double val) {
   Settings::Settings::axisDeadzone5.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone6_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone6_valueChanged(double val) {
   Settings::Settings::axisDeadzone6.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone7_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone7_valueChanged(double val) {
   Settings::Settings::axisDeadzone7.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone8_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone8_valueChanged(double val) {
   Settings::Settings::axisDeadzone8.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxRotateGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxRotateGain_valueChanged(double val) {
   Settings::Settings::inputRotateGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxRotateVPRelGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxRotateVPRelGain_valueChanged(
+    double val) {
   Settings::Settings::inputRotateVPRelGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTranslationGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTranslationGain_valueChanged(
+    double val) {
   Settings::Settings::inputTranslationGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTranslationVPRelGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTranslationVPRelGain_valueChanged(
+    double val) {
   Settings::Settings::inputTranslationVPRelGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxZoomGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxZoomGain_valueChanged(double val) {
   Settings::Settings::inputZoomGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_AxisTrim()
-{
+void AxisConfigWidget::on_AxisTrim() {
   InputEventMapper::instance()->onAxisAutoTrim();
 
   for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spin = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+    auto spin =
+        this->findChild<QDoubleSpinBox*>(QString("doubleSpinBoxTrim%1").arg(i));
     if (spin) {
       spin->setValue(InputEventMapper::axisTrimSettings(i).value());
     }
@@ -430,11 +438,11 @@ void AxisConfigWidget::on_AxisTrim()
   writeSettings();
 }
 
-void AxisConfigWidget::on_AxisTrimReset()
-{
+void AxisConfigWidget::on_AxisTrimReset() {
   InputEventMapper::instance()->onAxisTrimReset();
   for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spin = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+    auto spin =
+        this->findChild<QDoubleSpinBox*>(QString("doubleSpinBoxTrim%1").arg(i));
     if (spin) {
       InputEventMapper::axisTrimSettings(i).setValue(0.00);
       spin->setValue(0.00);
@@ -444,8 +452,7 @@ void AxisConfigWidget::on_AxisTrimReset()
   writeSettings();
 }
 
-void AxisConfigWidget::on_checkBoxHIDAPI_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxHIDAPI_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverHIDAPI.setValue(val);
     writeSettings();
@@ -456,8 +463,7 @@ void AxisConfigWidget::on_checkBoxHIDAPI_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::on_checkBoxSpaceNav_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxSpaceNav_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverSPNAV.setValue(val);
     writeSettings();
@@ -467,8 +473,7 @@ void AxisConfigWidget::on_checkBoxSpaceNav_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::on_checkBoxJoystick_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxJoystick_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverJOYSTICK.setValue(val);
     writeSettings();
@@ -478,8 +483,7 @@ void AxisConfigWidget::on_checkBoxJoystick_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::on_checkBoxQGamepad_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxQGamepad_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverQGAMEPAD.setValue(val);
     writeSettings();
@@ -489,8 +493,7 @@ void AxisConfigWidget::on_checkBoxQGamepad_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::on_checkBoxDBus_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxDBus_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverDBUS.setValue(val);
     writeSettings();
@@ -500,24 +503,26 @@ void AxisConfigWidget::on_checkBoxDBus_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::applyComboBox(QComboBox * /*comboBox*/, int val, Settings::SettingsEntryEnum<std::string>& entry)
-{
+void AxisConfigWidget::applyComboBox(
+    QComboBox* /*comboBox*/,
+    int val,
+    Settings::SettingsEntryEnum<std::string>& entry) {
   entry.setIndex(val);
   writeSettings();
 }
 
-void AxisConfigWidget::writeSettings()
-{
+void AxisConfigWidget::writeSettings() {
   Settings::Settings::visit(SettingsWriter());
 }
 
-
-void AxisConfigWidget::updateStates(){
-  if (!initialized) return;
+void AxisConfigWidget::updateStates() {
+  if (!initialized)
+    return;
 
   size_t cnt = InputDriverManager::instance()->getAxisCount();
   for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto progressbar = this->findChild<QProgressBar *>(QString("progressBarAxis%1").arg(i));
+    auto progressbar =
+        this->findChild<QProgressBar*>(QString("progressBarAxis%1").arg(i));
     if (progressbar) {
       if (cnt <= i) {
         progressbar->setEnabled(false);
diff --git a/src/gui/input/AxisConfigWidget.h b/src/gui/input/AxisConfigWidget.h
index 428293721..c81b0815c 100644
--- a/src/gui/input/AxisConfigWidget.h
+++ b/src/gui/input/AxisConfigWidget.h
@@ -1,24 +1,25 @@
 #pragma once
 
-#include "gui/qtgettext.h"
 #include <QComboBox>
 #include <QWidget>
 #include <string>
 #include "core/Settings.h"
-#include "ui_AxisConfigWidget.h"
 #include "gui/InitConfigurator.h"
+#include "gui/qtgettext.h"
+#include "ui_AxisConfigWidget.h"
 
-class AxisConfigWidget : public QWidget, public Ui::Axis, public InitConfigurator
-{
+class AxisConfigWidget : public QWidget,
+                         public Ui::Axis,
+                         public InitConfigurator {
   Q_OBJECT
 
-public:
-  AxisConfigWidget(QWidget *parent = nullptr);
+ public:
+  AxisConfigWidget(QWidget* parent = nullptr);
   void updateButtonState(int, bool) const;
   void AxesChanged(int nr, double val) const;
   void init();
 
-public slots:
+ public slots:
   // Input Driver
   void on_AxisTrim();
   void on_AxisTrimReset();
@@ -71,53 +72,70 @@ public slots:
 
   void updateStates();
 
-signals:
+ signals:
   void inputMappingChanged() const;
   void inputCalibrationChanged() const;
   void inputGainChanged() const;
 
-private:
+ private:
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryEnum<std::string>& entry);
+  void applyComboBox(QComboBox* comboBox,
+                     int val,
+                     Settings::SettingsEntryEnum<std::string>& entry);
   void writeSettings();
 
   bool initialized = false;
 
-  QString NotEnabledDuringBuild = _("This driver was not enabled during build time and is thus not available.");
-
-  QString DBusInputDriverDescription = _("The DBUS driver is not for actual devices but for remote control, Linux only.");
-  QString HidApiInputDriverDescription = _("The HIDAPI driver communicates directly with the 3D mice, Windows and macOS.");
-  QString SpaceNavInputDriverDescription = _("The SpaceNav driver enables 3D-input-devices using the spacenavd daemon, Linux only.");
-  QString JoystickInputDriverDescription = _("The Joystick driver uses the Linux joystick device (fixed to /dev/input/js0), Linux only.");
-  QString QGamepadInputDriverDescription = _("The QGAMEPAD driver is for multiplattform Gamepad Support.");
+  QString NotEnabledDuringBuild =
+      _("This driver was not enabled during build time and is thus not "
+        "available.");
+
+  QString DBusInputDriverDescription =
+      _("The DBUS driver is not for actual devices but for remote control, "
+        "Linux only.");
+  QString HidApiInputDriverDescription =
+      _("The HIDAPI driver communicates directly with the 3D mice, Windows and "
+        "macOS.");
+  QString SpaceNavInputDriverDescription =
+      _("The SpaceNav driver enables 3D-input-devices using the spacenavd "
+        "daemon, Linux only.");
+  QString JoystickInputDriverDescription =
+      _("The Joystick driver uses the Linux joystick device (fixed to "
+        "/dev/input/js0), Linux only.");
+  QString QGamepadInputDriverDescription =
+      _("The QGAMEPAD driver is for multiplattform Gamepad Support.");
 
   bool darkModeDetected = false;
 
   QString ProgressbarStyleLight =
-    "QProgressBar::chunk {"
-    "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #66d9ff,stop: 1 #ccf2ff );"
-    "border-radius: 5px;"
-    "border: 1px solid #007399;"
-    "}";
+      "QProgressBar::chunk {"
+      "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 "
+      "#66d9ff,stop: 1 #ccf2ff );"
+      "border-radius: 5px;"
+      "border: 1px solid #007399;"
+      "}";
 
   QString ProgressbarStyleLightActive =
-    "QProgressBar::chunk {"
-    "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #66ff66,stop: 1 #ccffcc );"
-    "border-radius: 5px;"
-    "border: 1px solid #007399;"
-    "}";
+      "QProgressBar::chunk {"
+      "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 "
+      "#66ff66,stop: 1 #ccffcc );"
+      "border-radius: 5px;"
+      "border: 1px solid #007399;"
+      "}";
 
   QString ProgressbarStyleDark =
-    "QProgressBar::chunk {"
-    "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #001a33,stop: 1 #0069cc );"
-    "border-radius: 5px;"
-    "border: 1px solid #000d1a;"
-    "}";
+      "QProgressBar::chunk {"
+      "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 "
+      "#001a33,stop: 1 #0069cc );"
+      "border-radius: 5px;"
+      "border: 1px solid #000d1a;"
+      "}";
 
   QString ProgressbarStyleDarkActive =
-    "QProgressBar::chunk {"
-    "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #00331a,stop: 1 #00cc69 );"
-    "border-radius: 5px;"
-    "border: 1px solid #000d1a;"
-    "}";
+      "QProgressBar::chunk {"
+      "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 "
+      "#00331a,stop: 1 #00cc69 );"
+      "border-radius: 5px;"
+      "border: 1px solid #000d1a;"
+      "}";
 };
diff --git a/src/gui/input/ButtonConfigWidget.cc b/src/gui/input/ButtonConfigWidget.cc
index c4b51af08..8ed49abc7 100644
--- a/src/gui/input/ButtonConfigWidget.cc
+++ b/src/gui/input/ButtonConfigWidget.cc
@@ -33,27 +33,28 @@
 #include <QWidget>
 #include <cstddef>
 #include "core/Settings.h"
-#include "gui/input/InputDriverManager.h"
-#include "gui/SettingsWriter.h"
 #include "gui/IgnoreWheelWhenNotFocused.h"
+#include "gui/SettingsWriter.h"
+#include "gui/input/InputDriverManager.h"
 #include "gui/input/InputEventMapper.h"
 
-ButtonConfigWidget::ButtonConfigWidget(QWidget *parent) : QWidget(parent)
-{
+ButtonConfigWidget::ButtonConfigWidget(QWidget* parent) : QWidget(parent) {
   setupUi(this);
 }
 
 void ButtonConfigWidget::updateButtonState(int nr, bool pressed) const {
-  QString style = pressed ? ButtonConfigWidget::ActiveStyleString : ButtonConfigWidget::EmptyString;
+  QString style = pressed ? ButtonConfigWidget::ActiveStyleString
+                          : ButtonConfigWidget::EmptyString;
 
-  auto label = this->findChild<QLabel *>(QString("labelInputButton%1").arg(nr));
-  if (label == nullptr) return;
+  auto label = this->findChild<QLabel*>(QString("labelInputButton%1").arg(nr));
+  if (label == nullptr)
+    return;
   label->setStyleSheet(style);
 }
 
 void ButtonConfigWidget::init() {
   for (size_t i = 0; i < InputEventMapper::getMaxButtons(); ++i) {
-    auto box = this->findChild<QComboBox *>(QString("comboBoxButton%1").arg(i));
+    auto box = this->findChild<QComboBox*>(QString("comboBoxButton%1").arg(i));
     if (box) {
       initActionComboBox(box, InputEventMapper::inputButtonSettings(i));
     }
@@ -64,175 +65,154 @@ void ButtonConfigWidget::init() {
   initialized = true;
 }
 
-void ButtonConfigWidget::on_comboBoxButton0_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton0_activated(int val) {
   applyComboBox(comboBoxButton0, val, Settings::Settings::inputButton0);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton1_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton1_activated(int val) {
   applyComboBox(comboBoxButton1, val, Settings::Settings::inputButton1);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton2_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton2_activated(int val) {
   applyComboBox(comboBoxButton2, val, Settings::Settings::inputButton2);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton3_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton3_activated(int val) {
   applyComboBox(comboBoxButton3, val, Settings::Settings::inputButton3);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton4_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton4_activated(int val) {
   applyComboBox(comboBoxButton4, val, Settings::Settings::inputButton4);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton5_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton5_activated(int val) {
   applyComboBox(comboBoxButton5, val, Settings::Settings::inputButton5);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton6_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton6_activated(int val) {
   applyComboBox(comboBoxButton6, val, Settings::Settings::inputButton6);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton7_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton7_activated(int val) {
   applyComboBox(comboBoxButton7, val, Settings::Settings::inputButton7);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton8_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton8_activated(int val) {
   applyComboBox(comboBoxButton8, val, Settings::Settings::inputButton8);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton9_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton9_activated(int val) {
   applyComboBox(comboBoxButton9, val, Settings::Settings::inputButton9);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton10_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton10_activated(int val) {
   applyComboBox(comboBoxButton10, val, Settings::Settings::inputButton10);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton11_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton11_activated(int val) {
   applyComboBox(comboBoxButton11, val, Settings::Settings::inputButton11);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton12_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton12_activated(int val) {
   applyComboBox(comboBoxButton12, val, Settings::Settings::inputButton12);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton13_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton13_activated(int val) {
   applyComboBox(comboBoxButton13, val, Settings::Settings::inputButton13);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton14_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton14_activated(int val) {
   applyComboBox(comboBoxButton14, val, Settings::Settings::inputButton14);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton15_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton15_activated(int val) {
   applyComboBox(comboBoxButton15, val, Settings::Settings::inputButton15);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton16_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton16_activated(int val) {
   applyComboBox(comboBoxButton16, val, Settings::Settings::inputButton16);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton17_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton17_activated(int val) {
   applyComboBox(comboBoxButton17, val, Settings::Settings::inputButton17);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton18_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton18_activated(int val) {
   applyComboBox(comboBoxButton18, val, Settings::Settings::inputButton18);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton19_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton19_activated(int val) {
   applyComboBox(comboBoxButton19, val, Settings::Settings::inputButton19);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton20_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton20_activated(int val) {
   applyComboBox(comboBoxButton20, val, Settings::Settings::inputButton20);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton21_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton21_activated(int val) {
   applyComboBox(comboBoxButton21, val, Settings::Settings::inputButton21);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton22_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton22_activated(int val) {
   applyComboBox(comboBoxButton22, val, Settings::Settings::inputButton22);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton23_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton23_activated(int val) {
   applyComboBox(comboBoxButton23, val, Settings::Settings::inputButton23);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryString& entry)
-{
+void ButtonConfigWidget::applyComboBox(QComboBox* comboBox,
+                                       int val,
+                                       Settings::SettingsEntryString& entry) {
   entry.setValue(comboBox->itemData(val).toString().toStdString());
   writeSettings();
 }
 
-void ButtonConfigWidget::updateComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry)
-{
+void ButtonConfigWidget::updateComboBox(
+    QComboBox* comboBox,
+    const Settings::SettingsEntryString& entry) {
   QString value = QString::fromStdString(entry.value());
   int index = comboBox->findData(value);
   if (index >= 0) {
     comboBox->setCurrentIndex(index);
   } else {
-    comboBox->addItem(QIcon::fromTheme("emblem-unreadable"), value + " " + ("(not supported)"), value);
+    comboBox->addItem(QIcon::fromTheme("emblem-unreadable"),
+                      value + " " + ("(not supported)"), value);
     comboBox->setCurrentIndex(comboBox->count() - 1);
   }
 }
 
-void ButtonConfigWidget::writeSettings()
-{
+void ButtonConfigWidget::writeSettings() {
   Settings::Settings::visit(SettingsWriter());
 }
 
-void ButtonConfigWidget::initActionComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry)
-{
+void ButtonConfigWidget::initActionComboBox(
+    QComboBox* comboBox,
+    const Settings::SettingsEntryString& entry) {
   comboBox->clear();
 
   // Create an empty icon, so that all comboboxes have the same alignment
@@ -241,7 +221,8 @@ void ButtonConfigWidget::initActionComboBox(QComboBox *comboBox, const Settings:
   const QIcon emptyIcon = QIcon(map);
 
   comboBox->addItem(emptyIcon, QString::fromStdString(_("None")), "");
-  comboBox->addItem(emptyIcon, QString::fromStdString(_("Toggle Perspective")), "viewActionTogglePerspective");
+  comboBox->addItem(emptyIcon, QString::fromStdString(_("Toggle Perspective")),
+                    "viewActionTogglePerspective");
 
   for (const auto& action : InputDriverManager::instance()->getActions()) {
     const auto icon = action.icon;
@@ -253,14 +234,16 @@ void ButtonConfigWidget::initActionComboBox(QComboBox *comboBox, const Settings:
   updateComboBox(comboBox, entry);
 }
 
-void ButtonConfigWidget::updateStates(){
-  if (!initialized) return;
+void ButtonConfigWidget::updateStates() {
+  if (!initialized)
+    return;
 
   size_t cnt = InputDriverManager::instance()->getButtonCount();
   for (size_t i = 0; i < InputEventMapper::getMaxButtons(); ++i) {
-    auto label = this->findChild<QLabel *>(QString("labelInputButton%1").arg(i));
+    auto label = this->findChild<QLabel*>(QString("labelInputButton%1").arg(i));
     if (label) {
-      QString style = (cnt <= i) ? ButtonConfigWidget::DisabledStyleString : ButtonConfigWidget::EmptyString;
+      QString style = (cnt <= i) ? ButtonConfigWidget::DisabledStyleString
+                                 : ButtonConfigWidget::EmptyString;
       label->setStyleSheet(style);
     }
   }
diff --git a/src/gui/input/ButtonConfigWidget.h b/src/gui/input/ButtonConfigWidget.h
index d811b2b6b..5535dc145 100644
--- a/src/gui/input/ButtonConfigWidget.h
+++ b/src/gui/input/ButtonConfigWidget.h
@@ -1,22 +1,21 @@
 #pragma once
 
-#include "gui/qtgettext.h"
 #include <QComboBox>
 #include <QWidget>
-#include "ui_ButtonConfigWidget.h"
 #include "core/Settings.h"
+#include "gui/qtgettext.h"
+#include "ui_ButtonConfigWidget.h"
 
-class ButtonConfigWidget : public QWidget, public Ui::Button
-{
+class ButtonConfigWidget : public QWidget, public Ui::Button {
   Q_OBJECT
 
-public:
-  ButtonConfigWidget(QWidget *parent = nullptr);
+ public:
+  ButtonConfigWidget(QWidget* parent = nullptr);
   void updateButtonState(int, bool) const;
   void init();
   void updateStates();
 
-public slots:
+ public slots:
   void on_comboBoxButton0_activated(int val);
   void on_comboBoxButton1_activated(int val);
   void on_comboBoxButton2_activated(int val);
@@ -42,16 +41,20 @@ public slots:
   void on_comboBoxButton22_activated(int val);
   void on_comboBoxButton23_activated(int val);
 
-signals:
+ signals:
   void inputMappingChanged() const;
 
-private:
+ private:
   /** Initialize combobox list values from the settings range values */
-  void initActionComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry);
+  void initActionComboBox(QComboBox* comboBox,
+                          const Settings::SettingsEntryString& entry);
   /** Update combobox from current settings */
-  void updateComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry);
+  void updateComboBox(QComboBox* comboBox,
+                      const Settings::SettingsEntryString& entry);
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryString& entry);
+  void applyComboBox(QComboBox* comboBox,
+                     int val,
+                     Settings::SettingsEntryString& entry);
   void writeSettings();
 
   const QString EmptyString = QString("");
diff --git a/src/gui/input/DBusInputDriver.cc b/src/gui/input/DBusInputDriver.cc
index b547ffd9d..2a0e049be 100644
--- a/src/gui/input/DBusInputDriver.cc
+++ b/src/gui/input/DBusInputDriver.cc
@@ -28,32 +28,25 @@
 #include <QList>
 #include <QStringList>
 #include "gui/input/InputDriverManager.h"
-#include "utils/printutils.h"
 #include "openscad_adaptor.h"
 #include "openscad_interface.h"
+#include "utils/printutils.h"
 
-void DBusInputDriver::run()
-{
-
-}
+void DBusInputDriver::run() {}
 
-DBusInputDriver::DBusInputDriver()
-{
+DBusInputDriver::DBusInputDriver() {
   name = "DBusInputDriver";
 }
 
-bool DBusInputDriver::openOnce() const
-{
+bool DBusInputDriver::openOnce() const {
   return true;
 }
 
-bool DBusInputDriver::isOpen() const
-{
+bool DBusInputDriver::isOpen() const {
   return is_open;
 }
 
-bool DBusInputDriver::open()
-{
+bool DBusInputDriver::open() {
   if (is_open) {
     return true;
   }
@@ -74,53 +67,49 @@ bool DBusInputDriver::open()
   return true;
 }
 
-void DBusInputDriver::close()
-{
-
-}
+void DBusInputDriver::close() {}
 
-void DBusInputDriver::zoom(double zoom) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventZoom(zoom, true, false));
+void DBusInputDriver::zoom(double zoom) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventZoom(zoom, true, false));
 }
 
-void DBusInputDriver::zoomTo(double zoom) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventZoom(zoom, false, false));
+void DBusInputDriver::zoomTo(double zoom) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventZoom(zoom, false, false));
 }
 
-void DBusInputDriver::rotate(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate(x, y, z, true, false));
+void DBusInputDriver::rotate(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventRotate(x, y, z, true, false));
 }
 
-void DBusInputDriver::rotateTo(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate(x, y, z, false, false));
+void DBusInputDriver::rotateTo(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventRotate(x, y, z, false, false));
 }
 
-void DBusInputDriver::rotateByVector(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate2(x, y, z, false));
+void DBusInputDriver::rotateByVector(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventRotate2(x, y, z, false));
 }
 
-void DBusInputDriver::translate(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventTranslate(x, y, z, true, false, false));
+void DBusInputDriver::translate(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventTranslate(x, y, z, true, false, false));
 }
 
-void DBusInputDriver::translateTo(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventTranslate(x, y, z, false, false, false));
+void DBusInputDriver::translateTo(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventTranslate(x, y, z, false, false, false));
 }
 
-void DBusInputDriver::action(const QString& name) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventAction(name.toStdString(), false));
+void DBusInputDriver::action(const QString& name) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventAction(name.toStdString(), false));
 }
 
-const QStringList DBusInputDriver::getActions() const
-{
+const QStringList DBusInputDriver::getActions() const {
   QStringList ret;
   for (const auto& action : InputDriverManager::instance()->getActions()) {
     ret << action.name;
@@ -128,28 +117,25 @@ const QStringList DBusInputDriver::getActions() const
   return ret;
 }
 
-void DBusInputDriver::buttonPress(uint idx) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(idx, true, false));
-  InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(idx, false, false));
+void DBusInputDriver::buttonPress(uint idx) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventButtonChanged(idx, true, false));
+  InputDriverManager::instance()->sendEvent(
+      new InputEventButtonChanged(idx, false, false));
 }
 
-const QList<double> DBusInputDriver::getRotation() const
-{
+const QList<double> DBusInputDriver::getRotation() const {
   return InputDriverManager::instance()->getRotation();
 }
 
-const QList<double> DBusInputDriver::getTranslation() const
-{
+const QList<double> DBusInputDriver::getTranslation() const {
   return InputDriverManager::instance()->getTranslation();
 }
 
-const std::string& DBusInputDriver::get_name() const
-{
+const std::string& DBusInputDriver::get_name() const {
   return this->name;
 }
 
-std::string DBusInputDriver::get_info() const
-{
+std::string DBusInputDriver::get_info() const {
   return STR(get_name(), " ", (isOpen() ? "open" : "not open"));
 }
diff --git a/src/gui/input/DBusInputDriver.h b/src/gui/input/DBusInputDriver.h
index e4cc2fd0a..91fd58cae 100644
--- a/src/gui/input/DBusInputDriver.h
+++ b/src/gui/input/DBusInputDriver.h
@@ -28,18 +28,17 @@
 #include <QList>
 #include <QString>
 #include <QStringList>
-#include "gui/input/InputDriver.h"
 #include <string>
+#include "gui/input/InputDriver.h"
 
-class DBusInputDriver : public InputDriver
-{
+class DBusInputDriver : public InputDriver {
   Q_OBJECT
 
   bool is_open{false};
 
   std::string name;
 
-public:
+ public:
   DBusInputDriver();
   void run() override;
   bool open() override;
@@ -50,7 +49,7 @@ public:
   const std::string& get_name() const override;
   std::string get_info() const override;
 
-public slots:
+ public slots:
   void zoom(double zoom) const;
   void zoomTo(double zoom) const;
   void rotate(double x, double y, double z) const;
diff --git a/src/gui/input/HidApiInputDriver.cc b/src/gui/input/HidApiInputDriver.cc
index b978568e6..f7dc20517 100644
--- a/src/gui/input/HidApiInputDriver.cc
+++ b/src/gui/input/HidApiInputDriver.cc
@@ -31,22 +31,22 @@
 
 #include "gui/input/HidApiInputDriver.h"
 
-#include <ios>
-#include <sstream>
-#include <cstdint>
 #include <bitset>
 #include <boost/format.hpp>
 #include <chrono>
 #include <cmath>
 #include <codecvt>
+#include <cstdint>
 #include <fstream>
 #include <iomanip>
+#include <ios>
+#include <sstream>
 #include <string>
 
 #include "core/Settings.h"
-#include "platform/PlatformUtils.h"
 #include "gui/input/InputDriverEvent.h"
 #include "gui/input/InputDriverManager.h"
+#include "platform/PlatformUtils.h"
 #include "utils/printutils.h"
 
 static constexpr int BUFLEN = 64;
@@ -60,26 +60,60 @@ static ch::system_clock::time_point logtime;
 // http://www.linux-usb.org/usb.ids
 // http://www.3dconnexion.eu/nc/service/faq/show_faq/7ece50ed-0b39-b57e-d3b2-4afd9420604e.html
 static const struct device_id device_ids[] = {
-  { 0x046d, 0xc603, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spacemouse Plus XT"},
-  { 0x046d, 0xc605, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion CADman"},
-  { 0x046d, 0xc606, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spacemouse Classic"},
-  { 0x046d, 0xc621, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spaceball 5000"},
-  { 0x046d, 0xc623, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Traveller 3D Mouse"},
-  { 0x046d, 0xc625, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Pilot 3D Mouse"},
-  { 0x046d, 0xc626, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Navigator 3D Mouse"},
-  { 0x046d, 0xc627, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Explorer 3D Mouse"},
-  { 0x046d, 0xc628, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Navigator for Notebooks"},
-  { 0x046d, 0xc629, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion SpacePilot Pro 3D Mouse"},
-  { 0x046d, 0xc62b, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro"},
-  { 0x256f, 0xc62e, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless (cabled)"},
-  { 0x256f, 0xc62f, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless"},
-  { 0x256f, 0xc631, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro Wireless (cabled)"},
-  { 0x256f, 0xc632, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro Wireless"},
-  { 0x256f, 0xc635, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Compact"},
-  { 0x256f, 0xc63a, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless BT"},
-  // This is reported to be used with a 3Dconnexion Space Mouse Wireless 256f:c62e
-  { 0x256f, 0xc652, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Universal Receiver"},
-  { -1, -1, nullptr, nullptr, nullptr},
+    {0x046d, 0xc603, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Spacemouse Plus XT"},
+    {0x046d, 0xc605, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button, "3Dconnexion CADman"},
+    {0x046d, 0xc606, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Spacemouse Classic"},
+    {0x046d, 0xc621, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spaceball 5000"},
+    {0x046d, 0xc623, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Traveller 3D Mouse"},
+    {0x046d, 0xc625, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Pilot 3D Mouse"},
+    {0x046d, 0xc626, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Navigator 3D Mouse"},
+    {0x046d, 0xc627, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Explorer 3D Mouse"},
+    {0x046d, 0xc628, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Navigator for Notebooks"},
+    {0x046d, 0xc629, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion SpacePilot Pro 3D Mouse"},
+    {0x046d, 0xc62b, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro"},
+    {0x256f, 0xc62e, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Wireless (cabled)"},
+    {0x256f, 0xc62f, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Wireless"},
+    {0x256f, 0xc631, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Pro Wireless (cabled)"},
+    {0x256f, 0xc632, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Pro Wireless"},
+    {0x256f, 0xc635, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Compact"},
+    {0x256f, 0xc63a, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Wireless BT"},
+    // This is reported to be used with a 3Dconnexion Space Mouse Wireless
+    // 256f:c62e
+    {0x256f, 0xc652, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Universal Receiver"},
+    {-1, -1, nullptr, nullptr, nullptr},
 };
 
 #define HIDAPI_LOG(f) hidapi_log(boost::format(f))
@@ -89,15 +123,15 @@ static void hidapi_log(const boost::format& format) {
   if (logstream) {
     const ch::system_clock::duration time = ch::system_clock::now() - logtime;
 
-    logstream << ch::duration_cast<ch::milliseconds>(time).count() << ": " << format.str() << std::endl;
+    logstream << ch::duration_cast<ch::milliseconds>(time).count() << ": "
+              << format.str() << std::endl;
     if (logstream.tellp() > MAX_LOG_SIZE) {
       logstream.close();
     }
   }
 }
 
-static void hidapi_log_input(unsigned char *buf, int len)
-{
+static void hidapi_log_input(unsigned char* buf, int len) {
   if (logstream) {
     std::ostringstream s;
 
@@ -109,8 +143,7 @@ static void hidapi_log_input(unsigned char *buf, int len)
   }
 }
 
-static std::string to_string(const wchar_t *wstr)
-{
+static std::string to_string(const wchar_t* wstr) {
   if (wstr) {
     std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> conv;
     return conv.to_bytes(wstr);
@@ -118,28 +151,26 @@ static std::string to_string(const wchar_t *wstr)
   return "<null>";
 }
 
-static const device_id *match_device(const struct hid_device_info *info)
-{
+static const device_id* match_device(const struct hid_device_info* info) {
   for (int idx = 0; device_ids[idx].name != nullptr; ++idx) {
-    if ((device_ids[idx].vendor_id == info->vendor_id) && (device_ids[idx].product_id == info->product_id)) {
+    if ((device_ids[idx].vendor_id == info->vendor_id) &&
+        (device_ids[idx].product_id == info->product_id)) {
       return &device_ids[idx];
     }
   }
   return nullptr;
 }
 
-HidApiInputDriver::HidApiInputDriver()
-{
+HidApiInputDriver::HidApiInputDriver() {
   name = "HidApiInputDriver";
 }
 
-void HidApiInputDriver::run()
-{
+void HidApiInputDriver::run() {
   hidapi_input(hid_dev);
 }
 
-void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf, unsigned int len)
-{
+void HidApiInputDriver::hidapi_decode_axis(const unsigned char* buf,
+                                           unsigned int len) {
   if ((buf[0] == 1 || buf[0] == 2) && len == 7) {
     // Values are in the range -10..10 at min. speed and -2595..2595
     // at max. speed.
@@ -153,13 +184,19 @@ void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf, unsigned in
     const double y = y_value / 350.0;
     const double z = z_value / 350.0;
     if (buf[0] == 1) {
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, x));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, y));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, z));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(0, x));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(1, y));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(2, z));
     } else {
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, x));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, y));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, z));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(3, x));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(4, y));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(5, z));
     }
   } else if (buf[0] == 1 && len == 13) {
     // Same as above, but all 6 axis is a single 13 byte HID message.
@@ -167,15 +204,15 @@ void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf, unsigned in
       const int16_t i = buf[2 * a + 1] | (buf[2 * a + 2] << 8);
       double val = (double)i / 350.0;
       if (std::fabs(val) > 0.01) {
-        InputEvent *event = new InputEventAxisChanged(a, val);
+        InputEvent* event = new InputEventAxisChanged(a, val);
         InputDriverManager::instance()->sendEvent(event);
       }
     }
   }
 }
 
-void HidApiInputDriver::hidapi_decode_button(const unsigned char *buf, unsigned int len)
-{
+void HidApiInputDriver::hidapi_decode_button(const unsigned char* buf,
+                                             unsigned int len) {
   if (buf[0] == 3 && len >= 3) {
     // Handle button events, on Linux the packet has a length of 3 but
     // on Windows the length is 13.
@@ -186,7 +223,7 @@ void HidApiInputDriver::hidapi_decode_button(const unsigned char *buf, unsigned
 
     for (int i = 0; i < 16; ++i) {
       if (bits_curr.test(i) != bits_last.test(i)) {
-        InputEvent *event = new InputEventButtonChanged(i, bits_curr.test(i));
+        InputEvent* event = new InputEventButtonChanged(i, bits_curr.test(i));
         InputDriverManager::instance()->sendEvent(event);
       }
     }
@@ -195,8 +232,7 @@ void HidApiInputDriver::hidapi_decode_button(const unsigned char *buf, unsigned
   }
 }
 
-void HidApiInputDriver::hidapi_input(hid_device *hid_dev)
-{
+void HidApiInputDriver::hidapi_input(hid_device* hid_dev) {
   unsigned char buf[BUFLEN];
   unsigned int len;
   while ((len = hid_read(hid_dev, buf, BUFLEN)) > 0) {
@@ -207,38 +243,44 @@ void HidApiInputDriver::hidapi_input(hid_device *hid_dev)
   hid_close(hid_dev);
 }
 
-std::pair<hid_device *, const struct device_id *> HidApiInputDriver::enumerate() const
-{
-  hid_device *ret_hid_dev = nullptr;
-  const struct device_id *ret_dev = nullptr;
+std::pair<hid_device*, const struct device_id*> HidApiInputDriver::enumerate()
+    const {
+  hid_device* ret_hid_dev = nullptr;
+  const struct device_id* ret_dev = nullptr;
 
   HIDAPI_LOG("Enumerating HID devices...");
-  struct hid_device_info *info = hid_enumerate(0, 0);
+  struct hid_device_info* info = hid_enumerate(0, 0);
   for (; info != nullptr; info = info->next) {
-    HIDAPI_LOGP("D: %04x:%04x | path = %s, serial = %s, manufacturer = %s, product = %s",
-                info->vendor_id % info->product_id % info->path
-                % to_string(info->serial_number)
-                % to_string(info->manufacturer_string)
-                % to_string(info->product_string));
-    const device_id *dev = match_device(info);
+    HIDAPI_LOGP(
+        "D: %04x:%04x | path = %s, serial = %s, manufacturer = %s, product = "
+        "%s",
+        info->vendor_id % info->product_id % info->path %
+            to_string(info->serial_number) %
+            to_string(info->manufacturer_string) %
+            to_string(info->product_string));
+    const device_id* dev = match_device(info);
     if (!dev) {
       continue;
     }
 
-    hid_device *hid_dev;
+    hid_device* hid_dev;
 
-    HIDAPI_LOGP("P: %04x:%04x | %s", info->vendor_id % info->product_id % info->path);
+    HIDAPI_LOGP("P: %04x:%04x | %s",
+                info->vendor_id % info->product_id % info->path);
     hid_dev = hid_open_path(info->path);
 
     if (!hid_dev) {
-      HIDAPI_LOGP("O: %04x:%04x | %s", info->vendor_id % info->product_id % to_string(info->serial_number));
-      hid_dev = hid_open(info->vendor_id, info->product_id, info->serial_number);
+      HIDAPI_LOGP("O: %04x:%04x | %s", info->vendor_id % info->product_id %
+                                           to_string(info->serial_number));
+      hid_dev =
+          hid_open(info->vendor_id, info->product_id, info->serial_number);
       if (!hid_dev) {
         continue;
       }
     }
 
-    HIDAPI_LOGP("R: %04x:%04x | %s", info->vendor_id % info->product_id % to_string(info->serial_number));
+    HIDAPI_LOGP("R: %04x:%04x | %s", info->vendor_id % info->product_id %
+                                         to_string(info->serial_number));
     unsigned char buf[BUFLEN];
     const int len = hid_read_timeout(hid_dev, buf, BUFLEN, 100);
     HIDAPI_LOGP("?: %d", len);
@@ -254,12 +296,12 @@ std::pair<hid_device *, const struct device_id *> HidApiInputDriver::enumerate()
     break;
   }
   hid_free_enumeration(info);
-  HIDAPI_LOGP("Done enumerating (status = %s).", (ret_hid_dev != nullptr ? "ok" : "failed"));
+  HIDAPI_LOGP("Done enumerating (status = %s).",
+              (ret_hid_dev != nullptr ? "ok" : "failed"));
   return {ret_hid_dev, ret_dev};
 }
 
-bool HidApiInputDriver::open()
-{
+bool HidApiInputDriver::open() {
   if (Settings::Settings::inputEnableDriverHIDAPILog.value()) {
     logtime = ch::system_clock::now();
     logstream.open(PlatformUtils::backupPath() + "/hidapi.log");
@@ -274,9 +316,8 @@ bool HidApiInputDriver::open()
 
   std::tie(this->hid_dev, this->dev) = enumerate();
   if (this->dev) {
-    name = STR(std::setfill('0'), std::setw(4), std::hex,
-               "HidApiInputDriver (", dev->vendor_id, ":", dev->product_id,
-               " - ", dev->name, ")");
+    name = STR(std::setfill('0'), std::setw(4), std::hex, "HidApiInputDriver (",
+               dev->vendor_id, ":", dev->product_id, " - ", dev->name, ")");
     start();
     HIDAPI_LOGP("HidApiInputDriver::open(): %s", name);
     return true;
@@ -286,8 +327,7 @@ bool HidApiInputDriver::open()
   return false;
 }
 
-void HidApiInputDriver::close()
-{
+void HidApiInputDriver::close() {
   this->dev = nullptr;
   this->hid_dev = nullptr;
   this->name = "HidApiInputDriver";
@@ -295,13 +335,11 @@ void HidApiInputDriver::close()
   logstream.close();
 }
 
-const std::string& HidApiInputDriver::get_name() const
-{
+const std::string& HidApiInputDriver::get_name() const {
   return name;
 }
 
-std::string HidApiInputDriver::get_info() const
-{
+std::string HidApiInputDriver::get_info() const {
   std::ostringstream stream;
   stream << get_name() << " ";
   if (isOpen()) {
diff --git a/src/gui/input/HidApiInputDriver.h b/src/gui/input/HidApiInputDriver.h
index 7bb8171c2..f361076fe 100644
--- a/src/gui/input/HidApiInputDriver.h
+++ b/src/gui/input/HidApiInputDriver.h
@@ -26,23 +26,22 @@
 
 #pragma once
 
+#include <hidapi.h>
 #include <cstddef>
 #include <string>
-#include <hidapi.h>
 
 #include "core/Settings.h"
 #include "gui/input/InputDriver.h"
 
-class HidApiInputDriver : public InputDriver
-{
+class HidApiInputDriver : public InputDriver {
   Q_OBJECT
 
   std::string name;
   unsigned int buttons{0};
-  hid_device *hid_dev{nullptr};
-  const struct device_id *dev {nullptr};
+  hid_device* hid_dev{nullptr};
+  const struct device_id* dev{nullptr};
 
-public:
+ public:
   HidApiInputDriver();
   void run() override;
   bool open() override;
@@ -51,25 +50,23 @@ public:
   const std::string& get_name() const override;
   std::string get_info() const override;
 
-  void hidapi_decode_axis(const unsigned char *buf, unsigned int len);
-  void hidapi_decode_button(const unsigned char *buf, unsigned int len);
+  void hidapi_decode_axis(const unsigned char* buf, unsigned int len);
+  void hidapi_decode_button(const unsigned char* buf, unsigned int len);
 
-  size_t getButtonCount() const override {
-    return Settings::max_buttons;
-  }
-  size_t getAxisCount() const override {
-    return Settings::max_axis;
-  }
+  size_t getButtonCount() const override { return Settings::max_buttons; }
+  size_t getAxisCount() const override { return Settings::max_axis; }
 
-private:
-  std::pair<hid_device *, const struct device_id *> enumerate() const;
-  void hidapi_input(hid_device *hid_dev);
+ private:
+  std::pair<hid_device*, const struct device_id*> enumerate() const;
+  void hidapi_input(hid_device* hid_dev);
 };
 
 struct device_id {
   int vendor_id;
   int product_id;
-  void (HidApiInputDriver::*axis_decoder)(const unsigned char *buf, unsigned int len);
-  void (HidApiInputDriver::*button_decoder)(const unsigned char *buf, unsigned int len);
-  const char *name;
+  void (HidApiInputDriver::*axis_decoder)(const unsigned char* buf,
+                                          unsigned int len);
+  void (HidApiInputDriver::*button_decoder)(const unsigned char* buf,
+                                            unsigned int len);
+  const char* name;
 };
diff --git a/src/gui/input/InputDriver.cc b/src/gui/input/InputDriver.cc
index 976e71585..1013cd186 100644
--- a/src/gui/input/InputDriver.cc
+++ b/src/gui/input/InputDriver.cc
@@ -27,19 +27,16 @@
 #include <QEvent>
 #include "gui/input/InputDriverEvent.h"
 
-const QEvent::Type InputEvent::eventType = static_cast<QEvent::Type>(QEvent::registerEventType());
+const QEvent::Type InputEvent::eventType =
+    static_cast<QEvent::Type>(QEvent::registerEventType());
 
-InputEvent::InputEvent(const bool activeOnly) : QEvent(eventType), activeOnly(activeOnly)
-{
+InputEvent::InputEvent(const bool activeOnly)
+    : QEvent(eventType), activeOnly(activeOnly) {}
 
-}
-
-bool InputDriver::isOpen() const
-{
+bool InputDriver::isOpen() const {
   return isRunning();
 }
 
-bool InputDriver::openOnce() const
-{
+bool InputDriver::openOnce() const {
   return false;
 }
diff --git a/src/gui/input/InputDriver.h b/src/gui/input/InputDriver.h
index cccde19d3..9e5495ffd 100644
--- a/src/gui/input/InputDriver.h
+++ b/src/gui/input/InputDriver.h
@@ -29,9 +29,8 @@
 #include <cstddef>
 #include <string>
 
-class InputDriver : public QThread
-{
-public:
+class InputDriver : public QThread {
+ public:
   InputDriver() = default;
 
   virtual const std::string& get_name() const = 0;
@@ -52,6 +51,6 @@ public:
    */
   virtual bool openOnce() const;
 
-  virtual size_t getButtonCount() const {return 0;}
-  virtual size_t getAxisCount() const {return 0;}
+  virtual size_t getButtonCount() const { return 0; }
+  virtual size_t getAxisCount() const { return 0; }
 };
diff --git a/src/gui/input/InputDriverEvent.h b/src/gui/input/InputDriverEvent.h
index db88c1d98..3b225624d 100644
--- a/src/gui/input/InputDriverEvent.h
+++ b/src/gui/input/InputDriverEvent.h
@@ -25,42 +25,38 @@
  */
 #pragma once
 
-#include <utility>
 #include <QEvent>
 #include <string>
+#include <utility>
 
-class InputEventHandler
-{
-public:
-
+class InputEventHandler {
+ public:
   virtual ~InputEventHandler() = default;
 
-  virtual void onAxisChanged(class InputEventAxisChanged *event) = 0;
-  virtual void onButtonChanged(class InputEventButtonChanged *event) = 0;
+  virtual void onAxisChanged(class InputEventAxisChanged* event) = 0;
+  virtual void onButtonChanged(class InputEventButtonChanged* event) = 0;
 
-  virtual void onTranslateEvent(class InputEventTranslate *event) = 0;
-  virtual void onRotateEvent(class InputEventRotate *event) = 0;
-  virtual void onRotate2Event(class InputEventRotate2 *event) = 0;
-  virtual void onActionEvent(class InputEventAction *event) = 0;
-  virtual void onZoomEvent(class InputEventZoom *event) = 0;
+  virtual void onTranslateEvent(class InputEventTranslate* event) = 0;
+  virtual void onRotateEvent(class InputEventRotate* event) = 0;
+  virtual void onRotate2Event(class InputEventRotate2* event) = 0;
+  virtual void onActionEvent(class InputEventAction* event) = 0;
+  virtual void onZoomEvent(class InputEventZoom* event) = 0;
 };
 
-class InputEvent : public QEvent
-{
-public:
+class InputEvent : public QEvent {
+ public:
   const bool activeOnly;
 
   InputEvent(const bool activeOnly = true);
 
-  virtual void deliver(InputEventHandler *receiver) = 0;
+  virtual void deliver(InputEventHandler* receiver) = 0;
 
   static const QEvent::Type eventType;
 };
 
-class GenericInputEvent : public InputEvent
-{
-public:
-  GenericInputEvent(const bool activeOnly = true) : InputEvent(activeOnly) { }
+class GenericInputEvent : public InputEvent {
+ public:
+  GenericInputEvent(const bool activeOnly = true) : InputEvent(activeOnly) {}
 };
 
 /**
@@ -68,16 +64,17 @@ public:
  * one axis. The value is assumed to be an absolute value in the
  * range -1.0 to 1.0.
  */
-class InputEventAxisChanged : public GenericInputEvent
-{
-public:
+class InputEventAxisChanged : public GenericInputEvent {
+ public:
   const unsigned int axis;
   const double value;
 
-  InputEventAxisChanged(const unsigned int axis, const double value, const bool activeOnly = true) : GenericInputEvent(activeOnly), axis(axis), value(value) { }
+  InputEventAxisChanged(const unsigned int axis,
+                        const double value,
+                        const bool activeOnly = true)
+      : GenericInputEvent(activeOnly), axis(axis), value(value) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler* receiver) override {
     receiver->onAxisChanged(this);
   }
 };
@@ -86,16 +83,17 @@ public:
  * Generic event for use by input drivers to report button press
  * and button release events.
  */
-class InputEventButtonChanged : public GenericInputEvent
-{
-public:
+class InputEventButtonChanged : public GenericInputEvent {
+ public:
   const unsigned int button;
   const bool down;
 
-  InputEventButtonChanged(const unsigned int button, const bool down, const bool activeOnly = true) : GenericInputEvent(activeOnly), button(button), down(down) { }
+  InputEventButtonChanged(const unsigned int button,
+                          const bool down,
+                          const bool activeOnly = true)
+      : GenericInputEvent(activeOnly), button(button), down(down) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler* receiver) override {
     receiver->onButtonChanged(this);
   }
 };
@@ -107,76 +105,90 @@ public:
  * type in the driver itself (e.g. the DBus driver uses this to report
  * calls to the translate method).
  */
-class InputEventTranslate : public InputEvent
-{
-public:
+class InputEventTranslate : public InputEvent {
+ public:
   const double x;
   const double y;
   const double z;
   const bool relative;
   const bool viewPortRelative;
-  InputEventTranslate(const double x, const double y, const double z, const bool relative = true, const bool viewPortRelative = false, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative), viewPortRelative(viewPortRelative) { }
-
-  void deliver(InputEventHandler *receiver) override
-  {
+  InputEventTranslate(const double x,
+                      const double y,
+                      const double z,
+                      const bool relative = true,
+                      const bool viewPortRelative = false,
+                      const bool activeOnly = true)
+      : InputEvent(activeOnly),
+        x(x),
+        y(y),
+        z(z),
+        relative(relative),
+        viewPortRelative(viewPortRelative) {}
+
+  void deliver(InputEventHandler* receiver) override {
     receiver->onTranslateEvent(this);
   }
 };
 
-class InputEventRotate : public InputEvent
-{
-public:
+class InputEventRotate : public InputEvent {
+ public:
   const double x;
   const double y;
   const double z;
   const bool relative;
 
-  InputEventRotate(const double x, const double y, const double z, const bool relative = true, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative) { }
+  InputEventRotate(const double x,
+                   const double y,
+                   const double z,
+                   const bool relative = true,
+                   const bool activeOnly = true)
+      : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler* receiver) override {
     receiver->onRotateEvent(this);
   }
 };
 
-class InputEventRotate2 : public InputEvent
-{
-public:
+class InputEventRotate2 : public InputEvent {
+ public:
   const double x;
   const double y;
   const double z;
 
-  InputEventRotate2(const double x, const double y, const double z, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z) { }
+  InputEventRotate2(const double x,
+                    const double y,
+                    const double z,
+                    const bool activeOnly = true)
+      : InputEvent(activeOnly), x(x), y(y), z(z) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler* receiver) override {
     receiver->onRotate2Event(this);
   }
 };
 
-class InputEventZoom : public InputEvent
-{
-public:
+class InputEventZoom : public InputEvent {
+ public:
   const double zoom;
   const bool relative;
 
-  InputEventZoom(const double zoom, const bool relative = true, const bool activeOnly = true) : InputEvent(activeOnly), zoom(zoom), relative(relative) { }
+  InputEventZoom(const double zoom,
+                 const bool relative = true,
+                 const bool activeOnly = true)
+      : InputEvent(activeOnly), zoom(zoom), relative(relative) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler* receiver) override {
     receiver->onZoomEvent(this);
   }
 };
 
-class InputEventAction : public InputEvent
-{
-public:
+class InputEventAction : public InputEvent {
+ public:
   const std::string action;
 
-  InputEventAction(std::string action, const bool activeOnly = true) : InputEvent(activeOnly), action(std::move(action)) { }
+  InputEventAction(std::string action, const bool activeOnly = true)
+      : InputEvent(activeOnly), action(std::move(action)) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler* receiver) override {
     receiver->onActionEvent(this);
   }
 };
diff --git a/src/gui/input/InputDriverManager.cc b/src/gui/input/InputDriverManager.cc
index 7d4d855bd..54a461cbe 100644
--- a/src/gui/input/InputDriverManager.cc
+++ b/src/gui/input/InputDriverManager.cc
@@ -25,50 +25,52 @@
  */
 #include "gui/input/InputDriverManager.h"
 
-#include "gui/input/InputDriverEvent.h"
-#include "gui/MainWindow.h"
+#include <QAction>
+#include <QApplication>
+#include <QCoreApplication>
 #include <QList>
+#include <QMenu>
 #include <QString>
 #include <QTimer>
 #include <algorithm>
+#include <cstddef>
 #include <list>
 #include <sstream>
-#include <QAction>
-#include <QMenu>
-#include <QApplication>
-#include <QCoreApplication>
-#include <cstddef>
 #include <string>
+#include "gui/MainWindow.h"
+#include "gui/input/InputDriverEvent.h"
 
-InputDriverManager *InputDriverManager::self = nullptr;
+InputDriverManager* InputDriverManager::self = nullptr;
 
 /**
  * This can be called from non-GUI context, so no Qt initialization is done
  * at this point.
  */
-InputDriverManager *InputDriverManager::instance()
-{
+InputDriverManager* InputDriverManager::instance() {
   if (!self) {
     self = new InputDriverManager();
   }
   return self;
 }
 
-void InputDriverManager::registerDriver(InputDriver *driver)
-{
+void InputDriverManager::registerDriver(InputDriver* driver) {
   this->drivers.push_back(driver);
 }
 
-void InputDriverManager::unregisterDriver(InputDriver *driver)
-{
+void InputDriverManager::unregisterDriver(InputDriver* driver) {
   this->drivers.remove(driver);
 }
 
-void InputDriverManager::registerActions(const QList<QAction *>& actions, const QString& parent, const QString& target)
-{
+void InputDriverManager::registerActions(const QList<QAction*>& actions,
+                                         const QString& parent,
+                                         const QString& target) {
   const QString emptyQString("");
   for (const auto action : actions) {
-    const auto description = ((parent == emptyQString) ? emptyQString : (parent + QString::fromUtf8(u8" \u2192 "))) + action->text();
+    const auto description =
+        ((parent == emptyQString)
+             ? emptyQString
+             : (parent + QString::fromUtf8(u8" \u2192 "))) +
+        action->text();
     if (!action->objectName().isEmpty()) {
       QString actionName = action->objectName();
       if ("" != target) {
@@ -82,18 +84,17 @@ void InputDriverManager::registerActions(const QList<QAction *>& actions, const
   }
 }
 
-void InputDriverManager::init()
-{
+void InputDriverManager::init() {
   timer = new QTimer(this);
-  connect(qApp, &QApplication::focusChanged, this, &InputDriverManager::onFocusChanged);
+  connect(qApp, &QApplication::focusChanged, this,
+          &InputDriverManager::onFocusChanged);
 
   doOpen(true);
   connect(timer, &QTimer::timeout, this, &InputDriverManager::onTimeout);
   timer->start(10 * 1000);
 }
 
-void InputDriverManager::onTimeout()
-{
+void InputDriverManager::onTimeout() {
   for (auto driver : drivers) {
     if (driver->openOnce()) {
       continue;
@@ -105,8 +106,7 @@ void InputDriverManager::onTimeout()
   doOpen(false);
 }
 
-void InputDriverManager::doOpen(bool firstOpen)
-{
+void InputDriverManager::doOpen(bool firstOpen) {
   for (auto driver : drivers) {
     if (driver->openOnce()) {
       continue;
@@ -125,10 +125,9 @@ void InputDriverManager::doOpen(bool firstOpen)
   }
 }
 
-std::string InputDriverManager::listDrivers() const
-{
+std::string InputDriverManager::listDrivers() const {
   std::ostringstream stream;
-  const char *sep = "";
+  const char* sep = "";
   for (auto driver : drivers) {
     stream << sep << driver->get_name();
     if (driver->isOpen()) {
@@ -139,10 +138,9 @@ std::string InputDriverManager::listDrivers() const
   return stream.str();
 }
 
-std::string InputDriverManager::listDriverInfos() const
-{
+std::string InputDriverManager::listDriverInfos() const {
   std::ostringstream stream;
-  const char *sep = "";
+  const char* sep = "";
   for (auto driver : drivers) {
     stream << sep << driver->get_info();
     sep = "\n";
@@ -150,8 +148,7 @@ std::string InputDriverManager::listDriverInfos() const
   return stream.str();
 }
 
-void InputDriverManager::closeDrivers()
-{
+void InputDriverManager::closeDrivers() {
   if (timer != nullptr) {
     timer->stop();
   }
@@ -162,61 +159,53 @@ void InputDriverManager::closeDrivers()
   }
 }
 
-void InputDriverManager::sendEvent(InputEvent *event)
-{
+void InputDriverManager::sendEvent(InputEvent* event) {
   event->deliver(&mapper);
 }
 
-void InputDriverManager::postEvent(InputEvent *event)
-{
-  QWidget *window = event->activeOnly ? QApplication::activeWindow() : currentWindow;
+void InputDriverManager::postEvent(InputEvent* event) {
+  QWidget* window =
+      event->activeOnly ? QApplication::activeWindow() : currentWindow;
   if (window) {
     QCoreApplication::postEvent(window, event);
   }
 }
 
-const std::list<ActionStruct>& InputDriverManager::getActions() const
-{
+const std::list<ActionStruct>& InputDriverManager::getActions() const {
   return actions;
 }
 
-QList<double> InputDriverManager::getTranslation() const
-{
-  const MainWindow *window = currentWindow;
+QList<double> InputDriverManager::getTranslation() const {
+  const MainWindow* window = currentWindow;
   if (window) {
     return window->getTranslation();
   }
   return QList<double>({0.0, 0.0, 0.0});
 }
 
-QList<double> InputDriverManager::getRotation() const
-{
-  const MainWindow *window = currentWindow;
+QList<double> InputDriverManager::getRotation() const {
+  const MainWindow* window = currentWindow;
   if (window) {
     return window->getRotation();
   }
   return QList<double>({0.0, 0.0, 0.0});
 }
 
-void InputDriverManager::onFocusChanged(QWidget *, QWidget *current)
-{
+void InputDriverManager::onFocusChanged(QWidget*, QWidget* current) {
   if (current) {
-    currentWindow = dynamic_cast<MainWindow *>(current->window());
+    currentWindow = dynamic_cast<MainWindow*>(current->window());
   }
 }
 
-void InputDriverManager::onInputMappingUpdated()
-{
+void InputDriverManager::onInputMappingUpdated() {
   mapper.onInputMappingUpdated();
 }
 
-void InputDriverManager::onInputCalibrationUpdated()
-{
+void InputDriverManager::onInputCalibrationUpdated() {
   mapper.onInputCalibrationUpdated();
 }
 
-void InputDriverManager::onInputGainUpdated()
-{
+void InputDriverManager::onInputGainUpdated() {
   mapper.onInputGainUpdated();
 }
 
diff --git a/src/gui/input/InputDriverManager.h b/src/gui/input/InputDriverManager.h
index 6e7f42d6d..60f33b1ed 100644
--- a/src/gui/input/InputDriverManager.h
+++ b/src/gui/input/InputDriverManager.h
@@ -25,14 +25,14 @@
  */
 #pragma once
 
+#include <QIcon>
 #include <QList>
 #include <QObject>
 #include <QString>
-#include <list>
-#include <QWidget>
 #include <QThread>
 #include <QTimer>
-#include <QIcon>
+#include <QWidget>
+#include <list>
 
 #include <cstddef>
 #include <string>
@@ -48,11 +48,10 @@ struct ActionStruct {
   QIcon icon;
 };
 
-class InputDriverManager : public QObject
-{
+class InputDriverManager : public QObject {
   Q_OBJECT
-private:
-  using drivers_t = std::list<InputDriver *>;
+ private:
+  using drivers_t = std::list<InputDriver*>;
 
   drivers_t drivers;
 
@@ -60,28 +59,30 @@ private:
 
   InputEventMapper mapper;
 
-  MainWindow *currentWindow{nullptr};
+  MainWindow* currentWindow{nullptr};
 
-  QTimer *timer{nullptr};
+  QTimer* timer{nullptr};
 
-  static InputDriverManager *self;
+  static InputDriverManager* self;
 
-  void postEvent(InputEvent *event);
+  void postEvent(InputEvent* event);
 
-public:
+ public:
   InputDriverManager() = default;
 
-  void sendEvent(InputEvent *event);
+  void sendEvent(InputEvent* event);
 
   void init();
   std::string listDrivers() const;
   std::string listDriverInfos() const;
-  void registerDriver(InputDriver *driver);
-  void unregisterDriver(InputDriver *driver);
+  void registerDriver(InputDriver* driver);
+  void unregisterDriver(InputDriver* driver);
   void closeDrivers();
-  void registerActions(const QList<QAction *>& actions, const QString& parent = QString(""), const QString& target = QString(""));
+  void registerActions(const QList<QAction*>& actions,
+                       const QString& parent = QString(""),
+                       const QString& target = QString(""));
 
-  static InputDriverManager *instance();
+  static InputDriverManager* instance();
 
   const std::list<ActionStruct>& getActions() const;
   QList<double> getTranslation() const;
@@ -90,15 +91,15 @@ public:
   size_t getButtonCount() const;
   size_t getAxisCount() const;
 
-public slots:
+ public slots:
   void onInputMappingUpdated();
   void onInputCalibrationUpdated();
   void onInputGainUpdated();
 
-private slots:
+ private slots:
   void onTimeout();
   void doOpen(bool firstOpen);
-  void onFocusChanged(QWidget *, QWidget *);
+  void onFocusChanged(QWidget*, QWidget*);
 
   friend class InputEventMapper;
 };
diff --git a/src/gui/input/InputEventMapper.cc b/src/gui/input/InputEventMapper.cc
index ecc0a99e6..f603ddd3c 100644
--- a/src/gui/input/InputEventMapper.cc
+++ b/src/gui/input/InputEventMapper.cc
@@ -24,25 +24,24 @@
  *
  */
 #include "gui/input/InputEventMapper.h"
-#include "gui/input/InputDriverManager.h"
-#include "core/Settings.h"
-#include "gui/Preferences.h"
-#include "gui/input/AxisConfigWidget.h"
-#include "gui/input/ButtonConfigWidget.h"
-#include <array>
 #include <QMetaObject>
+#include <QSettings>
 #include <QTimer>
+#include <array>
+#include <cmath>
 #include <cstddef>
 #include <string>
-#include <cmath>
-#include <QSettings>
+#include "core/Settings.h"
+#include "gui/Preferences.h"
+#include "gui/input/AxisConfigWidget.h"
+#include "gui/input/ButtonConfigWidget.h"
+#include "gui/input/InputDriverManager.h"
 
 using S = Settings::Settings;
 
-InputEventMapper *InputEventMapper::self = nullptr;
+InputEventMapper* InputEventMapper::self = nullptr;
 
-InputEventMapper::InputEventMapper()
-{
+InputEventMapper::InputEventMapper() {
   stopRequest = false;
 
   for (size_t a = 0; a < getMaxAxis(); ++a) {
@@ -72,8 +71,7 @@ InputEventMapper::InputEventMapper()
   self = this;
 }
 
-InputEventMapper *InputEventMapper::instance()
-{
+InputEventMapper* InputEventMapper::instance() {
   if (!self) {
     self = new InputEventMapper();
   }
@@ -85,41 +83,40 @@ InputEventMapper *InputEventMapper::instance()
     0 -> 0
     1 ->  10.72
  */
-double InputEventMapper::scale(double val)
-{
+double InputEventMapper::scale(double val) {
   double x = 4 * val;
   double xx = x < 0 ? -exp(-x) + 1 : exp(x) - 1;
   return xx / 5.0;
 }
 
-double InputEventMapper::getAxisValue(int config)
-{
-  if (config == 0)    // avoid indexing by -1 when using default settings (and causing bizarre behavior)
+double InputEventMapper::getAxisValue(int config) {
+  if (config == 0)  // avoid indexing by -1 when using default settings (and
+                    // causing bizarre behavior)
     return scale(0);
 
   int idx = abs(config) - 1;
-  if (idx > 8)        // avoid reading over end of arrays (and causing segfaults)
+  if (idx > 8)  // avoid reading over end of arrays (and causing segfaults)
     return scale(0);
 
   bool neg = config < 0;
   double trimmedVal = axisRawValue[idx] + axisTrimValue[idx];
   double val = neg ? -trimmedVal : trimmedVal;
-  if (val < axisDeadzone[idx] and - val < axisDeadzone[idx]) {
+  if (val < axisDeadzone[idx] and -val < axisDeadzone[idx]) {
     val = 0;
   }
   return scale(val);
 }
 
-bool InputEventMapper::generateDeferredEvents()
-{
+bool InputEventMapper::generateDeferredEvents() {
   bool any = false;
   const double threshold = 0.01;
 
   double tx = getAxisValue(translate[0]) * translationGain;
   double ty = getAxisValue(translate[1]) * translationGain;
   double tz = getAxisValue(translate[2]) * translationGain;
-  if ((fabs(tx) > threshold) || (fabs(ty) > threshold) || (fabs(tz) > threshold)) {
-    InputEvent *inputEvent = new InputEventTranslate(tx, ty, tz);
+  if ((fabs(tx) > threshold) || (fabs(ty) > threshold) ||
+      (fabs(tz) > threshold)) {
+    InputEvent* inputEvent = new InputEventTranslate(tx, ty, tz);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
   }
@@ -127,8 +124,10 @@ bool InputEventMapper::generateDeferredEvents()
   double txVPRel = getAxisValue(translate[3]) * translationVPRelGain;
   double tyVPRel = getAxisValue(translate[4]) * translationVPRelGain;
   double tzVPRel = getAxisValue(translate[5]) * translationVPRelGain;
-  if ((fabs(txVPRel) > threshold) || (fabs(tyVPRel) > threshold) || (fabs(tzVPRel) > threshold)) {
-    InputEvent *inputEvent = new InputEventTranslate(txVPRel, tyVPRel, tzVPRel, true, true, false);
+  if ((fabs(txVPRel) > threshold) || (fabs(tyVPRel) > threshold) ||
+      (fabs(tzVPRel) > threshold)) {
+    InputEvent* inputEvent =
+        new InputEventTranslate(txVPRel, tyVPRel, tzVPRel, true, true, false);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
   }
@@ -136,8 +135,9 @@ bool InputEventMapper::generateDeferredEvents()
   double rx = getAxisValue(rotate[0]) * rotateGain;
   double ry = getAxisValue(rotate[1]) * rotateGain;
   double rz = getAxisValue(rotate[2]) * rotateGain;
-  if ((fabs(rx) > threshold) || (fabs(ry) > threshold) || (fabs(rz) > threshold)) {
-    InputEvent *inputEvent = new InputEventRotate(rx, ry, rz);
+  if ((fabs(rx) > threshold) || (fabs(ry) > threshold) ||
+      (fabs(rz) > threshold)) {
+    InputEvent* inputEvent = new InputEventRotate(rx, ry, rz);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
   }
@@ -145,15 +145,16 @@ bool InputEventMapper::generateDeferredEvents()
   double rxVPRel = getAxisValue(rotate[3]) * rotateVPRelGain;
   double ryVPRel = getAxisValue(rotate[4]) * rotateVPRelGain;
   double rzVPRel = getAxisValue(rotate[5]) * rotateVPRelGain;
-  if ((fabs(rxVPRel) > threshold) || (fabs(ryVPRel) > threshold) || (fabs(rzVPRel) > threshold)) {
-    InputEvent *inputEvent = new InputEventRotate2(rxVPRel, ryVPRel, rzVPRel);
+  if ((fabs(rxVPRel) > threshold) || (fabs(ryVPRel) > threshold) ||
+      (fabs(rzVPRel) > threshold)) {
+    InputEvent* inputEvent = new InputEventRotate2(rxVPRel, ryVPRel, rzVPRel);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
   }
 
   double z = (getAxisValue(zoom) + getAxisValue(zoom2)) * zoomGain;
   if (fabs(z) > threshold) {
-    InputEvent *inputEvent = new InputEventZoom(z);
+    InputEvent* inputEvent = new InputEventZoom(z);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
   }
@@ -161,26 +162,28 @@ bool InputEventMapper::generateDeferredEvents()
   return any;
 }
 
-void InputEventMapper::considerGeneratingDeferredEvents()
-{
+void InputEventMapper::considerGeneratingDeferredEvents() {
   if (!timer->isActive()) {
-    QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection, Q_ARG(int, 30));
+    QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection,
+                              Q_ARG(int, 30));
   }
 }
 
-void InputEventMapper::onTimer()
-{
+void InputEventMapper::onTimer() {
   bool generated_any_events = generateDeferredEvents();
 
-  //update the UI on time, NOT on event as a joystick can fire a high rate of events
+  // update the UI on time, NOT on event as a joystick can fire a high rate of
+  // events
   for (size_t i = 0; i < getMaxButtons(); ++i) {
     if (button_state[i] != button_state_last[i]) {
       button_state_last[i] = button_state[i];
-      GlobalPreferences::inst()->ButtonConfig->updateButtonState(i, button_state[i]);
+      GlobalPreferences::inst()->ButtonConfig->updateButtonState(
+          i, button_state[i]);
     }
   }
   for (size_t i = 0; i < getMaxAxis(); ++i) {
-    GlobalPreferences::inst()->AxisConfig->AxesChanged(i, axisRawValue[i] + axisTrimValue[i]);
+    GlobalPreferences::inst()->AxisConfig->AxesChanged(
+        i, axisRawValue[i] + axisTrimValue[i]);
   }
 
   if (!generated_any_events) {
@@ -190,14 +193,12 @@ void InputEventMapper::onTimer()
   }
 }
 
-void InputEventMapper::onAxisChanged(InputEventAxisChanged *event)
-{
+void InputEventMapper::onAxisChanged(InputEventAxisChanged* event) {
   axisRawValue[event->axis] = event->value;
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onButtonChanged(InputEventButtonChanged *event)
-{
+void InputEventMapper::onButtonChanged(InputEventButtonChanged* event) {
   unsigned int button = event->button;
 
   if (button < getMaxButtons()) {
@@ -213,58 +214,57 @@ void InputEventMapper::onButtonChanged(InputEventButtonChanged *event)
 
     std::string action = actions[event->button].toStdString();
     if (!action.empty()) {
-      InputEvent *inputEvent = new InputEventAction(action, false);
+      InputEvent* inputEvent = new InputEventAction(action, false);
       InputDriverManager::instance()->postEvent(inputEvent);
     }
   }
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onTranslateEvent(InputEventTranslate *event)
-{
+void InputEventMapper::onTranslateEvent(InputEventTranslate* event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-void InputEventMapper::onRotateEvent(InputEventRotate *event)
-{
+void InputEventMapper::onRotateEvent(InputEventRotate* event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-void InputEventMapper::onRotate2Event(InputEventRotate2 *event)
-{
+void InputEventMapper::onRotate2Event(InputEventRotate2* event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-void InputEventMapper::onActionEvent(InputEventAction *event)
-{
+void InputEventMapper::onActionEvent(InputEventAction* event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-void InputEventMapper::onZoomEvent(InputEventZoom *event)
-{
+void InputEventMapper::onZoomEvent(InputEventZoom* event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-int InputEventMapper::parseSettingValue(const std::string& val)
-{
+int InputEventMapper::parseSettingValue(const std::string& val) {
   if (val.length() != 2) {
     return 0;
   }
   return atoi(val.c_str());
 }
 
-void InputEventMapper::onInputMappingUpdated()
-{
+void InputEventMapper::onInputMappingUpdated() {
   for (size_t i = 0; i < getMaxButtons(); ++i) {
     actions[i] = QString::fromStdString(inputButtonSettings(i).value());
   }
 
-  translate[0] = parseSettingValue(Settings::Settings::inputTranslationX.value());
-  translate[1] = parseSettingValue(Settings::Settings::inputTranslationY.value());
-  translate[2] = parseSettingValue(Settings::Settings::inputTranslationZ.value());
-  translate[3] = parseSettingValue(Settings::Settings::inputTranslationXVPRel.value());
-  translate[4] = parseSettingValue(Settings::Settings::inputTranslationYVPRel.value());
-  translate[5] = parseSettingValue(Settings::Settings::inputTranslationZVPRel.value());
+  translate[0] =
+      parseSettingValue(Settings::Settings::inputTranslationX.value());
+  translate[1] =
+      parseSettingValue(Settings::Settings::inputTranslationY.value());
+  translate[2] =
+      parseSettingValue(Settings::Settings::inputTranslationZ.value());
+  translate[3] =
+      parseSettingValue(Settings::Settings::inputTranslationXVPRel.value());
+  translate[4] =
+      parseSettingValue(Settings::Settings::inputTranslationYVPRel.value());
+  translate[5] =
+      parseSettingValue(Settings::Settings::inputTranslationZVPRel.value());
   rotate[0] = parseSettingValue(Settings::Settings::inputRotateX.value());
   rotate[1] = parseSettingValue(Settings::Settings::inputRotateY.value());
   rotate[2] = parseSettingValue(Settings::Settings::inputRotateZ.value());
@@ -276,8 +276,7 @@ void InputEventMapper::onInputMappingUpdated()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onInputGainUpdated()
-{
+void InputEventMapper::onInputGainUpdated() {
   translationGain = Settings::Settings::inputTranslationGain.value();
   translationVPRelGain = Settings::Settings::inputTranslationVPRelGain.value();
   rotateGain = Settings::Settings::inputRotateGain.value();
@@ -287,8 +286,7 @@ void InputEventMapper::onInputGainUpdated()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onInputCalibrationUpdated()
-{
+void InputEventMapper::onInputCalibrationUpdated() {
   for (size_t i = 0; i < getMaxAxis(); ++i) {
     axisTrimValue[i] = axisTrimSettings(i).value();
     axisDeadzone[i] = axisDeadzoneSettings(i).value();
@@ -296,8 +294,7 @@ void InputEventMapper::onInputCalibrationUpdated()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onAxisAutoTrim()
-{
+void InputEventMapper::onAxisAutoTrim() {
   for (size_t i = 0; i < getMaxAxis(); ++i) {
     axisTrimValue[i] = -axisRawValue[i];
     axisTrimSettings(i).setValue(axisTrimValue[i]);
@@ -305,8 +302,7 @@ void InputEventMapper::onAxisAutoTrim()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onAxisTrimReset()
-{
+void InputEventMapper::onAxisTrimReset() {
   for (size_t i = 0; i < getMaxAxis(); ++i) {
     axisTrimValue[i] = 0.00;
     axisTrimSettings(i).setValue(axisTrimValue[i]);
@@ -314,44 +310,40 @@ void InputEventMapper::onAxisTrimReset()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::stop(){
+void InputEventMapper::stop() {
   stopRequest = true;
   timer->stop();
 }
 
-Settings::SettingsEntryString& InputEventMapper::inputButtonSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryString *, getMaxButtons()> entries {
-    &S::inputButton0,  &S::inputButton1,  &S::inputButton2,  &S::inputButton3,
-    &S::inputButton4,  &S::inputButton5,  &S::inputButton6,  &S::inputButton7,
-    &S::inputButton8,  &S::inputButton9,  &S::inputButton10, &S::inputButton11,
-    &S::inputButton12, &S::inputButton13, &S::inputButton14, &S::inputButton15,
-    &S::inputButton16, &S::inputButton17, &S::inputButton18, &S::inputButton19,
-    &S::inputButton20, &S::inputButton21, &S::inputButton22, &S::inputButton23
-  };
+Settings::SettingsEntryString& InputEventMapper::inputButtonSettings(
+    size_t id) {
+  const std::array<Settings::SettingsEntryString*, getMaxButtons()> entries{
+      &S::inputButton0,  &S::inputButton1,  &S::inputButton2,
+      &S::inputButton3,  &S::inputButton4,  &S::inputButton5,
+      &S::inputButton6,  &S::inputButton7,  &S::inputButton8,
+      &S::inputButton9,  &S::inputButton10, &S::inputButton11,
+      &S::inputButton12, &S::inputButton13, &S::inputButton14,
+      &S::inputButton15, &S::inputButton16, &S::inputButton17,
+      &S::inputButton18, &S::inputButton19, &S::inputButton20,
+      &S::inputButton21, &S::inputButton22, &S::inputButton23};
   assert(id >= 0 && id < entries.size());
   return *entries[id];
 }
 
-Settings::SettingsEntryDouble& InputEventMapper::axisTrimSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryDouble *, getMaxAxis()> entries {
-    &S::axisTrim0, &S::axisTrim1, &S::axisTrim2,
-    &S::axisTrim3, &S::axisTrim4, &S::axisTrim5,
-    &S::axisTrim6, &S::axisTrim7, &S::axisTrim8
-  };
+Settings::SettingsEntryDouble& InputEventMapper::axisTrimSettings(size_t id) {
+  const std::array<Settings::SettingsEntryDouble*, getMaxAxis()> entries{
+      &S::axisTrim0, &S::axisTrim1, &S::axisTrim2, &S::axisTrim3, &S::axisTrim4,
+      &S::axisTrim5, &S::axisTrim6, &S::axisTrim7, &S::axisTrim8};
   assert(id >= 0 && id < entries.size());
   return *entries[id];
 }
 
-Settings::SettingsEntryDouble& InputEventMapper::axisDeadzoneSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryDouble *, getMaxAxis()> entries {
-    &S::axisDeadzone0, &S::axisDeadzone1, &S::axisDeadzone2,
-    &S::axisDeadzone3, &S::axisDeadzone4, &S::axisDeadzone5,
-    &S::axisDeadzone6, &S::axisDeadzone7, &S::axisDeadzone8
-  };
+Settings::SettingsEntryDouble& InputEventMapper::axisDeadzoneSettings(
+    size_t id) {
+  const std::array<Settings::SettingsEntryDouble*, getMaxAxis()> entries{
+      &S::axisDeadzone0, &S::axisDeadzone1, &S::axisDeadzone2,
+      &S::axisDeadzone3, &S::axisDeadzone4, &S::axisDeadzone5,
+      &S::axisDeadzone6, &S::axisDeadzone7, &S::axisDeadzone8};
   assert(id >= 0 && id < entries.size());
   return *entries[id];
 }
-
diff --git a/src/gui/input/InputEventMapper.h b/src/gui/input/InputEventMapper.h
index 6d53613a5..003058230 100644
--- a/src/gui/input/InputEventMapper.h
+++ b/src/gui/input/InputEventMapper.h
@@ -25,24 +25,25 @@
  */
 #pragma once
 
-#include <QTimer>
 #include <QObject>
+#include <QTimer>
 
 #include <cstddef>
 #include <string>
 #include "core/Settings.h"
 #include "gui/input/InputDriverEvent.h"
 
-class InputEventMapper : public QObject, public InputEventHandler
-{
+class InputEventMapper : public QObject, public InputEventHandler {
   Q_OBJECT
 
-public:
-  constexpr static inline size_t getMaxButtons() { return Settings::max_buttons; }
+ public:
+  constexpr static inline size_t getMaxButtons() {
+    return Settings::max_buttons;
+  }
   constexpr static inline size_t getMaxAxis() { return Settings::max_axis; }
 
-private:
-  QTimer *timer;
+ private:
+  QTimer* timer;
   double axisRawValue[Settings::max_axis];
   double axisTrimValue[Settings::max_axis];
   double axisDeadzone[Settings::max_axis];
@@ -61,7 +62,7 @@ private:
   bool button_state[Settings::max_buttons];
   bool button_state_last[Settings::max_buttons];
 
-  static InputEventMapper *self;
+  static InputEventMapper* self;
 
   double translationGain;
   double translationVPRelGain;
@@ -69,19 +70,19 @@ private:
   double rotateVPRelGain;
   double zoomGain;
 
-public:
+ public:
   InputEventMapper();
 
   void stop();
 
-  void onAxisChanged(class InputEventAxisChanged *event) override;
-  void onButtonChanged(class InputEventButtonChanged *event) override;
+  void onAxisChanged(class InputEventAxisChanged* event) override;
+  void onButtonChanged(class InputEventButtonChanged* event) override;
 
-  void onTranslateEvent(class InputEventTranslate *event) override;
-  void onRotateEvent(class InputEventRotate *event) override;
-  void onRotate2Event(class InputEventRotate2 *event) override;
-  void onActionEvent(class InputEventAction *event) override;
-  void onZoomEvent(class InputEventZoom *event) override;
+  void onTranslateEvent(class InputEventTranslate* event) override;
+  void onRotateEvent(class InputEventRotate* event) override;
+  void onRotate2Event(class InputEventRotate2* event) override;
+  void onActionEvent(class InputEventAction* event) override;
+  void onZoomEvent(class InputEventZoom* event) override;
 
   void onInputMappingUpdated();
   void onInputCalibrationUpdated();
@@ -90,12 +91,12 @@ public:
   void onAxisAutoTrim();
   void onAxisTrimReset();
 
-  static InputEventMapper *instance();
+  static InputEventMapper* instance();
 
   static Settings::SettingsEntryString& inputButtonSettings(size_t id);
   static Settings::SettingsEntryDouble& axisTrimSettings(size_t id);
   static Settings::SettingsEntryDouble& axisDeadzoneSettings(size_t id);
 
-private slots:
+ private slots:
   void onTimer();
 };
diff --git a/src/gui/input/JoystickInputDriver.cc b/src/gui/input/JoystickInputDriver.cc
index 99b081567..09fdf48c3 100644
--- a/src/gui/input/JoystickInputDriver.cc
+++ b/src/gui/input/JoystickInputDriver.cc
@@ -25,22 +25,21 @@
  */
 #include "gui/input/JoystickInputDriver.h"
 
-#include <string>
 #include <fcntl.h>
-#include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 #include <boost/format.hpp>
+#include <string>
 #include <utility>
 
 #include "gui/input/InputDriverManager.h"
 #include "utils/printutils.h"
 
-#include <unistd.h>
 #include <linux/input.h>
 #include <linux/joystick.h>
+#include <unistd.h>
 
-void JoystickInputDriver::run()
-{
+void JoystickInputDriver::run() {
   struct js_event js;
 
   while (!stopRequest) {
@@ -52,19 +51,20 @@ void JoystickInputDriver::run()
       continue;
     }
     switch (js.type & ~JS_EVENT_INIT) {
-    case JS_EVENT_BUTTON:
-      InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(js.number, js.value != 0));
-      break;
-    case JS_EVENT_AXIS:
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(js.number, js.value / 32767.0));
-      break;
+      case JS_EVENT_BUTTON:
+        InputDriverManager::instance()->sendEvent(
+            new InputEventButtonChanged(js.number, js.value != 0));
+        break;
+      case JS_EVENT_AXIS:
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(js.number, js.value / 32767.0));
+        break;
     }
   }
   ::close(fd);
 }
 
-bool JoystickInputDriver::open()
-{
+bool JoystickInputDriver::open() {
   stopRequest = false;
 
   auto path = boost::format("/dev/input/js%d") % this->nr;
@@ -88,28 +88,21 @@ bool JoystickInputDriver::open()
   return true;
 }
 
-void JoystickInputDriver::close()
-{
+void JoystickInputDriver::close() {
   stopRequest = true;
 }
 
-const std::string& JoystickInputDriver::get_name() const
-{
+const std::string& JoystickInputDriver::get_name() const {
   static std::string name = "JoystickInputDriver";
   return name;
 }
 
-std::string JoystickInputDriver::get_info() const
-{
-  return STR(
-    get_name(), " ", (isOpen() ? "open" : "not open"), " ",
-    "Name: ", name, " ",
-    "Axis: ", (int) axes, " ",
-    "Buttons: ", (int) buttons, " "
-    );
+std::string JoystickInputDriver::get_info() const {
+  return STR(get_name(), " ", (isOpen() ? "open" : "not open"), " ",
+             "Name: ", name, " ", "Axis: ", (int)axes, " ",
+             "Buttons: ", (int)buttons, " ");
 }
 
-void JoystickInputDriver::setJoystickNr(std::string jnr)
-{
+void JoystickInputDriver::setJoystickNr(std::string jnr) {
   this->nr = std::move(jnr);
 }
diff --git a/src/gui/input/JoystickInputDriver.h b/src/gui/input/JoystickInputDriver.h
index ebe97ce84..b8860be70 100644
--- a/src/gui/input/JoystickInputDriver.h
+++ b/src/gui/input/JoystickInputDriver.h
@@ -30,9 +30,8 @@
 #include <cstddef>
 #include <string>
 
-class JoystickInputDriver : public InputDriver
-{
-public:
+class JoystickInputDriver : public InputDriver {
+ public:
   JoystickInputDriver() = default;
   void run() override;
   bool open() override;
@@ -41,14 +40,10 @@ public:
   std::string get_info() const override;
   void setJoystickNr(std::string jnr);
 
-  size_t getButtonCount() const override {
-    return buttons;
-  }
-  size_t getAxisCount() const override {
-    return axes;
-  }
+  size_t getButtonCount() const override { return buttons; }
+  size_t getAxisCount() const override { return axes; }
 
-private:
+ private:
   int fd{-1};
   int version{0};
   std::string nr{"0"};
diff --git a/src/gui/input/QGamepadInputDriver.cc b/src/gui/input/QGamepadInputDriver.cc
index d2c27a7d2..9eec197c1 100644
--- a/src/gui/input/QGamepadInputDriver.cc
+++ b/src/gui/input/QGamepadInputDriver.cc
@@ -30,16 +30,11 @@
 
 #include <string>
 
-void QGamepadInputDriver::run()
-{
-}
+void QGamepadInputDriver::run() {}
 
-QGamepadInputDriver::QGamepadInputDriver() : gamepad(nullptr)
-{
-}
+QGamepadInputDriver::QGamepadInputDriver() : gamepad(nullptr) {}
 
-bool QGamepadInputDriver::open()
-{
+bool QGamepadInputDriver::open() {
   if (gamepad) {
     return false;
   }
@@ -51,99 +46,139 @@ bool QGamepadInputDriver::open()
 
   this->gamepad.reset(new QGamepad(*gamepads.begin(), this));
 
-  connect(this->gamepad.get(), &QGamepad::axisLeftXChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::axisLeftYChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::axisRightXChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::axisRightYChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonL2Changed, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonR2Changed, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, value));
-  });
-
-  connect(this->gamepad.get(), &QGamepad::buttonAChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(0, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonBChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(1, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonXChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(2, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonYChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(3, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonL1Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(4, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonR1Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(5, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonSelectChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(6, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonStartChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(7, pressed));
-  });
-
-  connect(this->gamepad.get(), &QGamepad::buttonL3Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(8, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonR3Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(9, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonCenterChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(10, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonUpChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(11, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonDownChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(12, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonLeftChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(13, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonRightChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(14, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonGuideChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(15, pressed));
-  });
+  connect(this->gamepad.get(), &QGamepad::axisLeftXChanged, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(0, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::axisLeftYChanged, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(1, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::axisRightXChanged, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(2, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::axisRightYChanged, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(3, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonL2Changed, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(4, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonR2Changed, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(5, value));
+          });
+
+  connect(this->gamepad.get(), &QGamepad::buttonAChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(0, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonBChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(1, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonXChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(2, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonYChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(3, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonL1Changed, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(4, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonR1Changed, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(5, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonSelectChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(6, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonStartChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(7, pressed));
+          });
+
+  connect(this->gamepad.get(), &QGamepad::buttonL3Changed, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(8, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonR3Changed, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(9, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonCenterChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(10, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonUpChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(11, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonDownChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(12, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonLeftChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(13, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonRightChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(14, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonGuideChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(15, pressed));
+          });
 
   return true;
 }
 
-void QGamepadInputDriver::close()
-{
+void QGamepadInputDriver::close() {
   gamepad.reset();
 }
 
-const std::string& QGamepadInputDriver::get_name() const
-{
+const std::string& QGamepadInputDriver::get_name() const {
   static std::string name = "QGamepadInputDriver";
   return name;
 }
 
-bool QGamepadInputDriver::isOpen() const
-{
+bool QGamepadInputDriver::isOpen() const {
   return this->gamepad ? this->gamepad->isConnected() : false;
 }
 
-std::string QGamepadInputDriver::get_info() const
-{
-  const auto status = isOpen()
-      ? std::string{"connected: "} + this->gamepad->name().toUtf8().constData()
-      : std::string{"not connected"};
+std::string QGamepadInputDriver::get_info() const {
+  const auto status = isOpen() ? std::string{"connected: "} +
+                                     this->gamepad->name().toUtf8().constData()
+                               : std::string{"not connected"};
 
   return get_name() + " " + status;
 }
diff --git a/src/gui/input/QGamepadInputDriver.h b/src/gui/input/QGamepadInputDriver.h
index a41fd425f..31afa2bc4 100644
--- a/src/gui/input/QGamepadInputDriver.h
+++ b/src/gui/input/QGamepadInputDriver.h
@@ -28,13 +28,12 @@
 #include "core/Settings.h"
 #include "gui/input/InputDriver.h"
 
+#include <QtGamepad/QGamepad>
 #include <cstddef>
 #include <string>
-#include <QtGamepad/QGamepad>
 
-class QGamepadInputDriver : public InputDriver
-{
-public:
+class QGamepadInputDriver : public InputDriver {
+ public:
   QGamepadInputDriver();
   void run() override;
   bool open() override;
@@ -44,13 +43,9 @@ public:
   const std::string& get_name() const override;
   std::string get_info() const override;
 
-  size_t getButtonCount() const override {
-    return Settings::max_buttons;
-  }
-  size_t getAxisCount() const override {
-    return Settings::max_axis;
-  }
+  size_t getButtonCount() const override { return Settings::max_buttons; }
+  size_t getAxisCount() const override { return Settings::max_axis; }
 
-private:
+ private:
   std::unique_ptr<QGamepad> gamepad;
 };
diff --git a/src/gui/input/SpaceNavInputDriver.cc b/src/gui/input/SpaceNavInputDriver.cc
index c55959c24..c3e3675df 100644
--- a/src/gui/input/SpaceNavInputDriver.cc
+++ b/src/gui/input/SpaceNavInputDriver.cc
@@ -33,13 +33,12 @@
 #include "gui/input/InputDriverManager.h"
 #include "utils/printutils.h"
 
-#include <QThread>
 #include <spnav.h>
 #include <unistd.h>
+#include <QThread>
 #include <string>
 
-void SpaceNavInputDriver::run()
-{
+void SpaceNavInputDriver::run() {
   while (spnav_input()) {
     QThread::msleep(20);
     spnav_remove_events(SPNAV_EVENT_MOTION);
@@ -51,8 +50,7 @@ void SpaceNavInputDriver::run()
  * one event is available and then processes all events until the queue is
  * empty.
  */
-bool SpaceNavInputDriver::spnav_input()
-{
+bool SpaceNavInputDriver::spnav_input() {
   spnav_event ev;
 
   // The low level driver seems to inhibit events in the dead zone, so if we
@@ -83,63 +81,102 @@ bool SpaceNavInputDriver::spnav_input()
     if (ev.type == SPNAV_EVENT_MOTION) {
 #ifdef DEBUG
       if ((ev.motion.x != 0) || (ev.motion.y != 0) || (ev.motion.z != 0)) {
-        PRINTDB("Translate Event: x = %d, y = %d, z = %d", ev.motion.x % ev.motion.y % ev.motion.z);
+        PRINTDB("Translate Event: x = %d, y = %d, z = %d",
+                ev.motion.x % ev.motion.y % ev.motion.z);
       }
       if ((ev.motion.rx != 0) || (ev.motion.ry != 0) || (ev.motion.rz != 0)) {
-        PRINTDB("Rotate Event: rx = %d, ry = %d, rz = %d", ev.motion.rx % ev.motion.ry % ev.motion.rz);
+        PRINTDB("Rotate Event: rx = %d, ry = %d, rz = %d",
+                ev.motion.rx % ev.motion.ry % ev.motion.rz);
       }
 #endif
 
       if (this->dominantAxisOnly) {
         // dominant axis only
         int m = ev.motion.x;
-        if (abs(m) < abs(ev.motion.y)) m = ev.motion.y;
-        if (abs(m) < abs(ev.motion.z)) m = ev.motion.z;
-        if (abs(m) < abs(ev.motion.rx)) m = ev.motion.rx;
-        if (abs(m) < abs(ev.motion.ry)) m = ev.motion.ry;
-        if (abs(m) < abs(ev.motion.rz)) m = ev.motion.rz;
+        if (abs(m) < abs(ev.motion.y))
+          m = ev.motion.y;
+        if (abs(m) < abs(ev.motion.z))
+          m = ev.motion.z;
+        if (abs(m) < abs(ev.motion.rx))
+          m = ev.motion.rx;
+        if (abs(m) < abs(ev.motion.ry))
+          m = ev.motion.ry;
+        if (abs(m) < abs(ev.motion.rz))
+          m = ev.motion.rz;
 
         if (ev.motion.x == m) {
-          ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.y == m) {
-          ev.motion.x = 0;                ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.z == m) {
-          ev.motion.x = 0; ev.motion.y = 0;                ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.rx == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0;                 ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.ry == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0;                 ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.rz == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
         }
       }
 
       if (ev.motion.x != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, ev.motion.x / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(0, ev.motion.x / 500.0));
       }
       if (ev.motion.y != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, ev.motion.y / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(1, ev.motion.y / 500.0));
       }
       if (ev.motion.z != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, ev.motion.z / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(2, ev.motion.z / 500.0));
       }
       if (ev.motion.rx != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, ev.motion.rx / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(3, ev.motion.rx / 500.0));
       }
       if (ev.motion.ry != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, ev.motion.ry / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(4, ev.motion.ry / 500.0));
       }
       if (ev.motion.rz != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, ev.motion.rz / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(5, ev.motion.rz / 500.0));
       }
     } else if (ev.type == SPNAV_EVENT_BUTTON) {
-      PRINTDB("Button Event: num = %d, %s", ev.button.bnum % (ev.button.press ? "pressed" : "released"));
-      InputEvent *event = new InputEventButtonChanged(ev.button.bnum, ev.button.press);
+      PRINTDB("Button Event: num = %d, %s",
+              ev.button.bnum % (ev.button.press ? "pressed" : "released"));
+      InputEvent* event =
+          new InputEventButtonChanged(ev.button.bnum, ev.button.press);
       InputDriverManager::instance()->sendEvent(event);
     }
   } while (spnav_poll_event(&ev));
@@ -147,8 +184,7 @@ bool SpaceNavInputDriver::spnav_input()
   return true;
 }
 
-bool SpaceNavInputDriver::open()
-{
+bool SpaceNavInputDriver::open() {
   if (spnav_open() < 0) {
     return false;
   }
@@ -156,22 +192,17 @@ bool SpaceNavInputDriver::open()
   return true;
 }
 
-void SpaceNavInputDriver::close()
-{
-
-}
+void SpaceNavInputDriver::close() {}
 
-void SpaceNavInputDriver::setDominantAxisOnly(bool var){
+void SpaceNavInputDriver::setDominantAxisOnly(bool var) {
   this->dominantAxisOnly = var;
 }
 
-const std::string& SpaceNavInputDriver::get_name() const
-{
+const std::string& SpaceNavInputDriver::get_name() const {
   static std::string name = "SpaceNavInputDriver";
   return name;
 }
 
-std::string SpaceNavInputDriver::get_info() const
-{
+std::string SpaceNavInputDriver::get_info() const {
   return STR(get_name(), " ", (isOpen() ? "open" : "not open"), " ");
 }
diff --git a/src/gui/input/SpaceNavInputDriver.h b/src/gui/input/SpaceNavInputDriver.h
index 58eca0585..f374b68d1 100644
--- a/src/gui/input/SpaceNavInputDriver.h
+++ b/src/gui/input/SpaceNavInputDriver.h
@@ -31,11 +31,10 @@
 #include "core/Settings.h"
 #include "gui/input/InputDriver.h"
 
-class SpaceNavInputDriver : public InputDriver
-{
+class SpaceNavInputDriver : public InputDriver {
   Q_OBJECT
 
-public:
+ public:
   SpaceNavInputDriver() = default;
   void run() override;
   bool open() override;
@@ -45,14 +44,10 @@ public:
   const std::string& get_name() const override;
   std::string get_info() const override;
 
-  size_t getButtonCount() const override {
-    return Settings::max_buttons;
-  }
-  size_t getAxisCount() const override {
-    return Settings::max_axis;
-  }
+  size_t getButtonCount() const override { return Settings::max_buttons; }
+  size_t getAxisCount() const override { return Settings::max_axis; }
 
-private:
+ private:
   bool spnav_input();
   bool dominantAxisOnly{true};
 };
diff --git a/src/gui/parameter/GroupWidget.cc b/src/gui/parameter/GroupWidget.cc
index 042167e9d..8679104fe 100644
--- a/src/gui/parameter/GroupWidget.cc
+++ b/src/gui/parameter/GroupWidget.cc
@@ -1,13 +1,13 @@
 #include "gui/parameter/GroupWidget.h"
 
+#include <QLineEdit>
 #include <QObject>
 #include <QSizePolicy>
 #include <QString>
 #include <QWidget>
-#include <QLineEdit>
 
-GroupWidget::GroupWidget(const QString& title, QWidget *parent) : QWidget(parent)
-{
+GroupWidget::GroupWidget(const QString& title, QWidget* parent)
+    : QWidget(parent) {
   this->toggleButton.setText(title);
   this->toggleButton.setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum);
   this->toggleButton.setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
@@ -28,16 +28,15 @@ GroupWidget::GroupWidget(const QString& title, QWidget *parent) : QWidget(parent
   setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum);
   setLayout(&mainLayout);
 
-  QObject::connect(&toggleButton, &QToolButton::toggled, this, &GroupWidget::setExpanded);
+  QObject::connect(&toggleButton, &QToolButton::toggled, this,
+                   &GroupWidget::setExpanded);
 }
 
-void GroupWidget::addWidget(QWidget *widget)
-{
+void GroupWidget::addWidget(QWidget* widget) {
   contentLayout.addWidget(widget);
 }
 
-void GroupWidget::setExpanded(bool expanded)
-{
+void GroupWidget::setExpanded(bool expanded) {
   toggleButton.setChecked(expanded);
   toggleButton.setArrowType(expanded ? Qt::DownArrow : Qt::RightArrow);
   if (expanded) {
diff --git a/src/gui/parameter/GroupWidget.h b/src/gui/parameter/GroupWidget.h
index 86cba49e1..2ed822bc7 100644
--- a/src/gui/parameter/GroupWidget.h
+++ b/src/gui/parameter/GroupWidget.h
@@ -1,27 +1,26 @@
 #pragma once
 
-#include <QString>
 #include <QGridLayout>
+#include <QString>
 #include <QToolButton>
 #include <QVBoxLayout>
 #include <QWidget>
 
-class GroupWidget : public QWidget
-{
+class GroupWidget : public QWidget {
   Q_OBJECT
-private:
+ private:
   QGridLayout mainLayout;
   QToolButton toggleButton;
   QWidget contentArea;
   QVBoxLayout contentLayout;
 
-public:
-  GroupWidget(const QString& title, QWidget *parent = nullptr);
-  void addWidget(QWidget *widget);
+ public:
+  GroupWidget(const QString& title, QWidget* parent = nullptr);
+  void addWidget(QWidget* widget);
 
   bool isExpanded() const { return toggleButton.isChecked(); }
   QString title() const { return toggleButton.text(); }
 
-public slots:
+ public slots:
   void setExpanded(bool expanded);
 };
diff --git a/src/gui/parameter/ParameterCheckBox.cc b/src/gui/parameter/ParameterCheckBox.cc
index 6f11edad2..4b408aaff 100644
--- a/src/gui/parameter/ParameterCheckBox.cc
+++ b/src/gui/parameter/ParameterCheckBox.cc
@@ -1,29 +1,29 @@
-#include <QWidget>
 #include "gui/parameter/ParameterCheckBox.h"
+#include <QWidget>
 
-ParameterCheckBox::ParameterCheckBox(QWidget *parent, BoolParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterCheckBox::ParameterCheckBox(QWidget* parent,
+                                     BoolParameter* parameter,
+                                     DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
   if (descriptionStyle == DescriptionStyle::ShowDetails) {
-    //large checkbox, when we have the space
-    checkBox->setStyleSheet("QCheckBox::indicator { width: 20px; height: 20px; } QCheckBox { spacing: 0px; }");
+    // large checkbox, when we have the space
+    checkBox->setStyleSheet(
+        "QCheckBox::indicator { width: 20px; height: 20px; } QCheckBox { "
+        "spacing: 0px; }");
   }
 
   connect(checkBox, &QCheckBox::clicked, this, &ParameterCheckBox::onChanged);
   ParameterCheckBox::setValue();
 }
 
-void ParameterCheckBox::onChanged()
-{
+void ParameterCheckBox::onChanged() {
   parameter->value = checkBox->isChecked();
   emit changed(true);
 }
 
-void ParameterCheckBox::setValue()
-{
+void ParameterCheckBox::setValue() {
   checkBox->setChecked(parameter->value);
 }
diff --git a/src/gui/parameter/ParameterCheckBox.h b/src/gui/parameter/ParameterCheckBox.h
index 55c8078d3..bfd95a4fc 100644
--- a/src/gui/parameter/ParameterCheckBox.h
+++ b/src/gui/parameter/ParameterCheckBox.h
@@ -1,20 +1,21 @@
 #pragma once
 
-#include "gui/parameter/ParameterVirtualWidget.h"
 #include <QWidget>
+#include "gui/parameter/ParameterVirtualWidget.h"
 #include "ui_ParameterCheckBox.h"
 
-class ParameterCheckBox : public ParameterVirtualWidget, Ui::ParameterCheckBox
-{
+class ParameterCheckBox : public ParameterVirtualWidget, Ui::ParameterCheckBox {
   Q_OBJECT
 
-public:
-  ParameterCheckBox(QWidget *parent, BoolParameter *parameter, DescriptionStyle descriptionStyle);
+ public:
+  ParameterCheckBox(QWidget* parent,
+                    BoolParameter* parameter,
+                    DescriptionStyle descriptionStyle);
   void setValue() override;
 
-protected slots:
+ protected slots:
   void onChanged();
 
-private:
-  BoolParameter *parameter;
+ private:
+  BoolParameter* parameter;
 };
diff --git a/src/gui/parameter/ParameterComboBox.cc b/src/gui/parameter/ParameterComboBox.cc
index 9d6fc286a..95f34b0fa 100644
--- a/src/gui/parameter/ParameterComboBox.cc
+++ b/src/gui/parameter/ParameterComboBox.cc
@@ -3,33 +3,32 @@
 #include <QWidget>
 #include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterComboBox::ParameterComboBox(QWidget *parent, EnumParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterComboBox::ParameterComboBox(QWidget* parent,
+                                     EnumParameter* parameter,
+                                     DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
-  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
+  auto* ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
   comboBox->installEventFilter(ignoreWheelWhenNotFocused);
 
   for (const auto& item : parameter->items) {
     comboBox->addItem(QString::fromStdString(item.key));
   }
 
-  connect(comboBox, QOverload<int>::of(&QComboBox::activated), this, &ParameterComboBox::onChanged);
+  connect(comboBox, QOverload<int>::of(&QComboBox::activated), this,
+          &ParameterComboBox::onChanged);
   ParameterComboBox::setValue();
 }
 
-void ParameterComboBox::onChanged(int index)
-{
+void ParameterComboBox::onChanged(int index) {
   if (parameter->valueIndex != index) {
     parameter->valueIndex = index;
     emit changed(true);
   }
 }
 
-void ParameterComboBox::setValue()
-{
+void ParameterComboBox::setValue() {
   comboBox->setCurrentIndex(parameter->valueIndex);
 }
diff --git a/src/gui/parameter/ParameterComboBox.h b/src/gui/parameter/ParameterComboBox.h
index 387f8f4af..15d5ef609 100644
--- a/src/gui/parameter/ParameterComboBox.h
+++ b/src/gui/parameter/ParameterComboBox.h
@@ -1,20 +1,21 @@
 #pragma once
 
-#include "gui/parameter/ParameterVirtualWidget.h"
 #include <QWidget>
+#include "gui/parameter/ParameterVirtualWidget.h"
 #include "ui_ParameterComboBox.h"
 
-class ParameterComboBox : public ParameterVirtualWidget, Ui::ParameterComboBox
-{
+class ParameterComboBox : public ParameterVirtualWidget, Ui::ParameterComboBox {
   Q_OBJECT
 
-public:
-  ParameterComboBox(QWidget *parent, EnumParameter *parameter, DescriptionStyle descriptionStyle);
+ public:
+  ParameterComboBox(QWidget* parent,
+                    EnumParameter* parameter,
+                    DescriptionStyle descriptionStyle);
   void setValue() override;
 
-protected slots:
+ protected slots:
   void onChanged(int index);
 
-private:
-  EnumParameter *parameter;
+ private:
+  EnumParameter* parameter;
 };
diff --git a/src/gui/parameter/ParameterSlider.cc b/src/gui/parameter/ParameterSlider.cc
index 46d26604c..129469035 100644
--- a/src/gui/parameter/ParameterSlider.cc
+++ b/src/gui/parameter/ParameterSlider.cc
@@ -1,18 +1,18 @@
 #include "gui/parameter/ParameterSlider.h"
 #include <QWidget>
-#include <cmath>
 #include <cassert>
+#include <cmath>
 #include <limits>
 #include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterSlider::ParameterSlider(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterSlider::ParameterSlider(QWidget* parent,
+                                 NumberParameter* parameter,
+                                 DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
-  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
+  auto* ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
   slider->installEventFilter(ignoreWheelWhenNotFocused);
   doubleSpinBox->installEventFilter(ignoreWheelWhenNotFocused);
   doubleSpinBox->setKeyboardTracking(true);
@@ -24,23 +24,23 @@ ParameterSlider::ParameterSlider(QWidget *parent, NumberParameter *parameter, De
   this->minimum = *parameter->minimum;
   if (parameter->step) {
     this->step = *parameter->step;
-    decimals = decimalsRequired({
-      this->minimum,
-      parameter->defaultValue,
-      this->step
-    });
+    decimals =
+        decimalsRequired({this->minimum, parameter->defaultValue, this->step});
   } else {
-    decimals = decimalsRequired({
-      this->minimum,
-      parameter->defaultValue
-    });
+    decimals = decimalsRequired({this->minimum, parameter->defaultValue});
     this->step = pow(0.1, decimals);
   }
 
-  static constexpr auto maxSteps = static_cast<double>(std::numeric_limits<int>::max());
-  // Use nextafter to compensate for possible floating point inaccurary where result is just below a whole number.
-  double tempSteps = std::nextafter((*parameter->maximum - this->minimum) / this->step, maxSteps) + 1.0;
-  int numSteps = tempSteps >= maxSteps ? std::numeric_limits<int>::max() : static_cast<int>(tempSteps);
+  static constexpr auto maxSteps =
+      static_cast<double>(std::numeric_limits<int>::max());
+  // Use nextafter to compensate for possible floating point inaccurary where
+  // result is just below a whole number.
+  double tempSteps =
+      std::nextafter((*parameter->maximum - this->minimum) / this->step,
+                     maxSteps) +
+      1.0;
+  int numSteps = tempSteps >= maxSteps ? std::numeric_limits<int>::max()
+                                       : static_cast<int>(tempSteps);
   // Truncate end value to full steps, same as Thingiverse customizer.
   // This also makes sure the step size of the spin box does not go to
   // invalid values.
@@ -52,13 +52,18 @@ ParameterSlider::ParameterSlider(QWidget *parent, NumberParameter *parameter, De
   doubleSpinBox->setRange(this->minimum, maximumValue);
   doubleSpinBox->setSingleStep(this->step);
 
-  //connect(slider, &QSlider::sliderPressed, this, &ParameterSlider::onSliderPressed);
-  connect(slider, &QSlider::sliderReleased, this, &ParameterSlider::onSliderReleased);
+  // connect(slider, &QSlider::sliderPressed, this,
+  // &ParameterSlider::onSliderPressed);
+  connect(slider, &QSlider::sliderReleased, this,
+          &ParameterSlider::onSliderReleased);
   connect(slider, &QSlider::sliderMoved, this, &ParameterSlider::onSliderMoved);
-  connect(slider, &QSlider::valueChanged, this, &ParameterSlider::onSliderChanged);
+  connect(slider, &QSlider::valueChanged, this,
+          &ParameterSlider::onSliderChanged);
 
-  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterSlider::onSpinBoxChanged);
-  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this, &ParameterSlider::onSpinBoxEditingFinished);
+  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged),
+          this, &ParameterSlider::onSpinBoxChanged);
+  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this,
+          &ParameterSlider::onSpinBoxEditingFinished);
 
   ParameterSlider::setValue();
 }
@@ -68,19 +73,15 @@ void ParameterSlider::valueApplied() {
 }
 
 // slider handle grabbed
-void ParameterSlider::onSliderPressed()
-{
-}
+void ParameterSlider::onSliderPressed() {}
 
 // slider handle released
-void ParameterSlider::onSliderReleased()
-{
+void ParameterSlider::onSliderReleased() {
   this->commitChange(true);
 }
 
 // slider handle dragged
-void ParameterSlider::onSliderMoved(int position)
-{
+void ParameterSlider::onSliderMoved(int position) {
   double value = parameterValue(position);
   doubleSpinBox->blockSignals(true);
   doubleSpinBox->setValue(value);
@@ -88,9 +89,9 @@ void ParameterSlider::onSliderMoved(int position)
 }
 
 // slider track clicked
-// changes by pageStep or sets absolute position, depending on platform or specific mouse button
-void ParameterSlider::onSliderChanged(int position)
-{
+// changes by pageStep or sets absolute position, depending on platform or
+// specific mouse button
+void ParameterSlider::onSliderChanged(int position) {
   double value = parameterValue(position);
   doubleSpinBox->blockSignals(true);
   doubleSpinBox->setValue(value);
@@ -99,8 +100,7 @@ void ParameterSlider::onSliderChanged(int position)
 }
 
 // spin button click or arrow keypress
-void ParameterSlider::onSpinBoxChanged(double value)
-{
+void ParameterSlider::onSpinBoxChanged(double value) {
   int position = sliderPosition(value);
   slider->blockSignals(true);
   slider->setValue(position);
@@ -109,39 +109,38 @@ void ParameterSlider::onSpinBoxChanged(double value)
 }
 
 // Enter key pressed or spinbox focus lost
-void ParameterSlider::onSpinBoxEditingFinished()
-{
+void ParameterSlider::onSpinBoxEditingFinished() {
   commitChange(true);
 }
 
 void ParameterSlider::commitChange(bool immediate) {
   double value = parameterValue(slider->sliderPosition());
 #ifdef DEBUG
-  PRINTD(STR("[commit] value=", value, ", parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD(STR("[commit] value=", value, ", parameter->value=", parameter->value,
+             ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
-  if ((immediate && lastApplied != value) || (!immediate && lastSent != value) ) {
+  if ((immediate && lastApplied != value) ||
+      (!immediate && lastSent != value)) {
     lastSent = parameter->value = value;
     emit changed(immediate);
   }
 }
 
 // Called when populating parameter presets
-void ParameterSlider::setValue()
-{
+void ParameterSlider::setValue() {
 #ifdef DEBUG
-  PRINTD(STR("[setValue] parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD(STR("[setValue] parameter->value=", parameter->value,
+             ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
   int position = sliderPosition(parameter->value);
   lastApplied = lastSent = parameter->value;
   slider->setValue(position);
 }
 
-int ParameterSlider::sliderPosition(double value)
-{
+int ParameterSlider::sliderPosition(double value) {
   return static_cast<int>(std::round((value - this->minimum) / this->step));
 }
 
-double ParameterSlider::parameterValue(int sliderPosition)
-{
+double ParameterSlider::parameterValue(int sliderPosition) {
   return this->minimum + sliderPosition * this->step;
 }
diff --git a/src/gui/parameter/ParameterSlider.h b/src/gui/parameter/ParameterSlider.h
index a92e5ed48..201b1e0c2 100644
--- a/src/gui/parameter/ParameterSlider.h
+++ b/src/gui/parameter/ParameterSlider.h
@@ -1,19 +1,20 @@
 #pragma once
 
-#include "gui/parameter/ParameterVirtualWidget.h"
 #include <QWidget>
+#include "gui/parameter/ParameterVirtualWidget.h"
 #include "ui_ParameterSlider.h"
 
-class ParameterSlider : public ParameterVirtualWidget, Ui::ParameterSlider
-{
+class ParameterSlider : public ParameterVirtualWidget, Ui::ParameterSlider {
   Q_OBJECT
 
-public:
-  ParameterSlider(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle);
+ public:
+  ParameterSlider(QWidget* parent,
+                  NumberParameter* parameter,
+                  DescriptionStyle descriptionStyle);
   void setValue() override;
   void valueApplied() override;
 
-protected slots:
+ protected slots:
   void onSliderPressed();
   void onSliderReleased();
   void onSliderMoved(int position);
@@ -22,8 +23,8 @@ protected slots:
   void onSpinBoxChanged(double value);
   void onSpinBoxEditingFinished();
 
-private:
-  NumberParameter *parameter;
+ private:
+  NumberParameter* parameter;
   boost::optional<double> lastSent;
   boost::optional<double> lastApplied;
   double minimum;
diff --git a/src/gui/parameter/ParameterSpinBox.cc b/src/gui/parameter/ParameterSpinBox.cc
index 61edc37d9..bb672244e 100644
--- a/src/gui/parameter/ParameterSpinBox.cc
+++ b/src/gui/parameter/ParameterSpinBox.cc
@@ -4,14 +4,14 @@
 #include <limits>
 #include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterSpinBox::ParameterSpinBox(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterSpinBox::ParameterSpinBox(QWidget* parent,
+                                   NumberParameter* parameter,
+                                   DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
-  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
+  auto* ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
   doubleSpinBox->installEventFilter(ignoreWheelWhenNotFocused);
   doubleSpinBox->setKeyboardTracking(true);
 
@@ -45,8 +45,10 @@ ParameterSpinBox::ParameterSpinBox(QWidget *parent, NumberParameter *parameter,
   doubleSpinBox->setRange(minimum, maximum);
   doubleSpinBox->setSingleStep(step);
 
-  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterSpinBox::onChanged);
-  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this, &ParameterSpinBox::onEditingFinished);
+  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged),
+          this, &ParameterSpinBox::onChanged);
+  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this,
+          &ParameterSpinBox::onEditingFinished);
   ParameterSpinBox::setValue();
 }
 
@@ -54,10 +56,10 @@ void ParameterSpinBox::valueApplied() {
   lastApplied = lastSent;
 }
 
-void ParameterSpinBox::onChanged(double value)
-{
+void ParameterSpinBox::onChanged(double value) {
 #ifdef DEBUG
-  PRINTD(STR("[changed] value=", value, ", parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD(STR("[changed] value=", value, ", parameter->value=", parameter->value,
+             ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
   parameter->value = value;
   if (lastSent != value) {
@@ -66,10 +68,10 @@ void ParameterSpinBox::onChanged(double value)
   }
 }
 
-void ParameterSpinBox::onEditingFinished()
-{
+void ParameterSpinBox::onEditingFinished() {
 #ifdef DEBUG
-  PRINTD(STR("[finished] parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD(STR("[finished] parameter->value=", parameter->value,
+             ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
   if (lastApplied != parameter->value) {
     lastSent = parameter->value;
@@ -77,8 +79,7 @@ void ParameterSpinBox::onEditingFinished()
   }
 }
 
-void ParameterSpinBox::setValue()
-{
+void ParameterSpinBox::setValue() {
   lastApplied = lastSent = parameter->value;
   doubleSpinBox->setValue(parameter->value);
 }
diff --git a/src/gui/parameter/ParameterSpinBox.h b/src/gui/parameter/ParameterSpinBox.h
index 5a39dc80c..89752d112 100644
--- a/src/gui/parameter/ParameterSpinBox.h
+++ b/src/gui/parameter/ParameterSpinBox.h
@@ -1,25 +1,25 @@
 #pragma once
 
-#include "gui/parameter/ParameterVirtualWidget.h"
 #include <QWidget>
+#include "gui/parameter/ParameterVirtualWidget.h"
 #include "ui_ParameterSpinBox.h"
 
-class ParameterSpinBox : public ParameterVirtualWidget, Ui::ParameterSpinBox
-{
+class ParameterSpinBox : public ParameterVirtualWidget, Ui::ParameterSpinBox {
   Q_OBJECT
 
-public:
-  ParameterSpinBox(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle);
+ public:
+  ParameterSpinBox(QWidget* parent,
+                   NumberParameter* parameter,
+                   DescriptionStyle descriptionStyle);
   void setValue() override;
   void valueApplied() override;
 
-protected slots:
+ protected slots:
   void onChanged(double);
   void onEditingFinished();
 
-private:
-  NumberParameter *parameter;
+ private:
+  NumberParameter* parameter;
   boost::optional<double> lastSent;
   boost::optional<double> lastApplied;
-
 };
diff --git a/src/gui/parameter/ParameterText.cc b/src/gui/parameter/ParameterText.cc
index 65c731c8b..8aad2e081 100644
--- a/src/gui/parameter/ParameterText.cc
+++ b/src/gui/parameter/ParameterText.cc
@@ -4,10 +4,10 @@
 #include <QWidget>
 #include <string>
 
-ParameterText::ParameterText(QWidget *parent, StringParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterText::ParameterText(QWidget* parent,
+                             StringParameter* parameter,
+                             DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
@@ -16,7 +16,8 @@ ParameterText::ParameterText(QWidget *parent, StringParameter *parameter, Descri
   }
 
   connect(lineEdit, &QLineEdit::textEdited, this, &ParameterText::onEdit);
-  connect(lineEdit, &QLineEdit::editingFinished, this, &ParameterText::onEditingFinished);
+  connect(lineEdit, &QLineEdit::editingFinished, this,
+          &ParameterText::onEditingFinished);
   ParameterText::setValue();
 }
 
@@ -24,8 +25,7 @@ void ParameterText::valueApplied() {
   lastApplied = lastSent;
 }
 
-void ParameterText::onEdit(const QString& text)
-{
+void ParameterText::onEdit(const QString& text) {
 #ifdef DEBUG
   PRINTD("edit");
 #endif
@@ -46,8 +46,7 @@ void ParameterText::onEditingFinished() {
   }
 }
 
-void ParameterText::setValue()
-{
+void ParameterText::setValue() {
   lastApplied = lastSent = parameter->value;
   lineEdit->setText(QString::fromStdString(parameter->value));
 }
diff --git a/src/gui/parameter/ParameterText.h b/src/gui/parameter/ParameterText.h
index 729a04ef0..98eea3098 100644
--- a/src/gui/parameter/ParameterText.h
+++ b/src/gui/parameter/ParameterText.h
@@ -7,21 +7,22 @@
 #include <QWidget>
 #include <string>
 
-class ParameterText : public ParameterVirtualWidget, Ui::ParameterText
-{
+class ParameterText : public ParameterVirtualWidget, Ui::ParameterText {
   Q_OBJECT
 
-public:
-  ParameterText(QWidget *parent, StringParameter *parameter, DescriptionStyle descriptionStyle);
+ public:
+  ParameterText(QWidget* parent,
+                StringParameter* parameter,
+                DescriptionStyle descriptionStyle);
   void setValue() override;
   void valueApplied() override;
 
-protected slots:
+ protected slots:
   void onEdit(const QString& text);
   void onEditingFinished();
 
-private:
-  StringParameter *parameter;
+ private:
+  StringParameter* parameter;
   boost::optional<std::string> lastSent;
   boost::optional<std::string> lastApplied;
 };
diff --git a/src/gui/parameter/ParameterVector.cc b/src/gui/parameter/ParameterVector.cc
index 8e390fbb3..ce4d70d2e 100644
--- a/src/gui/parameter/ParameterVector.cc
+++ b/src/gui/parameter/ParameterVector.cc
@@ -3,14 +3,14 @@
 #include <QWidget>
 #include <algorithm>
 #include <cassert>
-#include <limits>
 #include <cstddef>
+#include <limits>
 #include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterVector::ParameterVector(QWidget *parent, VectorParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterVector::ParameterVector(QWidget* parent,
+                                 VectorParameter* parameter,
+                                 DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
@@ -38,11 +38,12 @@ ParameterVector::ParameterVector(QWidget *parent, VectorParameter *parameter, De
     doubleSpinBox4->hide();
   }
 
-  // clang generates a bogus warning that ignoreWheelWhenNotFocused may be leaked
-  // NOLINTBEGIN(*NewDeleteLeaks)
-  if (spinboxes.size() > 0) { // only allocate if there are spinboxes to use the function
+  // clang generates a bogus warning that ignoreWheelWhenNotFocused may be
+  // leaked NOLINTBEGIN(*NewDeleteLeaks)
+  if (spinboxes.size() >
+      0) {  // only allocate if there are spinboxes to use the function
     // The parent (this) takes ownership of the object
-    auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
+    auto* ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
     for (auto spinbox : spinboxes) {
       spinbox->installEventFilter(ignoreWheelWhenNotFocused);
     }
@@ -80,8 +81,10 @@ ParameterVector::ParameterVector(QWidget *parent, VectorParameter *parameter, De
     spinbox->setRange(minimum, maximum);
     spinbox->setSingleStep(step);
     spinbox->show();
-    connect(spinbox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterVector::onChanged);
-    connect(spinbox, &QDoubleSpinBox::editingFinished, this, &ParameterVector::onEditingFinished);
+    connect(spinbox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this,
+            &ParameterVector::onChanged);
+    connect(spinbox, &QDoubleSpinBox::editingFinished, this,
+            &ParameterVector::onEditingFinished);
   }
 
   ParameterVector::setValue();
@@ -91,8 +94,7 @@ void ParameterVector::valueApplied() {
   lastApplied = lastSent;
 }
 
-void ParameterVector::onChanged()
-{
+void ParameterVector::onChanged() {
   for (size_t i = 0; i < spinboxes.size(); i++) {
     parameter->value[i] = spinboxes[i]->value();
   }
@@ -102,16 +104,14 @@ void ParameterVector::onChanged()
   }
 }
 
-void ParameterVector::onEditingFinished()
-{
+void ParameterVector::onEditingFinished() {
   if (lastApplied != parameter->value) {
     lastSent = parameter->value;
     emit changed(true);
   }
 }
 
-void ParameterVector::setValue()
-{
+void ParameterVector::setValue() {
 #ifdef DEBUG
   PRINTD("setValue");
 #endif
diff --git a/src/gui/parameter/ParameterVector.h b/src/gui/parameter/ParameterVector.h
index b24372aad..5f9cb034e 100644
--- a/src/gui/parameter/ParameterVector.h
+++ b/src/gui/parameter/ParameterVector.h
@@ -7,22 +7,23 @@
 #include <QWidget>
 #include <vector>
 
-class ParameterVector : public ParameterVirtualWidget, Ui::ParameterVector
-{
+class ParameterVector : public ParameterVirtualWidget, Ui::ParameterVector {
   Q_OBJECT
 
-public:
-  ParameterVector(QWidget *parent, VectorParameter *parameter, DescriptionStyle descriptionStyle);
+ public:
+  ParameterVector(QWidget* parent,
+                  VectorParameter* parameter,
+                  DescriptionStyle descriptionStyle);
   void setValue() override;
   void valueApplied() override;
 
-protected slots:
+ protected slots:
   void onChanged();
   void onEditingFinished();
 
-private:
-  VectorParameter *parameter;
-  std::vector<QDoubleSpinBox *> spinboxes;
+ private:
+  VectorParameter* parameter;
+  std::vector<QDoubleSpinBox*> spinboxes;
   std::vector<double> lastSent;
   std::vector<double> lastApplied;
 };
diff --git a/src/gui/parameter/ParameterVirtualWidget.cc b/src/gui/parameter/ParameterVirtualWidget.cc
index 0f38e6607..1de96ae39 100644
--- a/src/gui/parameter/ParameterVirtualWidget.cc
+++ b/src/gui/parameter/ParameterVirtualWidget.cc
@@ -1,22 +1,23 @@
 #include "gui/parameter/ParameterVirtualWidget.h"
 
+#include <QRegularExpression>
 #include <QSizePolicy>
 #include <QWidget>
 #include <algorithm>
-#include <cmath>
 #include <cassert>
-#include <QRegularExpression>
+#include <cmath>
 #include <vector>
 
-ParameterDescriptionWidget::ParameterDescriptionWidget(QWidget *parent) :
-  QWidget(parent)
-{
+ParameterDescriptionWidget::ParameterDescriptionWidget(QWidget* parent)
+    : QWidget(parent) {
   setupUi(this);
 }
 
-void ParameterDescriptionWidget::setDescription(ParameterObject *parameter, DescriptionStyle descriptionStyle)
-{
-  labelParameter->setText(QString::fromStdString(parameter->name()).replace(QRegularExpression("([_]+)"), " "));
+void ParameterDescriptionWidget::setDescription(
+    ParameterObject* parameter,
+    DescriptionStyle descriptionStyle) {
+  labelParameter->setText(QString::fromStdString(parameter->name())
+                              .replace(QRegularExpression("([_]+)"), " "));
   if (parameter->description().empty()) {
     labelDescription->hide();
     labelInline->setText("");
@@ -25,7 +26,8 @@ void ParameterDescriptionWidget::setDescription(ParameterObject *parameter, Desc
     labelInline->setText("");
   } else if (descriptionStyle == DescriptionStyle::Inline) {
     labelDescription->hide();
-    labelInline->setText(QString(" - ") + QString::fromStdString(parameter->description()));
+    labelInline->setText(QString(" - ") +
+                         QString::fromStdString(parameter->description()));
   } else if (descriptionStyle == DescriptionStyle::HideDetails) {
     labelDescription->hide();
     labelInline->setText("");
@@ -39,10 +41,9 @@ void ParameterDescriptionWidget::setDescription(ParameterObject *parameter, Desc
   }
 }
 
-ParameterVirtualWidget::ParameterVirtualWidget(QWidget *parent, ParameterObject *parameter) :
-  QWidget(parent),
-  parameter(parameter)
-{
+ParameterVirtualWidget::ParameterVirtualWidget(QWidget* parent,
+                                               ParameterObject* parameter)
+    : QWidget(parent), parameter(parameter) {
   QSizePolicy policy;
   policy.setHorizontalPolicy(QSizePolicy::Ignored);
   policy.setVerticalPolicy(QSizePolicy::Maximum);
@@ -53,8 +54,7 @@ ParameterVirtualWidget::ParameterVirtualWidget(QWidget *parent, ParameterObject
   setContentsMargins(4, 0, 4, 0);
 }
 
-int ParameterVirtualWidget::decimalsRequired(double value)
-{
+int ParameterVirtualWidget::decimalsRequired(double value) {
   int decimals = 0;
   value = std::abs(value);
   while (std::floor(value) < std::ceil(value) && decimals < 7) {
@@ -64,8 +64,8 @@ int ParameterVirtualWidget::decimalsRequired(double value)
   return decimals;
 }
 
-int ParameterVirtualWidget::decimalsRequired(const std::vector<double>& values)
-{
+int ParameterVirtualWidget::decimalsRequired(
+    const std::vector<double>& values) {
   assert(!values.empty());
   int decimals = 0;
   for (double value : values) {
diff --git a/src/gui/parameter/ParameterVirtualWidget.h b/src/gui/parameter/ParameterVirtualWidget.h
index b1c9b2457..ed5d8492a 100644
--- a/src/gui/parameter/ParameterVirtualWidget.h
+++ b/src/gui/parameter/ParameterVirtualWidget.h
@@ -4,44 +4,49 @@
 #include <boost/optional.hpp>
 #include <vector>
 
+#include "core/customizer/ParameterObject.h"
 #include "gui/qtgettext.h"
 #include "ui_ParameterDescriptionWidget.h"
-#include "core/customizer/ParameterObject.h"
 
-enum class DescriptionStyle { ShowDetails, Inline, HideDetails, DescriptionOnly };
+enum class DescriptionStyle {
+  ShowDetails,
+  Inline,
+  HideDetails,
+  DescriptionOnly
+};
 
-class ParameterDescriptionWidget : public QWidget, public Ui::ParameterDescriptionWidget
-{
+class ParameterDescriptionWidget : public QWidget,
+                                   public Ui::ParameterDescriptionWidget {
   Q_OBJECT
 
-public:
-
-  ParameterDescriptionWidget(QWidget *parent);
-  void setDescription(ParameterObject *parameter, DescriptionStyle descriptionStyle);
+ public:
+  ParameterDescriptionWidget(QWidget* parent);
+  void setDescription(ParameterObject* parameter,
+                      DescriptionStyle descriptionStyle);
 };
 
-class ParameterVirtualWidget : public QWidget
-{
+class ParameterVirtualWidget : public QWidget {
   Q_OBJECT
 
-public:
-  ParameterVirtualWidget(QWidget *parent, ParameterObject *parameter);
-  ParameterObject *getParameter() const { return parameter; }
+ public:
+  ParameterVirtualWidget(QWidget* parent, ParameterObject* parameter);
+  ParameterObject* getParameter() const { return parameter; }
   virtual void setValue() = 0;
   // Parent container (ParameterWidget) notifies when preview is updated,
   // so that widgets with immediate AND delayed changes can keep track
   // and avoid emitting excess changed() signals.
-  virtual void valueApplied() { }
-  // Widgets which are immediate only (combobox and checkbox) don't need to keep track.
+  virtual void valueApplied() {}
+  // Widgets which are immediate only (combobox and checkbox) don't need to keep
+  // track.
 
-signals:
+ signals:
   // immediate tells customizer auto preview to skip timeout
   void changed(bool immediate);
 
-private:
-  ParameterObject *parameter;
+ private:
+  ParameterObject* parameter;
 
-protected:
+ protected:
   static int decimalsRequired(double value);
   static int decimalsRequired(const std::vector<double>& values);
 };
diff --git a/src/gui/parameter/ParameterWidget.cc b/src/gui/parameter/ParameterWidget.cc
index 65ba4609a..8849acffb 100644
--- a/src/gui/parameter/ParameterWidget.cc
+++ b/src/gui/parameter/ParameterWidget.cc
@@ -27,22 +27,21 @@
 
 #include <QLayoutItem>
 #include <QString>
-#include <stdexcept>
+#include <QWidget>
 #include <cassert>
 #include <map>
-#include <set>
 #include <memory>
-#include <QWidget>
-
+#include <set>
+#include <stdexcept>
 
+#include "gui/Preferences.h"
 #include "gui/parameter/GroupWidget.h"
-#include "gui/parameter/ParameterSpinBox.h"
+#include "gui/parameter/ParameterCheckBox.h"
 #include "gui/parameter/ParameterComboBox.h"
 #include "gui/parameter/ParameterSlider.h"
-#include "gui/parameter/ParameterCheckBox.h"
+#include "gui/parameter/ParameterSpinBox.h"
 #include "gui/parameter/ParameterText.h"
 #include "gui/parameter/ParameterVector.h"
-#include "gui/Preferences.h"
 
 #include <filesystem>
 
@@ -53,40 +52,48 @@
 #include <utility>
 #include <vector>
 
-ParameterWidget::ParameterWidget(QWidget *parent) : QWidget(parent)
-{
+ParameterWidget::ParameterWidget(QWidget* parent) : QWidget(parent) {
   setupUi(this);
   scrollAreaWidgetContents->layout()->setAlignment(Qt::AlignTop);
 
   autoPreviewTimer.setInterval(1000);
   autoPreviewTimer.setSingleShot(true);
 
-  connect(&autoPreviewTimer, &QTimer::timeout, this, &ParameterWidget::emitParametersChanged);
-  connect(checkBoxAutoPreview, &QCheckBox::toggled, [this]() {
-    this->autoPreview(true);
-  });
-  connect(comboBoxDetails, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ParameterWidget::rebuildWidgets);
-  connect(comboBoxPreset, QOverload<int>::of(&QComboBox::activated), this, &ParameterWidget::onSetChanged);
-  //connect(comboBoxPreset, &QComboBox::editTextChanged, this, &ParameterWidget::onSetNameChanged);
+  connect(&autoPreviewTimer, &QTimer::timeout, this,
+          &ParameterWidget::emitParametersChanged);
+  connect(checkBoxAutoPreview, &QCheckBox::toggled,
+          [this]() { this->autoPreview(true); });
+  connect(comboBoxDetails, QOverload<int>::of(&QComboBox::currentIndexChanged),
+          this, &ParameterWidget::rebuildWidgets);
+  connect(comboBoxPreset, QOverload<int>::of(&QComboBox::activated), this,
+          &ParameterWidget::onSetChanged);
+  // connect(comboBoxPreset, &QComboBox::editTextChanged, this,
+  // &ParameterWidget::onSetNameChanged);
   connect(addButton, &QPushButton::clicked, this, &ParameterWidget::onSetAdd);
-  connect(deleteButton, &QPushButton::clicked, this, &ParameterWidget::onSetDelete);
-
-  QString fontfamily = GlobalPreferences::inst()->getValue("advanced/customizerFontFamily").toString();
-  uint fontsize = GlobalPreferences::inst()->getValue("advanced/customizerFontSize").toUInt();
+  connect(deleteButton, &QPushButton::clicked, this,
+          &ParameterWidget::onSetDelete);
+
+  QString fontfamily = GlobalPreferences::inst()
+                           ->getValue("advanced/customizerFontFamily")
+                           .toString();
+  uint fontsize = GlobalPreferences::inst()
+                      ->getValue("advanced/customizerFontSize")
+                      .toUInt();
   setFontFamilySize(fontfamily, fontsize);
 
-  connect(GlobalPreferences::inst(), &Preferences::customizerFontChanged, this, &ParameterWidget::setFontFamilySize);
+  connect(GlobalPreferences::inst(), &Preferences::customizerFontChanged, this,
+          &ParameterWidget::setFontFamilySize);
 }
 
 // Can only be called before the initial setParameters().
-void ParameterWidget::readFile(const QString& scadFile)
-{
+void ParameterWidget::readFile(const QString& scadFile) {
   assert(sets.empty());
   assert(parameters.empty());
   assert(widgets.empty());
 
   QString jsonFile = getJsonFile(scadFile);
-  if (!std::filesystem::exists(jsonFile.toStdString()) || this->sets.readFile(jsonFile.toStdString())) {
+  if (!std::filesystem::exists(jsonFile.toStdString()) ||
+      this->sets.readFile(jsonFile.toStdString())) {
     this->invalidJsonFile = QString();
   } else {
     this->invalidJsonFile = jsonFile;
@@ -99,8 +106,7 @@ void ParameterWidget::readFile(const QString& scadFile)
 
 // Write the json file if the parameter sets are not empty.
 // This prevents creating unnecessary json files.
-void ParameterWidget::saveFile(const QString& scadFile)
-{
+void ParameterWidget::saveFile(const QString& scadFile) {
   if (sets.empty()) {
     return;
   }
@@ -109,7 +115,10 @@ void ParameterWidget::saveFile(const QString& scadFile)
   if (jsonFile == this->invalidJsonFile) {
     QMessageBox msgBox;
     msgBox.setWindowTitle(_("Saving presets"));
-    msgBox.setText(QString(_("%1 was found, but was unreadable. Do you want to overwrite %1?")).arg(this->invalidJsonFile));
+    msgBox.setText(
+        QString(
+            _("%1 was found, but was unreadable. Do you want to overwrite %1?"))
+            .arg(this->invalidJsonFile));
     msgBox.setStandardButtons(QMessageBox::Save | QMessageBox::Cancel);
     msgBox.setDefaultButton(QMessageBox::Cancel);
     if (msgBox.exec() == QMessageBox::Cancel) {
@@ -121,8 +130,7 @@ void ParameterWidget::saveFile(const QString& scadFile)
   sets.writeFile(jsonFile.toStdString());
 }
 
-void ParameterWidget::saveBackupFile(const QString& scadFile)
-{
+void ParameterWidget::saveBackupFile(const QString& scadFile) {
   if (sets.empty()) {
     return;
   }
@@ -130,8 +138,8 @@ void ParameterWidget::saveBackupFile(const QString& scadFile)
   sets.writeFile(getJsonFile(scadFile).toStdString());
 }
 
-void ParameterWidget::setParameters(const SourceFile *sourceFile, const std::string& source)
-{
+void ParameterWidget::setParameters(const SourceFile* sourceFile,
+                                    const std::string& source) {
   if (this->source == source) {
     return;
   }
@@ -142,17 +150,15 @@ void ParameterWidget::setParameters(const SourceFile *sourceFile, const std::str
   loadSet(comboBoxPreset->currentIndex());
 }
 
-void ParameterWidget::applyParameters(SourceFile *sourceFile)
-{
+void ParameterWidget::applyParameters(SourceFile* sourceFile) {
   this->parameters.apply(sourceFile);
 }
 
-bool ParameterWidget::childHasFocus()
-{
+bool ParameterWidget::childHasFocus() {
   if (this->hasFocus()) {
     return true;
   }
-  auto children = this->findChildren<QWidget *>();
+  auto children = this->findChildren<QWidget*>();
   for (auto child : children) {
     if (child->hasFocus()) {
       return true;
@@ -161,8 +167,7 @@ bool ParameterWidget::childHasFocus()
   return false;
 }
 
-void ParameterWidget::setModified(bool modified)
-{
+void ParameterWidget::setModified(bool modified) {
   if (this->modified != modified) {
     this->modified = modified;
     emit modificationChanged();
@@ -171,15 +176,14 @@ void ParameterWidget::setModified(bool modified)
 
 void ParameterWidget::emitParametersChanged() {
   for (const auto& kvp : widgets) {
-    for (ParameterVirtualWidget *widget : kvp.second) {
+    for (ParameterVirtualWidget* widget : kvp.second) {
       widget->valueApplied();
     }
   }
   emit parametersChanged();
 }
 
-void ParameterWidget::autoPreview(bool immediate)
-{
+void ParameterWidget::autoPreview(bool immediate) {
   autoPreviewTimer.stop();
   if (checkBoxAutoPreview->isChecked()) {
     if (immediate) {
@@ -190,31 +194,25 @@ void ParameterWidget::autoPreview(bool immediate)
   }
 }
 
-void ParameterWidget::onSetChanged(int index)
-{
+void ParameterWidget::onSetChanged(int index) {
   loadSet(index);
   autoPreview(true);
 }
 
-void ParameterWidget::onSetNameChanged()
-{
+void ParameterWidget::onSetNameChanged() {
   assert(static_cast<size_t>(comboBoxPreset->count()) == sets.size() + 1);
-  comboBoxPreset->setItemText(comboBoxPreset->currentIndex(), comboBoxPreset->lineEdit()->text());
-  sets[comboBoxPreset->currentIndex() - 1].setName(comboBoxPreset->currentText().toStdString());
+  comboBoxPreset->setItemText(comboBoxPreset->currentIndex(),
+                              comboBoxPreset->lineEdit()->text());
+  sets[comboBoxPreset->currentIndex() - 1].setName(
+      comboBoxPreset->currentText().toStdString());
   setModified();
 }
 
-void ParameterWidget::onSetAdd()
-{
+void ParameterWidget::onSetAdd() {
   bool ok = true;
-  QString result = QInputDialog::getText(
-    this,
-    _("Create new set of parameter"),
-    _("Enter name of the parameter set"),
-    QLineEdit::Normal,
-    "",
-    &ok
-    );
+  QString result = QInputDialog::getText(this, _("Create new set of parameter"),
+                                         _("Enter name of the parameter set"),
+                                         QLineEdit::Normal, "", &ok);
 
   if (ok) {
     createSet(result.trimmed());
@@ -222,8 +220,7 @@ void ParameterWidget::onSetAdd()
   setModified();
 }
 
-void ParameterWidget::onSetDelete()
-{
+void ParameterWidget::onSetDelete() {
   int index = comboBoxPreset->currentIndex();
   assert(index > 0);
   int newIndex;
@@ -241,10 +238,9 @@ void ParameterWidget::onSetDelete()
   autoPreview(true);
 }
 
-void ParameterWidget::parameterModified(bool immediate)
-{
-  auto *widget = (ParameterVirtualWidget *)sender();
-  ParameterObject *parameter = widget->getParameter();
+void ParameterWidget::parameterModified(bool immediate) {
+  auto* widget = (ParameterVirtualWidget*)sender();
+  ParameterObject* parameter = widget->getParameter();
 
   // When attempting to modify the design default, create a new set to edit.
   if (comboBoxPreset->currentIndex() == 0) {
@@ -254,7 +250,7 @@ void ParameterWidget::parameterModified(bool immediate)
     }
 
     QString name;
-    for (int i = 1; ; i++) {
+    for (int i = 1;; i++) {
       name = _("New set ") + QString::number(i);
       if (setNames.count(name.toStdString()) == 0) {
         break;
@@ -268,7 +264,7 @@ void ParameterWidget::parameterModified(bool immediate)
   sets[setIndex][parameter->name()] = parameter->exportValue();
 
   assert(widgets.count(parameter) == 1);
-  for (ParameterVirtualWidget *otherWidget : widgets[parameter]) {
+  for (ParameterVirtualWidget* otherWidget : widgets[parameter]) {
     if (otherWidget != widget) {
       otherWidget->setValue();
     }
@@ -278,8 +274,7 @@ void ParameterWidget::parameterModified(bool immediate)
   autoPreview(immediate);
 }
 
-void ParameterWidget::loadSet(size_t index)
-{
+void ParameterWidget::loadSet(size_t index) {
   assert(index <= sets.size());
   if (index == 0) {
     parameters.reset();
@@ -290,56 +285,57 @@ void ParameterWidget::loadSet(size_t index)
   updateSetEditability();
 
   for (const auto& pair : widgets) {
-    for (ParameterVirtualWidget *widget : pair.second) {
+    for (ParameterVirtualWidget* widget : pair.second) {
       widget->setValue();
     }
   }
 }
 
-void ParameterWidget::createSet(const QString& name)
-{
+void ParameterWidget::createSet(const QString& name) {
   sets.push_back(parameters.exportValues(name.toStdString()));
   comboBoxPreset->addItem(name);
   comboBoxPreset->setCurrentIndex(comboBoxPreset->count() - 1);
   updateSetEditability();
 }
 
-void ParameterWidget::updateSetEditability()
-{
+void ParameterWidget::updateSetEditability() {
   if (comboBoxPreset->currentIndex() == 0) {
     comboBoxPreset->setEditable(false);
     deleteButton->setEnabled(false);
   } else {
     if (!comboBoxPreset->isEditable()) {
       comboBoxPreset->setEditable(true);
-      connect(comboBoxPreset->lineEdit(), &QLineEdit::textEdited, this, &ParameterWidget::onSetNameChanged);
+      connect(comboBoxPreset->lineEdit(), &QLineEdit::textEdited, this,
+              &ParameterWidget::onSetNameChanged);
     }
     deleteButton->setEnabled(true);
   }
 }
 
-void ParameterWidget::rebuildWidgets()
-{
+void ParameterWidget::rebuildWidgets() {
   std::map<QString, bool> expandedGroups;
-  for (GroupWidget *groupWidget : this->findChildren<GroupWidget *>()) {
+  for (GroupWidget* groupWidget : this->findChildren<GroupWidget*>()) {
     expandedGroups.emplace(groupWidget->title(), groupWidget->isExpanded());
   }
 
   widgets.clear();
-  QLayout *layout = this->scrollAreaWidgetContents->layout();
+  QLayout* layout = this->scrollAreaWidgetContents->layout();
   while (layout->count() > 0) {
-    QLayoutItem *child = layout->takeAt(0);
+    QLayoutItem* child = layout->takeAt(0);
     delete child->widget();
     delete child;
   }
 
-  auto descriptionStyle = static_cast<DescriptionStyle>(comboBoxDetails->currentIndex());
+  auto descriptionStyle =
+      static_cast<DescriptionStyle>(comboBoxDetails->currentIndex());
   std::vector<ParameterGroup> parameterGroups = getParameterGroups();
   for (const auto& group : parameterGroups) {
-    auto *groupWidget = new GroupWidget(group.name);
-    for (ParameterObject *parameter : group.parameters) {
-      ParameterVirtualWidget *parameterWidget = createParameterWidget(parameter, descriptionStyle);
-      connect(parameterWidget, &ParameterVirtualWidget::changed, this, &ParameterWidget::parameterModified);
+    auto* groupWidget = new GroupWidget(group.name);
+    for (ParameterObject* parameter : group.parameters) {
+      ParameterVirtualWidget* parameterWidget =
+          createParameterWidget(parameter, descriptionStyle);
+      connect(parameterWidget, &ParameterVirtualWidget::changed, this,
+              &ParameterWidget::parameterModified);
       if (!widgets.count(parameter)) {
         widgets[parameter] = {};
       }
@@ -352,11 +348,11 @@ void ParameterWidget::rebuildWidgets()
   }
 }
 
-std::vector<ParameterWidget::ParameterGroup> ParameterWidget::getParameterGroups()
-{
+std::vector<ParameterWidget::ParameterGroup>
+ParameterWidget::getParameterGroups() {
   std::vector<ParameterWidget::ParameterGroup> output;
   std::map<std::string, size_t> groupIndices;
-  std::vector<ParameterObject *> globalParameters;
+  std::vector<ParameterObject*> globalParameters;
 
   for (const std::unique_ptr<ParameterObject>& parameter : parameters) {
     std::string group = parameter->group();
@@ -380,47 +376,51 @@ std::vector<ParameterWidget::ParameterGroup> ParameterWidget::getParameterGroups
     output.push_back(std::move(global));
   } else {
     for (auto& group : output) {
-      group.parameters.insert(group.parameters.end(), globalParameters.begin(), globalParameters.end());
+      group.parameters.insert(group.parameters.end(), globalParameters.begin(),
+                              globalParameters.end());
     }
   }
 
   return output;
 }
 
-ParameterVirtualWidget *ParameterWidget::createParameterWidget(ParameterObject *parameter, DescriptionStyle descriptionStyle)
-{
+ParameterVirtualWidget* ParameterWidget::createParameterWidget(
+    ParameterObject* parameter,
+    DescriptionStyle descriptionStyle) {
   if (parameter->type() == ParameterObject::ParameterType::Bool) {
-    return new ParameterCheckBox(this, static_cast<BoolParameter *>(parameter), descriptionStyle);
+    return new ParameterCheckBox(this, static_cast<BoolParameter*>(parameter),
+                                 descriptionStyle);
   } else if (parameter->type() == ParameterObject::ParameterType::String) {
-    return new ParameterText(this, static_cast<StringParameter *>(parameter), descriptionStyle);
+    return new ParameterText(this, static_cast<StringParameter*>(parameter),
+                             descriptionStyle);
   } else if (parameter->type() == ParameterObject::ParameterType::Number) {
-    auto *numberParameter = static_cast<NumberParameter *>(parameter);
+    auto* numberParameter = static_cast<NumberParameter*>(parameter);
     if (numberParameter->minimum && numberParameter->maximum) {
       return new ParameterSlider(this, numberParameter, descriptionStyle);
     } else {
       return new ParameterSpinBox(this, numberParameter, descriptionStyle);
     }
   } else if (parameter->type() == ParameterObject::ParameterType::Vector) {
-    return new ParameterVector(this, static_cast<VectorParameter *>(parameter), descriptionStyle);
+    return new ParameterVector(this, static_cast<VectorParameter*>(parameter),
+                               descriptionStyle);
   } else if (parameter->type() == ParameterObject::ParameterType::Enum) {
-    return new ParameterComboBox(this, static_cast<EnumParameter *>(parameter), descriptionStyle);
+    return new ParameterComboBox(this, static_cast<EnumParameter*>(parameter),
+                                 descriptionStyle);
   } else {
     assert(false);
     throw std::runtime_error("Unsupported parameter widget type");
   }
 }
 
-QString ParameterWidget::getJsonFile(const QString& scadFile)
-{
+QString ParameterWidget::getJsonFile(const QString& scadFile) {
   std::filesystem::path p = scadFile.toStdString();
   return QString::fromStdString(p.replace_extension(".json").string());
 }
 
 // Remove set values that do not correspond to a parameter,
 // or that cannot be parsed as such.
-void ParameterWidget::cleanSets()
-{
-  std::map<std::string, ParameterObject *> namedParameters;
+void ParameterWidget::cleanSets() {
+  std::map<std::string, ParameterObject*> namedParameters;
   for (const auto& parameter : parameters) {
     namedParameters[parameter->name()] = parameter.get();
   }
@@ -440,7 +440,9 @@ void ParameterWidget::cleanSets()
   }
 }
 
-void ParameterWidget::setFontFamilySize(const QString& fontFamily, uint fontSize)
-{
-  scrollArea->setStyleSheet(QString("font-family: \"%1\"; font-size: %2pt;").arg(fontFamily).arg(fontSize));
+void ParameterWidget::setFontFamilySize(const QString& fontFamily,
+                                        uint fontSize) {
+  scrollArea->setStyleSheet(QString("font-family: \"%1\"; font-size: %2pt;")
+                                .arg(fontFamily)
+                                .arg(fontSize));
 }
diff --git a/src/gui/parameter/ParameterWidget.h b/src/gui/parameter/ParameterWidget.h
index 7e12786da..30ff4678e 100644
--- a/src/gui/parameter/ParameterWidget.h
+++ b/src/gui/parameter/ParameterWidget.h
@@ -26,47 +26,47 @@
 #pragma once
 
 #include <QString>
-#include <QWidget>
 #include <QTimer>
+#include <QWidget>
 #include <cstddef>
 #include <map>
 #include <string>
 #include <vector>
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
-#include "ui_ParameterWidget.h"
 #include "core/customizer/ParameterObject.h"
 #include "core/customizer/ParameterSet.h"
 #include "gui/parameter/ParameterVirtualWidget.h"
+#include "gui/qtgettext.h"  // IWYU pragma: keep
+#include "ui_ParameterWidget.h"
 
-class ParameterWidget : public QWidget, public Ui::ParameterWidget
-{
+class ParameterWidget : public QWidget, public Ui::ParameterWidget {
   Q_OBJECT
-private:
+ private:
   ParameterSets sets;
   std::string source;
   ParameterObjects parameters;
-  std::map<ParameterObject *, std::vector<ParameterVirtualWidget *>> widgets;
+  std::map<ParameterObject*, std::vector<ParameterVirtualWidget*>> widgets;
 
-  QString invalidJsonFile; // set if a json file was read that could not be parsed
+  QString
+      invalidJsonFile;  // set if a json file was read that could not be parsed
   QTimer autoPreviewTimer;
   bool modified = false;
 
-public:
-  ParameterWidget(QWidget *parent = nullptr);
+ public:
+  ParameterWidget(QWidget* parent = nullptr);
   void readFile(const QString& scadFile);
   void saveFile(const QString& scadFile);
   void saveBackupFile(const QString& scadFile);
-  void setParameters(const SourceFile *sourceFile, const std::string& source);
-  void applyParameters(SourceFile *sourceFile);
+  void setParameters(const SourceFile* sourceFile, const std::string& source);
+  void applyParameters(SourceFile* sourceFile);
   bool childHasFocus();
   bool isModified() const { return modified; }
 
-public slots:
+ public slots:
   void setModified(bool modified = true);
   void setFontFamilySize(const QString& fontfamily, uint fontsize);
 
-protected slots:
+ protected slots:
   void autoPreview(bool immediate = false);
   void emitParametersChanged();
   void onSetChanged(int index);
@@ -79,7 +79,7 @@ protected slots:
   void updateSetEditability();
   void rebuildWidgets();
 
-signals:
+ signals:
   // emitted when the effective values of the parameters have changed,
   // and the model view can be updated
   void parametersChanged();
@@ -87,14 +87,15 @@ signals:
   // and the parameter sets should be saved before closing
   void modificationChanged();
 
-protected:
-  struct ParameterGroup
-  {
+ protected:
+  struct ParameterGroup {
     QString name;
-    std::vector<ParameterObject *> parameters;
+    std::vector<ParameterObject*> parameters;
   };
   std::vector<ParameterGroup> getParameterGroups();
-  ParameterVirtualWidget *createParameterWidget(ParameterObject *parameter, DescriptionStyle descriptionStyle);
+  ParameterVirtualWidget* createParameterWidget(
+      ParameterObject* parameter,
+      DescriptionStyle descriptionStyle);
   QString getJsonFile(const QString& scadFile);
   void cleanSets();
 };
diff --git a/src/gui/qt-obsolete.h b/src/gui/qt-obsolete.h
index ccda5d70c..bb9e83864 100644
--- a/src/gui/qt-obsolete.h
+++ b/src/gui/qt-obsolete.h
@@ -8,10 +8,11 @@
 
 #if (QT_VERSION < QT_VERSION_CHECK(5, 15, 0))
 namespace std {
-template <> struct hash<QString> {
+template <>
+struct hash<QString> {
   std::size_t operator()(const QString& s) const noexcept {
-    return (size_t) qHash(s);
+    return (size_t)qHash(s);
   }
 };
-}
+}  // namespace std
 #endif
diff --git a/src/gui/qtgettext.h b/src/gui/qtgettext.h
index 6671ac674..5b7cfb4b4 100644
--- a/src/gui/qtgettext.h
+++ b/src/gui/qtgettext.h
@@ -13,10 +13,6 @@
 #include <QString>
 #include "utils/printutils.h"
 
-inline QString q_(const char *msgid, const char *msgctxt)
-{
-  return QString::fromUtf8(msgctxt ?
-                           _(msgid, msgctxt):
-                           _(msgid)
-                           );
+inline QString q_(const char* msgid, const char* msgctxt) {
+  return QString::fromUtf8(msgctxt ? _(msgid, msgctxt) : _(msgid));
 }
diff --git a/src/guitests/TestMainWindow.cc b/src/guitests/TestMainWindow.cc
index 1dd34d187..0d9dc951d 100644
--- a/src/guitests/TestMainWindow.cc
+++ b/src/guitests/TestMainWindow.cc
@@ -1,13 +1,13 @@
-#include <QTest>
-#include <QStringList>
 #include "TestMainWindow.h"
+#include <QStringList>
+#include <QTest>
 #include "platform/PlatformUtils.h"
 
-void TestMainWindow::checkOpenTabPropagateToWindow()
-{
+void TestMainWindow::checkOpenTabPropagateToWindow() {
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/empty.scad";
 
   // When we open a new file,
   window->tabManager->open(filename);
@@ -15,7 +15,8 @@ void TestMainWindow::checkOpenTabPropagateToWindow()
   // The window title must also have the name of open file
   QCOMPARE(window->windowTitle(), QFileInfo(filename).fileName());
 
-  filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty2.scad";
+  filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+             "/tests/basic-ux/empty2.scad";
 
   // When we open a new file,
   window->tabManager->open(filename);
@@ -24,11 +25,11 @@ void TestMainWindow::checkOpenTabPropagateToWindow()
   QCOMPARE(window->windowTitle(), QFileInfo(filename).fileName());
 }
 
-void TestMainWindow::checkSaveToShouldUpdateWindowTitle()
-{
+void TestMainWindow::checkSaveToShouldUpdateWindowTitle() {
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/empty.scad";
 
   // When we open a new file,
   window->tabManager->open(filename);
diff --git a/src/guitests/TestMainWindow.h b/src/guitests/TestMainWindow.h
index fb4cc7265..fb8ed8e0f 100644
--- a/src/guitests/TestMainWindow.h
+++ b/src/guitests/TestMainWindow.h
@@ -2,10 +2,9 @@
 
 #include "UXTest.h"
 
-class TestMainWindow : public UXTest
-{
+class TestMainWindow : public UXTest {
   Q_OBJECT;
-private slots:
+ private slots:
   void checkOpenTabPropagateToWindow();
   void checkSaveToShouldUpdateWindowTitle();
 };
diff --git a/src/guitests/TestModuleCache.cc b/src/guitests/TestModuleCache.cc
index 1b307acd0..4c0f8a0b1 100644
--- a/src/guitests/TestModuleCache.cc
+++ b/src/guitests/TestModuleCache.cc
@@ -1,63 +1,66 @@
-#include <QTest>
-#include <QStringList>
 #include "TestModuleCache.h"
+#include <QStringList>
+#include <QTest>
 #include "platform/PlatformUtils.h"
 
-void touchFile(const QString& filename)
-{
+void touchFile(const QString& filename) {
   auto timeStamp = QDateTime::currentDateTime();
 
   QFileInfo fileInfo(filename);
   QFile file(filename);
   file.open(QIODevice::WriteOnly);
-  if (file.isOpen()){
+  if (file.isOpen()) {
     file.setFileTime(timeStamp, QFileDevice::FileModificationTime);
     file.setFileTime(timeStamp, QFileDevice::FileAccessTime);
   }
 }
 
-void TestModuleCache::testBasicCache()
-{
+void TestModuleCache::testBasicCache() {
   restoreWindowInitialState();
 
   QString filename = QString::fromStdString("test-tmp.scad");
-  SourceFile *previousFile{nullptr};
-  SourceFile *currentFile{nullptr};
-  connect(window, &MainWindow::compilationDone, [&currentFile](SourceFile *file){
-    currentFile = file;
-  });
+  SourceFile* previousFile{nullptr};
+  SourceFile* currentFile{nullptr};
+  connect(window, &MainWindow::compilationDone,
+          [&currentFile](SourceFile* file) { currentFile = file; });
 
-  window->designActionAutoReload->setChecked(false);   // Disable auto-reload  & preview
-  window->tabManager->open(filename);                  // Open use.scad
-  window->actionReloadRenderPreview();                 // F5
+  window->designActionAutoReload->setChecked(
+      false);                           // Disable auto-reload  & preview
+  window->tabManager->open(filename);   // Open use.scad
+  window->actionReloadRenderPreview();  // F5
 
-  QVERIFY2(currentFile != nullptr, "The file 'test-tmp.scad' should be loaded.");
-  previousFile = currentFile;                          // save the loaded Source from the
+  QVERIFY2(currentFile != nullptr,
+           "The file 'test-tmp.scad' should be loaded.");
+  previousFile = currentFile;  // save the loaded Source from the
 
   window->actionReloadRenderPreview();
-  QVERIFY2(previousFile == currentFile, "The file should be the same as the file cache should have done its work.");
+  QVERIFY2(previousFile == currentFile,
+           "The file should be the same as the file cache should have done its "
+           "work.");
   sleep(1);
 
   touchFile(filename);
   window->actionReloadRenderPreview();
-  QVERIFY2(previousFile != currentFile, "The file should *not* be the same as the file cache should have detected the timestamp change.");
+  QVERIFY2(previousFile != currentFile,
+           "The file should *not* be the same as the file cache should have "
+           "detected the timestamp change.");
 }
 
-std::vector<std::string>& findNode(std::shared_ptr<AbstractNode> node, std::vector<std::string>& path)
-{
+std::vector<std::string>& findNode(std::shared_ptr<AbstractNode> node,
+                                   std::vector<std::string>& path) {
   path.push_back(node->verbose_name());
   for (auto child : node->getChildren())
     return findNode(child, path);
   return path;
 }
 
-void TestModuleCache::testMCAD()
-{
+void TestModuleCache::testMCAD() {
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/modulecache-tests/use-mcad.scad";
-  window->tabManager->open(filename);             // Open use-mcad.scad
-  window->actionReloadRenderPreview();            // F5
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/modulecache-tests/use-mcad.scad";
+  window->tabManager->open(filename);   // Open use-mcad.scad
+  window->actionReloadRenderPreview();  // F5
 
   auto node = window->instantiateRootFromSource(window->rootFile);
   QVERIFY2(node->verbose_name().empty(), "Root node name must be empty");
diff --git a/src/guitests/TestModuleCache.h b/src/guitests/TestModuleCache.h
index 056b9577b..0490a30fa 100644
--- a/src/guitests/TestModuleCache.h
+++ b/src/guitests/TestModuleCache.h
@@ -2,14 +2,13 @@
 
 #include "UXTest.h"
 
-class TestModuleCache : public UXTest
-{
+class TestModuleCache : public UXTest {
   Q_OBJECT;
 
-private slots:
+ private slots:
   void testBasicCache();
   void testMCAD();
 
-private:
+ private:
   QStringList files;
 };
diff --git a/src/guitests/TestTabManager.cc b/src/guitests/TestTabManager.cc
index 5833a0ac3..9f443eda1 100644
--- a/src/guitests/TestTabManager.cc
+++ b/src/guitests/TestTabManager.cc
@@ -1,19 +1,19 @@
-#include <QTest>
+#include "TestTabManager.h"
 #include <QStringList>
+#include <QTest>
 #include "platform/PlatformUtils.h"
-#include "TestTabManager.h"
 
-void TestTabManager::initTestCase()
-{
-}
+void TestTabManager::initTestCase() {}
 
-void TestTabManager::checkOpenClose()
-{
+void TestTabManager::checkOpenClose() {
   // The window has only one editor with file default.scad
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
-  QString filename2 = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty2.scad";
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/empty.scad";
+  QString filename2 =
+      QString::fromStdString(PlatformUtils::resourceBasePath()) +
+      "/tests/basic-ux/empty2.scad";
 
   window->tabManager->open(filename);
   // The active editor must have a filepath equal to the loaded file
@@ -33,18 +33,19 @@ void TestTabManager::checkOpenClose()
   QCOMPARE(window->tabManager->count(), 1);
 }
 
-void TestTabManager::checkReOpen()
-{
+void TestTabManager::checkReOpen() {
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/empty.scad";
   auto numPanel = window->tabManager->count();
 
   // When we open a new file,
   window->tabManager->open(filename);
   QCOMPARE(numPanel + 1, window->tabManager->count());
 
-  // When we re-open a new file, nothing should happens as the file is already there
+  // When we re-open a new file, nothing should happens as the file is already
+  // there
   window->tabManager->open(filename);
   QCOMPARE(numPanel + 1, window->tabManager->count());
 
diff --git a/src/guitests/TestTabManager.h b/src/guitests/TestTabManager.h
index 194024062..1995d46ad 100644
--- a/src/guitests/TestTabManager.h
+++ b/src/guitests/TestTabManager.h
@@ -1,10 +1,9 @@
 #pragma once
 #include "UXTest.h"
 
-class TestTabManager : public UXTest
-{
+class TestTabManager : public UXTest {
   Q_OBJECT;
-private slots:
+ private slots:
   void initTestCase();
   void checkOpenClose();
   void checkReOpen();
diff --git a/src/guitests/UXTest.cc b/src/guitests/UXTest.cc
index 5e67bf9f0..d71cb3869 100644
--- a/src/guitests/UXTest.cc
+++ b/src/guitests/UXTest.cc
@@ -1,15 +1,19 @@
 #include "UXTest.h"
 #include "platform/PlatformUtils.h"
 
-void UXTest::setWindow(MainWindow *window_){ window = window_; }
+void UXTest::setWindow(MainWindow* window_) {
+  window = window_;
+}
 
-void UXTest::restoreWindowInitialState(){
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/default.scad";
+void UXTest::restoreWindowInitialState() {
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/default.scad";
   window->tabManager->open(filename);
 
-  while (window->tabCount > 1){
+  while (window->tabCount > 1) {
     window->tabManager->closeCurrentTab();
   }
 
-  window->designActionAutoReload->setChecked(true);   // Enable auto-reload  & preview
+  window->designActionAutoReload->setChecked(
+      true);  // Enable auto-reload  & preview
 }
diff --git a/src/guitests/UXTest.h b/src/guitests/UXTest.h
index 88282efa8..599934105 100644
--- a/src/guitests/UXTest.h
+++ b/src/guitests/UXTest.h
@@ -3,15 +3,14 @@
 #include <QObject>
 #include "gui/MainWindow.h"
 
-class UXTest : public QObject
-{
+class UXTest : public QObject {
   Q_OBJECT;
 
-public:
-  void setWindow(MainWindow *window);
+ public:
+  void setWindow(MainWindow* window);
 
-protected:
+ protected:
   void restoreWindowInitialState();
 
-  MainWindow *window;
+  MainWindow* window;
 };
diff --git a/src/guitests/guitests.cc b/src/guitests/guitests.cc
index 7399bbc01..3d05fecf7 100644
--- a/src/guitests/guitests.cc
+++ b/src/guitests/guitests.cc
@@ -1,28 +1,28 @@
-#include "TestModuleCache.h"
 #include "TestMainWindow.h"
+#include "TestModuleCache.h"
 #include "TestTabManager.h"
 
 #include <QTest>
 
 template <typename TestClass>
-int runTests(MainWindow *window)
-{
+int runTests(MainWindow* window) {
   TestClass tc;
   tc.setWindow(window);
   return QTest::qExec(&tc);
   return 0;
 }
 
-int runAllTest(MainWindow *window)
-{
+int runAllTest(MainWindow* window) {
   int totalTestFailures = 0;
-  std::cout << "******************************* RUN UX TESTS ********************************" << std::endl;
+  std::cout << "******************************* RUN UX TESTS "
+               "********************************"
+            << std::endl;
   totalTestFailures += runTests<TestTabManager>(window);
   totalTestFailures += runTests<TestMainWindow>(window);
   totalTestFailures += runTests<TestModuleCache>(window);
-  std::cout << "********************************** RESULTS *********************************" << std::endl;
+  std::cout << "********************************** RESULTS "
+               "*********************************"
+            << std::endl;
   std::cout << "Failures: " << totalTestFailures << std::endl;
   return totalTestFailures;
 }
-
-
diff --git a/src/guitests/guitests.h b/src/guitests/guitests.h
index 21b9d0491..0c5a42011 100644
--- a/src/guitests/guitests.h
+++ b/src/guitests/guitests.h
@@ -1,4 +1,4 @@
 #pragma once
 
 #include "gui/MainWindow.h"
-int runAllTest(MainWindow *window);
+int runAllTest(MainWindow* window);
diff --git a/src/handle_dep.cc b/src/handle_dep.cc
index b3cf27679..05e27d108 100644
--- a/src/handle_dep.cc
+++ b/src/handle_dep.cc
@@ -18,7 +18,7 @@
 
 namespace fs = std::filesystem;
 
-const char *make_command = nullptr;
+const char* make_command = nullptr;
 
 namespace {
 
@@ -26,58 +26,61 @@ std::unordered_set<std::string> dependencies;
 
 }  // namespace
 
-void handle_dep(const std::string& filename)
-{
+void handle_dep(const std::string& filename) {
   const fs::path filepath(filename);
-  const std::string dep = boost::regex_replace(filepath.generic_string(), boost::regex("\\ "), "\\\\ ");
+  const std::string dep = boost::regex_replace(filepath.generic_string(),
+                                               boost::regex("\\ "), "\\\\ ");
   if (dependencies.find(dep) != dependencies.end()) {
-    return; // included and used files are very likely to be added many times by the parser
+    return;  // included and used files are very likely to be added many times
+             // by the parser
   }
   dependencies.insert(dep);
 
   if (make_command && !fs::exists(filepath)) {
     // This should only happen from command-line execution.
     // If changed, add an alternate error-reporting process.
-    auto cmd = STR(make_command, " '", boost::regex_replace(filename, boost::regex("'"), "'\\''"), "'");
+    auto cmd =
+        STR(make_command, " '",
+            boost::regex_replace(filename, boost::regex("'"), "'\\''"), "'");
     errno = 0;
     int res = system(cmd.c_str());
 
     // Could not launch system() correctly
 #ifdef _WIN32
     if ((res == 0 || res == -1) && errno != 0) {
-#else // NOT _WIN32
+#else   // NOT _WIN32
     if (res == -1 && errno != 0) {
-#endif // _WIN32 / NOT _WIN32
+#endif  // _WIN32 / NOT _WIN32
       perror("ERROR: system(make_cmd) failed");
     }
-
-#ifndef _WIN32 // NOT _WIN32
+#ifndef _WIN32  // NOT _WIN32
     // Abnormal process failure (e.g., segfault, killed, etc)
     else if (!WIFEXITED(res)) {
       std::cerr << "ERROR: " << cmd.c_str()
                 << ": Process terminated abnormally!" << std::endl;
     }
-#endif // NOT _WIN32
+#endif  // NOT _WIN32
 
     // Error code from process.
 #ifdef _WIN32
     else if (0 != res) {
-#else // NOT _WIN32
+#else   // NOT _WIN32
     else if (0 != (res = WEXITSTATUS(res))) {
-#endif // _WIN32 / NOT _WIN32
-      std::cerr << "ERROR: " << cmd.c_str() << ": Exit status "
-                << res << std::endl;
+#endif  // _WIN32 / NOT _WIN32
+      std::cerr << "ERROR: " << cmd.c_str() << ": Exit status " << res
+                << std::endl;
     }
 
     // Otherwise, success!
   }
 }
 
-bool write_deps(const std::string& filename, const std::vector<std::string>& output_files)
-{
-  FILE *fp = fopen(filename.c_str(), "wt");
+bool write_deps(const std::string& filename,
+                const std::vector<std::string>& output_files) {
+  FILE* fp = fopen(filename.c_str(), "wt");
   if (!fp) {
-    fprintf(stderr, "Can't open dependencies file `%s' for writing!\n", filename.c_str());
+    fprintf(stderr, "Can't open dependencies file `%s' for writing!\n",
+            filename.c_str());
     return false;
   }
   for (const auto& output_file : output_files) {
diff --git a/src/handle_dep.h b/src/handle_dep.h
index da426173c..17ae82a41 100644
--- a/src/handle_dep.h
+++ b/src/handle_dep.h
@@ -3,6 +3,7 @@
 #include <string>
 #include <vector>
 
-extern const char *make_command;
+extern const char* make_command;
 void handle_dep(const std::string& filename);
-bool write_deps(const std::string& filename, const std::vector<std::string>& output_files);
+bool write_deps(const std::string& filename,
+                const std::vector<std::string>& output_files);
diff --git a/src/io/DxfData.cc b/src/io/DxfData.cc
index a90944a5b..b68632248 100644
--- a/src/io/DxfData.cc
+++ b/src/io/DxfData.cc
@@ -44,13 +44,12 @@
 
 #include "core/Value.h"
 #include "geometry/Grid.h"
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "io/fileutils.h"
 #include "utils/calc.h"
 #include "utils/degree_trig.h"
 #include "utils/printutils.h"
-#include "utils/printutils.h"
 
 namespace fs = std::filesystem;
 
@@ -61,27 +60,31 @@ namespace fs = std::filesystem;
 
    1) Read DXF file from disk
    2) Store contents of DXF files as points, paths and dims
-   3) Store 2D polygons, both from the polygon() module and from 2D CSG operations.
-     Used for tessellation into triangles
-   4) Store 2D polygons before exporting to DXF
+   3) Store 2D polygons, both from the polygon() module and from 2D CSG
+   operations. Used for tessellation into triangles 4) Store 2D polygons before
+   exporting to DXF
 
 
  */
 
 struct Line {
-  int idx[2] = {-1, -1}; // indices into DxfData::points
+  int idx[2] = {-1, -1};  // indices into DxfData::points
   bool disabled{false};
   Line() = default;
-  Line(int i1, int i2) : idx{i1, i2} { }
+  Line(int i1, int i2) : idx{i1, i2} {}
 };
 
 /*!
    Reads a layer from the given file, or all layers if layername.empty()
  */
-DxfData::DxfData(double fn, double fs, double fa,
-                 const std::string& filename, const std::string& layername,
-                 double xorigin, double yorigin, double scale)
-{
+DxfData::DxfData(double fn,
+                 double fs,
+                 double fa,
+                 const std::string& filename,
+                 const std::string& layername,
+                 double xorigin,
+                 double yorigin,
+                 double scale) {
   std::ifstream stream(filename.c_str());
   if (!stream.good()) {
     LOG(message_group::Warning, "Can't open DXF file '%1$s'.", filename);
@@ -89,35 +92,35 @@ DxfData::DxfData(double fn, double fs, double fa,
   }
 
   Grid2d<std::vector<int>> grid(GRID_COARSE);
-  std::vector<Line> lines;                 // Global lines
-  std::unordered_map<std::string, std::vector<Line>> blockdata; // Lines in blocks
+  std::vector<Line> lines;  // Global lines
+  std::unordered_map<std::string, std::vector<Line>>
+      blockdata;  // Lines in blocks
 
   auto in_entities_section = false;
   auto in_blocks_section = false;
   std::string current_block;
 
-#define ADD_LINE(_x1, _y1, _x2, _y2) do {                   \
-          double _p1x = (_x1), _p1y = (_y1), _p2x = (_x2), _p2y = (_y2); \
-          if (!in_entities_section && !in_blocks_section)         \
-          break;                                                \
-          if (in_entities_section &&                              \
-              !(layername.empty() || layername == layer))         \
-          break;                                                \
-          grid.align(_p1x, _p1y);                                 \
-          grid.align(_p2x, _p2y);                                 \
-          grid.data(_p1x, _p1y).push_back(lines.size());          \
-          grid.data(_p2x, _p2y).push_back(lines.size());          \
-          if (in_entities_section)                                \
-          lines.emplace_back(                                   \
-            addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \
-          if (in_blocks_section && !current_block.empty())        \
-          blockdata[current_block].emplace_back(                \
-            addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \
-} while (0)
+#define ADD_LINE(_x1, _y1, _x2, _y2)                                       \
+  do {                                                                     \
+    double _p1x = (_x1), _p1y = (_y1), _p2x = (_x2), _p2y = (_y2);         \
+    if (!in_entities_section && !in_blocks_section)                        \
+      break;                                                               \
+    if (in_entities_section && !(layername.empty() || layername == layer)) \
+      break;                                                               \
+    grid.align(_p1x, _p1y);                                                \
+    grid.align(_p2x, _p2y);                                                \
+    grid.data(_p1x, _p1y).push_back(lines.size());                         \
+    grid.data(_p2x, _p2y).push_back(lines.size());                         \
+    if (in_entities_section)                                               \
+      lines.emplace_back(addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));      \
+    if (in_blocks_section && !current_block.empty())                       \
+      blockdata[current_block].emplace_back(addPoint(_p1x, _p1y),          \
+                                            addPoint(_p2x, _p2y));         \
+  } while (0)
 
   std::string mode, layer, name, iddata;
   int dimtype = 0;
-  double coords[7][2]; // Used by DIMENSION entities
+  double coords[7][2];  // Used by DIMENSION entities
   std::vector<double> xverts;
   std::vector<double> yverts;
   double radius = 0;
@@ -148,7 +151,8 @@ DxfData::DxfData(double fn, double fs, double fa,
       id = boost::lexical_cast<int>(id_str);
     } catch (const boost::bad_lexical_cast& blc) {
       if (!stream.eof()) {
-        LOG(message_group::Warning, "Illegal ID '%1$s' in `%2$s'", id_str, filename);
+        LOG(message_group::Warning, "Illegal ID '%1$s' in `%2$s'", id_str,
+            filename);
       }
       break;
     }
@@ -159,7 +163,8 @@ DxfData::DxfData(double fn, double fs, double fa,
         } else if (id == 11 || id == 12 || id == 16) {
           coords[id - 10][0] = boost::lexical_cast<double>(data) * scale;
         } else {
-          coords[id - 10][0] = (boost::lexical_cast<double>(data) - xorigin) * scale;
+          coords[id - 10][0] =
+              (boost::lexical_cast<double>(data) - xorigin) * scale;
         }
       }
 
@@ -169,223 +174,262 @@ DxfData::DxfData(double fn, double fs, double fa,
         } else if (id == 21 || id == 22 || id == 26) {
           coords[id - 20][1] = boost::lexical_cast<double>(data) * scale;
         } else {
-          coords[id - 20][1] = (boost::lexical_cast<double>(data) - yorigin) * scale;
+          coords[id - 20][1] =
+              (boost::lexical_cast<double>(data) - yorigin) * scale;
         }
       }
 
       switch (id) {
-      case 0:
-        if (mode == "SECTION") {
-          in_entities_section = iddata == "ENTITIES";
-          in_blocks_section = iddata == "BLOCKS";
-        } else if (mode == "LINE") {
-          ADD_LINE(xverts.at(0), yverts.at(0), xverts.at(1), yverts.at(1));
-        } else if (mode == "LWPOLYLINE") {
-          // assert(xverts.size() == yverts.size());
-          // Get maximum to enforce managed exception if xverts.size() != yverts.size()
-          const int numverts = std::max(xverts.size(), yverts.size());
-          for (int i = 1; i < numverts; ++i) {
-            ADD_LINE(xverts.at(i - 1), yverts.at(i - 1), xverts.at(i % numverts), yverts.at(i % numverts));
-          }
-          // polyline flag is stored in 'dimtype'
-          if (dimtype & 0x01) { // closed polyline
-            ADD_LINE(xverts.at(numverts - 1), yverts.at(numverts - 1), xverts.at(0), yverts.at(0));
-          }
-        } else if (mode == "CIRCLE") {
-          const int n = Calc::get_fragments_from_r(radius, fn, fs, fa);
-          Vector2d center(xverts.at(0), yverts.at(0));
-          for (int i = 0; i < n; ++i) {
-            const double a1 = (360.0 * i) / n;
-            const double a2 = (360.0 * (i + 1)) / n;
-            ADD_LINE(cos_degrees(a1) * radius + center[0], sin_degrees(a1) * radius + center[1],
-                     cos_degrees(a2) * radius + center[0], sin_degrees(a2) * radius + center[1]);
-          }
-        } else if (mode == "ARC") {
-          Vector2d center(xverts.at(0), yverts.at(0));
-          int n = Calc::get_fragments_from_r(radius, fn, fs, fa);
-          while (arc_start_angle > arc_stop_angle) {
-            arc_stop_angle += 360.0;
-          }
-          const double arc_angle = arc_stop_angle - arc_start_angle;
-          n = static_cast<int>(ceil(n * arc_angle / 360));
-          for (int i = 0; i < n; ++i) {
-            const double a1 = arc_start_angle + arc_angle * i / n;
-            const double a2 = arc_start_angle + arc_angle * (i + 1) / n;
-            ADD_LINE(cos_degrees(a1) * radius + center[0], sin_degrees(a1) * radius + center[1],
-                     cos_degrees(a2) * radius + center[0], sin_degrees(a2) * radius + center[1]);
-          }
-        } else if (mode == "ELLIPSE") {
-          // Commented code is meant as documentation of vector math
-          while (ellipse_start_angle > ellipse_stop_angle) ellipse_stop_angle += 2 * M_PI;
-//				Vector2d center(xverts[0], yverts[0]);
-          Vector2d center(xverts.at(0), yverts.at(0));
-//				Vector2d ce(xverts[1], yverts[1]);
-          Vector2d ce(xverts.at(1), yverts.at(1));
-//				double r_major = ce.length();
-          const double r_major = sqrt(ce[0] * ce[0] + ce[1] * ce[1]);
-//				double rot_angle = ce.angle();
-          double rot_angle;
-          {
-//					double dot = ce.dot(Vector2d(1.0, 0.0));
-            const double dot = ce[0];
-            double cosval = dot / r_major;
-            if (cosval > 1.0) cosval = 1.0;
-            if (cosval < -1.0) cosval = -1.0;
-            rot_angle = acos(cosval);
-            if (ce[1] < 0.0) rot_angle = 2 * M_PI - rot_angle;
-          }
+        case 0:
+          if (mode == "SECTION") {
+            in_entities_section = iddata == "ENTITIES";
+            in_blocks_section = iddata == "BLOCKS";
+          } else if (mode == "LINE") {
+            ADD_LINE(xverts.at(0), yverts.at(0), xverts.at(1), yverts.at(1));
+          } else if (mode == "LWPOLYLINE") {
+            // assert(xverts.size() == yverts.size());
+            // Get maximum to enforce managed exception if xverts.size() !=
+            // yverts.size()
+            const int numverts = std::max(xverts.size(), yverts.size());
+            for (int i = 1; i < numverts; ++i) {
+              ADD_LINE(xverts.at(i - 1), yverts.at(i - 1),
+                       xverts.at(i % numverts), yverts.at(i % numverts));
+            }
+            // polyline flag is stored in 'dimtype'
+            if (dimtype & 0x01) {  // closed polyline
+              ADD_LINE(xverts.at(numverts - 1), yverts.at(numverts - 1),
+                       xverts.at(0), yverts.at(0));
+            }
+          } else if (mode == "CIRCLE") {
+            const int n = Calc::get_fragments_from_r(radius, fn, fs, fa);
+            Vector2d center(xverts.at(0), yverts.at(0));
+            for (int i = 0; i < n; ++i) {
+              const double a1 = (360.0 * i) / n;
+              const double a2 = (360.0 * (i + 1)) / n;
+              ADD_LINE(cos_degrees(a1) * radius + center[0],
+                       sin_degrees(a1) * radius + center[1],
+                       cos_degrees(a2) * radius + center[0],
+                       sin_degrees(a2) * radius + center[1]);
+            }
+          } else if (mode == "ARC") {
+            Vector2d center(xverts.at(0), yverts.at(0));
+            int n = Calc::get_fragments_from_r(radius, fn, fs, fa);
+            while (arc_start_angle > arc_stop_angle) {
+              arc_stop_angle += 360.0;
+            }
+            const double arc_angle = arc_stop_angle - arc_start_angle;
+            n = static_cast<int>(ceil(n * arc_angle / 360));
+            for (int i = 0; i < n; ++i) {
+              const double a1 = arc_start_angle + arc_angle * i / n;
+              const double a2 = arc_start_angle + arc_angle * (i + 1) / n;
+              ADD_LINE(cos_degrees(a1) * radius + center[0],
+                       sin_degrees(a1) * radius + center[1],
+                       cos_degrees(a2) * radius + center[0],
+                       sin_degrees(a2) * radius + center[1]);
+            }
+          } else if (mode == "ELLIPSE") {
+            // Commented code is meant as documentation of vector math
+            while (ellipse_start_angle > ellipse_stop_angle)
+              ellipse_stop_angle += 2 * M_PI;
+            //				Vector2d center(xverts[0], yverts[0]);
+            Vector2d center(xverts.at(0), yverts.at(0));
+            //				Vector2d ce(xverts[1], yverts[1]);
+            Vector2d ce(xverts.at(1), yverts.at(1));
+            //				double r_major = ce.length();
+            const double r_major = sqrt(ce[0] * ce[0] + ce[1] * ce[1]);
+            //				double rot_angle = ce.angle();
+            double rot_angle;
+            {
+              //					double dot =
+              //ce.dot(Vector2d(1.0, 0.0));
+              const double dot = ce[0];
+              double cosval = dot / r_major;
+              if (cosval > 1.0)
+                cosval = 1.0;
+              if (cosval < -1.0)
+                cosval = -1.0;
+              rot_angle = acos(cosval);
+              if (ce[1] < 0.0)
+                rot_angle = 2 * M_PI - rot_angle;
+            }
 
-          // the ratio stored in 'radius; due to the parser code not checking entity type
-          const double r_minor = r_major * radius;
-          const double sweep_angle = ellipse_stop_angle - ellipse_start_angle;
-          int n = Calc::get_fragments_from_r(r_major, fn, fs, fa);
-          n = static_cast<int>(ceil(n * sweep_angle / (2 * M_PI)));
-//				Vector2d p1;
-          Vector2d p1{0.0, 0.0};
-          for (int i = 0; i <= n; ++i) {
-            const double a = (ellipse_start_angle + sweep_angle * i / n);
-//					Vector2d p2(cos(a)*r_major, sin(a)*r_minor);
-            Vector2d p2(cos(a) * r_major, sin(a) * r_minor);
-//					p2.rotate(rot_angle);
-            Vector2d p2_rot(cos(rot_angle) * p2[0] - sin(rot_angle) * p2[1],
-                            sin(rot_angle) * p2[0] + cos(rot_angle) * p2[1]);
-//					p2 += center;
-            p2_rot[0] += center[0];
-            p2_rot[1] += center[1];
-            if (i > 0) {
-//            ADD_LINE(p1[0], p1[1], p2[0], p2[1]);
-              ADD_LINE(p1[0], p1[1], p2_rot[0], p2_rot[1]);
+            // the ratio stored in 'radius; due to the parser code not checking
+            // entity type
+            const double r_minor = r_major * radius;
+            const double sweep_angle = ellipse_stop_angle - ellipse_start_angle;
+            int n = Calc::get_fragments_from_r(r_major, fn, fs, fa);
+            n = static_cast<int>(ceil(n * sweep_angle / (2 * M_PI)));
+            //				Vector2d p1;
+            Vector2d p1{0.0, 0.0};
+            for (int i = 0; i <= n; ++i) {
+              const double a = (ellipse_start_angle + sweep_angle * i / n);
+              //					Vector2d
+              //p2(cos(a)*r_major, sin(a)*r_minor);
+              Vector2d p2(cos(a) * r_major, sin(a) * r_minor);
+              //					p2.rotate(rot_angle);
+              Vector2d p2_rot(cos(rot_angle) * p2[0] - sin(rot_angle) * p2[1],
+                              sin(rot_angle) * p2[0] + cos(rot_angle) * p2[1]);
+              //					p2 += center;
+              p2_rot[0] += center[0];
+              p2_rot[1] += center[1];
+              if (i > 0) {
+                //            ADD_LINE(p1[0], p1[1], p2[0], p2[1]);
+                ADD_LINE(p1[0], p1[1], p2_rot[0], p2_rot[1]);
+              }
+              //					p1 = p2;
+              p1[0] = p2_rot[0];
+              p1[1] = p2_rot[1];
             }
-//					p1 = p2;
-            p1[0] = p2_rot[0];
-            p1[1] = p2_rot[1];
-          }
-        } else if (mode == "INSERT") {
-          // scale is stored in ellipse_start|stop_angle, rotation in arc_start_angle;
-          // due to the parser code not checking entity type
-          const int n = blockdata[iddata].size();
-          for (int i = 0; i < n; ++i) {
-            const double a = arc_start_angle;
-            const double lx1 = this->points[blockdata[iddata][i].idx[0]][0] * ellipse_start_angle;
-            const double ly1 = this->points[blockdata[iddata][i].idx[0]][1] * ellipse_stop_angle;
-            const double lx2 = this->points[blockdata[iddata][i].idx[1]][0] * ellipse_start_angle;
-            const double ly2 = this->points[blockdata[iddata][i].idx[1]][1] * ellipse_stop_angle;
-            const double px1 = (cos_degrees(a) * lx1 - sin_degrees(a) * ly1) * scale + xverts.at(0);
-            const double py1 = (sin_degrees(a) * lx1 + cos_degrees(a) * ly1) * scale + yverts.at(0);
-            const double px2 = (cos_degrees(a) * lx2 - sin_degrees(a) * ly2) * scale + xverts.at(0);
-            const double py2 = (sin_degrees(a) * lx2 + cos_degrees(a) * ly2) * scale + yverts.at(0);
-            ADD_LINE(px1, py1, px2, py2);
+          } else if (mode == "INSERT") {
+            // scale is stored in ellipse_start|stop_angle, rotation in
+            // arc_start_angle; due to the parser code not checking entity type
+            const int n = blockdata[iddata].size();
+            for (int i = 0; i < n; ++i) {
+              const double a = arc_start_angle;
+              const double lx1 = this->points[blockdata[iddata][i].idx[0]][0] *
+                                 ellipse_start_angle;
+              const double ly1 = this->points[blockdata[iddata][i].idx[0]][1] *
+                                 ellipse_stop_angle;
+              const double lx2 = this->points[blockdata[iddata][i].idx[1]][0] *
+                                 ellipse_start_angle;
+              const double ly2 = this->points[blockdata[iddata][i].idx[1]][1] *
+                                 ellipse_stop_angle;
+              const double px1 =
+                  (cos_degrees(a) * lx1 - sin_degrees(a) * ly1) * scale +
+                  xverts.at(0);
+              const double py1 =
+                  (sin_degrees(a) * lx1 + cos_degrees(a) * ly1) * scale +
+                  yverts.at(0);
+              const double px2 =
+                  (cos_degrees(a) * lx2 - sin_degrees(a) * ly2) * scale +
+                  xverts.at(0);
+              const double py2 =
+                  (sin_degrees(a) * lx2 + cos_degrees(a) * ly2) * scale +
+                  yverts.at(0);
+              ADD_LINE(px1, py1, px2, py2);
+            }
+          } else if (mode == "DIMENSION" &&
+                     (layername.empty() || layername == layer)) {
+            this->dims.emplace_back();
+            this->dims.back().type = dimtype;
+            for (int i = 0; i < 7; ++i) {
+              for (int j = 0; j < 2; ++j) {
+                this->dims.back().coords[i][j] = coords[i][j];
+              }
+            }
+            this->dims.back().angle = arc_start_angle;
+            this->dims.back().length = radius;
+            this->dims.back().name = name;
+          } else if (mode == "BLOCK") {
+            current_block = iddata;
+          } else if (mode == "ENDBLK") {
+            current_block.erase();
+          } else if (mode == "ENDSEC") {
+          } else if (in_blocks_section ||
+                     (in_entities_section &&
+                      (layername.empty() || layername == layer))) {
+            unsupported_entities_list[mode]++;
           }
-        } else if (mode == "DIMENSION" &&
-                   (layername.empty() || layername == layer)) {
-          this->dims.emplace_back();
-          this->dims.back().type = dimtype;
-          for (int i = 0; i < 7; ++i) {
-            for (int j = 0; j < 2; ++j) {
-              this->dims.back().coords[i][j] = coords[i][j];
+          mode = data;
+          layer.erase();
+          name.erase();
+          iddata.erase();
+          dimtype = 0;
+          for (auto& coord : coords) {
+            for (double& j : coord) {
+              j = 0;
             }
           }
-          this->dims.back().angle = arc_start_angle;
-          this->dims.back().length = radius;
-          this->dims.back().name = name;
-        } else if (mode == "BLOCK") {
-          current_block = iddata;
-        } else if (mode == "ENDBLK") {
-          current_block.erase();
-        } else if (mode == "ENDSEC") {
-        } else if (in_blocks_section || (in_entities_section &&
-                                         (layername.empty() || layername == layer))) {
-          unsupported_entities_list[mode]++;
-        }
-        mode = data;
-        layer.erase();
-        name.erase();
-        iddata.erase();
-        dimtype = 0;
-        for (auto& coord : coords) {
-          for (double& j : coord) {
-            j = 0;
+          xverts.clear();
+          yverts.clear();
+          radius = arc_start_angle = arc_stop_angle = 0;
+          ellipse_start_angle = ellipse_stop_angle = 0;
+          if (mode == "INSERT") {
+            ellipse_start_angle = ellipse_stop_angle = 1.0;  // scale
           }
-        }
-        xverts.clear();
-        yverts.clear();
-        radius = arc_start_angle = arc_stop_angle = 0;
-        ellipse_start_angle = ellipse_stop_angle = 0;
-        if (mode == "INSERT") {
-          ellipse_start_angle = ellipse_stop_angle = 1.0; // scale
-        }
-        break;
-      case 1:
-        name = data;
-        break;
-      case 2:
-        iddata = data;
-        break;
-      case 8:
-        layer = data;
-        break;
-      case 10: [[fallthrough]];
-      case 11:
-        if (in_blocks_section) {
-          xverts.push_back((boost::lexical_cast<double>(data)));
-        } else {
-          xverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);
-        }
-        break;
-      case 20: [[fallthrough]];
-      case 21:
-        if (in_blocks_section) {
-          yverts.push_back((boost::lexical_cast<double>(data)));
-        } else {
-          yverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);
-        }
-        break;
-      case 40:
-        // CIRCLE, ARC: radius
-        // ELLIPSE: minor to major ratio
-        // DIMENSION (radial, diameter): Leader length
-        radius = boost::lexical_cast<double>(data);
-        if (!in_blocks_section) radius *= scale;
-        break;
-      case 41:
-        // ELLIPSE: start_angle
-        // INSERT: X scale
-        ellipse_start_angle = boost::lexical_cast<double>(data);
-        break;
-      case 50:
-        // ARC: start_angle
-        // INSERT: rot angle
-        // DIMENSION: linear and rotated: angle
-        arc_start_angle = boost::lexical_cast<double>(data);
-        break;
-      case 42:
-        // ELLIPSE: stop_angle
-        // INSERT: Y scale
-        ellipse_stop_angle = boost::lexical_cast<double>(data);
-        break;
-      case 51: // ARC
-        arc_stop_angle = boost::lexical_cast<double>(data);
-        break;
-      case 70:
-        // LWPOLYLINE: polyline flag
-        // DIMENSION: dimension type
-        dimtype = boost::lexical_cast<int>(data);
-        break;
+          break;
+        case 1:
+          name = data;
+          break;
+        case 2:
+          iddata = data;
+          break;
+        case 8:
+          layer = data;
+          break;
+        case 10:
+          [[fallthrough]];
+        case 11:
+          if (in_blocks_section) {
+            xverts.push_back((boost::lexical_cast<double>(data)));
+          } else {
+            xverts.push_back((boost::lexical_cast<double>(data) - xorigin) *
+                             scale);
+          }
+          break;
+        case 20:
+          [[fallthrough]];
+        case 21:
+          if (in_blocks_section) {
+            yverts.push_back((boost::lexical_cast<double>(data)));
+          } else {
+            yverts.push_back((boost::lexical_cast<double>(data) - yorigin) *
+                             scale);
+          }
+          break;
+        case 40:
+          // CIRCLE, ARC: radius
+          // ELLIPSE: minor to major ratio
+          // DIMENSION (radial, diameter): Leader length
+          radius = boost::lexical_cast<double>(data);
+          if (!in_blocks_section)
+            radius *= scale;
+          break;
+        case 41:
+          // ELLIPSE: start_angle
+          // INSERT: X scale
+          ellipse_start_angle = boost::lexical_cast<double>(data);
+          break;
+        case 50:
+          // ARC: start_angle
+          // INSERT: rot angle
+          // DIMENSION: linear and rotated: angle
+          arc_start_angle = boost::lexical_cast<double>(data);
+          break;
+        case 42:
+          // ELLIPSE: stop_angle
+          // INSERT: Y scale
+          ellipse_stop_angle = boost::lexical_cast<double>(data);
+          break;
+        case 51:  // ARC
+          arc_stop_angle = boost::lexical_cast<double>(data);
+          break;
+        case 70:
+          // LWPOLYLINE: polyline flag
+          // DIMENSION: dimension type
+          dimtype = boost::lexical_cast<int>(data);
+          break;
       }
     } catch (boost::bad_lexical_cast& blc) {
-      LOG(message_group::Warning, "Illegal value '%1$s'in `%2$s'", data, filename);
+      LOG(message_group::Warning, "Illegal value '%1$s'in `%2$s'", data,
+          filename);
     } catch (const std::out_of_range& oor) {
-      LOG(message_group::Warning, "Not enough input values for %1$s. in '%2$s'", data, filename);
+      LOG(message_group::Warning, "Not enough input values for %1$s. in '%2$s'",
+          data, filename);
     }
   }
 
   for (const auto& i : unsupported_entities_list) {
     if (layername.empty()) {
       LOG(message_group::Warning,
-          "Unsupported DXF Entity '%1$s' (%2$x) in %3$s.", i.first, i.second, QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+          "Unsupported DXF Entity '%1$s' (%2$x) in %3$s.", i.first, i.second,
+          QuotedString(
+              fs_uncomplete(filename, fs::current_path()).generic_string()));
     } else {
       LOG(message_group::Warning,
-          "Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s", i.first, i.second, layername, fs_uncomplete(filename, fs::current_path()).generic_string());
+          "Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s",
+          i.first, i.second, layername,
+          fs_uncomplete(filename, fs::current_path()).generic_string());
     }
   }
 
@@ -404,58 +448,66 @@ DxfData::DxfData(double fn, double fs, double fa,
     for (const auto& l : enabled_lines) {
       const int idx = l.second;
       for (int j = 0; j < 2; ++j) {
-        auto lv = grid.data(this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);
+        auto lv = grid.data(this->points[lines[idx].idx[j]][0],
+                            this->points[lines[idx].idx[j]][1]);
         for (const int k : lv) {
           if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-            LOG(message_group::Warning,
-                "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+            LOG(message_group::Warning, "Bad DXF line index in %1$s.",
+                QuotedString(fs_uncomplete(filename, fs::current_path())
+                                 .generic_string()));
             continue;
           }
-          if (k == idx || lines[k].disabled) continue;
+          if (k == idx || lines[k].disabled)
+            continue;
           goto next_open_path_j;
         }
         current_line = idx;
         current_point = j;
         goto create_open_path;
-next_open_path_j:;
+      next_open_path_j:;
       }
     }
 
     break;
 
-create_open_path:
+  create_open_path:
     this->paths.emplace_back();
-    Path *this_path = &this->paths.back();
+    Path* this_path = &this->paths.back();
 
     this_path->indices.push_back(lines[current_line].idx[current_point]);
     while (true) {
       this_path->indices.push_back(lines[current_line].idx[!current_point]);
-      const auto& ref_point = this->points[lines[current_line].idx[!current_point]];
+      const auto& ref_point =
+          this->points[lines[current_line].idx[!current_point]];
       lines[current_line].disabled = true;
       enabled_lines.erase(current_line);
       auto lv = grid.data(ref_point[0], ref_point[1]);
       for (const int k : lv) {
         if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-          LOG(message_group::Warning,
-              "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+          LOG(message_group::Warning, "Bad DXF line index in %1$s.",
+              QuotedString(fs_uncomplete(filename, fs::current_path())
+                               .generic_string()));
           continue;
         }
-        if (lines[k].disabled) continue;
-        auto idk0 = lines[k].idx[0]; // make it easier to read and debug
+        if (lines[k].disabled)
+          continue;
+        auto idk0 = lines[k].idx[0];  // make it easier to read and debug
         auto idk1 = lines[k].idx[1];
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {
+        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0],
+                    this->points[idk0][1])) {
           current_line = k;
           current_point = 0;
           goto found_next_line_in_open_path;
         }
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {
+        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0],
+                    this->points[idk1][1])) {
           current_line = k;
           current_point = 1;
           goto found_next_line_in_open_path;
         }
       }
       break;
-found_next_line_in_open_path:;
+    found_next_line_in_open_path:;
     }
   }
 
@@ -471,32 +523,37 @@ found_next_line_in_open_path:;
     this_path.indices.push_back(lines[current_line].idx[current_point]);
     while (true) {
       this_path.indices.push_back(lines[current_line].idx[!current_point]);
-      const auto& ref_point = this->points[lines[current_line].idx[!current_point]];
+      const auto& ref_point =
+          this->points[lines[current_line].idx[!current_point]];
       lines[current_line].disabled = true;
       enabled_lines.erase(current_line);
       auto lv = grid.data(ref_point[0], ref_point[1]);
       for (const int k : lv) {
         if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-          LOG(message_group::Warning,
-              "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+          LOG(message_group::Warning, "Bad DXF line index in %1$s.",
+              QuotedString(fs_uncomplete(filename, fs::current_path())
+                               .generic_string()));
           continue;
         }
-        if (lines[k].disabled) continue;
-        auto idk0 = lines[k].idx[0]; // make it easier to read and debug
+        if (lines[k].disabled)
+          continue;
+        auto idk0 = lines[k].idx[0];  // make it easier to read and debug
         auto idk1 = lines[k].idx[1];
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {
+        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0],
+                    this->points[idk0][1])) {
           current_line = k;
           current_point = 0;
           goto found_next_line_in_closed_path;
         }
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {
+        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0],
+                    this->points[idk1][1])) {
           current_line = k;
           current_point = 1;
           goto found_next_line_in_closed_path;
         }
       }
       break;
-found_next_line_in_closed_path:;
+    found_next_line_in_closed_path:;
     }
   }
 
@@ -518,10 +575,10 @@ found_next_line_in_closed_path:;
    Ensures that all paths have the same vertex ordering.
    FIXME: CW or CCW?
  */
-void DxfData::fixup_path_direction()
-{
+void DxfData::fixup_path_direction() {
   for (auto& path : this->paths) {
-    if (!path.is_closed) break;
+    if (!path.is_closed)
+      break;
     path.is_inner = true;
     double min_x = this->points[path.indices[0]][0];
     size_t min_x_point = 0;
@@ -535,17 +592,22 @@ void DxfData::fixup_path_direction()
     const size_t b = min_x_point;
     const size_t a = b == 0 ? path.indices.size() - 2 : b - 1;
     const size_t c = b == path.indices.size() - 1 ? 1 : b + 1;
-    const double ax = this->points[path.indices[a]][0] - this->points[path.indices[b]][0];
-    const double ay = this->points[path.indices[a]][1] - this->points[path.indices[b]][1];
-    const double cx = this->points[path.indices[c]][0] - this->points[path.indices[b]][0];
-    const double cy = this->points[path.indices[c]][1] - this->points[path.indices[b]][1];
+    const double ax =
+        this->points[path.indices[a]][0] - this->points[path.indices[b]][0];
+    const double ay =
+        this->points[path.indices[a]][1] - this->points[path.indices[b]][1];
+    const double cx =
+        this->points[path.indices[c]][0] - this->points[path.indices[b]][0];
+    const double cy =
+        this->points[path.indices[c]][1] - this->points[path.indices[b]][1];
 #if 0
     printf("Rotate check:\n");
     printf("  a/b/c indices = %d %d %d\n", a, b, c);
     printf("  b->a vector = %f %f (%f)\n", ax, ay, atan2(ax, ay));
     printf("  b->c vector = %f %f (%f)\n", cx, cy, atan2(cx, cy));
 #endif
-    // FIXME: atan2() usually takes y,x. This variant probably makes the path clockwise..
+    // FIXME: atan2() usually takes y,x. This variant probably makes the path
+    // clockwise..
     if (atan2(ax, ay) < atan2(cx, cy)) {
       std::reverse(path.indices.begin(), path.indices.end());
     }
@@ -555,27 +617,22 @@ void DxfData::fixup_path_direction()
 /*!
    Adds a vertex and returns the index into DxfData::points
  */
-int DxfData::addPoint(double x, double y)
-{
+int DxfData::addPoint(double x, double y) {
   this->points.emplace_back(x, y);
   return this->points.size() - 1;
 }
 
-std::string DxfData::dump() const
-{
+std::string DxfData::dump() const {
   std::ostringstream out;
   out << "DxfData"
-      << "\n num points: " << points.size()
-      << "\n num paths: " << paths.size()
-      << "\n num dims: " << dims.size()
-      << "\n points: ";
+      << "\n num points: " << points.size() << "\n num paths: " << paths.size()
+      << "\n num dims: " << dims.size() << "\n points: ";
   for (const auto& point : points) {
     out << "\n  x y: " << point.transpose();
   }
   out << "\n paths: ";
   for (size_t i = 0; i < paths.size(); ++i) {
-    out << "\n  path:" << i
-        << "\n  is_closed: " << paths[i].is_closed
+    out << "\n  path:" << i << "\n  is_closed: " << paths[i].is_closed
         << "\n  is_inner: " << paths[i].is_inner;
     DxfData::Path path = paths[i];
     for (size_t j = 0; j < path.indices.size(); ++j) {
@@ -589,16 +646,18 @@ std::string DxfData::dump() const
 /*
     May return an empty polygon, but will not return nullptr
  */
-std::unique_ptr<Polygon2d> DxfData::toPolygon2d() const
-{
+std::unique_ptr<Polygon2d> DxfData::toPolygon2d() const {
   auto poly = std::make_unique<Polygon2d>();
   for (const auto& path : this->paths) {
     Outline2d outline;
     size_t endidx = path.indices.size();
-    // We don't support open paths; closing them to be compatible with existing behavior
-    if (!path.is_closed) endidx++;
+    // We don't support open paths; closing them to be compatible with existing
+    // behavior
+    if (!path.is_closed)
+      endidx++;
     for (size_t j = 1; j < endidx; ++j) {
-      outline.vertices.push_back(this->points[path.indices[path.indices.size() - j]]);
+      outline.vertices.push_back(
+          this->points[path.indices[path.indices.size() - j]]);
     }
     poly->addOutline(outline);
   }
diff --git a/src/io/DxfData.h b/src/io/DxfData.h
index bf136ecd0..3eb69ef97 100644
--- a/src/io/DxfData.h
+++ b/src/io/DxfData.h
@@ -6,11 +6,10 @@
 
 #include "geometry/linalg.h"
 
-class DxfData
-{
-public:
+class DxfData {
+ public:
   struct Path {
-    std::vector<int> indices; // indices into DxfData::points
+    std::vector<int> indices;  // indices into DxfData::points
     bool is_closed{false}, is_inner{false};
     Path() = default;
   };
@@ -37,9 +36,14 @@ public:
   std::vector<Dim> dims;
 
   DxfData() = default;
-  DxfData(double fn, double fs, double fa,
-          const std::string& filename, const std::string& layername = "",
-          double xorigin = 0.0, double yorigin = 0.0, double scale = 1.0);
+  DxfData(double fn,
+          double fs,
+          double fa,
+          const std::string& filename,
+          const std::string& layername = "",
+          double xorigin = 0.0,
+          double yorigin = 0.0,
+          double scale = 1.0);
 
   int addPoint(double x, double y);
 
diff --git a/src/io/dxfdim.cc b/src/io/dxfdim.cc
index 91b876b7a..e36a50a79 100644
--- a/src/io/dxfdim.cc
+++ b/src/io/dxfdim.cc
@@ -37,9 +37,9 @@
 
 #include "core/AST.h"
 #include "core/Builtins.h"
-#include "core/function.h"
 #include "core/Parameters.h"
 #include "core/Value.h"
+#include "core/function.h"
 #include "handle_dep.h"
 #include "io/DxfData.h"
 #include "io/fileutils.h"
@@ -50,15 +50,17 @@ std::unordered_map<std::string, double> dxf_dim_cache;
 std::unordered_map<std::string, std::vector<double>> dxf_cross_cache;
 namespace fs = std::filesystem;
 
-static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
-{
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file", "layer", "origin", "scale", "name"});
+static Value builtin_dxf_dim(Arguments arguments, const Location& loc) {
+  const Parameters parameters =
+      Parameters::parse(std::move(arguments), loc, {},
+                        {"file", "layer", "origin", "scale", "name"});
 
   std::string rawFilename;
   std::string filename;
   if (parameters.contains("file")) {
     rawFilename = parameters["file"].toString();
-    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(), parameters.documentRoot());
+    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(),
+                           parameters.documentRoot());
   }
   double xorigin = 0;
   double yorigin = 0;
@@ -66,7 +68,9 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
     bool originOk = parameters["origin"].getVec2(xorigin, yorigin);
     originOk &= std::isfinite(xorigin) && std::isfinite(yorigin);
     if (!originOk) {
-      LOG(message_group::Warning, loc, parameters.documentRoot(), "dxf_dim(..., origin=%1$s) could not be converted", parameters["origin"].toEchoString());
+      LOG(message_group::Warning, loc, parameters.documentRoot(),
+          "dxf_dim(..., origin=%1$s) could not be converted",
+          parameters["origin"].toEchoString());
     }
   }
   std::string layername = parameters.get("layer", "");
@@ -82,21 +86,24 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       lastwritetime = fs_timestamp(filepath);
     }
   } else {
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't open DXF file '%1$s'!", rawFilename);
+    LOG(message_group::Warning, loc, parameters.documentRoot(),
+        "Can't open DXF file '%1$s'!", rawFilename);
     return Value::undefined.clone();
   }
-  const std::string key = STR(filename, "|", layername, "|", name, "|", xorigin,
-                              "|", yorigin, "|", scale, "|", lastwritetime,
-                              "|", filesize);
+  const std::string key =
+      STR(filename, "|", layername, "|", name, "|", xorigin, "|", yorigin, "|",
+          scale, "|", lastwritetime, "|", filesize);
   auto result = dxf_dim_cache.find(key);
-  if (result != dxf_dim_cache.end()) return {result->second};
+  if (result != dxf_dim_cache.end())
+    return {result->second};
   handle_dep(filepath.string());
   DxfData dxf(36, 0, 0, filename, layername, xorigin, yorigin, scale);
 
   for (auto& dim : dxf.dims) {
-    if (!name.empty() && dim.name != name) continue;
+    if (!name.empty() && dim.name != name)
+      continue;
 
-    DxfData::Dim *d = &dim;
+    DxfData::Dim* d = &dim;
     const int type = d->type & 7;
 
     if (type == 0) {
@@ -104,7 +111,8 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       const double x = d->coords[4][0] - d->coords[3][0];
       const double y = d->coords[4][1] - d->coords[3][1];
       const double angle = d->angle;
-      const double distance_projected_on_line = std::fabs(x * cos_degrees(angle) + y * sin_degrees(angle));
+      const double distance_projected_on_line =
+          std::fabs(x * cos_degrees(angle) + y * sin_degrees(angle));
       dxf_dim_cache.emplace(key, distance_projected_on_line);
       return {distance_projected_on_line};
     } else if (type == 1) {
@@ -116,8 +124,10 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       return {value};
     } else if (type == 2) {
       // Angular
-      const double a1 = atan2_degrees(d->coords[0][0] - d->coords[5][0], d->coords[0][1] - d->coords[5][1]);
-      const double a2 = atan2_degrees(d->coords[4][0] - d->coords[3][0], d->coords[4][1] - d->coords[3][1]);
+      const double a1 = atan2_degrees(d->coords[0][0] - d->coords[5][0],
+                                      d->coords[0][1] - d->coords[5][1]);
+      const double a2 = atan2_degrees(d->coords[4][0] - d->coords[3][0],
+                                      d->coords[4][1] - d->coords[3][1]);
       const double value = std::fabs(a1 - a2);
       dxf_dim_cache.emplace(key, value);
       return {value};
@@ -137,25 +147,31 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       return {value};
     }
 
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Dimension '%1$s' in '%2$s', layer '%3$s' has unsupported type!", name, rawFilename, layername);
+    LOG(message_group::Warning, loc, parameters.documentRoot(),
+        "Dimension '%1$s' in '%2$s', layer '%3$s' has unsupported type!", name,
+        rawFilename, layername);
     return Value::undefined.clone();
   }
 
-  LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't find dimension '%1$s' in '%2$s', layer '%3$s'!", name, rawFilename, layername);
+  LOG(message_group::Warning, loc, parameters.documentRoot(),
+      "Can't find dimension '%1$s' in '%2$s', layer '%3$s'!", name, rawFilename,
+      layername);
 
   return Value::undefined.clone();
 }
 
-static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
-{
-  auto *session = arguments.session();
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file", "layer", "origin", "scale", "name"});
+static Value builtin_dxf_cross(Arguments arguments, const Location& loc) {
+  auto* session = arguments.session();
+  const Parameters parameters =
+      Parameters::parse(std::move(arguments), loc, {},
+                        {"file", "layer", "origin", "scale", "name"});
 
   std::string rawFilename;
   std::string filename;
   if (parameters.contains("file")) {
     rawFilename = parameters["file"].toString();
-    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(), parameters.documentRoot());
+    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(),
+                           parameters.documentRoot());
   }
   double xorigin = 0;
   double yorigin = 0;
@@ -163,7 +179,9 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
     bool originOk = parameters["origin"].getVec2(xorigin, yorigin);
     originOk &= std::isfinite(xorigin) && std::isfinite(yorigin);
     if (!originOk) {
-      LOG(message_group::Warning, loc, parameters.documentRoot(), "dxf_cross(..., origin=%1$s) could not be converted", parameters["origin"].toEchoString());
+      LOG(message_group::Warning, loc, parameters.documentRoot(),
+          "dxf_cross(..., origin=%1$s) could not be converted",
+          parameters["origin"].toEchoString());
     }
   }
   std::string layername = parameters.get("layer", "");
@@ -178,13 +196,14 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
       lastwritetime = fs_timestamp(filepath);
     }
   } else {
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't open DXF file '%1$s'!", rawFilename);
+    LOG(message_group::Warning, loc, parameters.documentRoot(),
+        "Can't open DXF file '%1$s'!", rawFilename);
     return Value::undefined.clone();
   }
 
-  const std::string key = STR(filename, "|", layername, "|", xorigin, "|", yorigin,
-                              "|", scale, "|", lastwritetime,
-                              "|", filesize);
+  const std::string key =
+      STR(filename, "|", layername, "|", xorigin, "|", yorigin, "|", scale, "|",
+          lastwritetime, "|", filesize);
 
   auto result = dxf_cross_cache.find(key);
   if (result != dxf_cross_cache.end()) {
@@ -201,7 +220,8 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
   double coords[4][2];
 
   for (size_t i = 0, j = 0; i < dxf.paths.size(); ++i) {
-    if (dxf.paths[i].indices.size() != 2) continue;
+    if (dxf.paths[i].indices.size() != 2)
+      continue;
     coords[j][0] = dxf.points[dxf.paths[i].indices[0]][0];
     coords[j++][1] = dxf.points[dxf.paths[i].indices[0]][1];
     coords[j][0] = dxf.points[dxf.paths[i].indices[1]][0];
@@ -213,7 +233,8 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
       const double x3 = coords[2][0], y3 = coords[2][1];
       const double x4 = coords[3][0], y4 = coords[3][1];
       const double dem = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
-      if (dem == 0) break;
+      if (dem == 0)
+        break;
       const double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / dem;
       // double ub = ((x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3)) / dem;
       const double x = x1 + ua * (x2 - x1);
@@ -229,19 +250,19 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
     }
   }
 
-  LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't find cross in '%1$s', layer '%2$s'!", rawFilename, layername);
+  LOG(message_group::Warning, loc, parameters.documentRoot(),
+      "Can't find cross in '%1$s', layer '%2$s'!", rawFilename, layername);
   return Value::undefined.clone();
 }
 
-void initialize_builtin_dxf_dim()
-{
+void initialize_builtin_dxf_dim() {
   Builtins::init("dxf_dim", new BuiltinFunction(&builtin_dxf_dim),
-  {
-    "dxf_dim()",
-  });
+                 {
+                     "dxf_dim()",
+                 });
 
   Builtins::init("dxf_cross", new BuiltinFunction(&builtin_dxf_cross),
-  {
-    "dxf_cross()",
-  });
+                 {
+                     "dxf_cross()",
+                 });
 }
diff --git a/src/io/export.cc b/src/io/export.cc
index 9a3dfd14a..ce5e818e4 100644
--- a/src/io/export.cc
+++ b/src/io/export.cc
@@ -44,21 +44,20 @@
 #include <vector>
 
 #ifdef _WIN32
-#include <io.h>
 #include <fcntl.h>
+#include <io.h>
 #endif
 
 #include "geometry/Geometry.h"
 #include "geometry/GeometryUtils.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
+#include "geometry/linalg.h"
 #include "glview/Camera.h"
 #include "glview/ColorMap.h"
 #include "glview/RenderSettings.h"
 #include "utils/printutils.h"
 
-
-#define QUOTE(x__) # x__
+#define QUOTE(x__) #x__
 #define QUOTED(x__) QUOTE(x__)
 
 namespace {
@@ -74,33 +73,36 @@ void add_item(Containers& containers, const FileFormatInfo& info) {
 }
 
 Containers& containers() {
-  static std::unique_ptr<Containers> containers = [](){
-      auto containers = std::make_unique<Containers>();
-
-      add_item(*containers, {FileFormat::ASCII_STL, "asciistl", "stl", "STL (ascii)"});
-      add_item(*containers, {FileFormat::BINARY_STL, "binstl", "stl", "STL (binary)"});
-      add_item(*containers, {FileFormat::OBJ, "obj", "obj", "OBJ"});
-      add_item(*containers, {FileFormat::OFF, "off", "off", "OFF"});
-      add_item(*containers, {FileFormat::WRL, "wrl", "wrl", "VRML"});
-      add_item(*containers, {FileFormat::AMF, "amf", "amf", "AMF"});
-      add_item(*containers, {FileFormat::_3MF, "3mf", "3mf", "3MF"});
-      add_item(*containers, {FileFormat::DXF, "dxf", "dxf", "DXF"});
-      add_item(*containers, {FileFormat::SVG, "svg", "svg", "SVG"});
-      add_item(*containers, {FileFormat::NEFDBG, "nefdbg", "nefdbg", "nefdbg"});
-      add_item(*containers, {FileFormat::NEF3, "nef3", "nef3", "nef3"});
-      add_item(*containers, {FileFormat::CSG, "csg", "csg", "CSG"});
-      add_item(*containers, {FileFormat::PARAM, "param", "param", "param"});
-      add_item(*containers, {FileFormat::AST, "ast", "ast", "AST"});
-      add_item(*containers, {FileFormat::TERM, "term", "term", "term"});
-      add_item(*containers, {FileFormat::ECHO, "echo", "echo", "echo"});
-      add_item(*containers, {FileFormat::PNG, "png", "png", "PNG"});
-      add_item(*containers, {FileFormat::PDF, "pdf", "pdf", "PDF"});
-      add_item(*containers, {FileFormat::POV, "pov", "pov", "POV"});
-
-      // Alias
-      containers->identifierToInfo["stl"] = containers->identifierToInfo["asciistl"];
-      return containers;
-    }();
+  static std::unique_ptr<Containers> containers = []() {
+    auto containers = std::make_unique<Containers>();
+
+    add_item(*containers,
+             {FileFormat::ASCII_STL, "asciistl", "stl", "STL (ascii)"});
+    add_item(*containers,
+             {FileFormat::BINARY_STL, "binstl", "stl", "STL (binary)"});
+    add_item(*containers, {FileFormat::OBJ, "obj", "obj", "OBJ"});
+    add_item(*containers, {FileFormat::OFF, "off", "off", "OFF"});
+    add_item(*containers, {FileFormat::WRL, "wrl", "wrl", "VRML"});
+    add_item(*containers, {FileFormat::AMF, "amf", "amf", "AMF"});
+    add_item(*containers, {FileFormat::_3MF, "3mf", "3mf", "3MF"});
+    add_item(*containers, {FileFormat::DXF, "dxf", "dxf", "DXF"});
+    add_item(*containers, {FileFormat::SVG, "svg", "svg", "SVG"});
+    add_item(*containers, {FileFormat::NEFDBG, "nefdbg", "nefdbg", "nefdbg"});
+    add_item(*containers, {FileFormat::NEF3, "nef3", "nef3", "nef3"});
+    add_item(*containers, {FileFormat::CSG, "csg", "csg", "CSG"});
+    add_item(*containers, {FileFormat::PARAM, "param", "param", "param"});
+    add_item(*containers, {FileFormat::AST, "ast", "ast", "AST"});
+    add_item(*containers, {FileFormat::TERM, "term", "term", "term"});
+    add_item(*containers, {FileFormat::ECHO, "echo", "echo", "echo"});
+    add_item(*containers, {FileFormat::PNG, "png", "png", "PNG"});
+    add_item(*containers, {FileFormat::PDF, "pdf", "pdf", "PDF"});
+    add_item(*containers, {FileFormat::POV, "pov", "pov", "POV"});
+
+    // Alias
+    containers->identifierToInfo["stl"] =
+        containers->identifierToInfo["asciistl"];
+    return containers;
+  }();
   return *containers;
 }
 
@@ -108,8 +110,7 @@ Containers& containers() {
 
 namespace fileformat {
 
-std::vector<FileFormat> all()
-{
+std::vector<FileFormat> all() {
   std::vector<FileFormat> allFileFormats;
   for (const auto& item : containers().fileFormatToInfo) {
     allFileFormats.push_back(item.first);
@@ -117,8 +118,7 @@ std::vector<FileFormat> all()
   return allFileFormats;
 }
 
-std::vector<FileFormat> all2D()
-{
+std::vector<FileFormat> all2D() {
   std::vector<FileFormat> all2DFormats;
   for (const auto& item : containers().fileFormatToInfo) {
     if (is2D(item.first)) {
@@ -128,8 +128,7 @@ std::vector<FileFormat> all2D()
   return all2DFormats;
 }
 
-std::vector<FileFormat> all3D()
-{
+std::vector<FileFormat> all3D() {
   std::vector<FileFormat> all3DFormats;
   for (const auto& item : containers().fileFormatToInfo) {
     if (is3D(item.first)) {
@@ -139,65 +138,59 @@ std::vector<FileFormat> all3D()
   return all3DFormats;
 }
 
-const FileFormatInfo& info(FileFormat fileFormat)
-{
+const FileFormatInfo& info(FileFormat fileFormat) {
   return containers().fileFormatToInfo[fileFormat];
 }
 
-bool fromIdentifier(const std::string& identifier, FileFormat& format)
-{
+bool fromIdentifier(const std::string& identifier, FileFormat& format) {
   auto it = containers().identifierToInfo.find(identifier);
-  if (it == containers().identifierToInfo.end()) return false;
+  if (it == containers().identifierToInfo.end())
+    return false;
   format = it->second.format;
   return true;
 }
 
-const std::string& toSuffix(FileFormat format)
-{
+const std::string& toSuffix(FileFormat format) {
   return containers().fileFormatToInfo[format].suffix;
 }
 
 bool canPreview(FileFormat format) {
-  return (format == FileFormat::AST ||
-          format == FileFormat::CSG ||
-          format == FileFormat::PARAM ||
-          format == FileFormat::ECHO ||
-          format == FileFormat::TERM ||
-          format == FileFormat::PNG);
+  return (format == FileFormat::AST || format == FileFormat::CSG ||
+          format == FileFormat::PARAM || format == FileFormat::ECHO ||
+          format == FileFormat::TERM || format == FileFormat::PNG);
 }
 
 bool is3D(FileFormat format) {
-  return format == FileFormat::ASCII_STL ||
-         format == FileFormat::BINARY_STL ||
-         format == FileFormat::OBJ ||
-         format == FileFormat::OFF ||
-         format == FileFormat::WRL ||
-         format == FileFormat::AMF ||
-         format == FileFormat::_3MF ||
-         format == FileFormat::NEFDBG ||
-         format == FileFormat::NEF3 ||
-         format == FileFormat::POV;
+  return format == FileFormat::ASCII_STL || format == FileFormat::BINARY_STL ||
+         format == FileFormat::OBJ || format == FileFormat::OFF ||
+         format == FileFormat::WRL || format == FileFormat::AMF ||
+         format == FileFormat::_3MF || format == FileFormat::NEFDBG ||
+         format == FileFormat::NEF3 || format == FileFormat::POV;
 }
 
 bool is2D(FileFormat format) {
-  return format == FileFormat::DXF ||
-         format == FileFormat::SVG ||
+  return format == FileFormat::DXF || format == FileFormat::SVG ||
          format == FileFormat::PDF;
 }
 
-}  // namespace FileFormat
+}  // namespace fileformat
 
-ExportInfo createExportInfo(const FileFormat& format, const FileFormatInfo& info, const std::string& filepath, const Camera *camera, const CmdLineExportOptions& cmdLineOptions)
-{
-  const auto colorScheme = ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
+ExportInfo createExportInfo(const FileFormat& format,
+                            const FileFormatInfo& info,
+                            const std::string& filepath,
+                            const Camera* camera,
+                            const CmdLineExportOptions& cmdLineOptions) {
+  const auto colorScheme =
+      ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
   auto exportInfo = ExportInfo{
-    .format = format,
-    .info = info,
-    .title = std::filesystem::path(filepath).filename().string(),
-    .sourceFilePath = filepath,
-    .camera = camera,
-    .defaultColor = ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR),
-    .colorScheme = colorScheme,
+      .format = format,
+      .info = info,
+      .title = std::filesystem::path(filepath).filename().string(),
+      .sourceFilePath = filepath,
+      .camera = camera,
+      .defaultColor =
+          ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR),
+      .colorScheme = colorScheme,
   };
 
   if (format == FileFormat::_3MF) {
@@ -209,57 +202,58 @@ ExportInfo createExportInfo(const FileFormat& format, const FileFormatInfo& info
   return exportInfo;
 }
 
-static void exportFile(const std::shared_ptr<const Geometry>& root_geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+static void exportFile(const std::shared_ptr<const Geometry>& root_geom,
+                       std::ostream& output,
+                       const ExportInfo& exportInfo) {
   switch (exportInfo.format) {
-  case FileFormat::ASCII_STL:
-    export_stl(root_geom, output, false);
-    break;
-  case FileFormat::BINARY_STL:
-    export_stl(root_geom, output, true);
-    break;
-  case FileFormat::OBJ:
-    export_obj(root_geom, output);
-    break;
-  case FileFormat::OFF:
-    export_off(root_geom, output);
-    break;
-  case FileFormat::WRL:
-    export_wrl(root_geom, output);
-    break;
-  case FileFormat::AMF:
-    export_amf(root_geom, output);
-    break;
-  case FileFormat::_3MF:
-    export_3mf(root_geom, output, exportInfo);
-    break;
-  case FileFormat::DXF:
-    export_dxf(root_geom, output);
-    break;
-  case FileFormat::SVG:
-    export_svg(root_geom, output);
-    break;
-  case FileFormat::PDF:
-    export_pdf(root_geom, output, exportInfo);
-    break;
-  case FileFormat::POV:
-    export_pov(root_geom, output, exportInfo);
-    break;
+    case FileFormat::ASCII_STL:
+      export_stl(root_geom, output, false);
+      break;
+    case FileFormat::BINARY_STL:
+      export_stl(root_geom, output, true);
+      break;
+    case FileFormat::OBJ:
+      export_obj(root_geom, output);
+      break;
+    case FileFormat::OFF:
+      export_off(root_geom, output);
+      break;
+    case FileFormat::WRL:
+      export_wrl(root_geom, output);
+      break;
+    case FileFormat::AMF:
+      export_amf(root_geom, output);
+      break;
+    case FileFormat::_3MF:
+      export_3mf(root_geom, output, exportInfo);
+      break;
+    case FileFormat::DXF:
+      export_dxf(root_geom, output);
+      break;
+    case FileFormat::SVG:
+      export_svg(root_geom, output);
+      break;
+    case FileFormat::PDF:
+      export_pdf(root_geom, output, exportInfo);
+      break;
+    case FileFormat::POV:
+      export_pov(root_geom, output, exportInfo);
+      break;
 #ifdef ENABLE_CGAL
-  case FileFormat::NEFDBG:
-    export_nefdbg(root_geom, output);
-    break;
-  case FileFormat::NEF3:
-    export_nef3(root_geom, output);
-    break;
+    case FileFormat::NEFDBG:
+      export_nefdbg(root_geom, output);
+      break;
+    case FileFormat::NEF3:
+      export_nef3(root_geom, output);
+      break;
 #endif
-  default:
-    assert(false && "Unknown file format");
+    default:
+      assert(false && "Unknown file format");
   }
 }
 
-bool exportFileStdOut(const std::shared_ptr<const Geometry>& root_geom, const ExportInfo& exportInfo)
-{
+bool exportFileStdOut(const std::shared_ptr<const Geometry>& root_geom,
+                      const ExportInfo& exportInfo) {
 #ifdef _WIN32
   _setmode(_fileno(stdout), _O_BINARY);
 #endif
@@ -267,10 +261,13 @@ bool exportFileStdOut(const std::shared_ptr<const Geometry>& root_geom, const Ex
   return true;
 }
 
-bool exportFileByName(const std::shared_ptr<const Geometry>& root_geom, const std::string& filename, const ExportInfo& exportInfo)
-{
+bool exportFileByName(const std::shared_ptr<const Geometry>& root_geom,
+                      const std::string& filename,
+                      const ExportInfo& exportInfo) {
   std::ios::openmode mode = std::ios::out | std::ios::trunc;
-  if (exportInfo.format == FileFormat::_3MF || exportInfo.format == FileFormat::BINARY_STL || exportInfo.format == FileFormat::PDF) {
+  if (exportInfo.format == FileFormat::_3MF ||
+      exportInfo.format == FileFormat::BINARY_STL ||
+      exportInfo.format == FileFormat::PDF) {
     mode |= std::ios::binary;
   }
   const std::filesystem::path path(filename);
@@ -286,13 +283,14 @@ bool exportFileByName(const std::shared_ptr<const Geometry>& root_geom, const st
     } catch (std::ios::failure&) {
       onerror = true;
     }
-    try { // make sure file closed - resources released
+    try {  // make sure file closed - resources released
       fstream.close();
     } catch (std::ios::failure&) {
       onerror = true;
     }
     if (onerror) {
-      LOG(message_group::Error, _("\"%1$s\" write error. (Disk full?)"), filename);
+      LOG(message_group::Error, _("\"%1$s\" write error. (Disk full?)"),
+          filename);
     }
     return !onerror;
   }
@@ -306,9 +304,9 @@ double remove_negative_zero(double x) {
 
 Vector3d remove_negative_zero(const Vector3d& pt) {
   return {
-    remove_negative_zero(pt[0]),
-    remove_negative_zero(pt[1]),
-    remove_negative_zero(pt[2]),
+      remove_negative_zero(pt[0]),
+      remove_negative_zero(pt[1]),
+      remove_negative_zero(pt[2]),
   };
 }
 
@@ -317,28 +315,32 @@ Vector3d remove_negative_zero(const Vector3d& pt) {
 struct LexographicLess {
   template <class T>
   bool operator()(T const& lhs, T const& rhs) const {
-    return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), std::less{});
+    return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),
+                                        rhs.end(), std::less{});
   }
 };
 #else
 struct LexographicLess {
   template <class T>
   bool operator()(T const& lhs, T const& rhs) const {
-    return std::lexicographical_compare(lhs.data(), lhs.data() + lhs.size(), rhs.data(), rhs.data() + rhs.size(), std::less{});
+    return std::lexicographical_compare(lhs.data(), lhs.data() + lhs.size(),
+                                        rhs.data(), rhs.data() + rhs.size(),
+                                        std::less{});
   }
 };
-#endif // if EIGEN_VERSION_AT_LEAST(3, 4, 0)
+#endif  // if EIGEN_VERSION_AT_LEAST(3, 4, 0)
 
-} // namespace
+}  // namespace
 
 std::string get_current_iso8601_date_time_utc() {
   auto now = std::chrono::system_clock::now();
   auto time = std::chrono::system_clock::to_time_t(now);
-  return STR(std::put_time(gmtime(&time), "%Y-%m-%dT%H:%M:%SZ")); // %F/%T not fully supported everywhere
+  return STR(std::put_time(
+      gmtime(&time),
+      "%Y-%m-%dT%H:%M:%SZ"));  // %F/%T not fully supported everywhere
 }
 
-std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps)
-{
+std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps) {
   auto out = std::make_unique<PolySet>(ps.getDimension(), ps.convexValue());
   out->setTriangular(ps.isTriangular());
   out->setConvexity(ps.getConvexity());
@@ -348,7 +350,8 @@ std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps)
   for (const auto& poly : ps.indices) {
     IndexedFace face;
     for (const auto idx : poly) {
-      auto pos = vertexMap.emplace(remove_negative_zero(ps.vertices[idx]), vertexMap.size());
+      auto pos = vertexMap.emplace(remove_negative_zero(ps.vertices[idx]),
+                                   vertexMap.size());
       face.push_back(pos.first->second);
     }
     out->indices.push_back(face);
@@ -369,7 +372,9 @@ std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps)
     for (const auto idx : poly) {
       polygon.push_back(indexTranslationMap[idx]);
     }
-    std::rotate(polygon.begin(), std::min_element(polygon.begin(), polygon.end()), polygon.end());
+    std::rotate(polygon.begin(),
+                std::min_element(polygon.begin(), polygon.end()),
+                polygon.end());
     poly = polygon;
   }
   if (ps.color_indices.empty()) {
@@ -384,9 +389,10 @@ std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps)
     for (size_t i = 0, n = ps.indices.size(); i < n; i++) {
       faces.push_back({out->indices[i], out->color_indices[i]});
     }
-    std::sort(faces.begin(), faces.end(), [](const ColoredFace& a, const ColoredFace& b) {
-      return a.face < b.face;
-    });
+    std::sort(faces.begin(), faces.end(),
+              [](const ColoredFace& a, const ColoredFace& b) {
+                return a.face < b.face;
+              });
     for (size_t i = 0, n = faces.size(); i < n; i++) {
       auto& face = faces[i];
       out->indices[i] = face.face;
diff --git a/src/io/export.h b/src/io/export.h
index 7b4086e92..f1716abc7 100644
--- a/src/io/export.h
+++ b/src/io/export.h
@@ -9,12 +9,12 @@
 #include <unordered_map>
 #include <vector>
 
-#include <boost/range/algorithm.hpp>
 #include <boost/range/adaptor/map.hpp>
+#include <boost/range/algorithm.hpp>
 
 #include "core/Settings.h"
-#include "core/Tree.h"
 #include "core/SourceFile.h"
+#include "core/Tree.h"
 #include "geometry/Geometry.h"
 #include "geometry/linalg.h"
 #include "glview/Camera.h"
@@ -70,13 +70,16 @@ bool canPreview(FileFormat format);
 bool is3D(FileFormat format);
 bool is2D(FileFormat format);
 
-}  // namespace FileFormat
+}  // namespace fileformat
 
-using CmdLineExportOptions = std::unordered_map<std::string, std::unordered_map<std::string, std::string>>;
+using CmdLineExportOptions =
+    std::unordered_map<std::string,
+                       std::unordered_map<std::string, std::string>>;
 
 template <typename settings_entry_type>
-auto set_cmd_line_option(const CmdLineExportOptions& cmdLineOptions, const std::string& section, const settings_entry_type& se)
-{
+auto set_cmd_line_option(const CmdLineExportOptions& cmdLineOptions,
+                         const std::string& section,
+                         const settings_entry_type& se) {
   if (cmdLineOptions.count(section) == 0) {
     return se.defaultValue();
   }
@@ -110,47 +113,88 @@ struct ExportPdfOptions {
   std::string strokeColor = "black";
   double strokeWidth = 1;
 
-  static std::shared_ptr<const ExportPdfOptions> withOptions(const CmdLineExportOptions& cmdLineOptions) {
+  static std::shared_ptr<const ExportPdfOptions> withOptions(
+      const CmdLineExportOptions& cmdLineOptions) {
     return std::make_shared<const ExportPdfOptions>(ExportPdfOptions{
-      .showScale = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowScale),
-      .showScaleMsg = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowScaleMessage),
-      .showGrid = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowGrid),
-      .gridSize = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfGridSize),
-      .showDesignFilename = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowFilename),
-      .orientation = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfOrientation),
-      .paperSize = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfPaperSize),
-      .addMetaData = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfAddMetaData),
-      .metaDataTitle = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataTitle),
-      .metaDataAuthor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataAuthor),
-      .metaDataSubject = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataSubject),
-      .metaDataKeywords = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataKeywords),
-      .fill = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfFill),
-      .fillColor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfFillColor),
-      .stroke = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStroke),
-      .strokeColor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStrokeColor),
-      .strokeWidth = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStrokeWidth),
+        .showScale = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfShowScale),
+        .showScaleMsg = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfShowScaleMessage),
+        .showGrid =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+                                Settings::SettingsExportPdf::exportPdfShowGrid),
+        .gridSize =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+                                Settings::SettingsExportPdf::exportPdfGridSize),
+        .showDesignFilename = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfShowFilename),
+        .orientation = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfOrientation),
+        .paperSize = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfPaperSize),
+        .addMetaData = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfAddMetaData),
+        .metaDataTitle = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfMetaDataTitle),
+        .metaDataAuthor = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfMetaDataAuthor),
+        .metaDataSubject = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfMetaDataSubject),
+        .metaDataKeywords = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfMetaDataKeywords),
+        .fill =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+                                Settings::SettingsExportPdf::exportPdfFill),
+        .fillColor = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfFillColor),
+        .stroke =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+                                Settings::SettingsExportPdf::exportPdfStroke),
+        .strokeColor = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfStrokeColor),
+        .strokeWidth = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfStrokeWidth),
     });
   }
 
   static const std::shared_ptr<const ExportPdfOptions> fromSettings() {
     return std::make_shared<const ExportPdfOptions>(ExportPdfOptions{
-      .showScale = SPDF::exportPdfShowScale.value(),
-      .showScaleMsg = SPDF::exportPdfShowScaleMessage.value(),
-      .showGrid = SPDF::exportPdfShowGrid.value(),
-      .gridSize = SPDF::exportPdfGridSize.value(),
-      .showDesignFilename = SPDF::exportPdfShowFilename.value(),
-      .orientation = SPDF::exportPdfOrientation.value(),
-      .paperSize = SPDF::exportPdfPaperSize.value(),
-      .addMetaData = SPDF::exportPdfAddMetaData.value(),
-      .metaDataTitle = SPDF::exportPdfMetaDataTitle.value(),
-      .metaDataAuthor = SPDF::exportPdfAddMetaDataAuthor.value() ? SPDF::exportPdfMetaDataAuthor.value() : "",
-      .metaDataSubject = SPDF::exportPdfAddMetaDataSubject.value() ? SPDF::exportPdfMetaDataSubject.value() : "",
-      .metaDataKeywords = SPDF::exportPdfAddMetaDataKeywords.value() ? SPDF::exportPdfMetaDataKeywords.value() : "",
-      .fill = SPDF::exportPdfFill.value(),
-      .fillColor = SPDF::exportPdfFillColor.value(),
-      .stroke = SPDF::exportPdfStroke.value(),
-      .strokeColor = SPDF::exportPdfStrokeColor.value(),
-      .strokeWidth = SPDF::exportPdfStrokeWidth.value(),
+        .showScale = SPDF::exportPdfShowScale.value(),
+        .showScaleMsg = SPDF::exportPdfShowScaleMessage.value(),
+        .showGrid = SPDF::exportPdfShowGrid.value(),
+        .gridSize = SPDF::exportPdfGridSize.value(),
+        .showDesignFilename = SPDF::exportPdfShowFilename.value(),
+        .orientation = SPDF::exportPdfOrientation.value(),
+        .paperSize = SPDF::exportPdfPaperSize.value(),
+        .addMetaData = SPDF::exportPdfAddMetaData.value(),
+        .metaDataTitle = SPDF::exportPdfMetaDataTitle.value(),
+        .metaDataAuthor = SPDF::exportPdfAddMetaDataAuthor.value()
+                              ? SPDF::exportPdfMetaDataAuthor.value()
+                              : "",
+        .metaDataSubject = SPDF::exportPdfAddMetaDataSubject.value()
+                               ? SPDF::exportPdfMetaDataSubject.value()
+                               : "",
+        .metaDataKeywords = SPDF::exportPdfAddMetaDataKeywords.value()
+                                ? SPDF::exportPdfMetaDataKeywords.value()
+                                : "",
+        .fill = SPDF::exportPdfFill.value(),
+        .fillColor = SPDF::exportPdfFillColor.value(),
+        .stroke = SPDF::exportPdfStroke.value(),
+        .strokeColor = SPDF::exportPdfStrokeColor.value(),
+        .strokeWidth = SPDF::exportPdfStrokeWidth.value(),
     });
   }
 };
@@ -169,37 +213,73 @@ struct Export3mfOptions {
   std::string metaDataLicenseTerms;
   std::string metaDataRating;
 
-  static const std::shared_ptr<const Export3mfOptions> withOptions(const CmdLineExportOptions& cmdLineOptions) {
+  static const std::shared_ptr<const Export3mfOptions> withOptions(
+      const CmdLineExportOptions& cmdLineOptions) {
     return std::make_shared<const Export3mfOptions>(Export3mfOptions{
-      .colorMode = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfColorMode),
-      .unit = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfUnit),
-      .color = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfColor),
-      .materialType = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMaterialType),
-      .decimalPrecision = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfDecimalPrecision),
-      .addMetaData = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfAddMetaData),
-      .metaDataTitle = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataTitle),
-      .metaDataDesigner = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataDesigner),
-      .metaDataDescription = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataDescription),
-      .metaDataCopyright = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataCopyright),
-      .metaDataLicenseTerms = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataLicenseTerms),
-      .metaDataRating = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataRating),
+        .colorMode = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfColorMode),
+        .unit =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+                                Settings::SettingsExport3mf::export3mfUnit),
+        .color =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+                                Settings::SettingsExport3mf::export3mfColor),
+        .materialType = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMaterialType),
+        .decimalPrecision = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfDecimalPrecision),
+        .addMetaData = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfAddMetaData),
+        .metaDataTitle = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataTitle),
+        .metaDataDesigner = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataDesigner),
+        .metaDataDescription = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataDescription),
+        .metaDataCopyright = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataCopyright),
+        .metaDataLicenseTerms = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataLicenseTerms),
+        .metaDataRating = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataRating),
     });
   }
 
   static const std::shared_ptr<const Export3mfOptions> fromSettings() {
     return std::make_shared<const Export3mfOptions>(Export3mfOptions{
-      .colorMode = S3MF::export3mfColorMode.value(),
-      .unit = S3MF::export3mfUnit.value(),
-      .color = S3MF::export3mfColor.value(),
-      .materialType = S3MF::export3mfMaterialType.value(),
-      .decimalPrecision = S3MF::export3mfDecimalPrecision.value(),
-      .addMetaData = S3MF::export3mfAddMetaData.value(),
-      .metaDataTitle = S3MF::export3mfMetaDataTitle.value(),
-      .metaDataDesigner = S3MF::export3mfAddMetaDataDesigner.value() ? S3MF::export3mfMetaDataDesigner.value() : "",
-      .metaDataDescription = S3MF::export3mfAddMetaDataDescription.value() ? S3MF::export3mfMetaDataDescription.value() : "",
-      .metaDataCopyright = S3MF::export3mfAddMetaDataCopyright.value() ? S3MF::export3mfMetaDataCopyright.value() : "",
-      .metaDataLicenseTerms = S3MF::export3mfAddMetaDataLicenseTerms.value() ? S3MF::export3mfMetaDataLicenseTerms.value() : "",
-      .metaDataRating = S3MF::export3mfAddMetaDataRating.value() ? S3MF::export3mfMetaDataRating.value() : "",
+        .colorMode = S3MF::export3mfColorMode.value(),
+        .unit = S3MF::export3mfUnit.value(),
+        .color = S3MF::export3mfColor.value(),
+        .materialType = S3MF::export3mfMaterialType.value(),
+        .decimalPrecision = S3MF::export3mfDecimalPrecision.value(),
+        .addMetaData = S3MF::export3mfAddMetaData.value(),
+        .metaDataTitle = S3MF::export3mfMetaDataTitle.value(),
+        .metaDataDesigner = S3MF::export3mfAddMetaDataDesigner.value()
+                                ? S3MF::export3mfMetaDataDesigner.value()
+                                : "",
+        .metaDataDescription = S3MF::export3mfAddMetaDataDescription.value()
+                                   ? S3MF::export3mfMetaDataDescription.value()
+                                   : "",
+        .metaDataCopyright = S3MF::export3mfAddMetaDataCopyright.value()
+                                 ? S3MF::export3mfMetaDataCopyright.value()
+                                 : "",
+        .metaDataLicenseTerms =
+            S3MF::export3mfAddMetaDataLicenseTerms.value()
+                ? S3MF::export3mfMetaDataLicenseTerms.value()
+                : "",
+        .metaDataRating = S3MF::export3mfAddMetaDataRating.value()
+                              ? S3MF::export3mfMetaDataRating.value()
+                              : "",
     });
   }
 };
@@ -208,34 +288,55 @@ struct ExportInfo {
   FileFormat format;
   FileFormatInfo info;
   std::string title;
-  std::string sourceFilePath; // Full path to the OpenSCAD source file
-  const Camera *camera;
+  std::string sourceFilePath;  // Full path to the OpenSCAD source file
+  const Camera* camera;
   const Color4f defaultColor;
-  const ColorScheme *colorScheme;
+  const ColorScheme* colorScheme;
 
   std::shared_ptr<const ExportPdfOptions> optionsPdf;
   std::shared_ptr<const Export3mfOptions> options3mf;
 };
 
-ExportInfo createExportInfo(const FileFormat& format, const FileFormatInfo& info, const std::string& filepath, const Camera *camera, const CmdLineExportOptions& cmdLineOptions);
+ExportInfo createExportInfo(const FileFormat& format,
+                            const FileFormatInfo& info,
+                            const std::string& filepath,
+                            const Camera* camera,
+                            const CmdLineExportOptions& cmdLineOptions);
 
-bool exportFileByName(const std::shared_ptr<const class Geometry>& root_geom, const std::string& filename, const ExportInfo& exportInfo);
-bool exportFileStdOut(const std::shared_ptr<const class Geometry>& root_geom, const ExportInfo& exportInfo);
+bool exportFileByName(const std::shared_ptr<const class Geometry>& root_geom,
+                      const std::string& filename,
+                      const ExportInfo& exportInfo);
+bool exportFileStdOut(const std::shared_ptr<const class Geometry>& root_geom,
+                      const ExportInfo& exportInfo);
 
-void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
+void export_stl(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
                 bool binary = true);
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_obj(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_dxf(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_nefdbg(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_nef3(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-
+void export_3mf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
+                const ExportInfo& exportInfo);
+void export_obj(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output);
+void export_off(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output);
+void export_wrl(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output);
+void export_amf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output);
+void export_dxf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output);
+void export_svg(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output);
+void export_pov(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
+                const ExportInfo& exportInfo);
+void export_pdf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
+                const ExportInfo& exportInfo);
+void export_nefdbg(const std::shared_ptr<const Geometry>& geom,
+                   std::ostream& output);
+void export_nef3(const std::shared_ptr<const Geometry>& geom,
+                 std::ostream& output);
 
 enum class Previewer { OPENCSG, THROWNTOGETHER };
 enum class RenderType { GEOMETRY, BACKEND_SPECIFIC, OPENCSG, THROWNTOGETHER };
@@ -250,10 +351,10 @@ struct ViewOptions {
   RenderType renderer{RenderType::OPENCSG};
 
   std::map<std::string, bool> flags{
-    {"axes", false},
-    {"scales", false},
-    {"edges", false},
-    {"crosshairs", false},
+      {"axes", false},
+      {"scales", false},
+      {"edges", false},
+      {"crosshairs", false},
   };
 
   const std::vector<std::string> names() {
@@ -262,23 +363,23 @@ struct ViewOptions {
     return names;
   }
 
-  bool& operator[](const std::string& name) {
-    return flags.at(name);
-  }
-
-  bool operator[](const std::string& name) const {
-    return flags.at(name);
-  }
+  bool& operator[](const std::string& name) { return flags.at(name); }
 
+  bool operator[](const std::string& name) const { return flags.at(name); }
 };
 
 class OffscreenView;
 
 std::string get_current_iso8601_date_time_utc();
 
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera);
-bool export_png(const std::shared_ptr<const class Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output);
+std::unique_ptr<OffscreenView> prepare_preview(Tree& tree,
+                                               const ViewOptions& options,
+                                               Camera& camera);
+bool export_png(const std::shared_ptr<const class Geometry>& root_geom,
+                const ViewOptions& options,
+                Camera& camera,
+                std::ostream& output);
 bool export_png(const OffscreenView& glview, std::ostream& output);
-bool export_param(SourceFile *root, const fs::path& path, std::ostream& output);
+bool export_param(SourceFile* root, const fs::path& path, std::ostream& output);
 
 std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps);
diff --git a/src/io/export_3mf_dummy.cc b/src/io/export_3mf_dummy.cc
index 50580be45..7ca388130 100644
--- a/src/io/export_3mf_dummy.cc
+++ b/src/io/export_3mf_dummy.cc
@@ -26,11 +26,12 @@
 
 #include <memory>
 #include <ostream>
-#include "io/export.h"
 #include "geometry/Geometry.h"
+#include "io/export.h"
 #include "utils/printutils.h"
 
-void export_3mf(const std::shared_ptr<const class Geometry>&, std::ostream&, const ExportInfo&)
-{
+void export_3mf(const std::shared_ptr<const class Geometry>&,
+                std::ostream&,
+                const ExportInfo&) {
   LOG("Export to 3MF format was not enabled when building the application.");
 }
diff --git a/src/io/export_3mf_v1.cc b/src/io/export_3mf_v1.cc
index 94191757b..1dabedc8a 100644
--- a/src/io/export_3mf_v1.cc
+++ b/src/io/export_3mf_v1.cc
@@ -39,9 +39,9 @@
 #include "core/ColorUtil.h"
 #include "export_enums.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 #ifdef ENABLE_MANIFOLD
@@ -49,8 +49,8 @@
 #endif
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgalutils.h"
 #endif
 
 #undef BOOL
@@ -61,8 +61,8 @@ using S = Settings::SettingsExport3mf;
 namespace {
 
 struct ExportContext {
-  PLib3MFModel *model = nullptr;
-  PLib3MFModelBaseMaterial *basematerial = nullptr;
+  PLib3MFModel* model = nullptr;
+  PLib3MFModelBaseMaterial* basematerial = nullptr;
   DWORD basematerialid = 0;
   bool usecolors = false;
   int modelcount = 0;
@@ -73,20 +73,19 @@ struct ExportContext {
   const std::shared_ptr<const Export3mfOptions> options;
 };
 
-uint32_t lib3mf_write_callback(const char *data, uint32_t bytes, std::ostream *stream)
-{
+uint32_t lib3mf_write_callback(const char* data,
+                               uint32_t bytes,
+                               std::ostream* stream) {
   stream->write(data, bytes);
   return !(*stream);
 }
 
-uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream *stream)
-{
+uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream* stream) {
   stream->seekp(pos);
   return !(*stream);
 }
 
-void export_3mf_error(std::string msg, PLib3MFModel *& model)
-{
+void export_3mf_error(std::string msg, PLib3MFModel*& model) {
   LOG(message_group::Export_Error, std::move(msg));
   if (model) {
     lib3mf_release(model);
@@ -94,8 +93,8 @@ void export_3mf_error(std::string msg, PLib3MFModel *& model)
   }
 }
 
-int count_mesh_objects(PLib3MFModel *& model) {
-  PLib3MFModelResourceIterator *it;
+int count_mesh_objects(PLib3MFModel*& model) {
+  PLib3MFModelResourceIterator* it;
   if (lib3mf_model_getmeshobjects(model, &it) != LIB3MF_OK) {
     return 0;
   }
@@ -115,8 +114,11 @@ int count_mesh_objects(PLib3MFModel *& model) {
   return count;
 }
 
-bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::unique_ptr<PolySet>& ps, int triangle_index, int color_index, ExportContext& ctx)
-{
+bool handle_triangle_color(PLib3MFPropertyHandler* propertyhandler,
+                           const std::unique_ptr<PolySet>& ps,
+                           int triangle_index,
+                           int color_index,
+                           ExportContext& ctx) {
   if (color_index < 0) {
     return true;
   }
@@ -131,13 +133,17 @@ bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::u
   }
 
   if (ctx.basematerial) {
-    if (lib3mf_propertyhandler_setbasematerial(propertyhandler, triangle_index, ctx.basematerialid, ctx.materialids[color_index]) != LIB3MF_OK) {
+    if (lib3mf_propertyhandler_setbasematerial(
+            propertyhandler, triangle_index, ctx.basematerialid,
+            ctx.materialids[color_index]) != LIB3MF_OK) {
       export_3mf_error("Can't set triangle base material.", ctx.model);
       return false;
     }
   } else if (ctx.usecolors) {
     const auto& col = ps->colors[color_index];
-    if (lib3mf_propertyhandler_setsinglecolorfloatrgba(propertyhandler, triangle_index, col.r(), col.g(), col.b(), col.a()) != LIB3MF_OK) {
+    if (lib3mf_propertyhandler_setsinglecolorfloatrgba(
+            propertyhandler, triangle_index, col.r(), col.g(), col.b(),
+            col.a()) != LIB3MF_OK) {
       export_3mf_error("Can't set triangle color.", ctx.model);
       return false;
     }
@@ -146,13 +152,12 @@ bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::u
   return true;
 }
 
-
 /*
  * PolySet must be triangulated.
  */
-bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx)
-{
-  PLib3MFModelMeshObject *mesh = nullptr;
+bool append_polyset(const std::shared_ptr<const PolySet>& ps,
+                    ExportContext& ctx) {
+  PLib3MFModelMeshObject* mesh = nullptr;
   if (lib3mf_model_addmeshobject(ctx.model, &mesh) != LIB3MF_OK) {
     export_3mf_error("Can't add mesh to 3MF model.", ctx.model);
     return false;
@@ -172,30 +177,29 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
   }
 
   auto vertexFunc = [&](const Vector3d& coords) -> bool {
-      const auto f = coords.cast<float>();
-      MODELMESHVERTEX v{f[0], f[1], f[2]};
-      return lib3mf_meshobject_addvertex(mesh, &v, nullptr) == LIB3MF_OK;
-    };
+    const auto f = coords.cast<float>();
+    MODELMESHVERTEX v{f[0], f[1], f[2]};
+    return lib3mf_meshobject_addvertex(mesh, &v, nullptr) == LIB3MF_OK;
+  };
 
   auto triangleFunc = [&](const IndexedFace& indices) -> bool {
-      MODELMESHTRIANGLE t{(DWORD)indices[0], (DWORD)indices[1], (DWORD)indices[2]};
-      return lib3mf_meshobject_addtriangle(mesh, &t, nullptr) == LIB3MF_OK;
-    };
+    MODELMESHTRIANGLE t{(DWORD)indices[0], (DWORD)indices[1],
+                        (DWORD)indices[2]};
+    return lib3mf_meshobject_addtriangle(mesh, &t, nullptr) == LIB3MF_OK;
+  };
 
   auto materialFunc = [&](int idx, const Color4f& col) -> DWORD {
-      const auto colname = "Color " + std::to_string(idx);
+    const auto colname = "Color " + std::to_string(idx);
 
-      DWORD id = 0;
-      uint8_t r, g, b, a;
-      if (!col.getRgba(r, g, b, a)) {
-        LOG(message_group::Warning, "Invalid color in 3MF export");
-      }
-      lib3mf_basematerial_addmaterialutf8(ctx.basematerial,
-                                          colname.c_str(),
-                                          r, g, b,
-                                          &id);
-      return id;
-    };
+    DWORD id = 0;
+    uint8_t r, g, b, a;
+    if (!col.getRgba(r, g, b, a)) {
+      LOG(message_group::Warning, "Invalid color in 3MF export");
+    }
+    lib3mf_basematerial_addmaterialutf8(ctx.basematerial, colname.c_str(), r, g,
+                                        b, &id);
+    return id;
+  };
 
   auto sorted_ps = createSortedPolySet(*ps);
 
@@ -215,21 +219,24 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 
   DWORD materials = 0;
   if (ctx.basematerial) {
-    PLib3MFModelResourceIterator *it;
+    PLib3MFModelResourceIterator* it;
     if (lib3mf_model_getbasematerials(ctx.model, &it) == LIB3MF_OK) {
       while (true) {
         BOOL hasNext = false;
         if (lib3mf_resourceiterator_movenext(it, &hasNext) != LIB3MF_OK) {
-          export_3mf_error("Can't move to next base material iterator value.", ctx.model);
+          export_3mf_error("Can't move to next base material iterator value.",
+                           ctx.model);
           return false;
         }
         if (!hasNext) {
           break;
         }
 
-        PLib3MFModelResource *resource = nullptr;
+        PLib3MFModelResource* resource = nullptr;
         if (lib3mf_resourceiterator_getcurrent(it, &resource) != LIB3MF_OK) {
-          export_3mf_error("Can't get current value from base material iterator.", ctx.model);
+          export_3mf_error(
+              "Can't get current value from base material iterator.",
+              ctx.model);
           return false;
         } else {
           DWORD count = 0;
@@ -241,12 +248,14 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 
     ctx.materialids.reserve(sorted_ps->colors.size());
     for (int i = 0; i < sorted_ps->colors.size(); i++) {
-      ctx.materialids.push_back(materialFunc(materials + i, sorted_ps->colors[i]));
+      ctx.materialids.push_back(
+          materialFunc(materials + i, sorted_ps->colors[i]));
     }
   }
 
-  PLib3MFPropertyHandler *propertyhandler = nullptr;
-  if (lib3mf_meshobject_createpropertyhandler(mesh, &propertyhandler) != LIB3MF_OK) {
+  PLib3MFPropertyHandler* propertyhandler = nullptr;
+  if (lib3mf_meshobject_createpropertyhandler(mesh, &propertyhandler) !=
+      LIB3MF_OK) {
     export_3mf_error("Can't create property handler for 3MF model.", ctx.model);
     return false;
   }
@@ -260,30 +269,36 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 
   lib3mf_release(propertyhandler);
 
-  PLib3MFPropertyHandler *defaultpropertyhandler = nullptr;
-  if (lib3mf_object_createdefaultpropertyhandler(mesh, &defaultpropertyhandler) != LIB3MF_OK) {
-    export_3mf_error("Can't create default property handler for 3MF model.", ctx.model);
+  PLib3MFPropertyHandler* defaultpropertyhandler = nullptr;
+  if (lib3mf_object_createdefaultpropertyhandler(
+          mesh, &defaultpropertyhandler) != LIB3MF_OK) {
+    export_3mf_error("Can't create default property handler for 3MF model.",
+                     ctx.model);
     return false;
   }
 
   if (ctx.basematerial) {
-    lib3mf_defaultpropertyhandler_setbasematerial(defaultpropertyhandler, ctx.basematerialid, ctx.defaultColorId);
+    lib3mf_defaultpropertyhandler_setbasematerial(
+        defaultpropertyhandler, ctx.basematerialid, ctx.defaultColorId);
   } else if (ctx.usecolors) {
     uint8_t r, g, b, a;
     if (!ctx.defaultColor.getRgba(r, g, b, a)) {
       LOG(message_group::Warning, "Invalid color in 3MF export");
     }
-    lib3mf_defaultpropertyhandler_setcolorrgba(defaultpropertyhandler, r, g, b, a);
+    lib3mf_defaultpropertyhandler_setcolorrgba(defaultpropertyhandler, r, g, b,
+                                               a);
   }
 
   lib3mf_release(defaultpropertyhandler);
 
-  PLib3MFModelBuildItem *builditem = nullptr;
-  if (lib3mf_model_addbuilditem(ctx.model, mesh, nullptr, &builditem) != LIB3MF_OK) {
+  PLib3MFModelBuildItem* builditem = nullptr;
+  if (lib3mf_model_addbuilditem(ctx.model, mesh, nullptr, &builditem) !=
+      LIB3MF_OK) {
     export_3mf_error("Can't add build item to 3MF model.", ctx.model);
     return false;
   }
-  if (!partname.empty() && lib3mf_builditem_setpartnumberutf8(builditem, partname.c_str()) != LIB3MF_OK) {
+  if (!partname.empty() && lib3mf_builditem_setpartnumberutf8(
+                               builditem, partname.c_str()) != LIB3MF_OK) {
     export_3mf_error("Can't set part name of build item.", ctx.model);
     return false;
   }
@@ -295,54 +310,62 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 }
 
 #ifdef ENABLE_CGAL
-bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx)
-{
+bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx) {
   if (!root_N.p3) {
     LOG(message_group::Export_Error, "Export failed, empty geometry.");
     return false;
   }
 
   if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+    LOG(message_group::Export_Warning,
+        "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-
-  if (std::shared_ptr<PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
+  if (std::shared_ptr<PolySet> ps =
+          CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
     return append_polyset(ps, ctx);
   }
 
   export_3mf_error("Error converting NEF Polyhedron.", ctx.model);
   return false;
 }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
 
-static bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContext& ctx)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+static bool append_3mf(const std::shared_ptr<const Geometry>& geom,
+                       ExportContext& ctx) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     ctx.modelcount = geomlist->getChildren().size();
     for (const auto& item : geomlist->getChildren()) {
-      if (!append_3mf(item.second, ctx)) return false;
+      if (!append_3mf(item.second, ctx))
+        return false;
     }
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     return append_nef(*N, ctx);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     return append_polyset(mani->toPolySet(), ctx);
 #endif
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     return append_polyset(PolySetUtils::tessellate_faces(*ps), ctx);
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { // NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const Polygon2d>(
+                 geom)) {  // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
-  } else { // NOLINT(bugprone-branch-clone)
+  } else {  // NOLINT(bugprone-branch-clone)
     assert(false && "Not implemented");
   }
 
   return true;
 }
 
-void add_meta_data(PLib3MFModelMeshObject *& model, const std::string& name, const std::string& value, const std::string& value2 = "") {
+void add_meta_data(PLib3MFModelMeshObject*& model,
+                   const std::string& name,
+                   const std::string& value,
+                   const std::string& value2 = "") {
   const std::string v = value.empty() ? value2 : value;
   if (v.empty()) {
     return;
@@ -351,53 +374,62 @@ void add_meta_data(PLib3MFModelMeshObject *& model, const std::string& name, con
   lib3mf_model_addmetadatautf8(model, name.c_str(), v.c_str());
 }
 
-} // namespace
+}  // namespace
 
 /*!
     Saves the current 3D Geometry as 3MF to the given file.
     The file must be open.
  */
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+void export_3mf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
+                const ExportInfo& exportInfo) {
   DWORD interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-  HRESULT result = lib3mf_getinterfaceversion(&interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
+  HRESULT result = lib3mf_getinterfaceversion(
+      &interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
   if (result != LIB3MF_OK) {
     LOG(message_group::Export_Error, "Error reading 3MF library version");
     return;
   }
 
   if ((interfaceVersionMajor != NMR_APIVERSION_INTERFACE_MAJOR)) {
-    LOG(message_group::Export_Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d", interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro, NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO);
+    LOG(message_group::Export_Error,
+        "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+        "%4$d.%5$d.%6$d",
+        interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
+        NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR,
+        NMR_APIVERSION_INTERFACE_MICRO);
     return;
   }
 
-  PLib3MFModel *model;
+  PLib3MFModel* model;
   result = lib3mf_createmodel(&model);
   if (result != LIB3MF_OK) {
     LOG(message_group::Export_Error, "Can't create 3MF model.");
     return;
   }
 
-  const auto& options3mf = exportInfo.options3mf ? exportInfo.options3mf : std::make_shared<Export3mfOptions>();
+  const auto& options3mf = exportInfo.options3mf
+                               ? exportInfo.options3mf
+                               : std::make_shared<Export3mfOptions>();
   switch (options3mf->unit) {
-  case Export3mfUnit::micron:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_MICROMETER);
-    break;
-  case Export3mfUnit::centimeter:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_CENTIMETER);
-    break;
-  case Export3mfUnit::meter:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_METER);
-    break;
-  case Export3mfUnit::inch:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_INCH);
-    break;
-  case Export3mfUnit::foot:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_FOOT);
-    break;
-  default:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_MILLIMETER);
-    break;
+    case Export3mfUnit::micron:
+      lib3mf_model_setunit(model, eModelUnit::MODELUNIT_MICROMETER);
+      break;
+    case Export3mfUnit::centimeter:
+      lib3mf_model_setunit(model, eModelUnit::MODELUNIT_CENTIMETER);
+      break;
+    case Export3mfUnit::meter:
+      lib3mf_model_setunit(model, eModelUnit::MODELUNIT_METER);
+      break;
+    case Export3mfUnit::inch:
+      lib3mf_model_setunit(model, eModelUnit::MODELUNIT_INCH);
+      break;
+    case Export3mfUnit::foot:
+      lib3mf_model_setunit(model, eModelUnit::MODELUNIT_FOOT);
+      break;
+    default:
+      lib3mf_model_setunit(model, eModelUnit::MODELUNIT_MILLIMETER);
+      break;
   }
 
   Color4f defaultColor;
@@ -405,20 +437,23 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   bool usecolors = false;
   DWORD basematerialid = 0;
-  PLib3MFModelBaseMaterial *basematerial = nullptr;
+  PLib3MFModelBaseMaterial* basematerial = nullptr;
   if (options3mf->colorMode != Export3mfColorMode::none) {
     if (options3mf->colorMode == Export3mfColorMode::model) {
       // use default color that ultimately should come from the color scheme
       defaultColor = exportInfo.defaultColor;
     } else {
-      defaultColor = OpenSCAD::getColor(options3mf->color, exportInfo.defaultColor);
+      defaultColor =
+          OpenSCAD::getColor(options3mf->color, exportInfo.defaultColor);
     }
     if (options3mf->materialType == Export3mfMaterialType::basematerial) {
-      if (lib3mf_model_addbasematerialgroup(model, &basematerial) != LIB3MF_OK) {
+      if (lib3mf_model_addbasematerialgroup(model, &basematerial) !=
+          LIB3MF_OK) {
         export_3mf_error("Can't create base material group.", model);
         return;
       }
-      if (lib3mf_resource_getresourceid(basematerial, &basematerialid) != LIB3MF_OK) {
+      if (lib3mf_resource_getresourceid(basematerial, &basematerialid) !=
+          LIB3MF_OK) {
         export_3mf_error("Can't get base material resource id.", model);
         return;
       }
@@ -426,8 +461,7 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
       if (!defaultColor.getRgba(r, g, b, a)) {
         LOG(message_group::Warning, "Invalid color in 3MF export");
       }
-      if (lib3mf_basematerial_addmaterialutf8(basematerial, "Default",
-                                              r, g, b,
+      if (lib3mf_basematerial_addmaterialutf8(basematerial, "Default", r, g, b,
                                               &defaultColorId) != LIB3MF_OK) {
         export_3mf_error("Can't add default material color.", model);
         return;
@@ -448,36 +482,34 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     add_meta_data(model, "Rating", options3mf->metaDataRating);
   }
 
-  ExportContext ctx{
-    .model = model,
-    .basematerial = basematerial,
-    .basematerialid = basematerialid,
-    .usecolors = usecolors,
-    .modelcount = 1,
-    .defaultColor = defaultColor,
-    .defaultColorId = defaultColorId,
-    .info = exportInfo,
-    .options = options3mf
-  };
+  ExportContext ctx{.model = model,
+                    .basematerial = basematerial,
+                    .basematerialid = basematerialid,
+                    .usecolors = usecolors,
+                    .modelcount = 1,
+                    .defaultColor = defaultColor,
+                    .defaultColorId = defaultColorId,
+                    .info = exportInfo,
+                    .options = options3mf};
 
   if (!append_3mf(geom, ctx)) {
-    if (model) lib3mf_release(model);
+    if (model)
+      lib3mf_release(model);
     return;
   }
 
-  PLib3MFModelWriter *writer;
+  PLib3MFModelWriter* writer;
   if (lib3mf_model_querywriter(model, "3mf", &writer) != LIB3MF_OK) {
     export_3mf_error("Can't get writer for 3MF model.", model);
     return;
   }
 
-  result = lib3mf_writer_writetocallback(writer, (void *)lib3mf_write_callback, (void *)lib3mf_seek_callback, &output);
+  result = lib3mf_writer_writetocallback(writer, (void*)lib3mf_write_callback,
+                                         (void*)lib3mf_seek_callback, &output);
   output.flush();
   lib3mf_release(writer);
   lib3mf_release(model);
   if (result != LIB3MF_OK) {
     LOG(message_group::Export_Error, "Error writing 3MF model.");
   }
-
-
 }
diff --git a/src/io/export_3mf_v2.cc b/src/io/export_3mf_v2.cc
index cdbe65c0b..9f8bb877b 100644
--- a/src/io/export_3mf_v2.cc
+++ b/src/io/export_3mf_v2.cc
@@ -27,8 +27,8 @@
 #include "io/export.h"
 
 #include <algorithm>
-#include <cstddef>
 #include <cassert>
+#include <cstddef>
 #include <cstdint>
 #include <memory>
 #include <ostream>
@@ -42,14 +42,14 @@
 #include "export_enums.h"
 #include "geometry/Geometry.h"
 #include "geometry/GeometryUtils.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgalutils.h"
 #endif
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
@@ -71,31 +71,35 @@ struct ExportContext {
   const std::shared_ptr<const Export3mfOptions> options;
 };
 
-uint32_t lib3mf_write_callback(const char *data, uint32_t bytes, std::ostream *stream)
-{
+uint32_t lib3mf_write_callback(const char* data,
+                               uint32_t bytes,
+                               std::ostream* stream) {
   stream->write(data, bytes);
   return !(*stream);
 }
 
-uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream *stream)
-{
+uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream* stream) {
   stream->seekp(pos);
   return !(*stream);
 }
 
-void export_3mf_error(std::string msg)
-{
+void export_3mf_error(std::string msg) {
   LOG(message_group::Export_Error, std::move(msg));
 }
 
 int count_mesh_objects(const Lib3MF::PModel& model) {
   const auto mesh_object_it = model->GetMeshObjects();
   int count = 0;
-  while (mesh_object_it->MoveNext()) ++count;
+  while (mesh_object_it->MoveNext())
+    ++count;
   return count;
 }
 
-void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx, Lib3MF::PMeshObject& mesh, Lib3MF_uint32 triangle, int color_index) {
+void handle_triangle_color(const std::shared_ptr<const PolySet>& ps,
+                           ExportContext& ctx,
+                           Lib3MF::PMeshObject& mesh,
+                           Lib3MF_uint32 triangle,
+                           int color_index) {
   if (color_index < 0) {
     return;
   }
@@ -115,11 +119,14 @@ void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportConte
   Lib3MF_uint32 col_idx = 0;
   if (col_it == ctx.colors.end()) {
     Lib3MF::sColor materialcolor;
-    if (!col.getRgba(materialcolor.m_Red, materialcolor.m_Green, materialcolor.m_Blue, materialcolor.m_Alpha)) {
+    if (!col.getRgba(materialcolor.m_Red, materialcolor.m_Green,
+                     materialcolor.m_Blue, materialcolor.m_Alpha)) {
       LOG(message_group::Warning, "Invalid color in 3MF export");
     }
     if (ctx.basematerialgroup) {
-      col_idx = ctx.basematerialgroup->AddMaterial("Color " + std::to_string(ctx.basematerialgroup->GetCount()), materialcolor);
+      col_idx = ctx.basematerialgroup->AddMaterial(
+          "Color " + std::to_string(ctx.basematerialgroup->GetCount()),
+          materialcolor);
     } else if (ctx.colorgroup) {
       col_idx = ctx.colorgroup->AddColor(materialcolor);
     }
@@ -136,63 +143,62 @@ void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportConte
   }
 
   if (res_id > 0) {
-    mesh->SetTriangleProperties(triangle, {
-        res_id,
-        {
-          col_idx,
-          col_idx,
-          col_idx
-        }
-      });
+    mesh->SetTriangleProperties(triangle,
+                                {res_id, {col_idx, col_idx, col_idx}});
   }
 }
 
 /*
  * PolySet must be triangulated.
  */
-bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx)
-{
+bool append_polyset(const std::shared_ptr<const PolySet>& ps,
+                    ExportContext& ctx) {
   try {
     auto mesh = ctx.model->AddMeshObject();
-    if (!mesh) return false;
+    if (!mesh)
+      return false;
 
     const int mesh_count = count_mesh_objects(ctx.model);
-    const auto modelname = ctx.modelcount == 1 ? "OpenSCAD Model" : "OpenSCAD Model " + std::to_string(mesh_count);
-    const auto partname = ctx.modelcount == 1 ? "" : "Part " + std::to_string(mesh_count);
+    const auto modelname = ctx.modelcount == 1
+                               ? "OpenSCAD Model"
+                               : "OpenSCAD Model " + std::to_string(mesh_count);
+    const auto partname =
+        ctx.modelcount == 1 ? "" : "Part " + std::to_string(mesh_count);
     mesh->SetName(modelname);
     if (ctx.basematerialgroup) {
-      mesh->SetObjectLevelProperty(ctx.basematerialgroup->GetUniqueResourceID(), 1);
+      mesh->SetObjectLevelProperty(ctx.basematerialgroup->GetUniqueResourceID(),
+                                   1);
     } else if (ctx.colorgroup) {
       mesh->SetObjectLevelProperty(ctx.colorgroup->GetUniqueResourceID(), 1);
     }
 
     auto vertexFunc = [&](const Vector3d& coords) -> bool {
-        const auto f = coords.cast<float>();
-        try {
-          const Lib3MF::sPosition v{f[0], f[1], f[2]};
-          mesh->AddVertex(v);
-        } catch (Lib3MF::ELib3MFException& e) {
-          export_3mf_error(e.what());
-          return false;
-        }
-        return true;
-      };
-
-    auto triangleFunc = [&](const IndexedFace& indices, int color_index) -> bool {
-        try {
-          const auto triangle = mesh->AddTriangle({
-            static_cast<Lib3MF_uint32>(indices[0]),
-            static_cast<Lib3MF_uint32>(indices[1]),
-            static_cast<Lib3MF_uint32>(indices[2])
-          });
-
-          handle_triangle_color(ps, ctx, mesh, triangle, color_index);
-        } catch (Lib3MF::ELib3MFException& e) {
-          export_3mf_error(e.what());
-          return false;
-        }
-        return true;
-      };
+      const auto f = coords.cast<float>();
+      try {
+        const Lib3MF::sPosition v{f[0], f[1], f[2]};
+        mesh->AddVertex(v);
+      } catch (Lib3MF::ELib3MFException& e) {
+        export_3mf_error(e.what());
+        return false;
+      }
+      return true;
+    };
+
+    auto triangleFunc = [&](const IndexedFace& indices,
+                            int color_index) -> bool {
+      try {
+        const auto triangle =
+            mesh->AddTriangle({static_cast<Lib3MF_uint32>(indices[0]),
+                               static_cast<Lib3MF_uint32>(indices[1]),
+                               static_cast<Lib3MF_uint32>(indices[2])});
+
+        handle_triangle_color(ps, ctx, mesh, triangle, color_index);
+      } catch (Lib3MF::ELib3MFException& e) {
+        export_3mf_error(e.what());
+        return false;
+      }
+      return true;
+    };
 
     std::shared_ptr<const PolySet> out_ps = ps;
     if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
@@ -207,7 +213,8 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
     }
 
     for (size_t i = 0; i < out_ps->indices.size(); i++) {
-      auto color_index = i < out_ps->color_indices.size() ? out_ps->color_indices[i] : -1;
+      auto color_index =
+          i < out_ps->color_indices.size() ? out_ps->color_indices[i] : -1;
       if (!triangleFunc(out_ps->indices[i], color_index)) {
         export_3mf_error("Can't add triangle to 3MF model.");
         return false;
@@ -215,7 +222,8 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
     }
 
     try {
-      auto builditem = ctx.model->AddBuildItem(mesh.get(), ctx.wrapper->GetIdentityTransform());
+      auto builditem = ctx.model->AddBuildItem(
+          mesh.get(), ctx.wrapper->GetIdentityTransform());
       if (!partname.empty()) {
         builditem->SetPartNumber(partname);
       }
@@ -230,38 +238,43 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 }
 
 #ifdef ENABLE_CGAL
-bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx)
-{
+bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx) {
   if (!root_N.p3) {
     LOG(message_group::Export_Error, "Export failed, empty geometry.");
     return false;
   }
 
   if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+    LOG(message_group::Export_Warning,
+        "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-  if (const std::shared_ptr<const PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
+  if (const std::shared_ptr<const PolySet> ps =
+          CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
     return append_polyset(ps, ctx);
   }
   export_3mf_error("Error converting NEF Polyhedron.");
   return false;
 }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
 
-bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContext& ctx)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+bool append_3mf(const std::shared_ptr<const Geometry>& geom,
+                ExportContext& ctx) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     ctx.modelcount = geomlist->getChildren().size();
     for (const auto& item : geomlist->getChildren()) {
-      if (!append_3mf(item.second, ctx)) return false;
+      if (!append_3mf(item.second, ctx))
+        return false;
     }
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     return append_nef(*N, ctx);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     return append_polyset(mani->toPolySet(), ctx);
 #endif
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
@@ -275,7 +288,10 @@ bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContext& ctx)
   return true;
 }
 
-void add_meta_data(Lib3MF::PMetaDataGroup& metadatagroup, const std::string& name, const std::string& value, const std::string& value2 = "") {
+void add_meta_data(Lib3MF::PMetaDataGroup& metadatagroup,
+                   const std::string& name,
+                   const std::string& value,
+                   const std::string& value2 = "") {
   const std::string v = value.empty() ? value2 : value;
   if (v.empty()) {
     return;
@@ -284,22 +300,27 @@ void add_meta_data(Lib3MF::PMetaDataGroup& metadatagroup, const std::string& nam
   metadatagroup->AddMetaData("", name, v, "xs:string", true);
 }
 
-} // namespace
+}  // namespace
 
 /*!
     Saves the current 3D Geometry as 3MF to the given file.
     The file must be open.
  */
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
-  Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
+void export_3mf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
+                const ExportInfo& exportInfo) {
+  Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor,
+      interfaceVersionMicro;
   Lib3MF::PWrapper wrapper;
 
   try {
     wrapper = Lib3MF::CWrapper::loadLibrary();
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
+    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor,
+                               interfaceVersionMicro);
     if (interfaceVersionMajor != LIB3MF_VERSION_MAJOR) {
-      LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+      LOG(message_group::Error,
+          "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+          "%4$d.%5$d.%6$d",
           interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
           LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
       return;
@@ -310,7 +331,11 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   }
 
   if ((interfaceVersionMajor != LIB3MF_VERSION_MAJOR)) {
-    LOG(message_group::Export_Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d", interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro, LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
+    LOG(message_group::Export_Error,
+        "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+        "%4$d.%5$d.%6$d",
+        interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
+        LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
     return;
   }
 
@@ -326,26 +351,28 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     return;
   }
 
-  const auto& options3mf = exportInfo.options3mf ? exportInfo.options3mf : std::make_shared<Export3mfOptions>();
+  const auto& options3mf = exportInfo.options3mf
+                               ? exportInfo.options3mf
+                               : std::make_shared<Export3mfOptions>();
   switch (options3mf->unit) {
-  case Export3mfUnit::micron:
-    model->SetUnit(Lib3MF::eModelUnit::MicroMeter);
-    break;
-  case Export3mfUnit::centimeter:
-    model->SetUnit(Lib3MF::eModelUnit::CentiMeter);
-    break;
-  case Export3mfUnit::meter:
-    model->SetUnit(Lib3MF::eModelUnit::Meter);
-    break;
-  case Export3mfUnit::inch:
-    model->SetUnit(Lib3MF::eModelUnit::Inch);
-    break;
-  case Export3mfUnit::foot:
-    model->SetUnit(Lib3MF::eModelUnit::Foot);
-    break;
-  default:
-    model->SetUnit(Lib3MF::eModelUnit::MilliMeter);
-    break;
+    case Export3mfUnit::micron:
+      model->SetUnit(Lib3MF::eModelUnit::MicroMeter);
+      break;
+    case Export3mfUnit::centimeter:
+      model->SetUnit(Lib3MF::eModelUnit::CentiMeter);
+      break;
+    case Export3mfUnit::meter:
+      model->SetUnit(Lib3MF::eModelUnit::Meter);
+      break;
+    case Export3mfUnit::inch:
+      model->SetUnit(Lib3MF::eModelUnit::Inch);
+      break;
+    case Export3mfUnit::foot:
+      model->SetUnit(Lib3MF::eModelUnit::Foot);
+      break;
+    default:
+      model->SetUnit(Lib3MF::eModelUnit::MilliMeter);
+      break;
   }
 
   // use default color that ultimately should come from the color scheme
@@ -355,13 +382,15 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   Lib3MF::PBaseMaterialGroup basematerialgroup;
   if (options3mf->colorMode != Export3mfColorMode::none) {
     if (options3mf->colorMode != Export3mfColorMode::model) {
-      // use color selected in the export dialog and stored in settings (if valid)
+      // use color selected in the export dialog and stored in settings (if
+      // valid)
       color = OpenSCAD::getColor(options3mf->color, exportInfo.defaultColor);
     }
     if (options3mf->materialType == Export3mfMaterialType::basematerial) {
       basematerialgroup = model->AddBaseMaterialGroup();
       Lib3MF::sColor materialcolor;
-      if (!color.getRgba(materialcolor.m_Red, materialcolor.m_Green, materialcolor.m_Blue, materialcolor.m_Alpha)) {
+      if (!color.getRgba(materialcolor.m_Red, materialcolor.m_Green,
+                         materialcolor.m_Blue, materialcolor.m_Alpha)) {
         LOG(message_group::Warning, "Invalid color in 3MF export");
       }
       materialcolor.m_Alpha = 0xff;
@@ -369,7 +398,8 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     } else if (options3mf->materialType == Export3mfMaterialType::color) {
       colorgroup = model->AddColorGroup();
       Lib3MF::sColor groupcolor;
-      if (!color.getRgba(groupcolor.m_Red, groupcolor.m_Green, groupcolor.m_Blue, groupcolor.m_Alpha)) {
+      if (!color.getRgba(groupcolor.m_Red, groupcolor.m_Green,
+                         groupcolor.m_Blue, groupcolor.m_Alpha)) {
         LOG(message_group::Warning, "Invalid color in 3MF export");
       }
       colorgroup->AddColor(groupcolor);
@@ -378,26 +408,28 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   if (options3mf->addMetaData) {
     auto metadatagroup = model->GetMetaDataGroup();
-    add_meta_data(metadatagroup, "Title", options3mf->metaDataTitle, exportInfo.title);
+    add_meta_data(metadatagroup, "Title", options3mf->metaDataTitle,
+                  exportInfo.title);
     add_meta_data(metadatagroup, "Application", EXPORT_CREATOR);
-    add_meta_data(metadatagroup, "CreationDate", get_current_iso8601_date_time_utc());
+    add_meta_data(metadatagroup, "CreationDate",
+                  get_current_iso8601_date_time_utc());
     add_meta_data(metadatagroup, "Designer", options3mf->metaDataDesigner);
-    add_meta_data(metadatagroup, "Description", options3mf->metaDataDescription);
+    add_meta_data(metadatagroup, "Description",
+                  options3mf->metaDataDescription);
     add_meta_data(metadatagroup, "Copyright", options3mf->metaDataCopyright);
-    add_meta_data(metadatagroup, "LicenseTerms", options3mf->metaDataLicenseTerms);
+    add_meta_data(metadatagroup, "LicenseTerms",
+                  options3mf->metaDataLicenseTerms);
     add_meta_data(metadatagroup, "Rating", options3mf->metaDataRating);
   }
 
-  ExportContext ctx{
-    .wrapper = wrapper,
-    .model = model,
-    .colorgroup = colorgroup,
-    .basematerialgroup = basematerialgroup,
-    .modelcount = 1,
-    .selectedColor = color,
-    .info = exportInfo,
-    .options = options3mf
-  };
+  ExportContext ctx{.wrapper = wrapper,
+                    .model = model,
+                    .colorgroup = colorgroup,
+                    .basematerialgroup = basematerialgroup,
+                    .modelcount = 1,
+                    .selectedColor = color,
+                    .info = exportInfo,
+                    .options = options3mf};
 
   if (!append_3mf(geom, ctx)) {
     return;
@@ -418,11 +450,14 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   try {
     writer->SetDecimalPrecision(ctx.options->decimalPrecision);
   } catch (Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, "Error setting decimal precision for export: %1$s", e.what());
+    LOG(message_group::Export_Error,
+        "Error setting decimal precision for export: %1$s", e.what());
   }
 
   try {
-    writer->WriteToCallback((Lib3MF::WriteCallback)lib3mf_write_callback, (Lib3MF::SeekCallback)lib3mf_seek_callback, &output);
+    writer->WriteToCallback((Lib3MF::WriteCallback)lib3mf_write_callback,
+                            (Lib3MF::SeekCallback)lib3mf_seek_callback,
+                            &output);
   } catch (Lib3MF::ELib3MFException& e) {
     LOG(message_group::Export_Error, e.what());
   }
diff --git a/src/io/export_amf.cc b/src/io/export_amf.cc
index 891fd308a..2515cf16a 100644
--- a/src/io/export_amf.cc
+++ b/src/io/export_amf.cc
@@ -29,22 +29,22 @@
 #include "geometry/Geometry.h"
 
 #ifdef ENABLE_CGAL
+#include "geometry/cgal/CGALNefGeometry.h"
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
-#include "geometry/cgal/CGALNefGeometry.h"
 #endif
 
 #include <algorithm>
-#include <iterator>
 #include <cassert>
+#include <cstddef>
 #include <exception>
-#include <ostream>
+#include <iterator>
 #include <memory>
-#include <cstddef>
+#include <ostream>
 #include <string>
 #include <vector>
 
-#define QUOTE(x__) # x__
+#define QUOTE(x__) #x__
 #define QUOTED(x__) QUOTE(x__)
 
 struct vertex_str {
@@ -88,10 +88,10 @@ static size_t add_vertex(std::vector<vertex_str>& vertices, const Point& p) {
     Saves the current 3D CGAL Nef polyhedron as AMF to the given file.
     The file must be open.
  */
-static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
-{
+static void append_amf(const CGALNefGeometry& root_N, std::ostream& output) {
   if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Export failed, the object isn't a valid 2-manifold.");
+    LOG(message_group::Export_Warning,
+        "Export failed, the object isn't a valid 2-manifold.");
     return;
   }
   try {
@@ -116,8 +116,8 @@ static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
         if (vi1 != vi2 && vi1 != vi3 && vi2 != vi3) {
           // The above condition ensures that there are 3 distinct vertices, but
           // they may be collinear. If they are, the unit normal is meaningless
-          // so the default value of "1 0 0" can be used. If the vertices are not
-          // collinear then the unit normal must be calculated from the
+          // so the default value of "1 0 0" can be used. If the vertices are
+          // not collinear then the unit normal must be calculated from the
           // components.
           triangles.push_back({vi1, vi2, vi3});
         }
@@ -147,45 +147,50 @@ static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
     output << "  </mesh>\r\n"
            << " </object>\r\n";
   } catch (std::exception& e) {
-    LOG(message_group::Export_Error, "CGAL error in CGAL_Nef_polyhedron3::convert_to_polyhedron(): %1$s", e.what());
+    LOG(message_group::Export_Error,
+        "CGAL error in CGAL_Nef_polyhedron3::convert_to_polyhedron(): %1$s",
+        e.what());
   }
 }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
 
-static void append_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+static void append_amf(const std::shared_ptr<const Geometry>& geom,
+                       std::ostream& output) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     for (const auto& item : geomlist->getChildren()) {
       append_amf(item.second, output);
     }
 #ifdef ENABLE_CGAL
   } else if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
     // FIXME: Implement this without creating a Nef polyhedron
-    if (!N->isEmpty()) append_amf(*N, output);
+    if (!N->isEmpty())
+      append_amf(*N, output);
 #endif
-  } else if (geom->getDimension() != 3) { // NOLINT(bugprone-branch-clone)
+  } else if (geom->getDimension() != 3) {  // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
-  } else { // NOLINT(bugprone-branch-clone)
+  } else {  // NOLINT(bugprone-branch-clone)
     assert(false && "Not implemented");
   }
 }
 
-void export_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  LOG(message_group::Deprecated, "AMF export is deprecated. Please use 3MF instead.");
-  setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
+void export_amf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output) {
+  LOG(message_group::Deprecated,
+      "AMF export is deprecated. Please use 3MF instead.");
+  setlocale(LC_NUMERIC, "C");  // Ensure radix is . (not ,) in output
 
   output << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
          << "<amf unit=\"millimeter\">\r\n"
          << " <metadata type=\"producer\">OpenSCAD " << QUOTED(OPENSCAD_VERSION)
 #ifdef OPENSCAD_COMMIT
-    << " (git " << QUOTED(OPENSCAD_COMMIT) << ")"
+         << " (git " << QUOTED(OPENSCAD_COMMIT) << ")"
 #endif
-    << "</metadata>\r\n";
+         << "</metadata>\r\n";
 
   objectid = 0;
   append_amf(geom, output);
 
   output << "</amf>\r\n";
-  setlocale(LC_NUMERIC, ""); // Set default locale
+  setlocale(LC_NUMERIC, "");  // Set default locale
 }
diff --git a/src/io/export_dxf.cc b/src/io/export_dxf.cc
index 3f7b4c002..5af7fe6b7 100644
--- a/src/io/export_dxf.cc
+++ b/src/io/export_dxf.cc
@@ -32,16 +32,19 @@
 #include <ostream>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
 /*!
     Saves the current Polygon2d as DXF to the given absolute filename.
  */
 
-static void export_dxf_header(std::ostream& output, double xMin, double yMin, double xMax, double yMax) {
-
+static void export_dxf_header(std::ostream& output,
+                              double xMin,
+                              double yMin,
+                              double xMax,
+                              double yMax) {
   // https://dxfwrite.readthedocs.io/en/latest/headervars.html
   // http://paulbourke.net/dataformats/dxf/min3d.html
 
@@ -56,8 +59,7 @@ static void export_dxf_header(std::ostream& output, double xMin, double yMin, do
   // - https://sharecad.org
   // - generic cutters
 
-  output
-    << "999\n" << "DXF from OpenSCAD\n";
+  output << "999\n" << "DXF from OpenSCAD\n";
 
   //
   // SECTION 1
@@ -65,105 +67,138 @@ static void export_dxf_header(std::ostream& output, double xMin, double yMin, do
 
   /* --- START --- */
 
-  output
-    << "  0\n" << "SECTION\n"
-    << "  2\n" << "HEADER\n"
-    << "  9\n" << "$ACADVER\n"
-    << "  1\n" << "AC1006\n"
-    << "  9\n" << "$INSBASE\n"
-    << " 10\n" << "0.0\n"
-    << " 20\n" << "0.0\n"
-    << " 30\n" << "0.0\n"
-  ;
+  output << "  0\n"
+         << "SECTION\n"
+         << "  2\n"
+         << "HEADER\n"
+         << "  9\n"
+         << "$ACADVER\n"
+         << "  1\n"
+         << "AC1006\n"
+         << "  9\n"
+         << "$INSBASE\n"
+         << " 10\n"
+         << "0.0\n"
+         << " 20\n"
+         << "0.0\n"
+         << " 30\n"
+         << "0.0\n";
 
   /* --- LIMITS --- */
 
-  output
-    << "  9\n" << "$EXTMIN\n"
-    << " 10\n" << xMin << "\n"
-    << " 20\n" << yMin << "\n"
-    << "  9\n" << "$EXTMAX\n"
-    << " 10\n" << xMax << "\n"
-    << " 20\n" << yMax << "\n";
-
-  output
-    << "  9\n" << "$LINMIN\n"
-    << " 10\n" << xMin << "\n"
-    << " 20\n" << yMin << "\n"
-    << "  9\n" << "$LINMAX\n"
-    << " 10\n" << xMax << "\n"
-    << " 20\n" << yMax << "\n";
-
-  output
-    << "  0\n" << "ENDSEC\n";
+  output << "  9\n"
+         << "$EXTMIN\n"
+         << " 10\n"
+         << xMin << "\n"
+         << " 20\n"
+         << yMin << "\n"
+         << "  9\n"
+         << "$EXTMAX\n"
+         << " 10\n"
+         << xMax << "\n"
+         << " 20\n"
+         << yMax << "\n";
+
+  output << "  9\n"
+         << "$LINMIN\n"
+         << " 10\n"
+         << xMin << "\n"
+         << " 20\n"
+         << yMin << "\n"
+         << "  9\n"
+         << "$LINMAX\n"
+         << " 10\n"
+         << xMax << "\n"
+         << " 20\n"
+         << yMax << "\n";
+
+  output << "  0\n" << "ENDSEC\n";
 
   //
   // SECTION 2
   //
 
-  output
-    << "  0\n" << "SECTION\n";
+  output << "  0\n" << "SECTION\n";
 
-  output
-    << "  2\n" << "TABLES\n";
+  output << "  2\n" << "TABLES\n";
 
   /* --- LINETYPE --- */
 
-  output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "LTYPE\n"
-    << " 70\n" << "1\n"
-
-    << "  0\n" << "LTYPE\n"
-    << "  2\n" << "CONTINUOUS\n"       // linetype name
-    << " 70\n" << "64\n"
-    << "  3\n" << "Solid line\n"       // descriptive text
-    << " 72\n" << "65\n"       // always 65
-    << " 73\n" << "0\n"        // number of linetype elements
-    << " 40\n" << "0.000000\n"       // total pattern length
-
-    << "  0\n" << "ENDTAB\n";
+  output << "  0\n"
+         << "TABLE\n"
+         << "  2\n"
+         << "LTYPE\n"
+         << " 70\n"
+         << "1\n"
+
+         << "  0\n"
+         << "LTYPE\n"
+         << "  2\n"
+         << "CONTINUOUS\n"  // linetype name
+         << " 70\n"
+         << "64\n"
+         << "  3\n"
+         << "Solid line\n"  // descriptive text
+         << " 72\n"
+         << "65\n"  // always 65
+         << " 73\n"
+         << "0\n"  // number of linetype elements
+         << " 40\n"
+         << "0.000000\n"  // total pattern length
+
+         << "  0\n"
+         << "ENDTAB\n";
 
   /* --- LAYERS --- */
 
-  output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "LAYER\n"
-    << " 70\n" << "6\n"
-
-    << "  0\n" << "LAYER\n"
-    << "  2\n" << "0\n"         // layer name
-    << " 70\n" << "64\n"
-    << " 62\n" << "7\n"         // color
-    << "  6\n" << "CONTINUOUS\n"
-
-    << "  0\n" << "ENDTAB\n";
+  output << "  0\n"
+         << "TABLE\n"
+         << "  2\n"
+         << "LAYER\n"
+         << " 70\n"
+         << "6\n"
+
+         << "  0\n"
+         << "LAYER\n"
+         << "  2\n"
+         << "0\n"  // layer name
+         << " 70\n"
+         << "64\n"
+         << " 62\n"
+         << "7\n"  // color
+         << "  6\n"
+         << "CONTINUOUS\n"
+
+         << "  0\n"
+         << "ENDTAB\n";
 
   /* --- STYLE --- */
 
-  output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "STYLE\n"
-    << " 70\n" << "0\n"
-    << "  0\n" << "ENDTAB\n";
+  output << "  0\n"
+         << "TABLE\n"
+         << "  2\n"
+         << "STYLE\n"
+         << " 70\n"
+         << "0\n"
+         << "  0\n"
+         << "ENDTAB\n";
 
-  output
-    << "  0\n" << "ENDSEC\n";
+  output << "  0\n" << "ENDSEC\n";
 
   //
   // SECTION 3
   //
 
-  output
-    << "  0\n" << "SECTION\n"
-    << "  2\n" << "BLOCKS\n"
-    << "  0\n" << "ENDSEC\n";
-
+  output << "  0\n"
+         << "SECTION\n"
+         << "  2\n"
+         << "BLOCKS\n"
+         << "  0\n"
+         << "ENDSEC\n";
 }
 
-static void export_dxf(const Polygon2d& poly, std::ostream& output)
-{
-  setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
+static void export_dxf(const Polygon2d& poly, std::ostream& output) {
+  setlocale(LC_NUMERIC, "C");  // Ensure radix is . (not ,) in output
 
   // find limits
   double xMin, yMin, xMax, yMax;
@@ -171,10 +206,14 @@ static void export_dxf(const Polygon2d& poly, std::ostream& output)
   xMax = yMax = std::numeric_limits<double>::min();
   for (const auto& o : poly.outlines()) {
     for (const auto& p : o.vertices) {
-      if (xMin > p[0]) xMin = p[0];
-      if (xMax < p[0]) xMax = p[0];
-      if (yMin > p[1]) yMin = p[1];
-      if (yMax < p[1]) yMax = p[1];
+      if (xMin > p[0])
+        xMin = p[0];
+      if (xMax < p[0])
+        xMax = p[0];
+      if (yMin > p[1])
+        yMin = p[1];
+      if (yMax < p[1])
+        yMax = p[1];
     }
   }
 
@@ -190,69 +229,97 @@ static void export_dxf(const Polygon2d& poly, std::ostream& output)
   // DXF Format
   //    https://documentation.help/AutoCAD-DXF/WSfacf1429558a55de185c428100849a0ab7-5f35.htm
 
-  output << "  0\n" << "SECTION\n"
-         << "  2\n" << "ENTITIES\n";
+  output << "  0\n"
+         << "SECTION\n"
+         << "  2\n"
+         << "ENTITIES\n";
 
   for (const auto& o : poly.outlines()) {
-    switch (o.vertices.size() ) {
-    case 1: {
-      // POINT: just in case it's supported in the future
-      const Vector2d& p = o.vertices[0];
-      output << "  0\n" << "POINT\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n" // layer 0
-             << "100\n" << "AcDbPoint\n"
-             << " 10\n" << p[0] << "\n" // x
-             << " 20\n" << p[1] << "\n"; // y
-    } break;
-    case 2: {
-      // LINE: just in case it's supported in the future
-      // The [X1 Y1 X2 Y2] order is the most common and can be parsed linearly.
-      // Some libraries, like the python libraries dxfgrabber and ezdxf, cannot open [X1 X2 Y1 Y2] order.
-      const Vector2d& p1 = o.vertices[0];
-      const Vector2d& p2 = o.vertices[1];
-      output << "  0\n" << "LINE\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n" // layer 0
-             << "100\n" << "AcDbLine\n"
-             << " 10\n" << p1[0] << "\n" // x1
-             << " 20\n" << p1[1] << "\n" // y1
-             << " 11\n" << p2[0] << "\n" // x2
-             << " 21\n" << p2[1] << "\n"; // y2
-    } break;
-    default:
-      // LWPOLYLINE
-      output << "  0\n" << "LWPOLYLINE\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n"      // layer 0
-             << "100\n" << "AcDbPolyline\n"
-             << " 90\n" << o.vertices.size() << "\n" // number of vertices
-             << " 70\n" << "1\n";         // closed = 1
-      for (const auto& p : o.vertices) {
-        output << " 10\n" << p[0] << "\n"
-               << " 20\n" << p[1] << "\n";
-      }
-      break;
+    switch (o.vertices.size()) {
+      case 1: {
+        // POINT: just in case it's supported in the future
+        const Vector2d& p = o.vertices[0];
+        output << "  0\n"
+               << "POINT\n"
+               << "100\n"
+               << "AcDbEntity\n"
+               << "  8\n"
+               << "0\n"  // layer 0
+               << "100\n"
+               << "AcDbPoint\n"
+               << " 10\n"
+               << p[0] << "\n"  // x
+               << " 20\n"
+               << p[1] << "\n";  // y
+      } break;
+      case 2: {
+        // LINE: just in case it's supported in the future
+        // The [X1 Y1 X2 Y2] order is the most common and can be parsed
+        // linearly. Some libraries, like the python libraries dxfgrabber and
+        // ezdxf, cannot open [X1 X2 Y1 Y2] order.
+        const Vector2d& p1 = o.vertices[0];
+        const Vector2d& p2 = o.vertices[1];
+        output << "  0\n"
+               << "LINE\n"
+               << "100\n"
+               << "AcDbEntity\n"
+               << "  8\n"
+               << "0\n"  // layer 0
+               << "100\n"
+               << "AcDbLine\n"
+               << " 10\n"
+               << p1[0] << "\n"  // x1
+               << " 20\n"
+               << p1[1] << "\n"  // y1
+               << " 11\n"
+               << p2[0] << "\n"  // x2
+               << " 21\n"
+               << p2[1] << "\n";  // y2
+      } break;
+      default:
+        // LWPOLYLINE
+        output << "  0\n"
+               << "LWPOLYLINE\n"
+               << "100\n"
+               << "AcDbEntity\n"
+               << "  8\n"
+               << "0\n"  // layer 0
+               << "100\n"
+               << "AcDbPolyline\n"
+               << " 90\n"
+               << o.vertices.size() << "\n"  // number of vertices
+               << " 70\n"
+               << "1\n";  // closed = 1
+        for (const auto& p : o.vertices) {
+          output << " 10\n"
+                 << p[0] << "\n"
+                 << " 20\n"
+                 << p[1] << "\n";
+        }
+        break;
     }
   }
 
   output << "  0\n" << "ENDSEC\n";
   output << "  0\n" << "EOF\n";
 
-  setlocale(LC_NUMERIC, ""); // set default locale
+  setlocale(LC_NUMERIC, "");  // set default locale
 }
 
-void export_dxf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+void export_dxf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     for (const auto& item : geomlist->getChildren()) {
       export_dxf(item.second, output);
     }
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+  } else if (const auto poly =
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     export_dxf(*poly, output);
-  } else if (std::dynamic_pointer_cast<const PolySet>(geom)) { // NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const PolySet>(
+                 geom)) {  // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
-  } else { // NOLINT(bugprone-branch-clone)
+  } else {  // NOLINT(bugprone-branch-clone)
     assert(false && "Export as DXF for this geometry type is not supported");
   }
 }
diff --git a/src/io/export_nef.cc b/src/io/export_nef.cc
index 71aee7d06..d47aa6172 100644
--- a/src/io/export_nef.cc
+++ b/src/io/export_nef.cc
@@ -36,8 +36,8 @@
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
 
-void export_nefdbg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_nefdbg(const std::shared_ptr<const Geometry>& geom,
+                   std::ostream& output) {
   if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
     output << N->dump();
   } else {
@@ -45,12 +45,13 @@ void export_nefdbg(const std::shared_ptr<const Geometry>& geom, std::ostream& ou
   }
 }
 
-void export_nef3(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_nef3(const std::shared_ptr<const Geometry>& geom,
+                 std::ostream& output) {
   if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
-    output << const_cast<CGAL_Nef_polyhedron3&>(*N->p3); // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
+    output << const_cast<CGAL_Nef_polyhedron3&>(
+        *N->p3);  // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
   } else {
     LOG("Not a CGALNefPoly. Add some CSG ops?");
   }
 }
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
diff --git a/src/io/export_obj.cc b/src/io/export_obj.cc
index 27e25d848..a1bb512a5 100644
--- a/src/io/export_obj.cc
+++ b/src/io/export_obj.cc
@@ -27,15 +27,15 @@
 
 #include "io/export.h"
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 
 #include "geometry/Geometry.h"
-#include "geometry/PolySetUtils.h"
 #include "geometry/PolySet.h"
+#include "geometry/PolySetUtils.h"
 
-void export_obj(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_obj(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output) {
   // FIXME: In lazy union mode, should we export multiple objects?
 
   std::shared_ptr<const PolySet> out = PolySetUtils::getGeometryAsPolySet(geom);
diff --git a/src/io/export_off.cc b/src/io/export_off.cc
index e39c01f7a..c510669e0 100644
--- a/src/io/export_off.cc
+++ b/src/io/export_off.cc
@@ -27,18 +27,18 @@
 
 #include "io/export.h"
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
 #include <cstdint>
+#include <memory>
+#include <ostream>
 
 #include "Feature.h"
 #include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
 
-void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_off(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output) {
   auto ps = PolySetUtils::getGeometryAsPolySet(geom);
   if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
     ps = createSortedPolySet(*ps);
@@ -46,7 +46,6 @@ void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   const auto& v = ps->vertices;
   const size_t numverts = v.size();
 
-
   output << "OFF " << numverts << " " << ps->indices.size() << " 0\n";
   for (size_t i = 0; i < numverts; ++i) {
     output << v[i][0] << " " << v[i][1] << " " << v[i][2] << " " << "\n";
@@ -57,7 +56,8 @@ void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   for (size_t i = 0; i < ps->indices.size(); ++i) {
     const size_t nverts = ps->indices[i].size();
     output << nverts;
-    for (size_t n = 0; n < nverts; ++n) output << " " << ps->indices[i][n];
+    for (size_t n = 0; n < nverts; ++n)
+      output << " " << ps->indices[i][n];
     if (has_color) {
       auto color_index = ps->color_indices[i];
       if (color_index >= 0) {
@@ -68,7 +68,8 @@ void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
         }
         output << " " << r << " " << g << " " << b;
         // Alpha channel is read by apps like MeshLab.
-        if (a != 255) output << " " << a;
+        if (a != 255)
+          output << " " << a;
       }
     }
     output << "\n";
diff --git a/src/io/export_param.cc b/src/io/export_param.cc
index 3561e8660..29f8b04d1 100644
--- a/src/io/export_param.cc
+++ b/src/io/export_param.cc
@@ -24,20 +24,22 @@
  *
  */
 
+#include <boost/property_tree/json_parser.hpp>
 #include <filesystem>
 #include <iostream>
 #include <string>
 #include "json/json.hpp"
-#include <boost/property_tree/json_parser.hpp>
 
-#include "io/export.h"
 #include "core/customizer/ParameterObject.h"
+#include "io/export.h"
 
 using json = nlohmann::json;
 
-bool export_param(SourceFile *sourceFile, const fs::path& path, std::ostream& output)
-{
-  const ParameterObjects parameters = ParameterObjects::fromSourceFile(sourceFile);
+bool export_param(SourceFile* sourceFile,
+                  const fs::path& path,
+                  std::ostream& output) {
+  const ParameterObjects parameters =
+      ParameterObjects::fromSourceFile(sourceFile);
 
   json params;
   for (auto& param : parameters) {
@@ -57,7 +59,8 @@ bool export_param(SourceFile *sourceFile, const fs::path& path, std::ostream& ou
   }
 
   json paramFile;
-  paramFile["title"] = path.has_stem() ? path.stem().generic_string() : "Unnamed";
+  paramFile["title"] =
+      path.has_stem() ? path.stem().generic_string() : "Unnamed";
   if (params.size() > 0) {
     paramFile["parameters"] = params;
   }
diff --git a/src/io/export_pdf.cc b/src/io/export_pdf.cc
index 1da26cd7a..f9e3d5558 100644
--- a/src/io/export_pdf.cc
+++ b/src/io/export_pdf.cc
@@ -1,33 +1,32 @@
 #include "io/export.h"
 
 #include <cassert>
-#include <ostream>
+#include <cmath>
 #include <memory>
+#include <ostream>
 #include <string>
-#include <cmath>
 
 #include <Eigen/Core>
 
 #include "core/ColorUtil.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "io/export_enums.h"
 #include "utils/printutils.h"
 #include "utils/version_helper.h"
 
 #ifdef ENABLE_CAIRO
 
-#include <cairo.h>
 #include <cairo-pdf.h>
+#include <cairo.h>
 
 constexpr inline auto FONT = "Liberation Sans";
 constexpr double MARGIN = 30.0;
 constexpr double PTS_IN_MM = 2.834645656693;
 
-std::string get_cairo_version()
-{
+std::string get_cairo_version() {
   return OpenSCAD::get_version(CAIRO_VERSION_STRING, cairo_version_string());
 }
 
@@ -38,35 +37,48 @@ namespace {
 // rows map to paperSizes enums
 // columns are Width, Height
 const int paperDimensions[7][2] = {
-  {298, 420},   // A6
-  {420, 595},   // A5
-  {595, 842},   // A4
-  {842, 1190},  // A3
-  {612, 792},   // Letter
-  {612, 1008},  // Legal
-  {792, 1224},  // Tabloid
+    {298, 420},   // A6
+    {420, 595},   // A5
+    {595, 842},   // A4
+    {842, 1190},  // A3
+    {612, 792},   // Letter
+    {612, 1008},  // Legal
+    {792, 1224},  // Tabloid
 };
 
-void draw_text(const char *text, cairo_t *cr, double x, double y, double fontSize)
-{
-  cairo_select_font_face(cr, FONT, CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
+void draw_text(const char* text,
+               cairo_t* cr,
+               double x,
+               double y,
+               double fontSize) {
+  cairo_select_font_face(cr, FONT, CAIRO_FONT_SLANT_NORMAL,
+                         CAIRO_FONT_WEIGHT_NORMAL);
   cairo_set_font_size(cr, fontSize);
   cairo_move_to(cr, x, y);
   cairo_show_text(cr, text);
 }
 
-double mm_to_points(double mm) { return mm * PTS_IN_MM; }
+double mm_to_points(double mm) {
+  return mm * PTS_IN_MM;
+}
 
-double points_to_mm(double pts) { return pts / PTS_IN_MM; }
+double points_to_mm(double pts) {
+  return pts / PTS_IN_MM;
+}
 
-void draw_grid(cairo_t *cr, double left, double right, double bottom, double top, double gridSize)
-{
-  if (gridSize < 1.) gridSize = 2.0;
+void draw_grid(cairo_t* cr,
+               double left,
+               double right,
+               double bottom,
+               double top,
+               double gridSize) {
+  if (gridSize < 1.)
+    gridSize = 2.0;
   const double darkerLine = 0.36;
   const double lightLine = 0.24;
   const int major = (gridSize > 10.0 ? gridSize : int(10.0 / gridSize));
 
-  double pts = 0.0; // for iteration across page
+  double pts = 0.0;  // for iteration across page
 
   // Bounds are margins in points.
   // Compute Xrange in units of gridSize
@@ -106,8 +118,11 @@ void draw_grid(cairo_t *cr, double left, double right, double bottom, double top
 }
 
 // New draw_axes (renamed from axis since it draws both).
-void draw_axes(cairo_t *cr, double left, double right, double bottom, double top)
-{
+void draw_axes(cairo_t* cr,
+               double left,
+               double right,
+               double bottom,
+               double top) {
   const double darkerLine = 0.36;
   const double offset = mm_to_points(5.);
   double pts = 0.;  // for iteration across page
@@ -156,8 +171,7 @@ void draw_axes(cairo_t *cr, double left, double right, double bottom, double top
 }
 
 // Draws a single 2D polygon.
-void draw_geom(const Polygon2d& poly, cairo_t *cr)
-{
+void draw_geom(const Polygon2d& poly, cairo_t* cr) {
   for (const auto& o : poly.outlines()) {
     if (o.vertices.empty()) {
       continue;
@@ -175,31 +189,34 @@ void draw_geom(const Polygon2d& poly, cairo_t *cr)
 }
 
 // Main entry:  draw geometry that consists of 2D polygons.  Walks the tree...
-void draw_geom(const std::shared_ptr<const Geometry>& geom, cairo_t *cr)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+void draw_geom(const std::shared_ptr<const Geometry>& geom, cairo_t* cr) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     for (const auto& item : geomlist->getChildren()) {
       draw_geom(item.second, cr);
     }
   } else if (std::dynamic_pointer_cast<const PolySet>(geom)) {
     assert(false && "Unsupported file format");
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+  } else if (const auto poly =
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     draw_geom(*poly, cr);
   } else {
     assert(false && "Export as PDF for this geometry type is not supported");
   }
 }
 
-cairo_status_t export_pdf_write(void *closure, const unsigned char *data, unsigned int length)
-{
-  auto *stream = static_cast<std::ostream *>(closure);
-  stream->write(reinterpret_cast<const char *>(data), length);
+cairo_status_t export_pdf_write(void* closure,
+                                const unsigned char* data,
+                                unsigned int length) {
+  auto* stream = static_cast<std::ostream*>(closure);
+  stream->write(reinterpret_cast<const char*>(data), length);
   return !(*stream) ? CAIRO_STATUS_WRITE_ERROR : CAIRO_STATUS_SUCCESS;
 }
 
-void add_meta_data(cairo_surface_t *surface, const cairo_pdf_metadata_t metadata,
-                   const std::string& value, const std::string& value2 = "")
-{
+void add_meta_data(cairo_surface_t* surface,
+                   const cairo_pdf_metadata_t metadata,
+                   const std::string& value,
+                   const std::string& value2 = "") {
   const std::string v = value.empty() ? value2 : value;
   if (v.empty()) {
     return;
@@ -210,11 +227,11 @@ void add_meta_data(cairo_surface_t *surface, const cairo_pdf_metadata_t metadata
 
 }  // namespace
 
-void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                const ExportInfo& exportInfo)
-{
+void export_pdf(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
+                const ExportInfo& exportInfo) {
   // Extract the options.  This will change when options becomes a variant.
-  const ExportPdfOptions *options;
+  const ExportPdfOptions* options;
   const ExportPdfOptions defaultPdfOptions;
 
   // Could use short-circuit short-form, but will need to grow.
@@ -241,7 +258,8 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   const int centerY = mm_to_points(miny) + spanY / 2.0;
 
   // Set orientation and paper size.
-  if ((options->orientation == ExportPdfPaperOrientation::AUTO && spanX > spanY) ||
+  if ((options->orientation == ExportPdfPaperOrientation::AUTO &&
+       spanX > spanY) ||
       (options->orientation == ExportPdfPaperOrientation::LANDSCAPE)) {
     pdfX = paperDimensions[static_cast<int>(options->paperSize)][1];
     pdfY = paperDimensions[static_cast<int>(options->paperSize)][0];
@@ -253,42 +271,54 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   // Does it fit? (in points)
   const bool inpaper = (spanX <= pdfX - MARGIN) && (spanY <= pdfY - MARGIN);
   if (!inpaper) {
-    LOG(message_group::Export_Warning, "Geometry is too large to fit into selected size.");
+    LOG(message_group::Export_Warning,
+        "Geometry is too large to fit into selected size.");
   }
 
   //  Center on page.  Still in points.
   // Note Cairo inverts the Y axis, with zero at the top, positive going down.
   // Compute translation and auxiliary numbers in lieu of transform matrices.
   const double tcX = pdfX / 2.0 - centerX;
-  const double tcY = (pdfY / 2.0 + centerY);  // Note Geometry Y will still need to be inverted.
+  const double tcY =
+      (pdfY / 2.0 +
+       centerY);  // Note Geometry Y will still need to be inverted.
   // Shifted exact margins
-  const double Mlx = centerX - pdfX / 2.0 + MARGIN;     // Left margin, X axis
-  const double Mrx = centerX + pdfX / 2.0 - MARGIN;     // Right margin, X axis
-  const double Mty = -(centerY - pdfY / 2.0 + MARGIN);  // INVERTED Top margin, Y axis
-  const double Mby = -(centerY + pdfY / 2.0 - MARGIN);  // INVERTED Bottom margin, Y axis
+  const double Mlx = centerX - pdfX / 2.0 + MARGIN;  // Left margin, X axis
+  const double Mrx = centerX + pdfX / 2.0 - MARGIN;  // Right margin, X axis
+  const double Mty =
+      -(centerY - pdfY / 2.0 + MARGIN);  // INVERTED Top margin, Y axis
+  const double Mby =
+      -(centerY + pdfY / 2.0 - MARGIN);  // INVERTED Bottom margin, Y axis
 
   // Initialize Cairo Surface and PDF
-  cairo_surface_t *surface = cairo_pdf_surface_create_for_stream(export_pdf_write, &output, pdfX, pdfY);
-  if (cairo_surface_status(surface) == cairo_status_t::CAIRO_STATUS_NULL_POINTER) {
+  cairo_surface_t* surface = cairo_pdf_surface_create_for_stream(
+      export_pdf_write, &output, pdfX, pdfY);
+  if (cairo_surface_status(surface) ==
+      cairo_status_t::CAIRO_STATUS_NULL_POINTER) {
     cairo_surface_destroy(surface);
     return;
   }
 
 #if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
   if (options->addMetaData) {
-    add_meta_data(surface, CAIRO_PDF_METADATA_TITLE, options->metaDataTitle, exportInfo.title);
+    add_meta_data(surface, CAIRO_PDF_METADATA_TITLE, options->metaDataTitle,
+                  exportInfo.title);
     add_meta_data(surface, CAIRO_PDF_METADATA_CREATOR, EXPORT_CREATOR);
-    add_meta_data(surface, CAIRO_PDF_METADATA_CREATE_DATE, get_current_iso8601_date_time_utc());
+    add_meta_data(surface, CAIRO_PDF_METADATA_CREATE_DATE,
+                  get_current_iso8601_date_time_utc());
     add_meta_data(surface, CAIRO_PDF_METADATA_MOD_DATE, "");
     add_meta_data(surface, CAIRO_PDF_METADATA_AUTHOR, options->metaDataAuthor);
-    add_meta_data(surface, CAIRO_PDF_METADATA_SUBJECT, options->metaDataSubject);
-    add_meta_data(surface, CAIRO_PDF_METADATA_KEYWORDS, options->metaDataKeywords);
+    add_meta_data(surface, CAIRO_PDF_METADATA_SUBJECT,
+                  options->metaDataSubject);
+    add_meta_data(surface, CAIRO_PDF_METADATA_KEYWORDS,
+                  options->metaDataKeywords);
   }
 #endif
 
-  cairo_t *cr = cairo_create(surface);
+  cairo_t* cr = cairo_create(surface);
 
-  // Note Y axis + is DOWN.  Drawings have to invert Y, but these translations account for that.
+  // Note Y axis + is DOWN.  Drawings have to invert Y, but these translations
+  // account for that.
   cairo_translate(cr, tcX, tcY);  // Center page on geometry;
 
   const Color4f black = Color4f(0.0f, 0.0f, 0.0f);
@@ -298,13 +328,15 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   if (options->fill) {
     Color4f fillColor = OpenSCAD::getColor(options->fillColor, black);
-    cairo_set_source_rgba(cr, fillColor.r(), fillColor.g(), fillColor.b(), fillColor.a());
+    cairo_set_source_rgba(cr, fillColor.r(), fillColor.g(), fillColor.b(),
+                          fillColor.a());
     cairo_fill_preserve(cr);
   }
 
   if (options->stroke) {
     Color4f strokeColor = OpenSCAD::getColor(options->strokeColor, black);
-    cairo_set_source_rgba(cr, strokeColor.r(), strokeColor.g(), strokeColor.b(), strokeColor.a());
+    cairo_set_source_rgba(cr, strokeColor.r(), strokeColor.g(), strokeColor.b(),
+                          strokeColor.a());
     cairo_set_line_width(cr, mm_to_points(options->strokeWidth));
     cairo_stroke_preserve(cr);
   }
@@ -314,18 +346,21 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   // Set Annotations
   const std::string about =
-    "Scale is to calibrate actual printed dimension. Check both X and Y. "
-    "Measure between tick 0 and last tick";
+      "Scale is to calibrate actual printed dimension. Check both X and Y. "
+      "Measure between tick 0 and last tick";
   cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 0.48);
   // Design Filename
-  if (options->showDesignFilename) draw_text(exportInfo.sourceFilePath.c_str(), cr, Mlx, Mby, 10.0);
+  if (options->showDesignFilename)
+    draw_text(exportInfo.sourceFilePath.c_str(), cr, Mlx, Mby, 10.0);
   // Scale
   if (options->showScale) {
     draw_axes(cr, Mlx, Mrx, Mty, Mby);
     // Scale Message
-    if (options->showScaleMsg) draw_text(about.c_str(), cr, Mlx + 1, Mty - 1, 5.0);
+    if (options->showScaleMsg)
+      draw_text(about.c_str(), cr, Mlx + 1, Mty - 1, 5.0);
     // Grid
-    if (options->showGrid) draw_grid(cr, Mlx, Mrx, Mty, Mby, options->gridSize);
+    if (options->showGrid)
+      draw_grid(cr, Mlx, Mrx, Mty, Mby, options->gridSize);
   }
 
   cairo_show_page(cr);
@@ -335,15 +370,16 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
 #else  // ENABLE_CAIRO
 
-const std::string get_cairo_version()
-{
+const std::string get_cairo_version() {
   const std::string cairo_version = "(not enabled)";
   return cairo_version;
 }
 
-void export_pdf(const std::shared_ptr<const Geometry>&, std::ostream&, const ExportInfo&)
-{
-  LOG(message_group::Error, "Export to PDF format was not enabled when building the application.");
+void export_pdf(const std::shared_ptr<const Geometry>&,
+                std::ostream&,
+                const ExportInfo&) {
+  LOG(message_group::Error,
+      "Export to PDF format was not enabled when building the application.");
 }
 
 #endif  // ENABLE_CAIRO
diff --git a/src/io/export_png.cc b/src/io/export_png.cc
index b12e4380b..e71ba0ac4 100644
--- a/src/io/export_png.cc
+++ b/src/io/export_png.cc
@@ -1,8 +1,8 @@
 #include "io/export.h"
 
-#include <ostream>
 #include <cstdio>
 #include <memory>
+#include <ostream>
 
 #include "core/Tree.h"
 #include "geometry/Geometry.h"
@@ -10,37 +10,40 @@
 #include "glview/Camera.h"
 #include "glview/CsgInfo.h"
 #include "glview/OffscreenView.h"
-#include "glview/Renderer.h"
 #include "glview/RenderSettings.h"
+#include "glview/Renderer.h"
 #include "utils/printutils.h"
 
 #ifndef NULLGL
-#include "glview/cgal/CGALRenderer.h"
 #include "glview/PolySetRenderer.h"
+#include "glview/cgal/CGALRenderer.h"
 
 #ifdef ENABLE_OPENCSG
-#include "glview/preview/OpenCSGRenderer.h"
 #include <opencsg.h>
+#include "glview/preview/OpenCSGRenderer.h"
 #endif  // ENABLE_OPENCSG
 
 #include "glview/preview/ThrownTogetherRenderer.h"
 
 namespace {
 
-void setupCamera(Camera& cam, const BoundingBox& bbox)
-{
-  if (cam.viewall) cam.viewAll(bbox);
+void setupCamera(Camera& cam, const BoundingBox& bbox) {
+  if (cam.viewall)
+    cam.viewAll(bbox);
 }
 
 }  // namespace
 
-bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output)
-{
+bool export_png(const std::shared_ptr<const Geometry>& root_geom,
+                const ViewOptions& options,
+                Camera& camera,
+                std::ostream& output) {
   assert(root_geom != nullptr);
   PRINTD("export_png geom");
   std::unique_ptr<OffscreenView> glview;
   try {
-    glview = std::make_unique<OffscreenView>(camera.pixel_width, camera.pixel_height);
+    glview = std::make_unique<OffscreenView>(camera.pixel_width,
+                                             camera.pixel_height);
   } catch (const OffscreenViewException& ex) {
     fprintf(stderr, "Can't create OffscreenView: %s.\n", ex.what());
     return false;
@@ -50,7 +53,7 @@ bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOpti
   // know that all geometries are convertible to PolySet.
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend ||
       std::dynamic_pointer_cast<const PolySet>(root_geom) ||
-      std::dynamic_pointer_cast<const Polygon2d>(root_geom)){
+      std::dynamic_pointer_cast<const Polygon2d>(root_geom)) {
     geomRenderer = std::make_shared<PolySetRenderer>(root_geom);
   } else {
     geomRenderer = std::make_shared<CGALRenderer>(root_geom);
@@ -70,15 +73,17 @@ bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOpti
   return true;
 }
 
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera)
-{
+std::unique_ptr<OffscreenView> prepare_preview(Tree& tree,
+                                               const ViewOptions& options,
+                                               Camera& camera) {
   PRINTD("prepare_preview_common");
   CsgInfo csgInfo = CsgInfo();
   csgInfo.compile_products(tree);
 
   std::unique_ptr<OffscreenView> glview;
   try {
-    glview = std::make_unique<OffscreenView>(camera.pixel_width, camera.pixel_height);
+    glview = std::make_unique<OffscreenView>(camera.pixel_width,
+                                             camera.pixel_height);
   } catch (const OffscreenViewException& ex) {
     LOG("Can't create OffscreenView: %1$s.", ex.what());
     return nullptr;
@@ -88,19 +93,22 @@ std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& op
   if (options.previewer == Previewer::OPENCSG) {
 #ifdef ENABLE_OPENCSG
     PRINTD("Initializing OpenCSGRenderer");
-    renderer = std::make_shared<OpenCSGRenderer>(csgInfo.root_products, csgInfo.highlights_products, csgInfo.background_products);
+    renderer = std::make_shared<OpenCSGRenderer>(csgInfo.root_products,
+                                                 csgInfo.highlights_products,
+                                                 csgInfo.background_products);
 #else
     fprintf(stderr, "This openscad was built without OpenCSG support\n");
     return 0;
 #endif
   } else {
     PRINTD("Initializing ThrownTogetherRenderer");
-    renderer = std::make_shared<ThrownTogetherRenderer>(csgInfo.root_products, csgInfo.highlights_products, csgInfo.background_products);
+    renderer = std::make_shared<ThrownTogetherRenderer>(
+        csgInfo.root_products, csgInfo.highlights_products,
+        csgInfo.background_products);
   }
 
   glview->setRenderer(renderer);
 
-
 #ifdef ENABLE_OPENCSG
   const BoundingBox bbox = glview->getRenderer()->getBoundingBox();
   setupCamera(camera, bbox);
@@ -117,17 +125,27 @@ std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& op
   return glview;
 }
 
-bool export_png(const OffscreenView& glview, std::ostream& output)
-{
+bool export_png(const OffscreenView& glview, std::ostream& output) {
   PRINTD("export_png_preview_common");
   glview.save(output);
   return true;
 }
 
-#else // NULLGL
+#else  // NULLGL
 
-bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output) { return false; }
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera) { return nullptr; }
-bool export_png(const OffscreenView& glview, std::ostream& output) { return false; }
+bool export_png(const std::shared_ptr<const Geometry>& root_geom,
+                const ViewOptions& options,
+                Camera& camera,
+                std::ostream& output) {
+  return false;
+}
+std::unique_ptr<OffscreenView> prepare_preview(Tree& tree,
+                                               const ViewOptions& options,
+                                               Camera& camera) {
+  return nullptr;
+}
+bool export_png(const OffscreenView& glview, std::ostream& output) {
+  return false;
+}
 
-#endif // NULLGL
+#endif  // NULLGL
diff --git a/src/io/export_pov.cc b/src/io/export_pov.cc
index 176a9e661..b38038e4a 100644
--- a/src/io/export_pov.cc
+++ b/src/io/export_pov.cc
@@ -36,9 +36,9 @@
 #include "geometry/PolySetUtils.h"
 #include "geometry/linalg.h"
 
-
-void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+void export_pov(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
+                const ExportInfo& exportInfo) {
   std::shared_ptr<const PolySet> ps = PolySetUtils::getGeometryAsPolySet(geom);
   if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
     ps = createSortedPolySet(*ps);
@@ -50,22 +50,28 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   output << "#version 3.7;\n";
   output << "global_settings { assumed_gamma 1.0 }\n";
-  output << "#declare MATERIAL=finish { specular 0.5 roughness 0.001 reflection{0 0.63 fresnel} ambient 0 diffuse 0.6 conserve_energy }\n";
+  output
+      << "#declare MATERIAL=finish { specular 0.5 roughness 0.001 reflection{0 "
+         "0.63 fresnel} ambient 0 diffuse 0.6 conserve_energy }\n";
   output << "#declare MATERIAL_INT=interior{ior 1.32}\n";
 
   auto has_color = !ps->color_indices.empty();
 
-  for (size_t polygon_index = 0; polygon_index < ps->indices.size(); polygon_index++) {
+  for (size_t polygon_index = 0; polygon_index < ps->indices.size();
+       polygon_index++) {
     const auto& polygon = ps->indices[polygon_index];
     output << "polygon { " << polygon.size() + 1 << ", \n";
     for (size_t i = 0; i < polygon.size(); i++) {
-      if (i)output << ", ";
+      if (i)
+        output << ", ";
       const auto& x = ps->vertices[polygon[i]].x();
       const auto& y = ps->vertices[polygon[i]].y();
       const auto& z = ps->vertices[polygon[i]].z();
       output << "<" << x << ", " << y << ", " << z << ">";
     }
-    output << ", <" << ps->vertices[polygon[0]].x() << ", " << ps->vertices[polygon[0]].y() << ", " << ps->vertices[polygon[0]].z() << ">";
+    output << ", <" << ps->vertices[polygon[0]].x() << ", "
+           << ps->vertices[polygon[0]].y() << ", "
+           << ps->vertices[polygon[0]].z() << ">";
     float r = exportInfo.defaultColor.r();
     float g = exportInfo.defaultColor.g();
     float b = exportInfo.defaultColor.b();
@@ -81,7 +87,8 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
       }
     }
     output << "\n";
-    output << "texture { pigment { color rgbf <" << r << ", " << g << ", " << b << ", " << f << "> } }\n";
+    output << "texture { pigment { color rgbf <" << r << ", " << g << ", " << b
+           << ", " << f << "> } }\n";
     output << "finish { MATERIAL } interior { MATERIAL_INT }\n";
     output << "}\n";
   }
@@ -101,16 +108,21 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   const double dz = max_z - min_z;
 
   constexpr double move_away_factor = 2.;
-  const std::vector<double> lx { min_x - dx * move_away_factor, bbox.center().x(), max_x + dx * move_away_factor };
-  const std::vector<double> ly { min_y - dy * move_away_factor, bbox.center().y(), max_y + dy * move_away_factor };
-  const std::vector<double> lz { min_z - dz * move_away_factor, bbox.center().z(), max_z + dz * move_away_factor };
+  const std::vector<double> lx{min_x - dx * move_away_factor, bbox.center().x(),
+                               max_x + dx * move_away_factor};
+  const std::vector<double> ly{min_y - dy * move_away_factor, bbox.center().y(),
+                               max_y + dy * move_away_factor};
+  const std::vector<double> lz{min_z - dz * move_away_factor, bbox.center().z(),
+                               max_z + dz * move_away_factor};
 
   constexpr float brightness = 0.2;  // 1.0 is way too bright
 
-  for (auto cur_lx: lx) {
-    for (auto cur_ly: ly) {
-      for (auto cur_lz: lz)
-        output << "light_source { <" << cur_lx << ", " << cur_ly << ", " << cur_lz << "> color rgb <" << brightness << ", " << brightness << ", " << brightness << "> }\n";
+  for (auto cur_lx : lx) {
+    for (auto cur_ly : ly) {
+      for (auto cur_lz : lz)
+        output << "light_source { <" << cur_lx << ", " << cur_ly << ", "
+               << cur_lz << "> color rgb <" << brightness << ", " << brightness
+               << ", " << brightness << "> }\n";
     }
   }
 
@@ -122,18 +134,36 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     auto yaw = vpr.y();
     auto roll = vpr.z();
 
-    output << "camera { look_at <" << 0 << ", " << 0 << ", " << 0 << ">\n "
-      "location <" << 0 << ", " << 0 << ", " << exportInfo.camera->viewer_distance << ">\n "
-      "angle " << exportInfo.camera->fov << " up <0, 1, 0> right <1, 0, 0> sky <0, 1, 0> right -x*image_width/image_height\n"
-      "translate <" << vpt.x() << ", " << vpt.y() << ", " << vpt.z() << ">\n"
-      "rotate <" << pitch << ", " << yaw << " + clock * 3, " << roll << " + clock>\n"
-      "}\n";
+    output << "camera { look_at <" << 0 << ", " << 0 << ", " << 0
+           << ">\n "
+              "location <"
+           << 0 << ", " << 0 << ", " << exportInfo.camera->viewer_distance
+           << ">\n "
+              "angle "
+           << exportInfo.camera->fov
+           << " up <0, 1, 0> right <1, 0, 0> sky <0, 1, 0> right "
+              "-x*image_width/image_height\n"
+              "translate <"
+           << vpt.x() << ", " << vpt.y() << ", " << vpt.z()
+           << ">\n"
+              "rotate <"
+           << pitch << ", " << yaw << " + clock * 3, " << roll
+           << " + clock>\n"
+              "}\n";
   } else {
-    output << "camera { look_at <" << bbox.center().x() << ", " << bbox.center().y() << ", " << bbox.center().z() << "> "
-      "location <" << min_x + dx * move_away_factor << ", " << min_y - dy * move_away_factor << ", " << min_z + dz * move_away_factor << "> "
-      "up <0, 0, 1> right <1, 0, 0> sky <0, 0, 1> rotate <-55, clock * 3, clock + 25> right x*image_width/image_height }\n";
+    output << "camera { look_at <" << bbox.center().x() << ", "
+           << bbox.center().y() << ", " << bbox.center().z()
+           << "> "
+              "location <"
+           << min_x + dx * move_away_factor << ", "
+           << min_y - dy * move_away_factor << ", "
+           << min_z + dz * move_away_factor
+           << "> "
+              "up <0, 0, 1> right <1, 0, 0> sky <0, 0, 1> rotate <-55, clock * "
+              "3, clock + 25> right x*image_width/image_height }\n";
   }
 
   output << "#include \"rad_def.inc\"\n";
-  output << "global_settings { photons { count 20000 autostop 0 jitter .4 } radiosity { Rad_Settings(Radiosity_Normal, off, off) } }\n";
+  output << "global_settings { photons { count 20000 autostop 0 jitter .4 } "
+            "radiosity { Rad_Settings(Radiosity_Normal, off, off) } }\n";
 }
diff --git a/src/io/export_stl.cc b/src/io/export_stl.cc
index cda164f78..7b6beaaeb 100644
--- a/src/io/export_stl.cc
+++ b/src/io/export_stl.cc
@@ -42,9 +42,9 @@
 #include <double-conversion/double-conversion.h>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 #ifdef ENABLE_MANIFOLD
@@ -59,7 +59,7 @@ namespace {
 /* Define values for double-conversion library. */
 #define DC_BUFFER_SIZE (128)
 #define DC_FLAGS (double_conversion::DoubleToStringConverter::UNIQUE_ZERO)
-#define DC_INF NULL // Only finite values in STL outputs!
+#define DC_INF NULL  // Only finite values in STL outputs!
 #define DC_NAN NULL
 #define DC_EXP 'e'
 #define DC_DECIMAL_LOW_EXP (-6)
@@ -67,12 +67,10 @@ namespace {
 #define DC_MAX_LEADING_ZEROES (5)
 #define DC_MAX_TRAILING_ZEROES (0)
 
-std::string toString(const Vector3d& v)
-{
+std::string toString(const Vector3d& v) {
   const double_conversion::DoubleToStringConverter dc(
-    DC_FLAGS, DC_INF, DC_NAN, DC_EXP,
-    DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES
-    );
+      DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP,
+      DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
 
   char buffer[DC_BUFFER_SIZE];
 
@@ -88,33 +86,33 @@ std::string toString(const Vector3d& v)
 }
 
 int32_t flipEndianness(int32_t x) {
-  return
-    ((x << 24) & 0xff000000) | ((x >> 24) & 0xff) |
-    ((x << 8) & 0xff0000) | ((x >> 8) & 0xff00);
+  return ((x << 24) & 0xff000000) | ((x >> 24) & 0xff) | ((x << 8) & 0xff0000) |
+         ((x >> 8) & 0xff00);
 }
 
 template <size_t N>
 void write_floats(std::ostream& output, const std::array<float, N>& data) {
   static constexpr uint16_t test = 0x0001;
-  static const bool isLittleEndian = *reinterpret_cast<const char *>(&test) == 1;
+  static const bool isLittleEndian = *reinterpret_cast<const char*>(&test) == 1;
 
   if (isLittleEndian) {
-    output.write(reinterpret_cast<char *>(const_cast<float *>(&data[0])), N * sizeof(float));
+    output.write(reinterpret_cast<char*>(const_cast<float*>(&data[0])),
+                 N * sizeof(float));
   } else {
     std::array<float, N> copy(data);
 
-    auto *ints = reinterpret_cast<int32_t *>(&copy[0]);
+    auto* ints = reinterpret_cast<int32_t*>(&copy[0]);
     for (size_t i = 0; i < N; i++) {
       ints[i] = flipEndianness(ints[i]);
     }
 
-    output.write(reinterpret_cast<char *>(&copy[0]), N * sizeof(float));
+    output.write(reinterpret_cast<char*>(&copy[0]), N * sizeof(float));
   }
 }
 
-
-uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream& output, bool binary)
-{
+uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset,
+                    std::ostream& output,
+                    bool binary) {
   static_assert(sizeof(float) == 4, "Need 32 bit float");
 
   std::shared_ptr<const PolySet> ps = polyset;
@@ -131,10 +129,9 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
   std::vector<std::string> vertexStrings;
   if (!binary) {
     vertexStrings.resize(ps->vertices.size());
-    std::transform(ps->vertices.begin(), ps->vertices.end(), vertexStrings.begin(),
-                   [](const auto& p) {
-        return toString(p);
-      });
+    std::transform(ps->vertices.begin(), ps->vertices.end(),
+                   vertexStrings.begin(),
+                   [](const auto& p) { return toString(p); });
   }
 
   // Used for binary mode only
@@ -156,9 +153,9 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
     if (binary) {
       auto coords_offset = 0;
       auto addCoords = [&](const auto& v) {
-          for (auto i : {0, 1, 2})
-            coords[coords_offset++] = v[i];
-        };
+        for (auto i : {0, 1, 2})
+          coords[coords_offset++] = v[i];
+      };
       addCoords(normal);
       addCoords(p0);
       addCoords(p1);
@@ -197,15 +194,17 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
     Saves the current 3D CGAL Nef polyhedron as STL to the given file.
     The file must be open.
  */
-uint64_t append_stl(const CGALNefGeometry& root_N, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl(const CGALNefGeometry& root_N,
+                    std::ostream& output,
+                    bool binary) {
   uint64_t triangle_count = 0;
   if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+    LOG(message_group::Export_Warning,
+        "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-  if (const std::shared_ptr<PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*(root_N.p3))) {
+  if (const std::shared_ptr<PolySet> ps =
+          CGALUtils::createPolySetFromNefPolyhedron3(*(root_N.p3))) {
     triangle_count += append_stl(ps, output, binary);
   } else {
     LOG(message_group::Export_Error, "Nef->PolySet failed");
@@ -221,12 +220,13 @@ uint64_t append_stl(const CGALNefGeometry& root_N, std::ostream& output,
    Saves the current 3D Manifold geometry as STL to the given file.
    The file must be open.
  */
-uint64_t append_stl(const ManifoldGeometry& mani, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl(const ManifoldGeometry& mani,
+                    std::ostream& output,
+                    bool binary) {
   uint64_t triangle_count = 0;
   if (!mani.isManifold()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+    LOG(message_group::Export_Warning,
+        "Exported object may not be a valid 2-manifold and may need repair");
   }
 
   const auto ps = mani.toPolySet();
@@ -240,42 +240,45 @@ uint64_t append_stl(const ManifoldGeometry& mani, std::ostream& output,
 }
 #endif  // ENABLE_MANIFOLD
 
-
-uint64_t append_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl(const std::shared_ptr<const Geometry>& geom,
+                    std::ostream& output,
+                    bool binary) {
   uint64_t triangle_count = 0;
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     for (const Geometry::GeometryItem& item : geomlist->getChildren()) {
       triangle_count += append_stl(item.second, output, binary);
     }
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     triangle_count += append_stl(ps, output, binary);
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     triangle_count += append_stl(*N, output, binary);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     triangle_count += append_stl(*mani, output, binary);
 #endif
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { //NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const Polygon2d>(
+                 geom)) {  // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
-  } else { //NOLINT(bugprone-branch-clone)
+  } else {  // NOLINT(bugprone-branch-clone)
     assert(false && "Not implemented");
   }
 
   return triangle_count;
 }
 
-} // namespace
+}  // namespace
 
-void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                bool binary)
-{
+void export_stl(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output,
+                bool binary) {
   // FIXME: In lazy union mode, should we export multiple solids?
   if (binary) {
-    std::ostringstream buffer; // Using a memory buffer
+    std::ostringstream buffer;  // Using a memory buffer
     char header[80] = "OpenSCAD Model\n";
     buffer.write(header, sizeof(header));
 
@@ -288,15 +291,16 @@ void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     triangle_count = append_stl(geom, buffer, binary);
 
     if (triangle_count > 4294967295) {
-      LOG(message_group::Export_Error, "Triangle count exceeded 4294967295, so the STL file is not valid");
+      LOG(message_group::Export_Error,
+          "Triangle count exceeded 4294967295, so the STL file is not valid");
     }
 
     // Updating the triangle count in the buffer
     char triangle_count_bytes[4] = {
-      static_cast<char>(triangle_count & 0xff),
-      static_cast<char>((triangle_count >> 8) & 0xff),
-      static_cast<char>((triangle_count >> 16) & 0xff),
-      static_cast<char>((triangle_count >> 24) & 0xff)};
+        static_cast<char>(triangle_count & 0xff),
+        static_cast<char>((triangle_count >> 8) & 0xff),
+        static_cast<char>((triangle_count >> 16) & 0xff),
+        static_cast<char>((triangle_count >> 24) & 0xff)};
     buffer.seekp(80, std::ios_base::beg);
     buffer.write(triangle_count_bytes, 4);
 
@@ -305,10 +309,10 @@ void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   } else {
     // ASCII mode: Write directly to the output stream
-    setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
+    setlocale(LC_NUMERIC, "C");  // Ensure radix is . (not ,) in output
     output << "solid OpenSCAD_Model\n";
     append_stl(geom, output, binary);
     output << "endsolid OpenSCAD_Model\n";
-    setlocale(LC_NUMERIC, ""); // Restore default locale
+    setlocale(LC_NUMERIC, "");  // Restore default locale
   }
 }
diff --git a/src/io/export_svg.cc b/src/io/export_svg.cc
index f4ec111cf..a5ba70154 100644
--- a/src/io/export_svg.cc
+++ b/src/io/export_svg.cc
@@ -32,12 +32,11 @@
 #include <ostream>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
-static void append_svg(const Polygon2d& poly, std::ostream& output)
-{
+static void append_svg(const Polygon2d& poly, std::ostream& output) {
   output << "<path d=\"\n";
   for (const auto& o : poly.outlines()) {
     if (o.vertices.empty()) {
@@ -56,27 +55,29 @@ static void append_svg(const Polygon2d& poly, std::ostream& output)
     output << " z\n";
   }
   output << "\" stroke=\"black\" fill=\"lightgray\" stroke-width=\"0.5\"/>\n";
-
 }
 
-static void append_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+static void append_svg(const std::shared_ptr<const Geometry>& geom,
+                       std::ostream& output) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     for (const auto& item : geomlist->getChildren()) {
       append_svg(item.second, output);
     }
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+  } else if (const auto poly =
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     append_svg(*poly, output);
-  } else if (std::dynamic_pointer_cast<const PolySet>(geom)) { // NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const PolySet>(
+                 geom)) {  // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
-  } else { // NOLINT(bugprone-branch-clone)
+  } else {  // NOLINT(bugprone-branch-clone)
     assert(false && "Export as SVG for this geometry type is not supported");
   }
 }
 
-void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
+void export_svg(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output) {
+  setlocale(LC_NUMERIC, "C");  // Ensure radix is . (not ,) in output
 
   BoundingBox bbox = geom->getBoundingBox();
   const int minx = (int)floor(bbox.min().x());
@@ -86,16 +87,17 @@ void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   const int width = maxx - minx;
   const int height = maxy - miny;
 
-  output
-    << "<?xml version=\"1.0\" standalone=\"no\"?>\n"
-    << "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"
-    << "<svg width=\"" << width << "mm\" height=\"" << height
-    << "mm\" viewBox=\"" << minx << " " << miny << " " << width << " " << height
-    << "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n"
-    << "<title>OpenSCAD Model</title>\n";
+  output << "<?xml version=\"1.0\" standalone=\"no\"?>\n"
+         << "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" "
+            "\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"
+         << "<svg width=\"" << width << "mm\" height=\"" << height
+         << "mm\" viewBox=\"" << minx << " " << miny << " " << width << " "
+         << height
+         << "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n"
+         << "<title>OpenSCAD Model</title>\n";
 
   append_svg(geom, output);
 
   output << "</svg>\n";
-  setlocale(LC_NUMERIC, ""); // Set default locale
+  setlocale(LC_NUMERIC, "");  // Set default locale
 }
diff --git a/src/io/export_wrl.cc b/src/io/export_wrl.cc
index 2e747340c..fa3ebd480 100644
--- a/src/io/export_wrl.cc
+++ b/src/io/export_wrl.cc
@@ -25,16 +25,16 @@
 
 #include "io/export.h"
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <ostream>
 
 #include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
 
-void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_wrl(const std::shared_ptr<const Geometry>& geom,
+                std::ostream& output) {
   // FIXME: In lazy union mode, should we export multiple IndexedFaceSets?
   auto ps = PolySetUtils::getGeometryAsPolySet(geom);
   if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
diff --git a/src/io/fileutils.cc b/src/io/fileutils.cc
index 97fc25b03..3ca48fb50 100644
--- a/src/io/fileutils.cc
+++ b/src/io/fileutils.cc
@@ -15,18 +15,23 @@ namespace fs = std::filesystem;
    used to be backwards compatible with <= 2013.01 (see issue #217).
  */
 std::string lookup_file(const std::string& filename,
-                        const std::string& path, const std::string& fallbackpath)
-{
+                        const std::string& path,
+                        const std::string& fallbackpath) {
   std::string resultfile;
   if (!filename.empty() && !fs::path(filename).is_absolute()) {
     fs::path absfile;
-    if (!path.empty()) absfile = fs::absolute(fs::path(path) / filename);
+    if (!path.empty())
+      absfile = fs::absolute(fs::path(path) / filename);
     fs::path absfile_fallback;
-    if (!fallbackpath.empty()) absfile_fallback = fs::absolute(fs::path(fallbackpath) / filename);
+    if (!fallbackpath.empty())
+      absfile_fallback = fs::absolute(fs::path(fallbackpath) / filename);
 
     if (!fs::exists(absfile) && fs::exists(absfile_fallback)) {
       resultfile = absfile_fallback.string();
-      LOG(message_group::Deprecated, "Imported file (%1$s) found in document root instead of relative to the importing module. This behavior is deprecated", std::string(filename));
+      LOG(message_group::Deprecated,
+          "Imported file (%1$s) found in document root instead of relative to "
+          "the importing module. This behavior is deprecated",
+          std::string(filename));
     } else {
       resultfile = absfile.string();
     }
@@ -36,9 +41,9 @@ std::string lookup_file(const std::string& filename,
   return resultfile;
 }
 
-fs::path fs_uncomplete(fs::path const& p, fs::path const& base)
-{
-  if (p == fs::path{}) return p;
+fs::path fs_uncomplete(fs::path const& p, fs::path const& base) {
+  if (p == fs::path{})
+    return p;
 #ifndef __EMSCRIPTEN__
   return fs::relative(p, base == fs::path{} ? fs::path{"."} : base);
 #else
@@ -51,7 +56,8 @@ int64_t fs_timestamp(fs::path const& path) {
   if (fs::exists(path)) {
     const auto t = fs::last_write_time(path);
     const auto duration = t.time_since_epoch();
-    seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
+    seconds =
+        std::chrono::duration_cast<std::chrono::seconds>(duration).count();
   }
   return seconds;
 }
\ No newline at end of file
diff --git a/src/io/fileutils.h b/src/io/fileutils.h
index 1419fd69c..ea24b8eec 100644
--- a/src/io/fileutils.h
+++ b/src/io/fileutils.h
@@ -7,8 +7,8 @@
 namespace fs = std::filesystem;
 
 std::string lookup_file(const std::string& filename,
-                        const std::string& path, const std::string& fallbackpath);
-
+                        const std::string& path,
+                        const std::string& fallbackpath);
 
 fs::path fs_uncomplete(fs::path const& p, fs::path const& base);
 int64_t fs_timestamp(fs::path const& path);
\ No newline at end of file
diff --git a/src/io/imageutils-lodepng.cc b/src/io/imageutils-lodepng.cc
index 61803dce2..8d806e0ab 100644
--- a/src/io/imageutils-lodepng.cc
+++ b/src/io/imageutils-lodepng.cc
@@ -5,8 +5,10 @@
 
 #include "lodepng/lodepng.h"
 
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height)
-{
+bool write_png(std::ostream& output,
+               unsigned char* pixels,
+               int width,
+               int height) {
   std::vector<unsigned char> dataout;
   lodepng::State state;
   state.encoder.auto_convert = false;
@@ -14,8 +16,10 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
   state.info_png.color.colortype = LCT_RGB;
   state.info_png.color.bitdepth = 8;
   const auto err = lodepng::encode(dataout, pixels, width, height, state);
-  if (err) return false;
-  output.write(reinterpret_cast<const char *>(&dataout[0]), dataout.size());
-  if (output.bad() ) std::cerr << "Error writing to ostream\n";
+  if (err)
+    return false;
+  output.write(reinterpret_cast<const char*>(&dataout[0]), dataout.size());
+  if (output.bad())
+    std::cerr << "Error writing to ostream\n";
   return output.good();
 }
diff --git a/src/io/imageutils-macosx.cc b/src/io/imageutils-macosx.cc
index daaa78f19..43a11db28 100644
--- a/src/io/imageutils-macosx.cc
+++ b/src/io/imageutils-macosx.cc
@@ -1,21 +1,22 @@
 #include "io/imageutils.h"
 
-#include <iostream>
 #include <cassert>
 #include <cstddef>
+#include <iostream>
 
 #include <ApplicationServices/ApplicationServices.h>
 
 static CGDataConsumerCallbacks dc_callbacks;
 
-static size_t write_bytes_to_ostream(void *info, const void *buffer, size_t count)
-{
+static size_t write_bytes_to_ostream(void* info,
+                                     const void* buffer,
+                                     size_t count) {
   assert(info && buffer);
-  auto *output = (std::ostream *)info;
+  auto* output = (std::ostream*)info;
   const size_t startpos = output->tellp();
   size_t endpos = startpos;
   try {
-    output->write((const char *)buffer, count);
+    output->write((const char*)buffer, count);
     endpos = output->tellp();
   } catch (const std::ios_base::failure& e) {
     std::cerr << "Error writing to ostream:" << e.what() << "\n";
@@ -23,24 +24,28 @@ static size_t write_bytes_to_ostream(void *info, const void *buffer, size_t coun
   return (endpos - startpos);
 }
 
-static CGDataConsumerRef CGDataConsumerCreateWithOstream(std::ostream& output)
-{
+static CGDataConsumerRef CGDataConsumerCreateWithOstream(std::ostream& output) {
   dc_callbacks.putBytes = write_bytes_to_ostream;
-  dc_callbacks.releaseConsumer = nullptr; // ostream closed by caller of write_png
-  CGDataConsumerRef dc = CGDataConsumerCreate( (void *)(&output), &dc_callbacks);
+  dc_callbacks.releaseConsumer =
+      nullptr;  // ostream closed by caller of write_png
+  CGDataConsumerRef dc = CGDataConsumerCreate((void*)(&output), &dc_callbacks);
   return dc;
 }
 
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height)
-{
+bool write_png(std::ostream& output,
+               unsigned char* pixels,
+               int width,
+               int height) {
   const size_t rowBytes = static_cast<size_t>(width) * 4;
-//  CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
+  //  CGColorSpaceRef colorSpace =
+  //  CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
-  const CGBitmapInfo bitmapInfo = kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big; // BGRA
+  const CGBitmapInfo bitmapInfo =
+      kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big;  // BGRA
   const int bitsPerComponent = 8;
-  CGContextRef contextRef = CGBitmapContextCreate(pixels, width, height,
-                                                  bitsPerComponent, rowBytes,
-                                                  colorSpace, bitmapInfo);
+  CGContextRef contextRef =
+      CGBitmapContextCreate(pixels, width, height, bitsPerComponent, rowBytes,
+                            colorSpace, bitmapInfo);
   if (!contextRef) {
     std::cerr << "Unable to create CGContextRef.";
     CGColorSpaceRelease(colorSpace);
@@ -57,12 +62,11 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
 
   CGDataConsumerRef dataconsumer = CGDataConsumerCreateWithOstream(output);
   /*
-     CFStringRef fname = CFStringCreateWithCString(kCFAllocatorDefault, filename, kCFStringEncodingUTF8);
-     CFURLRef fileURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
-                                                   fname, kCFURLPOSIXPathStyle, false);
-     if (!fileURL) {
-     std::cerr << "Unable to create file URL ref.";
-     return false;
+     CFStringRef fname = CFStringCreateWithCString(kCFAllocatorDefault,
+     filename, kCFStringEncodingUTF8); CFURLRef fileURL =
+     CFURLCreateWithFileSystemPath(kCFAllocatorDefault, fname,
+     kCFURLPOSIXPathStyle, false); if (!fileURL) { std::cerr << "Unable to
+     create file URL ref."; return false;
      }
 
      CGDataConsumerRef dataconsumer = CGDataConsumerCreateWithURL(fileURL);
@@ -72,10 +76,8 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
   CFMutableDictionaryRef fileDict = nullptr;
   CFStringRef fileUTType = kUTTypePNG;
   // Create an image destination opaque reference for authoring an image file
-  CGImageDestinationRef imageDest = CGImageDestinationCreateWithDataConsumer(dataconsumer,
-                                                                             fileUTType,
-                                                                             fileImageIndex,
-                                                                             fileDict);
+  CGImageDestinationRef imageDest = CGImageDestinationCreateWithDataConsumer(
+      dataconsumer, fileUTType, fileImageIndex, fileDict);
   if (!imageDest) {
     std::cerr << "Unable to create CGImageDestinationRef.";
     CFRelease(dataconsumer);
@@ -86,18 +88,16 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
   }
 
   const CFIndex capacity = 1;
-  CFMutableDictionaryRef imageProps =
-    CFDictionaryCreateMutable(kCFAllocatorDefault,
-                              capacity,
-                              &kCFTypeDictionaryKeyCallBacks,
-                              &kCFTypeDictionaryValueCallBacks);
+  CFMutableDictionaryRef imageProps = CFDictionaryCreateMutable(
+      kCFAllocatorDefault, capacity, &kCFTypeDictionaryKeyCallBacks,
+      &kCFTypeDictionaryValueCallBacks);
   CGImageDestinationAddImage(imageDest, imageRef, imageProps);
   CGImageDestinationFinalize(imageDest);
 
   CFRelease(imageDest);
   CFRelease(dataconsumer);
-  //CFRelease(fileURL);
-  //CFRelease(fname);
+  // CFRelease(fileURL);
+  // CFRelease(fname);
   CFRelease(imageProps);
   CGImageRelease(imageRef);
   CFRelease(contextRef);
diff --git a/src/io/imageutils.cc b/src/io/imageutils.cc
index abcd320b0..e040e07bf 100644
--- a/src/io/imageutils.cc
+++ b/src/io/imageutils.cc
@@ -1,12 +1,15 @@
 #include "io/imageutils.h"
 
-#include <iostream>
 #include <cassert>
 #include <cstring>
 #include <fstream>
+#include <iostream>
 
-void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize, size_t width, size_t height)
-{
+void flip_image(const unsigned char* src,
+                unsigned char* dst,
+                size_t pixelsize,
+                size_t width,
+                size_t height) {
   assert(src && dst);
   auto rowBytes = pixelsize * width;
   for (auto i = 0ul; i < height; ++i) {
@@ -14,8 +17,10 @@ void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize,
   }
 }
 
-bool write_png(const char *filename, unsigned char *pixels, int width, int height)
-{
+bool write_png(const char* filename,
+               unsigned char* pixels,
+               int width,
+               int height) {
   assert(filename && pixels);
   std::ofstream fstream(filename, std::ios::binary);
   if (fstream.is_open()) {
diff --git a/src/io/imageutils.h b/src/io/imageutils.h
index b799e6441..e1b8389cc 100644
--- a/src/io/imageutils.h
+++ b/src/io/imageutils.h
@@ -3,6 +3,16 @@
 #include <cstdlib>
 #include <iostream>
 
-bool write_png(const char *filename, unsigned char *pixels, int width, int height);
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height);
-void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize, size_t width, size_t height);
+bool write_png(const char* filename,
+               unsigned char* pixels,
+               int width,
+               int height);
+bool write_png(std::ostream& output,
+               unsigned char* pixels,
+               int width,
+               int height);
+void flip_image(const unsigned char* src,
+                unsigned char* dst,
+                size_t pixelsize,
+                size_t width,
+                size_t height);
diff --git a/src/io/import.h b/src/io/import.h
index 6e7f823bb..059d14327 100644
--- a/src/io/import.h
+++ b/src/io/import.h
@@ -7,19 +7,33 @@
 
 #include "core/AST.h"
 
-std::unique_ptr<class PolySet> import_stl(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_obj(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_off(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_amf(const std::string&, const Location& loc);
-std::unique_ptr<class PolySet> import_3mf(const std::string&, const Location& loc);
+std::unique_ptr<class PolySet> import_stl(const std::string& filename,
+                                          const Location& loc);
+std::unique_ptr<class PolySet> import_obj(const std::string& filename,
+                                          const Location& loc);
+std::unique_ptr<class PolySet> import_off(const std::string& filename,
+                                          const Location& loc);
+std::unique_ptr<class PolySet> import_amf(const std::string&,
+                                          const Location& loc);
+std::unique_ptr<class PolySet> import_3mf(const std::string&,
+                                          const Location& loc);
 
-std::unique_ptr<class Polygon2d> import_svg(double fn, double fs, double fa,
-                                            const std::string& filename,
-                                            const boost::optional<std::string>& id, const boost::optional<std::string>& layer,
-                                            const double dpi, const bool center, const Location& loc);
+std::unique_ptr<class Polygon2d> import_svg(
+    double fn,
+    double fs,
+    double fa,
+    const std::string& filename,
+    const boost::optional<std::string>& id,
+    const boost::optional<std::string>& layer,
+    const double dpi,
+    const bool center,
+    const Location& loc);
 
 #ifdef ENABLE_CGAL
-std::unique_ptr<class CGALNefGeometry> import_nef3(const std::string& filename, const Location& loc);
+std::unique_ptr<class CGALNefGeometry> import_nef3(const std::string& filename,
+                                                   const Location& loc);
 #endif
 
-class Value import_json(const std::string& filename, class EvaluationSession *session, const Location& loc);
+class Value import_json(const std::string& filename,
+                        class EvaluationSession* session,
+                        const Location& loc);
diff --git a/src/io/import_3mf_dummy.cc b/src/io/import_3mf_dummy.cc
index fba8fc1fc..7b5e8cf50 100644
--- a/src/io/import_3mf_dummy.cc
+++ b/src/io/import_3mf_dummy.cc
@@ -26,18 +26,21 @@
 
 #include <memory>
 #include <string>
-#include "io/import.h"
 #include "core/AST.h"
-#include "utils/printutils.h"
 #include "geometry/PolySet.h"
+#include "io/import.h"
 #include "io/lib3mf_utils.h"
+#include "utils/printutils.h"
 
 std::string get_lib3mf_version() {
   return "(not enabled)";
 }
 
-std::unique_ptr<class PolySet> import_3mf(const std::string&, const Location& loc)
-{
-  LOG(message_group::Warning, "Import from 3MF format was not enabled when building the application, import() at line %1$d", loc.firstLine());
+std::unique_ptr<class PolySet> import_3mf(const std::string&,
+                                          const Location& loc) {
+  LOG(message_group::Warning,
+      "Import from 3MF format was not enabled when building the application, "
+      "import() at line %1$d",
+      loc.firstLine());
   return PolySet::createEmpty();
 }
diff --git a/src/io/import_3mf_v1.cc b/src/io/import_3mf_v1.cc
index 9fe76d045..e5e0241d9 100644
--- a/src/io/import_3mf_v1.cc
+++ b/src/io/import_3mf_v1.cc
@@ -25,26 +25,26 @@
  */
 #include "io/import.h"
 
+#include <algorithm>
 #include <cstddef>
-#include <functional>
 #include <cstdint>
+#include <functional>
+#include <iomanip>
 #include <memory>
 #include <string>
-#include <iomanip>
-#include <algorithm>
 
 #include <Model/COM/NMR_DLLInterfaces.h>
 
+#include "core/AST.h"
+#include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
-#include "geometry/Geometry.h"
 #include "geometry/linalg.h"
-#include "utils/printutils.h"
-#include "utils/version_helper.h"
-#include "core/AST.h"
 #include "glview/RenderSettings.h"
 #include "io/lib3mf_utils.h"
+#include "utils/printutils.h"
+#include "utils/version_helper.h"
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
@@ -60,21 +60,21 @@ std::string get_lib3mf_version() {
   DWORD major, minor, micro;
   NMR::lib3mf_getinterfaceversion(&major, &minor, &micro);
 
-  const OpenSCAD::library_version_number header_version{NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO};
+  const OpenSCAD::library_version_number header_version{
+      NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR,
+      NMR_APIVERSION_INTERFACE_MICRO};
   const OpenSCAD::library_version_number runtime_version{major, minor, micro};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
 namespace {
 
-struct MeshObject
-{
-  PLib3MFModelObjectResource *obj;
+struct MeshObject {
+  PLib3MFModelObjectResource* obj;
   Matrix4d transform;
 };
 
-struct ModelMetadata
-{
+struct ModelMetadata {
   std::string title;
   std::string designer;
   std::string description;
@@ -90,44 +90,51 @@ using MeshObjectList = std::list<std::unique_ptr<MeshObject>>;
 
 // lib3mf_propertyhandler_getcolor states:
 // (#00000000) means no property or a different kind of property!
-Color4f get_color(const MODELMESHCOLOR_SRGB& color)
-{
-  if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 && color.m_Alpha == 0) {
-    return {}; // invalid color
+Color4f get_color(const MODELMESHCOLOR_SRGB& color) {
+  if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 &&
+      color.m_Alpha == 0) {
+    return {};  // invalid color
   }
   Color4f c{color.m_Red, color.m_Green, color.m_Blue, color.m_Alpha};
   return c;
 }
 
-Color4f get_color(const MODELMESH_TRIANGLECOLOR_SRGB& color, int idx)
-{
+Color4f get_color(const MODELMESH_TRIANGLECOLOR_SRGB& color, int idx) {
   return get_color(color.m_Colors[idx]);
 }
 
-Matrix4d get_matrix(MODELTRANSFORM& transform)
-{
+Matrix4d get_matrix(MODELTRANSFORM& transform) {
   Matrix4d tm;
-  tm << transform.m_fFields[0][0], transform.m_fFields[0][1], transform.m_fFields[0][2], transform.m_fFields[0][3],
-    transform.m_fFields[1][0], transform.m_fFields[1][1], transform.m_fFields[1][2], transform.m_fFields[1][3],
-    transform.m_fFields[2][0], transform.m_fFields[2][1], transform.m_fFields[2][2], transform.m_fFields[2][3],
-    0,                         0,                         0,                         1;
+  tm << transform.m_fFields[0][0], transform.m_fFields[0][1],
+      transform.m_fFields[0][2], transform.m_fFields[0][3],
+      transform.m_fFields[1][0], transform.m_fFields[1][1],
+      transform.m_fFields[1][2], transform.m_fFields[1][3],
+      transform.m_fFields[2][0], transform.m_fFields[2][1],
+      transform.m_fFields[2][2], transform.m_fFields[2][3], 0, 0, 0, 1;
   return tm;
 }
 
-std::string get_object_type_name(DWORD objecttype)
-{
+std::string get_object_type_name(DWORD objecttype) {
   switch (objecttype) {
-  case MODELOBJECTTYPE_OTHER: return "Other";
-  case MODELOBJECTTYPE_MODEL: return "Model";
-  case MODELOBJECTTYPE_SUPPORT: return "Support";
-  case MODELOBJECTTYPE_SOLIDSUPPORT: return "Solid Support";
-  case MODELOBJECTTYPE_SURFACE: return "Surface";
-  default: return "<Unknown>";
+    case MODELOBJECTTYPE_OTHER:
+      return "Other";
+    case MODELOBJECTTYPE_MODEL:
+      return "Model";
+    case MODELOBJECTTYPE_SUPPORT:
+      return "Support";
+    case MODELOBJECTTYPE_SOLIDSUPPORT:
+      return "Solid Support";
+    case MODELOBJECTTYPE_SURFACE:
+      return "Surface";
+    default:
+      return "<Unknown>";
   }
 }
 
-std::unique_ptr<PolySet> import_3mf_error(PLib3MFModel *model = nullptr, const std::string& errmsg = "", PLib3MFModelBuildItemIterator *it = nullptr)
-{
+std::unique_ptr<PolySet> import_3mf_error(
+    PLib3MFModel* model = nullptr,
+    const std::string& errmsg = "",
+    PLib3MFModelBuildItemIterator* it = nullptr) {
   if (!errmsg.empty()) {
     LOG(message_group::Error, "%1$s", errmsg);
   }
@@ -142,32 +149,44 @@ std::unique_ptr<PolySet> import_3mf_error(PLib3MFModel *model = nullptr, const s
   return PolySet::createEmpty();
 }
 
-std::string collect_mesh_objects(MeshObjectList& object_list, PLib3MFModelObjectResource *object, const Matrix4d& m, const Location& loc, int level = 1)
-{
+std::string collect_mesh_objects(MeshObjectList& object_list,
+                                 PLib3MFModelObjectResource* object,
+                                 const Matrix4d& m,
+                                 const Location& loc,
+                                 int level = 1) {
   BOOL is_mesh_object = false;
   if (lib3mf_object_ismeshobject(object, &is_mesh_object) != LIB3MF_OK) {
     return "Could not check for mesh object type";
   }
   BOOL is_components_object = false;
-  if (lib3mf_object_iscomponentsobject(object, &is_components_object) != LIB3MF_OK) {
+  if (lib3mf_object_iscomponentsobject(object, &is_components_object) !=
+      LIB3MF_OK) {
     return "Could not check for component object type";
   }
   DWORD objecttype;
   if (lib3mf_object_gettype(object, &objecttype) != LIB3MF_OK) {
     return "Could not read object type";
   }
-  char number[4096] = {0, };
+  char number[4096] = {
+      0,
+  };
   ULONG numberlen;
-  if (lib3mf_object_getpartnumberutf8(object, &number[0], sizeof(number), &numberlen) != LIB3MF_OK) {
+  if (lib3mf_object_getpartnumberutf8(object, &number[0], sizeof(number),
+                                      &numberlen) != LIB3MF_OK) {
     return "Could not read part number of object";
   }
-  char name[4096] = {0, };
+  char name[4096] = {
+      0,
+  };
   ULONG namelen;
-  if (lib3mf_object_getnameutf8(object, &name[0], sizeof(name), &namelen) != LIB3MF_OK) {
+  if (lib3mf_object_getnameutf8(object, &name[0], sizeof(name), &namelen) !=
+      LIB3MF_OK) {
     return "Could not read name of object";
   }
   BOOL hasuuid = false;
-  char uuid[40] = {0, };
+  char uuid[40] = {
+      0,
+  };
   if (lib3mf_object_getuuidutf8(object, &hasuuid, &uuid[0]) != LIB3MF_OK) {
     return "Could not read UUID of object";
   }
@@ -177,42 +196,59 @@ std::string collect_mesh_objects(MeshObjectList& object_list, PLib3MFModelObject
     return "Could not check object validity";
   }
   if (!is_valid_object) {
-    LOG(message_group::Warning, "Object '%1$s' with UUID '%2$s' is not valid, import() at line %3$d", name, uuid, loc.firstLine());
+    LOG(message_group::Warning,
+        "Object '%1$s' with UUID '%2$s' is not valid, import() at line %3$d",
+        name, uuid, loc.firstLine());
   }
 
   if (is_mesh_object) {
-    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % get_object_type_name(objecttype) % number % name % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)",
+            boost::io::group(std::setw(2 * level), "") %
+                get_object_type_name(objecttype) % number % name %
+                (hasuuid ? uuid : "<no uuid>"));
     object_list.push_back(std::make_unique<MeshObject>(MeshObject{object, m}));
     return "";
   }
   if (is_components_object) {
     DWORD componentcount;
-    if (lib3mf_componentsobject_getcomponentcount(object, &componentcount) != LIB3MF_OK) {
+    if (lib3mf_componentsobject_getcomponentcount(object, &componentcount) !=
+        LIB3MF_OK) {
       return "Could not get object component count";
     }
-    PRINTDB("%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % componentcount % get_object_type_name(objecttype) % number % name % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB(
+        "%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)",
+        boost::io::group(std::setw(2 * level), "") % componentcount %
+            get_object_type_name(objecttype) % number % name %
+            (hasuuid ? uuid : "<no uuid>"));
     for (DWORD idx = 0; idx < componentcount; ++idx) {
-      PLib3MFModelComponent *component = nullptr;
-      if (lib3mf_componentsobject_getcomponent(object, idx, &component) != LIB3MF_OK) {
+      PLib3MFModelComponent* component = nullptr;
+      if (lib3mf_componentsobject_getcomponent(object, idx, &component) !=
+          LIB3MF_OK) {
         return "Could not get object component";
       }
       BOOL has_transform = false;
-      if (lib3mf_component_hastransform(component, &has_transform) != LIB3MF_OK) {
+      if (lib3mf_component_hastransform(component, &has_transform) !=
+          LIB3MF_OK) {
         return "Could not check for component transform";
       }
-      MODELTRANSFORM transform{ .m_fFields = {{ 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 } } };
-      if (has_transform && lib3mf_component_gettransform(component, &transform) != LIB3MF_OK) {
+      MODELTRANSFORM transform{
+          .m_fFields = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}}};
+      if (has_transform &&
+          lib3mf_component_gettransform(component, &transform) != LIB3MF_OK) {
         return "Could not read transform of component";
       }
-      PLib3MFModelObjectResource *componentobject = nullptr;
-      if (lib3mf_component_getobjectresource(component, &componentobject) != LIB3MF_OK) {
+      PLib3MFModelObjectResource* componentobject = nullptr;
+      if (lib3mf_component_getobjectresource(component, &componentobject) !=
+          LIB3MF_OK) {
         return "Could not read object resource of component";
       }
       const Matrix4d cm = get_matrix(transform);
       if (has_transform) {
-        PRINTDB("%scomponent transform matrix\n%s", boost::io::group(std::setw(2 * level), "") % cm);
+        PRINTDB("%scomponent transform matrix\n%s",
+                boost::io::group(std::setw(2 * level), "") % cm);
       }
-      auto errmsg = collect_mesh_objects(object_list, componentobject, cm * m, loc, level + 1);
+      auto errmsg = collect_mesh_objects(object_list, componentobject, cm * m,
+                                         loc, level + 1);
       if (!errmsg.empty()) {
         return errmsg;
       }
@@ -222,25 +258,31 @@ std::string collect_mesh_objects(MeshObjectList& object_list, PLib3MFModelObject
   return "Unhandled object type, expected one of: mesh, component";
 }
 
-Color4f get_triangle_color_from_basematerial(PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx)
-{
+Color4f get_triangle_color_from_basematerial(
+    PLib3MFModel* model,
+    PLib3MFPropertyHandler* propertyhandler,
+    int idx) {
   DWORD materialIndex = 0;
   DWORD materialGroupID = 0;
 
-  if (lib3mf_propertyhandler_getbasematerial(propertyhandler, idx, &materialGroupID, &materialIndex) != LIB3MF_OK) {
+  if (lib3mf_propertyhandler_getbasematerial(propertyhandler, idx,
+                                             &materialGroupID,
+                                             &materialIndex) != LIB3MF_OK) {
     return {};
   }
   if (materialGroupID == 0) {
     return {};
   }
 
-  PLib3MFModelBaseMaterial *basematerial;
-  if (lib3mf_model_getbasematerialbyid(model, materialGroupID, &basematerial) != LIB3MF_OK) {
+  PLib3MFModelBaseMaterial* basematerial;
+  if (lib3mf_model_getbasematerialbyid(model, materialGroupID, &basematerial) !=
+      LIB3MF_OK) {
     return {};
   }
 
   BYTE r = 0, g = 0, b = 0, a = 0;
-  if (lib3mf_basematerial_getdisplaycolor(basematerial, materialIndex, &r, &g, &b, &a) != LIB3MF_OK) {
+  if (lib3mf_basematerial_getdisplaycolor(basematerial, materialIndex, &r, &g,
+                                          &b, &a) != LIB3MF_OK) {
     return {};
   }
 
@@ -248,31 +290,27 @@ Color4f get_triangle_color_from_basematerial(PLib3MFModel *model, PLib3MFPropert
   return col;
 }
 
-Color4f get_triangle_color(PLib3MFPropertyHandler *propertyhandler, int idx)
-{
-  MODELMESH_TRIANGLECOLOR_SRGB color = { .m_Colors = {
-                                           { 0, 0, 0 },
-                                           { 0, 0, 0 },
-                                           { 0, 0, 0 }
-                                         } };
-  if (lib3mf_propertyhandler_getcolor(propertyhandler, idx, &color) == LIB3MF_OK) {
+Color4f get_triangle_color(PLib3MFPropertyHandler* propertyhandler, int idx) {
+  MODELMESH_TRIANGLECOLOR_SRGB color = {
+      .m_Colors = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}};
+  if (lib3mf_propertyhandler_getcolor(propertyhandler, idx, &color) ==
+      LIB3MF_OK) {
     const Color4f col0 = get_color(color, 0);
     const Color4f col1 = get_color(color, 1);
     const Color4f col2 = get_color(color, 2);
     if (col0.isValid() && col1.isValid() && col2.isValid()) {
-      return {
-        std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)
-      };
+      return {std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
+              std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
+              std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
+              std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)};
     }
   }
   return {};
 }
 
-Color4f get_triangle_color(PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx)
-{
+Color4f get_triangle_color(PLib3MFModel* model,
+                           PLib3MFPropertyHandler* propertyhandler,
+                           int idx) {
   eModelPropertyType propertytype = MODELPROPERTYTYPE_NONE;
   lib3mf_propertyhandler_getpropertytype(propertyhandler, idx, &propertytype);
   if (propertytype == MODELPROPERTYTYPE_BASEMATERIALS) {
@@ -284,24 +322,31 @@ Color4f get_triangle_color(PLib3MFModel *model, PLib3MFPropertyHandler *property
   return {};
 }
 
-std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx, PLib3MFModel *model, std::unique_ptr<MeshObject>& mo, std::unique_ptr<PolySet>& ps)
-{
+std::string import_3mf_mesh(const std::string& filename,
+                            unsigned int mesh_idx,
+                            PLib3MFModel* model,
+                            std::unique_ptr<MeshObject>& mo,
+                            std::unique_ptr<PolySet>& ps) {
   DWORD vertex_count = 0;
   if (lib3mf_meshobject_getvertexcount(mo->obj, &vertex_count) != LIB3MF_OK) {
     return "Could not read vertex count";
   }
   DWORD triangle_count = 0;
-  if (lib3mf_meshobject_gettrianglecount(mo->obj, &triangle_count) != LIB3MF_OK) {
+  if (lib3mf_meshobject_gettrianglecount(mo->obj, &triangle_count) !=
+      LIB3MF_OK) {
     return "Could not read triangle count";
   }
   DWORD object_type = 0;
   if (lib3mf_object_gettype(mo->obj, &object_type) != LIB3MF_OK) {
     return "Could not read object type";
   }
-  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu", filename.c_str() % mesh_idx % get_object_type_name(object_type) % vertex_count % triangle_count);
+  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu",
+          filename.c_str() % mesh_idx % get_object_type_name(object_type) %
+              vertex_count % triangle_count);
 
-  PLib3MFPropertyHandler *propertyhandler = nullptr;
-  if (lib3mf_meshobject_createpropertyhandler(mo->obj, &propertyhandler) != LIB3MF_OK) {
+  PLib3MFPropertyHandler* propertyhandler = nullptr;
+  if (lib3mf_meshobject_createpropertyhandler(mo->obj, &propertyhandler) !=
+      LIB3MF_OK) {
     return "Could not create property handler";
   }
 
@@ -314,7 +359,9 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
     if (lib3mf_meshobject_getvertex(mo->obj, idx, &vertex) != LIB3MF_OK) {
       return "Could not read vertex from object";
     }
-    const Vector4d v = mo->transform * Vector4d(vertex.m_fPosition[0], vertex.m_fPosition[1], vertex.m_fPosition[2], 1);
+    const Vector4d v =
+        mo->transform * Vector4d(vertex.m_fPosition[0], vertex.m_fPosition[1],
+                                 vertex.m_fPosition[2], 1);
     ps->vertices.push_back(v.head(3));
   }
 
@@ -354,8 +401,7 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
   return "";
 }
 
-std::string read_metadata(PLib3MFModel *model)
-{
+std::string read_metadata(PLib3MFModel* model) {
   DWORD metadatacount;
   if (lib3mf_model_getmetadatacount(model, &metadatacount) != LIB3MF_OK) {
     return "Could not retrieve metadata";
@@ -363,14 +409,20 @@ std::string read_metadata(PLib3MFModel *model)
 
   ModelMetadata mmd;
   for (DWORD idx = 0; idx < metadatacount; ++idx) {
-    char key[4096] = { 0, };
+    char key[4096] = {
+        0,
+    };
     ULONG keylen = 0;
-    if (lib3mf_model_getmetadatakeyutf8(model, idx, &key[0], sizeof(key), &keylen) != LIB3MF_OK) {
+    if (lib3mf_model_getmetadatakeyutf8(model, idx, &key[0], sizeof(key),
+                                        &keylen) != LIB3MF_OK) {
       return "Could not retrieve metadata key";
     }
-    char value[4096] = { 0, };
+    char value[4096] = {
+        0,
+    };
     ULONG valuelen = 0;
-    if (lib3mf_model_getmetadatavalueutf8(model, idx, &value[0], sizeof(value), &valuelen) != LIB3MF_OK) {
+    if (lib3mf_model_getmetadatavalueutf8(model, idx, &value[0], sizeof(value),
+                                          &valuelen) != LIB3MF_OK) {
       return "Could not retrieve metadata value";
     }
     PRINTDB("METADATA[%d]: %s = '%s'", idx % key % value);
@@ -404,32 +456,36 @@ std::string read_metadata(PLib3MFModel *model)
   return "";
 }
 
-} // namespace
+}  // namespace
 
-std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<PolySet> import_3mf(const std::string& filename,
+                                    const Location& loc) {
   DWORD interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-  HRESULT result = lib3mf_getinterfaceversion(&interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
+  HRESULT result = lib3mf_getinterfaceversion(
+      &interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
   if (result != LIB3MF_OK) {
     LOG(message_group::Error, "Error reading 3MF library version");
     return PolySet::createEmpty();
   }
 
   if ((interfaceVersionMajor != NMR_APIVERSION_INTERFACE_MAJOR)) {
-    LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+    LOG(message_group::Error,
+        "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+        "%4$d.%5$d.%6$d",
         interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
-        NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO);
+        NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR,
+        NMR_APIVERSION_INTERFACE_MICRO);
     return PolySet::createEmpty();
   }
 
-  PLib3MFModel *model;
+  PLib3MFModel* model;
   result = lib3mf_createmodel(&model);
   if (result != LIB3MF_OK) {
     LOG(message_group::Error, "Could not create model: %1$08lx", result);
     return import_3mf_error();
   }
 
-  PLib3MFModelReader *reader;
+  PLib3MFModelReader* reader;
   result = lib3mf_model_queryreader(model, "3mf", &reader);
   if (result != LIB3MF_OK) {
     LOG(message_group::Error, "Could not create 3MF reader: %1$08lx", result);
@@ -439,13 +495,15 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
   result = lib3mf_reader_readfromfileutf8(reader, filename.c_str());
   lib3mf_release(reader);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Warning, "Could not read file '%1$s', import() at line %2$d", filename.c_str(), loc.firstLine());
+    LOG(message_group::Warning,
+        "Could not read file '%1$s', import() at line %2$d", filename.c_str(),
+        loc.firstLine());
     return import_3mf_error(model);
   }
 
   read_metadata(model);
 
-  PLib3MFModelBuildItemIterator *builditem_it = nullptr;
+  PLib3MFModelBuildItemIterator* builditem_it = nullptr;
   if (lib3mf_model_getbuilditems(model, &builditem_it) != LIB3MF_OK) {
     return import_3mf_error(model, "Could not retrieve build items");
   }
@@ -453,47 +511,67 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
   std::list<std::unique_ptr<PolySet>> meshes;
   while (true) {
     BOOL has_next = false;
-    if (lib3mf_builditemiterator_movenext(builditem_it, &has_next) != LIB3MF_OK) {
-      return import_3mf_error(model, "Error iterating over build items", builditem_it);
+    if (lib3mf_builditemiterator_movenext(builditem_it, &has_next) !=
+        LIB3MF_OK) {
+      return import_3mf_error(model, "Error iterating over build items",
+                              builditem_it);
     }
     if (!has_next) {
       break;
     }
 
-    PLib3MFModelBuildItem *builditem = nullptr;
-    if (lib3mf_builditemiterator_getcurrent(builditem_it, &builditem) != LIB3MF_OK) {
+    PLib3MFModelBuildItem* builditem = nullptr;
+    if (lib3mf_builditemiterator_getcurrent(builditem_it, &builditem) !=
+        LIB3MF_OK) {
       return import_3mf_error(model, "Could not read build item", builditem_it);
     }
     DWORD builditemhandle;
     if (lib3mf_builditem_gethandle(builditem, &builditemhandle) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get handle of build item", builditem_it);
+      return import_3mf_error(model, "Could not get handle of build item",
+                              builditem_it);
     }
-    char partnumber[4096] = {0, };
+    char partnumber[4096] = {
+        0,
+    };
     ULONG partnumberlen = 0;
-    if (lib3mf_builditem_getpartnumberutf8(builditem, &partnumber[0], sizeof(partnumber), &partnumberlen) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get part number of build item", builditem_it);
+    if (lib3mf_builditem_getpartnumberutf8(builditem, &partnumber[0],
+                                           sizeof(partnumber),
+                                           &partnumberlen) != LIB3MF_OK) {
+      return import_3mf_error(model, "Could not get part number of build item",
+                              builditem_it);
     }
     BOOL hasuuid = false;
-    char uuid[40] = {0, };
-    if (lib3mf_builditem_getuuidutf8(builditem, &hasuuid, &uuid[0]) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get uuid of build item", builditem_it);
+    char uuid[40] = {
+        0,
+    };
+    if (lib3mf_builditem_getuuidutf8(builditem, &hasuuid, &uuid[0]) !=
+        LIB3MF_OK) {
+      return import_3mf_error(model, "Could not get uuid of build item",
+                              builditem_it);
     }
-    PLib3MFModelObjectResource *object = nullptr;
+    PLib3MFModelObjectResource* object = nullptr;
     if (lib3mf_builditem_getobjectresource(builditem, &object) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not read object resource of build item", builditem_it);
+      return import_3mf_error(
+          model, "Could not read object resource of build item", builditem_it);
     }
 
     BOOL has_transform = false;
-    if (lib3mf_builditem_hasobjecttransform(builditem, &has_transform) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not check for build item transform", builditem_it);
+    if (lib3mf_builditem_hasobjecttransform(builditem, &has_transform) !=
+        LIB3MF_OK) {
+      return import_3mf_error(model, "Could not check for build item transform",
+                              builditem_it);
     }
-    MODELTRANSFORM transform{ .m_fFields = {{ 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 } } };
-    if (has_transform && lib3mf_builditem_getobjecttransform(builditem, &transform) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not read build item transform", builditem_it);
+    MODELTRANSFORM transform{
+        .m_fFields = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}}};
+    if (has_transform && lib3mf_builditem_getobjecttransform(
+                             builditem, &transform) != LIB3MF_OK) {
+      return import_3mf_error(model, "Could not read build item transform",
+                              builditem_it);
     }
     const Matrix4d m = get_matrix(transform);
 
-    PRINTDB("build item %d, part number = '%s' (%s)", builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB("build item %d, part number = '%s' (%s)",
+            builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
     if (has_transform) {
       PRINTDB("build item transform matrix\n%s", m);
     }
@@ -501,12 +579,14 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
     MeshObjectList object_list;
     std::string errmsg = collect_mesh_objects(object_list, object, m, loc);
     if (!errmsg.empty()) {
-      return import_3mf_error(model, "Error collecting meshes: " + errmsg, builditem_it);
+      return import_3mf_error(model, "Error collecting meshes: " + errmsg,
+                              builditem_it);
     }
 
     for (auto& mo : object_list) {
       auto ps = PolySet::createEmpty();
-      std::string errmsg = import_3mf_mesh(filename, meshes.size(), model, mo, ps);
+      std::string errmsg =
+          import_3mf_mesh(filename, meshes.size(), model, mo, ps);
       if (errmsg.empty()) {
         if (ps->isEmpty()) {
           continue;
@@ -530,28 +610,33 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
     std::unique_ptr<PolySet> p;
     Geometry::Geometries children;
     while (!meshes.empty()) {
-      children.emplace_back(std::shared_ptr<AbstractNode>(), std::shared_ptr<const Geometry>(std::move(meshes.front())));
+      children.emplace_back(
+          std::shared_ptr<AbstractNode>(),
+          std::shared_ptr<const Geometry>(std::move(meshes.front())));
       meshes.pop_front();
     }
 #ifdef ENABLE_MANIFOLD
     if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      if (auto ps = PolySetUtils::getGeometryAsPolySet(ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::UNION))) {
+      if (auto ps = PolySetUtils::getGeometryAsPolySet(
+              ManifoldUtils::applyOperator3DManifold(
+                  children, OpenSCADOperator::UNION))) {
         p = std::make_unique<PolySet>(*ps);
       } else {
         p = PolySet::createEmpty();
       }
     } else
-#endif // ifdef ENABLE_MANIFOLD
+#endif  // ifdef ENABLE_MANIFOLD
     {
 #ifdef ENABLE_CGAL
-      if (auto ps = PolySetUtils::getGeometryAsPolySet(CGALUtils::applyUnion3D(children.begin(), children.end()))) {
+      if (auto ps = PolySetUtils::getGeometryAsPolySet(
+              CGALUtils::applyUnion3D(children.begin(), children.end()))) {
         p = std::make_unique<PolySet>(*ps);
       } else {
         p = PolySet::createEmpty();
       }
 #else
       p = PolySet::createEmpty();
-#endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
     }
     return p;
   }
diff --git a/src/io/import_3mf_v2.cc b/src/io/import_3mf_v2.cc
index 6b62538a8..9e26168b9 100644
--- a/src/io/import_3mf_v2.cc
+++ b/src/io/import_3mf_v2.cc
@@ -37,25 +37,23 @@
 
 #include "core/AST.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
 #include "glview/RenderSettings.h"
+#include "io/lib3mf_utils.h"
 #include "utils/printutils.h"
 #include "utils/version_helper.h"
-#include "io/lib3mf_utils.h"
 
 namespace {
 
-struct MeshObject
-{
+struct MeshObject {
   const Lib3MF::PMeshObject obj;
   const Matrix4d transform;
 };
 
-struct ModelMetadata
-{
+struct ModelMetadata {
   std::string title;
   std::string designer;
   std::string description;
@@ -69,29 +67,38 @@ struct ModelMetadata
 
 using MeshObjectList = std::list<std::unique_ptr<MeshObject>>;
 
-std::string get_object_type_name(const Lib3MF::eObjectType objecttype)
-{
+std::string get_object_type_name(const Lib3MF::eObjectType objecttype) {
   switch (objecttype) {
-  case Lib3MF::eObjectType::Other: return "Other";
-  case Lib3MF::eObjectType::Model: return "Model";
-  case Lib3MF::eObjectType::Support: return "Support";
-  case Lib3MF::eObjectType::SolidSupport: return "Solid Support";
-  default: return "<Unknown>";
+    case Lib3MF::eObjectType::Other:
+      return "Other";
+    case Lib3MF::eObjectType::Model:
+      return "Model";
+    case Lib3MF::eObjectType::Support:
+      return "Support";
+    case Lib3MF::eObjectType::SolidSupport:
+      return "Solid Support";
+    default:
+      return "<Unknown>";
   }
 }
 
-Matrix4d get_matrix(Lib3MF::sTransform& transform)
-{
+Matrix4d get_matrix(Lib3MF::sTransform& transform) {
   Matrix4d tm;
-  tm << transform.m_Fields[0][0], transform.m_Fields[1][0], transform.m_Fields[2][0], transform.m_Fields[3][0],
-    transform.m_Fields[0][1], transform.m_Fields[1][1], transform.m_Fields[2][1], transform.m_Fields[3][1],
-    transform.m_Fields[0][2], transform.m_Fields[1][2], transform.m_Fields[2][2], transform.m_Fields[3][2],
-    0,                        0,                        0,                        1;
+  tm << transform.m_Fields[0][0], transform.m_Fields[1][0],
+      transform.m_Fields[2][0], transform.m_Fields[3][0],
+      transform.m_Fields[0][1], transform.m_Fields[1][1],
+      transform.m_Fields[2][1], transform.m_Fields[3][1],
+      transform.m_Fields[0][2], transform.m_Fields[1][2],
+      transform.m_Fields[2][2], transform.m_Fields[3][2], 0, 0, 0, 1;
   return tm;
 }
 
-std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& object_list, const Lib3MF::PObject& object, const Matrix4d& m, const Location& loc, int level = 1)
-{
+std::string collect_mesh_objects(const Lib3MF::PModel& model,
+                                 MeshObjectList& object_list,
+                                 const Lib3MF::PObject& object,
+                                 const Matrix4d& m,
+                                 const Location& loc,
+                                 int level = 1) {
   const bool is_mesh_object = object->IsMeshObject();
   const bool is_components_object = object->IsComponentsObject();
   const auto objecttype = object->GetType();
@@ -111,29 +118,42 @@ std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& ob
 #endif
 
   if (is_mesh_object) {
-    const auto meshobject = model->GetMeshObjectByID(object->GetUniqueResourceID());
-    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % get_object_type_name(objecttype) % partnumber % name % (hasuuid ? uuid : "<no uuid>"));
-    object_list.push_back(std::make_unique<MeshObject>(MeshObject{meshobject, m}));
+    const auto meshobject =
+        model->GetMeshObjectByID(object->GetUniqueResourceID());
+    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)",
+            boost::io::group(std::setw(2 * level), "") %
+                get_object_type_name(objecttype) % partnumber % name %
+                (hasuuid ? uuid : "<no uuid>"));
+    object_list.push_back(
+        std::make_unique<MeshObject>(MeshObject{meshobject, m}));
     return "";
   }
   if (is_components_object) {
-    const auto componentsobject = model->GetComponentsObjectByID(object->GetUniqueResourceID());
+    const auto componentsobject =
+        model->GetComponentsObjectByID(object->GetUniqueResourceID());
     const int componentcount = componentsobject->GetComponentCount();
-    PRINTDB("%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % componentcount % get_object_type_name(objecttype) % partnumber % name % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB(
+        "%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)",
+        boost::io::group(std::setw(2 * level), "") % componentcount %
+            get_object_type_name(objecttype) % partnumber % name %
+            (hasuuid ? uuid : "<no uuid>"));
 
     for (int idx = 0; idx < componentcount; ++idx) {
       const auto component = componentsobject->GetComponent(idx);
       const bool has_transform = component->HasTransform();
-      Lib3MF::sTransform transform{ .m_Fields = {{ 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }, { 0, 0, 1 } } };
+      Lib3MF::sTransform transform{
+          .m_Fields = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 1}}};
       if (has_transform) {
         transform = component->GetTransform();
       }
       const auto componentobject = component->GetObjectResource();
       const Matrix4d cm = get_matrix(transform);
       if (has_transform) {
-        PRINTDB("%scomponent transform matrix\n%s", boost::io::group(std::setw(2 * level), "") % cm);
+        PRINTDB("%scomponent transform matrix\n%s",
+                boost::io::group(std::setw(2 * level), "") % cm);
       }
-      auto errmsg = collect_mesh_objects(model, object_list, componentobject, cm * m, loc, level + 1);
+      auto errmsg = collect_mesh_objects(model, object_list, componentobject,
+                                         cm * m, loc, level + 1);
       if (!errmsg.empty()) {
         return errmsg;
       }
@@ -145,62 +165,75 @@ std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& ob
 
 // lib3mf_propertyhandler_getcolor states:
 // (#00000000) means no property or a different kind of property!
-Color4f get_color(const Lib3MF::PColorGroup& colorgroup, const Lib3MF_uint32 propertyid)
-{
+Color4f get_color(const Lib3MF::PColorGroup& colorgroup,
+                  const Lib3MF_uint32 propertyid) {
   const auto color = colorgroup->GetColor(propertyid);
-  if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 && color.m_Alpha == 0) {
-    return {}; // invalid color
+  if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 &&
+      color.m_Alpha == 0) {
+    return {};  // invalid color
   }
   Color4f c{color.m_Red, color.m_Green, color.m_Blue, color.m_Alpha};
   return c;
 }
 
-Color4f get_triangle_color(const Lib3MF::PModel& model, const Lib3MF::sTriangleProperties triangle_properties)
-{
-  const auto colorgroup = model->GetColorGroupByID(triangle_properties.m_ResourceID);
-  const Color4f col0 = get_color(colorgroup, triangle_properties.m_PropertyIDs[0]);
-  const Color4f col1 = get_color(colorgroup, triangle_properties.m_PropertyIDs[1]);
-  const Color4f col2 = get_color(colorgroup, triangle_properties.m_PropertyIDs[2]);
+Color4f get_triangle_color(
+    const Lib3MF::PModel& model,
+    const Lib3MF::sTriangleProperties triangle_properties) {
+  const auto colorgroup =
+      model->GetColorGroupByID(triangle_properties.m_ResourceID);
+  const Color4f col0 =
+      get_color(colorgroup, triangle_properties.m_PropertyIDs[0]);
+  const Color4f col1 =
+      get_color(colorgroup, triangle_properties.m_PropertyIDs[1]);
+  const Color4f col2 =
+      get_color(colorgroup, triangle_properties.m_PropertyIDs[2]);
   if (col0.isValid() && col1.isValid() && col2.isValid()) {
-    return {
-      std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)
-    };
+    return {std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
+            std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
+            std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
+            std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)};
   }
   return {};
 }
 
-Color4f get_triangle_color_from_basematerial(const Lib3MF::PModel& model, const Lib3MF::sTriangleProperties triangle_properties)
-{
-  const auto basematerialgroup = model->GetBaseMaterialGroupByID(triangle_properties.m_ResourceID);
-  const auto displaycolor = basematerialgroup->GetDisplayColor(triangle_properties.m_PropertyIDs[0]);
-  Color4f col{displaycolor.m_Red, displaycolor.m_Green, displaycolor.m_Blue, 255};
+Color4f get_triangle_color_from_basematerial(
+    const Lib3MF::PModel& model,
+    const Lib3MF::sTriangleProperties triangle_properties) {
+  const auto basematerialgroup =
+      model->GetBaseMaterialGroupByID(triangle_properties.m_ResourceID);
+  const auto displaycolor =
+      basematerialgroup->GetDisplayColor(triangle_properties.m_PropertyIDs[0]);
+  Color4f col{displaycolor.m_Red, displaycolor.m_Green, displaycolor.m_Blue,
+              255};
   return col;
 }
 
-Color4f get_triangle_color(const Lib3MF::PModel& model, const Lib3MF::PMeshObject& object, int idx)
-{
+Color4f get_triangle_color(const Lib3MF::PModel& model,
+                           const Lib3MF::PMeshObject& object,
+                           int idx) {
   Lib3MF::sTriangleProperties triangle_properties;
   object->GetTriangleProperties(idx, triangle_properties);
   if (triangle_properties.m_ResourceID == 0) {
     return {};
   }
 
-  const auto propertytype = model->GetPropertyTypeByID(triangle_properties.m_ResourceID);
+  const auto propertytype =
+      model->GetPropertyTypeByID(triangle_properties.m_ResourceID);
   switch (propertytype) {
-  case Lib3MF::ePropertyType::BaseMaterial:
-    return get_triangle_color_from_basematerial(model, triangle_properties);
-  case Lib3MF::ePropertyType::Colors:
-    return get_triangle_color(model, triangle_properties);
-  default:
-    return {};
+    case Lib3MF::ePropertyType::BaseMaterial:
+      return get_triangle_color_from_basematerial(model, triangle_properties);
+    case Lib3MF::ePropertyType::Colors:
+      return get_triangle_color(model, triangle_properties);
+    default:
+      return {};
   }
 }
 
-std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx, const Lib3MF::PModel& model, const std::unique_ptr<MeshObject>& mo, std::unique_ptr<PolySet>& ps)
-{
+std::string import_3mf_mesh(const std::string& filename,
+                            unsigned int mesh_idx,
+                            const Lib3MF::PModel& model,
+                            const std::unique_ptr<MeshObject>& mo,
+                            std::unique_ptr<PolySet>& ps) {
   const auto object = mo->obj;
   const auto vertex_count = object->GetVertexCount();
   const auto triangle_count = object->GetTriangleCount();
@@ -210,7 +243,9 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
 
   const auto object_type = get_object_type_name(object->GetType());
 
-  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu", filename.c_str() % mesh_idx % object_type % vertex_count % triangle_count);
+  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu",
+          filename.c_str() % mesh_idx % object_type % vertex_count %
+              triangle_count);
 
   ps->vertices.reserve(vertex_count);
   ps->indices.reserve(triangle_count);
@@ -219,7 +254,9 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
   std::vector<Lib3MF::sPosition> all_vertices;
   object->GetVertices(all_vertices);
   for (const auto& vertex : all_vertices) {
-    const Vector4d v = mo->transform * Vector4d(vertex.m_Coordinates[0], vertex.m_Coordinates[1], vertex.m_Coordinates[2], 1);
+    const Vector4d v = mo->transform * Vector4d(vertex.m_Coordinates[0],
+                                                vertex.m_Coordinates[1],
+                                                vertex.m_Coordinates[2], 1);
     ps->vertices.push_back(v.head(3));
   }
 
@@ -255,8 +292,7 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
   return "";
 }
 
-std::string read_metadata(const Lib3MF::PModel& model)
-{
+std::string read_metadata(const Lib3MF::PModel& model) {
   const auto metadatagroup = model->GetMetaDataGroup();
   const auto metadatacount = metadatagroup->GetMetaDataCount();
 
@@ -296,21 +332,25 @@ std::string read_metadata(const Lib3MF::PModel& model)
   return "";
 }
 
-} // namespace
+}  // namespace
 
 std::string get_lib3mf_version() {
-  Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
+  Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor,
+      interfaceVersionMicro;
   Lib3MF::PWrapper wrapper;
 
   try {
     wrapper = Lib3MF::CWrapper::loadLibrary();
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
+    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor,
+                               interfaceVersionMicro);
   } catch (const Lib3MF::ELib3MFException& e) {
     LOG(message_group::Export_Error, e.what());
   }
 
-  const OpenSCAD::library_version_number header_version{LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO};
-  const OpenSCAD::library_version_number runtime_version{interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro};
+  const OpenSCAD::library_version_number header_version{
+      LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO};
+  const OpenSCAD::library_version_number runtime_version{
+      interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
@@ -321,16 +361,20 @@ std::string get_lib3mf_version() {
 #include "geometry/manifold/manifoldutils.h"
 #endif
 
-std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<PolySet> import_3mf(const std::string& filename,
+                                    const Location& loc) {
   Lib3MF::PWrapper wrapper;
 
   try {
     wrapper = Lib3MF::CWrapper::loadLibrary();
-    Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
+    Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor,
+        interfaceVersionMicro;
+    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor,
+                               interfaceVersionMicro);
     if (interfaceVersionMajor != LIB3MF_VERSION_MAJOR) {
-      LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+      LOG(message_group::Error,
+          "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+          "%4$d.%5$d.%6$d",
           interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
           LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
       return PolySet::createEmpty();
@@ -360,14 +404,18 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
       return PolySet::createEmpty();
     }
   } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, "Could create 3MF reader, import() at line %1$d: %2$s", loc.firstLine(), e.what());
+    LOG(message_group::Export_Error,
+        "Could create 3MF reader, import() at line %1$d: %2$s", loc.firstLine(),
+        e.what());
     return PolySet::createEmpty();
   }
 
   try {
     reader->ReadFromFile(filename);
   } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Warning, "Could not read file '%1$s', import() at line %2$d: %3$s", filename.c_str(), loc.firstLine(), e.what());
+    LOG(message_group::Warning,
+        "Could not read file '%1$s', import() at line %2$d: %3$s",
+        filename.c_str(), loc.firstLine(), e.what());
     return PolySet::createEmpty();
   }
 
@@ -376,7 +424,9 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
   try {
     Lib3MF::PBuildItemIterator builditem_it = model->GetBuildItems();
     if (!builditem_it) {
-      LOG(message_group::Warning, "Could not retrieve build items, import() at line %2$d", filename.c_str(), loc.firstLine());
+      LOG(message_group::Warning,
+          "Could not retrieve build items, import() at line %2$d",
+          filename.c_str(), loc.firstLine());
       return PolySet::createEmpty();
     }
 
@@ -387,34 +437,41 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
       const auto partnumber = builditem->GetPartNumber();
       bool hasuuid = false;
       const auto uuid = builditem->GetUUID(hasuuid);
-      Lib3MF::sTransform transform{ .m_Fields = {{ 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }, { 0, 0, 0 } } };
+      Lib3MF::sTransform transform{
+          .m_Fields = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 0}}};
       if (builditem->HasObjectTransform()) {
         transform = builditem->GetObjectTransform();
       }
       const auto object = builditem->GetObjectResource();
       const Matrix4d m = get_matrix(transform);
 
-      PRINTDB("build item %d, part number = '%s' (%s)", builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
+      PRINTDB("build item %d, part number = '%s' (%s)",
+              builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
       if (builditem->HasObjectTransform()) {
         PRINTDB("build item transform matrix\n%s", m);
       }
 
       MeshObjectList object_list;
-      std::string errmsg = collect_mesh_objects(model, object_list, object, m, loc);
+      std::string errmsg =
+          collect_mesh_objects(model, object_list, object, m, loc);
       if (!errmsg.empty()) {
-        LOG(message_group::Warning, "Error collecting meshes, import() at line %2$d", filename.c_str(), loc.firstLine());
+        LOG(message_group::Warning,
+            "Error collecting meshes, import() at line %2$d", filename.c_str(),
+            loc.firstLine());
         return PolySet::createEmpty();
       }
 
       for (const auto& mo : object_list) {
         auto ps = PolySet::createEmpty();
-        std::string errmsg = import_3mf_mesh(filename, meshes.size(), model, mo, ps);
+        std::string errmsg =
+            import_3mf_mesh(filename, meshes.size(), model, mo, ps);
         if (errmsg.empty()) {
           if (ps->isEmpty()) {
             continue;
           }
         } else {
-          LOG(message_group::Warning, "%1$s, import() at line %2$d", errmsg, loc.firstLine());
+          LOG(message_group::Warning, "%1$s, import() at line %2$d", errmsg,
+              loc.firstLine());
           return PolySet::createEmpty();
         }
 
@@ -430,28 +487,34 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
       std::unique_ptr<PolySet> p;
       Geometry::Geometries children;
       while (!meshes.empty()) {
-        children.emplace_back(std::shared_ptr<AbstractNode>(), std::shared_ptr<const Geometry>(std::move(meshes.front())));
+        children.emplace_back(
+            std::shared_ptr<AbstractNode>(),
+            std::shared_ptr<const Geometry>(std::move(meshes.front())));
         meshes.pop_front();
       }
-  #ifdef ENABLE_MANIFOLD
-      if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-        if (auto ps = PolySetUtils::getGeometryAsPolySet(ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::UNION))) {
+#ifdef ENABLE_MANIFOLD
+      if (RenderSettings::inst()->backend3D ==
+          RenderBackend3D::ManifoldBackend) {
+        if (auto ps = PolySetUtils::getGeometryAsPolySet(
+                ManifoldUtils::applyOperator3DManifold(
+                    children, OpenSCADOperator::UNION))) {
           p = std::make_unique<PolySet>(*ps);
         } else {
           p = PolySet::createEmpty();
         }
       } else
-  #endif // ifdef ENABLE_MANIFOLD
+#endif  // ifdef ENABLE_MANIFOLD
       {
-  #ifdef ENABLE_CGAL
-        if (auto ps = PolySetUtils::getGeometryAsPolySet(CGALUtils::applyUnion3D(children.begin(), children.end()))) {
+#ifdef ENABLE_CGAL
+        if (auto ps = PolySetUtils::getGeometryAsPolySet(
+                CGALUtils::applyUnion3D(children.begin(), children.end()))) {
           p = std::make_unique<PolySet>(*ps);
         } else {
           p = PolySet::createEmpty();
         }
-  #else
+#else
         p = PolySet::createEmpty();
-  #endif // ifdef ENABLE_CGAL
+#endif  // ifdef ENABLE_CGAL
       }
       return p;
     }
diff --git a/src/io/import_amf.cc b/src/io/import_amf.cc
index 63c0ef261..3eea6e4a2 100644
--- a/src/io/import_amf.cc
+++ b/src/io/import_amf.cc
@@ -24,35 +24,36 @@
  *
  */
 
-#include "geometry/PolySet.h"
+#include "core/AST.h"
+#include "core/Assignment.h"
+#include "core/CsgOpNode.h"
+#include "core/ModuleInstantiation.h"
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
 #include "utils/printutils.h"
-#include "core/AST.h"
-#include "core/Assignment.h"
-#include "core/ModuleInstantiation.h"
-#include "core/CsgOpNode.h"
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
 
-#include <utility>
-#include <memory>
+#include <libxml/xmlreader.h>
 #include <sys/types.h>
+#include <boost/lexical_cast.hpp>
+#include <cassert>
 #include <cstddef>
+#include <filesystem>
 #include <map>
-#include <cassert>
+#include <memory>
 #include <string>
+#include <utility>
 #include <vector>
-#include <libxml/xmlreader.h>
-#include <filesystem>
-#include <boost/lexical_cast.hpp>
 
 static const std::string text_node("#text");
 static const std::string object("/amf/object");
-static const std::string coordinates("/amf/object/mesh/vertices/vertex/coordinates");
+static const std::string coordinates(
+    "/amf/object/mesh/vertices/vertex/coordinates");
 static const std::string coordinates_x = coordinates + "/x";
 static const std::string coordinates_y = coordinates + "/y";
 static const std::string coordinates_z = coordinates + "/z";
@@ -61,12 +62,11 @@ static const std::string triangle_v1 = triangle + "/v1";
 static const std::string triangle_v2 = triangle + "/v2";
 static const std::string triangle_v3 = triangle + "/v3";
 
-class AmfImporter
-{
-private:
-  std::string xpath; // element nesting stack
+class AmfImporter {
+ private:
+  std::string xpath;  // element nesting stack
 
-  using cb_func = void (*)(AmfImporter *, const xmlChar *);
+  using cb_func = void (*)(AmfImporter*, const xmlChar*);
 
   std::unique_ptr<PolySetBuilder> builder;
   std::vector<std::unique_ptr<PolySet>> polySets;
@@ -79,153 +79,141 @@ private:
   std::map<const std::string, cb_func> start_funcs;
   std::map<const std::string, cb_func> end_funcs;
 
-  static void set_x(AmfImporter *importer, const xmlChar *value);
-  static void set_y(AmfImporter *importer, const xmlChar *value);
-  static void set_z(AmfImporter *importer, const xmlChar *value);
-  static void set_v1(AmfImporter *importer, const xmlChar *value);
-  static void set_v2(AmfImporter *importer, const xmlChar *value);
-  static void set_v3(AmfImporter *importer, const xmlChar *value);
-  static void start_object(AmfImporter *importer, const xmlChar *value);
-  static void end_object(AmfImporter *importer, const xmlChar *value);
-  static void end_triangle(AmfImporter *importer, const xmlChar *vlue);
-  static void end_vertex(AmfImporter *importer, const xmlChar *value);
-
-  int streamFile(const char *filename);
+  static void set_x(AmfImporter* importer, const xmlChar* value);
+  static void set_y(AmfImporter* importer, const xmlChar* value);
+  static void set_z(AmfImporter* importer, const xmlChar* value);
+  static void set_v1(AmfImporter* importer, const xmlChar* value);
+  static void set_v2(AmfImporter* importer, const xmlChar* value);
+  static void set_v3(AmfImporter* importer, const xmlChar* value);
+  static void start_object(AmfImporter* importer, const xmlChar* value);
+  static void end_object(AmfImporter* importer, const xmlChar* value);
+  static void end_triangle(AmfImporter* importer, const xmlChar* vlue);
+  static void end_vertex(AmfImporter* importer, const xmlChar* value);
+
+  int streamFile(const char* filename);
   void processNode(xmlTextReaderPtr reader);
 
-protected:
+ protected:
   const Location& loc;
 
-public:
+ public:
   AmfImporter(const Location& loc);
   virtual ~AmfImporter() = default;
   std::unique_ptr<PolySet> read(const std::string& filename);
 
-  virtual xmlTextReaderPtr createXmlReader(const char *filename);
+  virtual xmlTextReaderPtr createXmlReader(const char* filename);
 };
 
-AmfImporter::AmfImporter(const Location& loc) : loc(loc)
-{
-}
+AmfImporter::AmfImporter(const Location& loc) : loc(loc) {}
 
-void AmfImporter::set_x(AmfImporter *importer, const xmlChar *value)
-{
-  importer->x = boost::lexical_cast<double>(std::string((const char *)value));
+void AmfImporter::set_x(AmfImporter* importer, const xmlChar* value) {
+  importer->x = boost::lexical_cast<double>(std::string((const char*)value));
 }
 
-void AmfImporter::set_y(AmfImporter *importer, const xmlChar *value)
-{
-  importer->y = boost::lexical_cast<double>(std::string((const char *)value));
+void AmfImporter::set_y(AmfImporter* importer, const xmlChar* value) {
+  importer->y = boost::lexical_cast<double>(std::string((const char*)value));
 }
 
-void AmfImporter::set_z(AmfImporter *importer, const xmlChar *value)
-{
-  importer->z = boost::lexical_cast<double>(std::string((const char *)value));
+void AmfImporter::set_z(AmfImporter* importer, const xmlChar* value) {
+  importer->z = boost::lexical_cast<double>(std::string((const char*)value));
 }
 
-void AmfImporter::set_v1(AmfImporter *importer, const xmlChar *value)
-{
-  importer->idx_v1 = boost::lexical_cast<int>(std::string((const char *)value));
+void AmfImporter::set_v1(AmfImporter* importer, const xmlChar* value) {
+  importer->idx_v1 = boost::lexical_cast<int>(std::string((const char*)value));
 }
 
-void AmfImporter::set_v2(AmfImporter *importer, const xmlChar *value)
-{
-  importer->idx_v2 = boost::lexical_cast<int>(std::string((const char *)value));
+void AmfImporter::set_v2(AmfImporter* importer, const xmlChar* value) {
+  importer->idx_v2 = boost::lexical_cast<int>(std::string((const char*)value));
 }
 
-void AmfImporter::set_v3(AmfImporter *importer, const xmlChar *value)
-{
-  importer->idx_v3 = boost::lexical_cast<int>(std::string((const char *)value));
+void AmfImporter::set_v3(AmfImporter* importer, const xmlChar* value) {
+  importer->idx_v3 = boost::lexical_cast<int>(std::string((const char*)value));
 }
 
-void AmfImporter::start_object(AmfImporter *importer, const xmlChar *)
-{
+void AmfImporter::start_object(AmfImporter* importer, const xmlChar*) {
   importer->builder = std::make_unique<PolySetBuilder>(0, 0);
 }
 
-void AmfImporter::end_object(AmfImporter *importer, const xmlChar *)
-{
+void AmfImporter::end_object(AmfImporter* importer, const xmlChar*) {
   PRINTDB("AMF: add object %d", importer->polySets.size());
   importer->polySets.push_back(importer->builder->build());
   importer->vertex_list.clear();
   importer->builder.reset(nullptr);
 }
 
-void AmfImporter::end_vertex(AmfImporter *importer, const xmlChar *)
-{
-  PRINTDB("AMF: add vertex %d - (%.2f, %.2f, %.2f)", importer->vertex_list.size() % importer->x % importer->y % importer->z);
+void AmfImporter::end_vertex(AmfImporter* importer, const xmlChar*) {
+  PRINTDB(
+      "AMF: add vertex %d - (%.2f, %.2f, %.2f)",
+      importer->vertex_list.size() % importer->x % importer->y % importer->z);
   importer->vertex_list.emplace_back(importer->x, importer->y, importer->z);
 }
 
-void AmfImporter::end_triangle(AmfImporter *importer, const xmlChar *)
-{
+void AmfImporter::end_triangle(AmfImporter* importer, const xmlChar*) {
   int idx[3] = {importer->idx_v1, importer->idx_v2, importer->idx_v3};
-  PRINTDB("AMF: add triangle %d - (%.2f, %.2f, %.2f)", importer->vertex_list.size() % idx[0] % idx[1] % idx[2]);
+  PRINTDB("AMF: add triangle %d - (%.2f, %.2f, %.2f)",
+          importer->vertex_list.size() % idx[0] % idx[1] % idx[2]);
 
   std::vector<Eigen::Vector3d>& v = importer->vertex_list;
 
   importer->builder->beginPolygon(3);
-  for (auto i : idx)// TODO set vertex array first
+  for (auto i : idx)  // TODO set vertex array first
     importer->builder->addVertex(Vector3d(v[i].x(), v[i].y(), v[i].z()));
 }
 
-void AmfImporter::processNode(xmlTextReaderPtr reader)
-{
-  const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-  if (name == nullptr) name = reinterpret_cast<const char *>(xmlStrdup(BAD_CAST "--"));
-  xmlChar *value = xmlTextReaderValue(reader);
+void AmfImporter::processNode(xmlTextReaderPtr reader) {
+  const char* name = reinterpret_cast<const char*>(xmlTextReaderName(reader));
+  if (name == nullptr)
+    name = reinterpret_cast<const char*>(xmlStrdup(BAD_CAST "--"));
+  xmlChar* value = xmlTextReaderValue(reader);
   int node_type = xmlTextReaderNodeType(reader);
   switch (node_type) {
-  case XML_READER_TYPE_ELEMENT:
-  {
-    xpath += '/';
-    xpath += name;
-    cb_func startFunc = start_funcs[xpath];
-    if (startFunc) {
-      PRINTDB("AMF: start %s", xpath);
-      startFunc(this, nullptr);
-    }
-  }
-  break;
-  case XML_READER_TYPE_END_ELEMENT:
-  {
-    cb_func endFunc = end_funcs[xpath];
-    if (endFunc) {
-      PRINTDB("AMF: end   %s", xpath);
-      endFunc(this, value);
-    }
-    size_t pos = xpath.find_last_of('/');
-    if (pos != std::string::npos) xpath.erase(pos);
-  }
-  break;
-  case XML_READER_TYPE_TEXT:
-  {
-    cb_func textFunc = funcs[xpath];
-    if (textFunc) {
-      PRINTDB("AMF: text  %s - '%s'", xpath % value);
-      textFunc(this, value);
-    }
-  }
-  break;
+    case XML_READER_TYPE_ELEMENT: {
+      xpath += '/';
+      xpath += name;
+      cb_func startFunc = start_funcs[xpath];
+      if (startFunc) {
+        PRINTDB("AMF: start %s", xpath);
+        startFunc(this, nullptr);
+      }
+    } break;
+    case XML_READER_TYPE_END_ELEMENT: {
+      cb_func endFunc = end_funcs[xpath];
+      if (endFunc) {
+        PRINTDB("AMF: end   %s", xpath);
+        endFunc(this, value);
+      }
+      size_t pos = xpath.find_last_of('/');
+      if (pos != std::string::npos)
+        xpath.erase(pos);
+    } break;
+    case XML_READER_TYPE_TEXT: {
+      cb_func textFunc = funcs[xpath];
+      if (textFunc) {
+        PRINTDB("AMF: text  %s - '%s'", xpath % value);
+        textFunc(this, value);
+      }
+    } break;
   }
 
   xmlFree(value);
-  xmlFree((void *) (name));
+  xmlFree((void*)(name));
 }
 
-xmlTextReaderPtr AmfImporter::createXmlReader(const char *filename)
-{
-  return xmlReaderForFile(filename, nullptr, XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
+xmlTextReaderPtr AmfImporter::createXmlReader(const char* filename) {
+  return xmlReaderForFile(
+      filename, nullptr,
+      XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
 }
 
-int AmfImporter::streamFile(const char *filename)
-{
+int AmfImporter::streamFile(const char* filename) {
   int ret;
 
   xmlTextReaderPtr reader = createXmlReader(filename);
 
   if (reader == nullptr) {
-    LOG(message_group::Warning, "Can't open import file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+    LOG(message_group::Warning,
+        "Can't open import file '%1$s', import() at line %2$d", filename,
+        this->loc.firstLine());
     return 1;
   }
 
@@ -241,13 +229,14 @@ int AmfImporter::streamFile(const char *filename)
     ret = -1;
   }
   if (ret != 0) {
-    LOG(message_group::Warning, "Failed to parse file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+    LOG(message_group::Warning,
+        "Failed to parse file '%1$s', import() at line %2$d", filename,
+        this->loc.firstLine());
   }
   return ret;
 }
 
-std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
-{
+std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename) {
   funcs[coordinates_x] = set_x;
   funcs[coordinates_y] = set_y;
   funcs[coordinates_z] = set_z;
@@ -270,17 +259,21 @@ std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
   if (polySets.size() > 1) {
     Geometry::Geometries children;
     for (auto& polySet : polySets) {
-      children.push_back(std::make_pair(std::shared_ptr<AbstractNode>(), std::move(polySet)));
+      children.push_back(
+          std::make_pair(std::shared_ptr<AbstractNode>(), std::move(polySet)));
     }
 
 #ifdef ENABLE_CGAL
-    std::unique_ptr<const Geometry> geom = CGALUtils::applyUnion3D(children.begin(), children.end());
+    std::unique_ptr<const Geometry> geom =
+        CGALUtils::applyUnion3D(children.begin(), children.end());
     if (auto ps = PolySetUtils::getGeometryAsPolySet(std::move(geom))) {
       // FIXME: Unnecessary copy
       return std::make_unique<PolySet>(*ps);
     } else
-#endif // ENABLE_CGAL
-    LOG(message_group::Error, "Error importing multi-object AMF file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+#endif  // ENABLE_CGAL
+      LOG(message_group::Error,
+          "Error importing multi-object AMF file '%1$s', import() at line %2$d",
+          filename, this->loc.firstLine());
   }
   return PolySet::createEmpty();
 }
@@ -289,57 +282,58 @@ std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
 
 #include <zip.h>
 
-class AmfImporterZIP : public AmfImporter
-{
-private:
-  struct zip *archive {nullptr};
-  struct zip_file *zipfile {nullptr};
+class AmfImporterZIP : public AmfImporter {
+ private:
+  struct zip* archive{nullptr};
+  struct zip_file* zipfile{nullptr};
 
-  static int read_callback(void *context, char *buffer, int len);
-  static int close_callback(void *context);
+  static int read_callback(void* context, char* buffer, int len);
+  static int close_callback(void* context);
 
-public:
+ public:
   AmfImporterZIP(const Location& loc);
 
-  xmlTextReaderPtr createXmlReader(const char *filename) override;
+  xmlTextReaderPtr createXmlReader(const char* filename) override;
 };
 
-AmfImporterZIP::AmfImporterZIP(const Location& loc) : AmfImporter(loc)
-{
-}
+AmfImporterZIP::AmfImporterZIP(const Location& loc) : AmfImporter(loc) {}
 
-int AmfImporterZIP::read_callback(void *context, char *buffer, int len)
-{
-  auto *importer = (AmfImporterZIP *)context;
+int AmfImporterZIP::read_callback(void* context, char* buffer, int len) {
+  auto* importer = (AmfImporterZIP*)context;
   return zip_fread(importer->zipfile, buffer, len);
 }
 
-int AmfImporterZIP::close_callback(void *context)
-{
-  auto *importer = (AmfImporterZIP *)context;
+int AmfImporterZIP::close_callback(void* context) {
+  auto* importer = (AmfImporterZIP*)context;
   return zip_fclose(importer->zipfile);
 }
 
-xmlTextReaderPtr AmfImporterZIP::createXmlReader(const char *filepath)
-{
+xmlTextReaderPtr AmfImporterZIP::createXmlReader(const char* filepath) {
   archive = zip_open(filepath, 0, nullptr);
   if (archive) {
-    // Separate the filename without using filesystem::path because that gives wide result on Windows TM
-    const char *last_slash = strrchr(filepath, '/');
-    const char *last_bslash = strrchr(filepath, '\\');
-    if (last_bslash > last_slash) last_slash = last_bslash;
-    const char *filename = last_slash ? last_slash + 1 : filepath;
+    // Separate the filename without using filesystem::path because that gives
+    // wide result on Windows TM
+    const char* last_slash = strrchr(filepath, '/');
+    const char* last_bslash = strrchr(filepath, '\\');
+    if (last_bslash > last_slash)
+      last_slash = last_bslash;
+    const char* filename = last_slash ? last_slash + 1 : filepath;
     zipfile = zip_fopen(archive, filename, ZIP_FL_NODIR);
     if (zipfile == nullptr) {
-      LOG(message_group::Warning, "Can't read file '%1$s' from zipped AMF '%2$s', import() at line %3$d", filename, filepath, this->loc.firstLine());
+      LOG(message_group::Warning,
+          "Can't read file '%1$s' from zipped AMF '%2$s', import() at line "
+          "%3$d",
+          filename, filepath, this->loc.firstLine());
     }
     if ((zipfile == nullptr) && (zip_get_num_entries(archive, 0) == 1)) {
-      LOG(message_group::Warning, "Trying to read single entry '%1$s'", zip_get_name(archive, 0, 0));
+      LOG(message_group::Warning, "Trying to read single entry '%1$s'",
+          zip_get_name(archive, 0, 0));
       zipfile = zip_fopen_index(archive, 0, 0);
     }
     if (zipfile) {
-      return xmlReaderForIO(read_callback, close_callback, this, filename, nullptr,
-                            XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
+      return xmlReaderForIO(
+          read_callback, close_callback, this, filename, nullptr,
+          XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
     } else {
       zip_close(archive);
       zipfile = nullptr;
@@ -350,18 +344,22 @@ xmlTextReaderPtr AmfImporterZIP::createXmlReader(const char *filepath)
   }
 }
 
-std::unique_ptr<PolySet> import_amf(const std::string& filename, const Location& loc) {
-  LOG(message_group::Deprecated, "AMF import is deprecated. Please use 3MF instead.");
+std::unique_ptr<PolySet> import_amf(const std::string& filename,
+                                    const Location& loc) {
+  LOG(message_group::Deprecated,
+      "AMF import is deprecated. Please use 3MF instead.");
   AmfImporterZIP importer(loc);
   return importer.read(filename);
 }
 
 #else
 
-std::unique_ptr<PolySet> import_amf(const std::string& filename, const Location& loc) {
-  LOG(message_group::Deprecated, "AMF import is deprecated. Please use 3MF instead.");
+std::unique_ptr<PolySet> import_amf(const std::string& filename,
+                                    const Location& loc) {
+  LOG(message_group::Deprecated,
+      "AMF import is deprecated. Please use 3MF instead.");
   AmfImporter importer(loc);
   return importer.read(filename);
 }
 
-#endif // ifdef ENABLE_LIBZIP
+#endif  // ifdef ENABLE_LIBZIP
diff --git a/src/io/import_json.cc b/src/io/import_json.cc
index e0e0e4460..e8666018b 100644
--- a/src/io/import_json.cc
+++ b/src/io/import_json.cc
@@ -41,10 +41,9 @@ using json = nlohmann::json;
 
 namespace {
 
-ObjectType to_obj(const json& j, EvaluationSession *session);
+ObjectType to_obj(const json& j, EvaluationSession* session);
 
-Value to_value(const json& j, EvaluationSession *session)
-{
+Value to_value(const json& j, EvaluationSession* session) {
   if (j.is_string()) {
     return Value{j.get<std::string>()};
   } else if (j.is_number()) {
@@ -63,8 +62,7 @@ Value to_value(const json& j, EvaluationSession *session)
   return Value::undefined.clone();
 }
 
-ObjectType to_obj(const json& j, EvaluationSession *session)
-{
+ObjectType to_obj(const json& j, EvaluationSession* session) {
   ObjectType obj{session};
   for (const auto& item : j.items()) {
     obj.set(item.key(), to_value(item.value(), session));
@@ -72,10 +70,11 @@ ObjectType to_obj(const json& j, EvaluationSession *session)
   return obj;
 }
 
-} // namespace
+}  // namespace
 
-Value import_json(const std::string& filename, EvaluationSession *session, const Location& loc)
-{
+Value import_json(const std::string& filename,
+                  EvaluationSession* session,
+                  const Location& loc) {
   std::ifstream i(filename);
 
   try {
@@ -84,10 +83,12 @@ Value import_json(const std::string& filename, EvaluationSession *session, const
       i >> j;
       return Value{to_value(j, session)};
     } else {
-      LOG(message_group::Warning, loc, "", "Could not read file '%1$s'", filename);
+      LOG(message_group::Warning, loc, "", "Could not read file '%1$s'",
+          filename);
     }
   } catch (const std::exception& e) {
-    LOG(message_group::Warning, loc, "", "Failed to parse file '%1$s': %s", filename, e.what());
+    LOG(message_group::Warning, loc, "", "Failed to parse file '%1$s': %s",
+        filename, e.what());
   }
 
   return Value::undefined.clone();
diff --git a/src/io/import_nef.cc b/src/io/import_nef.cc
index de4c41e35..1f5aa1f16 100644
--- a/src/io/import_nef.cc
+++ b/src/io/import_nef.cc
@@ -9,16 +9,18 @@
 #include "utils/printutils.h"
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgal.h"
-#include "geometry/cgal/CGALNefGeometry.h"
 #include <CGAL/IO/Nef_polyhedron_iostream_3.h>
+#include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgal.h"
 
-std::unique_ptr<CGALNefGeometry> import_nef3(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<CGALNefGeometry> import_nef3(const std::string& filename,
+                                             const Location& loc) {
   // Open file and position at the end
   std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary);
   if (!f.good()) {
-    LOG(message_group::Warning, "Can't open import file '%1$s', import() at line %2$d", filename, loc.firstLine());
+    LOG(message_group::Warning,
+        "Can't open import file '%1$s', import() at line %2$d", filename,
+        loc.firstLine());
     return std::make_unique<CGALNefGeometry>();
   }
 
@@ -27,10 +29,12 @@ std::unique_ptr<CGALNefGeometry> import_nef3(const std::string& filename, const
     f >> *nef;
     return std::make_unique<CGALNefGeometry>(nef);
   } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Warning, "Failure trying to import '%1$s', import() at line %2$d", filename, loc.firstLine());
+    LOG(message_group::Warning,
+        "Failure trying to import '%1$s', import() at line %2$d", filename,
+        loc.firstLine());
     LOG(e.what());
     return std::make_unique<CGALNefGeometry>();
   }
 }
 
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
diff --git a/src/io/import_obj.cc b/src/io/import_obj.cc
index 1e2ecb993..3cf52e650 100644
--- a/src/io/import_obj.cc
+++ b/src/io/import_obj.cc
@@ -13,19 +13,20 @@
 #include <boost/regex.hpp>
 
 #include "core/AST.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
-std::unique_ptr<PolySet> import_obj(const std::string& filename, const Location& loc) {
+std::unique_ptr<PolySet> import_obj(const std::string& filename,
+                                    const Location& loc) {
   PolySetBuilder builder;
 
   std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary);
   if (!f.good()) {
     LOG(message_group::Warning,
-        "Can't open import file '%1$s', import() at line %2$d",
-        filename, loc.firstLine());
+        "Can't open import file '%1$s', import() at line %2$d", filename,
+        loc.firstLine());
     return PolySet::createEmpty();
   }
   const boost::regex ex_comment(R"(^\s*#)");
@@ -41,11 +42,11 @@ std::unique_ptr<PolySet> import_obj(const std::string& filename, const Location&
   int lineno = 1;
   std::string line;
 
-  auto AsciiError = [&](const auto& errstr){
-      LOG(message_group::Error, loc, "",
-          "OBJ File line %1$s, %2$s line '%3$s' importing file '%4$s'",
-          lineno, errstr, line, filename);
-    };
+  auto AsciiError = [&](const auto& errstr) {
+    LOG(message_group::Error, loc, "",
+        "OBJ File line %1$s, %2$s line '%3$s' importing file '%4$s'", lineno,
+        errstr, line, filename);
+  };
   std::vector<int> vertex_map;
 
   while (!f.eof()) {
@@ -56,7 +57,8 @@ std::unique_ptr<PolySet> import_obj(const std::string& filename, const Location&
     boost::smatch results;
     if (line.length() == 0 || boost::regex_search(line, ex_comment)) {
       continue;
-    } else if (boost::regex_search(line, results, ex_v) && results.size() >= 4) {
+    } else if (boost::regex_search(line, results, ex_v) &&
+               results.size() >= 4) {
       try {
         Vector3d v;
         for (int i = 0; i < 3; i++) {
@@ -67,33 +69,43 @@ std::unique_ptr<PolySet> import_obj(const std::string& filename, const Location&
         AsciiError("can't parse vertex");
         return PolySet::createEmpty();
       }
-    } else if (boost::regex_search(line, results, ex_f) && results.size() >= 2) {
+    } else if (boost::regex_search(line, results, ex_f) &&
+               results.size() >= 2) {
       std::vector<std::string> words;
       boost::split(words, results[1], boost::is_any_of(" \t"));
       builder.beginPolygon(words.size());
       for (const std::string& word : words) {
         std::vector<std::string> wordindex;
         boost::split(wordindex, word, boost::is_any_of("/"));
-        if (wordindex.size() < 1)LOG(message_group::Warning, "Invalid Face index in File %1$s in Line %2$d", filename, lineno);
+        if (wordindex.size() < 1)
+          LOG(message_group::Warning,
+              "Invalid Face index in File %1$s in Line %2$d", filename, lineno);
         else {
           const size_t ind = boost::lexical_cast<int>(wordindex[0]);
           if (ind >= 1 && ind <= vertex_map.size()) {
             builder.addVertex(vertex_map[ind - 1]);
           } else {
-            LOG(message_group::Warning, "Index %1$d out of range in Line %2$d", filename, lineno);
+            LOG(message_group::Warning, "Index %1$d out of range in Line %2$d",
+                filename, lineno);
           }
         }
       }
 
-    } else if (boost::regex_search(line, results, ex_vt)) { // ignore texture coords
-    } else if (boost::regex_search(line, results, ex_vn)) { // ignore normal coords
-    } else if (boost::regex_search(line, results, ex_mtllib)) { // ignore material lib
-    } else if (boost::regex_search(line, results, ex_usemtl)) { // ignore usemtl
-    } else if (boost::regex_search(line, results, ex_o)) { // ignore object name
-    } else if (boost::regex_search(line, results, ex_s)) { // ignore smooting
-    } else if (boost::regex_search(line, results, ex_g)) { // ignore group name
+    } else if (boost::regex_search(line, results,
+                                   ex_vt)) {  // ignore texture coords
+    } else if (boost::regex_search(line, results,
+                                   ex_vn)) {  // ignore normal coords
+    } else if (boost::regex_search(line, results,
+                                   ex_mtllib)) {  // ignore material lib
+    } else if (boost::regex_search(line, results,
+                                   ex_usemtl)) {  // ignore usemtl
+    } else if (boost::regex_search(line, results,
+                                   ex_o)) {  // ignore object name
+    } else if (boost::regex_search(line, results, ex_s)) {  // ignore smooting
+    } else if (boost::regex_search(line, results, ex_g)) {  // ignore group name
     } else {
-      LOG(message_group::Warning, "Unrecognized Line  %1$s in line Line %2$d", line, lineno);
+      LOG(message_group::Warning, "Unrecognized Line  %1$s in line Line %2$d",
+          line, lineno);
     }
   }
   return builder.build();
diff --git a/src/io/import_off.cc b/src/io/import_off.cc
index d57435c14..85cf06076 100644
--- a/src/io/import_off.cc
+++ b/src/io/import_off.cc
@@ -5,11 +5,11 @@
 #include <cstdint>
 #include <cstdio>
 #include <fstream>
-#include <locale>
 #include <ios>
-#include <sstream>
+#include <locale>
 #include <map>
 #include <memory>
+#include <sstream>
 #include <string>
 #include <vector>
 
@@ -19,15 +19,15 @@
 #include <boost/regex.hpp>
 
 #include "core/AST.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 // References:
 // http://www.geomview.org/docs/html/OFF.html
 
-std::unique_ptr<PolySet> import_off(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<PolySet> import_off(const std::string& filename,
+                                    const Location& loc) {
   const boost::regex ex_magic(R"(^(ST)?(C)?(N)?(4)?(n)?OFF( BINARY)? *)");
   // XXX: are ST C N always in order?
   const boost::regex ex_cr(R"(\r$)");
@@ -39,61 +39,61 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
   int lineno = 0;
   std::string line;
 
-  auto AsciiError = [&](const auto& errstr){
-      LOG(message_group::Error, loc, "",
-          "OFF File line %1$s, %2$s line '%3$s' importing file '%4$s'",
-          lineno, errstr, line, filename);
-    };
-
-  auto getline_clean = [&](const auto& errstr){
-      do {
-        lineno++;
-        std::getline(f, line);
-        if (line.empty() && f.eof()) {
-          AsciiError(errstr);
-          return false;
-        }
-        // strip DOS line endings
-        if (boost::regex_search(line, results, ex_cr)) {
-          line = line.erase(results.position(), results[0].length());
-        }
-        // strip comments
-        if (boost::regex_search(line, results, ex_comment)) {
-          line = line.erase(results.position(), results[0].length());
-        }
-        boost::trim(line);
-      } while (line.empty());
+  auto AsciiError = [&](const auto& errstr) {
+    LOG(message_group::Error, loc, "",
+        "OFF File line %1$s, %2$s line '%3$s' importing file '%4$s'", lineno,
+        errstr, line, filename);
+  };
+
+  auto getline_clean = [&](const auto& errstr) {
+    do {
+      lineno++;
+      std::getline(f, line);
+      if (line.empty() && f.eof()) {
+        AsciiError(errstr);
+        return false;
+      }
+      // strip DOS line endings
+      if (boost::regex_search(line, results, ex_cr)) {
+        line = line.erase(results.position(), results[0].length());
+      }
+      // strip comments
+      if (boost::regex_search(line, results, ex_comment)) {
+        line = line.erase(results.position(), results[0].length());
+      }
+      boost::trim(line);
+    } while (line.empty());
 
-      return true;
-    };
+    return true;
+  };
 
-  auto getcolor = [&](const auto& word){
-      int c;
-      if (boost::contains(word, ".")) {
-        float f;
+  auto getcolor = [&](const auto& word) {
+    int c;
+    if (boost::contains(word, ".")) {
+      float f;
 #ifdef __cpp_lib_to_chars
-        auto result = std::from_chars(word.data(), word.data() + word.length(), f);
-        if (result.ec != std::errc{}) {
-          AsciiError("Parse error");
-          return 0;
-        }
+      auto result =
+          std::from_chars(word.data(), word.data() + word.length(), f);
+      if (result.ec != std::errc{}) {
+        AsciiError("Parse error");
+        return 0;
+      }
 #else
-        // fall back for pre C++17
-        std::istringstream istr(word);
-        istr.imbue(std::locale("C"));
-        istr >> f;
-        if (istr.peek() != EOF) {
-          AsciiError("Parse error");
-          return 0;
-        }
-#endif // ifdef __cpp_lib_to_chars
-        c = (int)(f * 255);
-      } else {
-        c = boost::lexical_cast<int>(word);
+      // fall back for pre C++17
+      std::istringstream istr(word);
+      istr.imbue(std::locale("C"));
+      istr >> f;
+      if (istr.peek() != EOF) {
+        AsciiError("Parse error");
+        return 0;
       }
-      return c;
-    };
-
+#endif  // ifdef __cpp_lib_to_chars
+      c = (int)(f * 255);
+    } else {
+      c = boost::lexical_cast<int>(word);
+    }
+    return c;
+  };
 
   if (!f.good()) {
     AsciiError("File error");
@@ -119,7 +119,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     has_color = results[2].matched;
     has_textures = results[1].matched;
     is_binary = results[6].matched;
-    if (results[4].matched)dimension = 4;
+    if (results[4].matched)
+      dimension = 4;
     has_ndim = results[5].matched;
   }
 
@@ -135,7 +136,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     if (line.empty() && !getline_clean("bad header: end of file")) {
       return PolySet::createEmpty();
     }
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
+    boost::split(words, line, boost::is_any_of(" \t"),
+                 boost::token_compress_on);
     if (f.eof() || words.size() < 1) {
       AsciiError("bad header: missing Ndim");
       return PolySet::createEmpty();
@@ -149,10 +151,13 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     }
   }
 
-  PRINTDB("Header flags: N:%d C:%d ST:%d Ndim:%d B:%d", has_normals % has_color % has_textures % dimension % is_binary);
+  PRINTDB("Header flags: N:%d C:%d ST:%d Ndim:%d B:%d",
+          has_normals % has_color % has_textures % dimension % is_binary);
 
   if (dimension != 3) {
-    AsciiError((boost::format("unhandled vertex dimensions (%d)") % dimension).str().c_str());
+    AsciiError((boost::format("unhandled vertex dimensions (%d)") % dimension)
+                   .str()
+                   .c_str());
     return PolySet::createEmpty();
   }
 
@@ -175,7 +180,7 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     vertices_count = boost::lexical_cast<unsigned long>(words[0]);
     faces_count = boost::lexical_cast<unsigned long>(words[1]);
     edges_count = boost::lexical_cast<unsigned long>(words[2]);
-    (void)edges_count; // ignored
+    (void)edges_count;  // ignored
   } catch (const boost::bad_lexical_cast& blc) {
     AsciiError("bad header: bad data");
     return PolySet::createEmpty();
@@ -186,7 +191,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     return PolySet::createEmpty();
   }
 
-  PRINTDB("%d vertices, %d faces, %d edges.", vertices_count % faces_count % edges_count);
+  PRINTDB("%d vertices, %d faces, %d edges.",
+          vertices_count % faces_count % edges_count);
 
   auto ps = PolySet::createEmpty();
   ps->vertices.reserve(vertices_count);
@@ -197,7 +203,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       return PolySet::createEmpty();
     }
 
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
+    boost::split(words, line, boost::is_any_of(" \t"),
+                 boost::token_compress_on);
     if (words.size() < 3) {
       AsciiError("can't parse vertex: not enough data");
       return PolySet::createEmpty();
@@ -209,14 +216,14 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       for (i = 0; i < dimension; i++) {
         v[i] = boost::lexical_cast<double>(words[i]);
       }
-      //PRINTDB("Vertex[%ld] = { %f, %f, %f }", vertex % v[0] % v[1] % v[2]);
+      // PRINTDB("Vertex[%ld] = { %f, %f, %f }", vertex % v[0] % v[1] % v[2]);
       if (has_normals) {
         // TODO words[i++]
         i += 0;
       }
       if (has_color) {
         // TODO: Meshlab appends color there, probably to allow gradients
-        i += 3; // 4?
+        i += 3;  // 4?
       }
       if (has_textures) {
         // TODO words[i++]
@@ -235,7 +242,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       return PolySet::createEmpty();
     }
 
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
+    boost::split(words, line, boost::is_any_of(" \t"),
+                 boost::token_compress_on);
     if (words.size() < 1) {
       AsciiError("can't parse face: not enough data");
       return PolySet::createEmpty();
@@ -251,17 +259,19 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       }
       const size_t face_idx = ps->indices.size();
       ps->indices.emplace_back().reserve(face_size);
-      //PRINTDB("Index[%d] [%d] = { ", face % n);
+      // PRINTDB("Index[%d] [%d] = { ", face % n);
       for (i = 0; i < face_size; i++) {
         int ind = boost::lexical_cast<int>(words[i + 1]);
-        //PRINTDB("%d, ", ind);
+        // PRINTDB("%d, ", ind);
         if (ind >= 0 && ind < vertices_count) {
           ps->indices.back().push_back(ind);
         } else {
-          AsciiError((boost::format("ignored bad face vertex index: %d") % ind).str().c_str());
+          AsciiError((boost::format("ignored bad face vertex index: %d") % ind)
+                         .str()
+                         .c_str());
         }
       }
-      //PRINTD("}");
+      // PRINTD("}");
       if (words.size() >= face_size + 4) {
         i = face_size + 1;
         // handle optional color info (r g b [a])
@@ -271,8 +281,10 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
         const int a = i < words.size() ? getcolor(words[i++]) : 255;
         const Color4f color(r, g, b, a);
 
-        auto iter_pair = color_indices.insert_or_assign(color, ps->colors.size());
-        if (iter_pair.second) ps->colors.push_back(color); // inserted
+        auto iter_pair =
+            color_indices.insert_or_assign(color, ps->colors.size());
+        if (iter_pair.second)
+          ps->colors.push_back(color);  // inserted
         ps->color_indices.resize(face_idx, -1);
         ps->color_indices.push_back(iter_pair.first->second);
       }
@@ -285,6 +297,7 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     ps->color_indices.resize(ps->indices.size(), -1);
   }
 
-  //PRINTDB("PS: %ld vertices, %ld indices", ps->vertices.size() % ps->indices.size());
+  // PRINTDB("PS: %ld vertices, %ld indices", ps->vertices.size() %
+  // ps->indices.size());
   return ps;
 }
diff --git a/src/io/import_stl.cc b/src/io/import_stl.cc
index 8ef70aea0..4dacecf59 100644
--- a/src/io/import_stl.cc
+++ b/src/io/import_stl.cc
@@ -8,9 +8,9 @@
 #include <memory>
 #include <string>
 
+#include <boost/predef.h>
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
-#include <boost/predef.h>
 #include <boost/regex.hpp>
 
 #include "core/AST.h"
@@ -18,7 +18,8 @@
 #include "geometry/PolySetBuilder.h"
 #include "utils/printutils.h"
 
-#if !defined(BOOST_ENDIAN_BIG_BYTE_AVAILABLE) && !defined(BOOST_ENDIAN_LITTLE_BYTE_AVAILABLE)
+#if !defined(BOOST_ENDIAN_BIG_BYTE_AVAILABLE) && \
+    !defined(BOOST_ENDIAN_LITTLE_BYTE_AVAILABLE)
 #error Byte order undefined or unknown. Currently only BOOST_ENDIAN_BIG_BYTE and BOOST_ENDIAN_LITTLE_BYTE are supported.
 #endif
 
@@ -27,7 +28,7 @@ inline constexpr size_t STL_FACET_NUMBYTES = 4ul * 3ul * 4ul + 2ul;
 // is a 'binary32' aka 'single' standard IEEE 32-bit floating point type
 union stl_facet {
   static_assert(sizeof(unsigned char) == sizeof(uint8_t), "existence check");
-  unsigned char data8[ STL_FACET_NUMBYTES ];
+  unsigned char data8[STL_FACET_NUMBYTES];
   struct facet_data {
     float i, j, k;
     float x1, y1, z1;
@@ -37,30 +38,31 @@ union stl_facet {
   } data;
 };
 
-static_assert(offsetof(stl_facet::facet_data, attribute_byte_count) == 4ul * 3ul * 4ul,
+static_assert(offsetof(stl_facet::facet_data, attribute_byte_count) ==
+                  4ul * 3ul * 4ul,
               "Invalid padding in stl_facet");
 
 #if BOOST_ENDIAN_BIG_BYTE
-static void uint32_byte_swap(unsigned char *p) {
-# if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 3) || defined(__clang__)
-  uint32_t& x = *reinterpret_cast<uint32_t *>(p);
+static void uint32_byte_swap(unsigned char* p) {
+#if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 3) || defined(__clang__)
+  uint32_t& x = *reinterpret_cast<uint32_t*>(p);
   x = __builtin_bswap32(x);
-# elif defined(_MSC_VER)
-  uint32_t& x = *reinterpret_cast<uint32_t *>(p);
+#elif defined(_MSC_VER)
+  uint32_t& x = *reinterpret_cast<uint32_t*>(p);
   x = _byteswap_ulong(x);
-# else
+#else
   std::swap(*p, *(p + 3));
   std::swap(*(p + 1), *(p + 2));
-# endif
+#endif
 }
 
 static void uint32_byte_swap(uint32_t& x) {
-  uint32_byte_swap(reinterpret_cast<unsigned char *>(&x));
+  uint32_byte_swap(reinterpret_cast<unsigned char*>(&x));
 }
-#endif // if BOOST_ENDIAN_BIG_BYTE
+#endif  // if BOOST_ENDIAN_BIG_BYTE
 
 static void read_stl_facet(std::ifstream& f, stl_facet& facet) {
-  f.read((char *)facet.data8, STL_FACET_NUMBYTES);
+  f.read((char*)facet.data8, STL_FACET_NUMBYTES);
   if (static_cast<size_t>(f.gcount()) < STL_FACET_NUMBYTES) {
     throw std::ios_base::failure("facet data truncated");
   }
@@ -72,13 +74,15 @@ static void read_stl_facet(std::ifstream& f, stl_facet& facet) {
 #endif
 }
 
-std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location& loc) {
+std::unique_ptr<PolySet> import_stl(const std::string& filename,
+                                    const Location& loc) {
   // Open file and position at the end
-  std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
+  std::ifstream f(filename.c_str(),
+                  std::ios::in | std::ios::binary | std::ios::ate);
   if (!f.good()) {
     LOG(message_group::Warning,
-        "Can't open import file '%1$s', import() at line %2$d",
-        filename, loc.firstLine());
+        "Can't open import file '%1$s', import() at line %2$d", filename,
+        loc.firstLine());
     return PolySet::createEmpty();
   }
 
@@ -88,14 +92,14 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
   const boost::regex ex_loopend("^\\s*endloop$");
   const boost::regex ex_vertex("^\\s*vertex");
   const boost::regex ex_vertices(
-    R"(^\s*vertex\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*$)");
+      R"(^\s*vertex\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*$)");
   const boost::regex ex_endsolid("^\\s*endsolid");
 
   bool binary = false;
   const std::streampos file_size = f.tellg();
   f.seekg(80);
   if (f.good() && !f.eof()) {
-    f.read((char *)&facenum, sizeof(uint32_t));
+    f.read((char*)&facenum, sizeof(uint32_t));
 #if BOOST_ENDIAN_BIG_BYTE
     uint32_byte_swap(facenum);
 #endif
@@ -103,7 +107,8 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
       binary = true;
     }
   }
-  if (!binary)facenum = 0;
+  if (!binary)
+    facenum = 0;
   PolySetBuilder builder(0, facenum);
   f.seekg(0);
 
@@ -115,11 +120,11 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
     std::array<std::array<double, 3>, 3> vdata;
     std::string line;
 
-    auto AsciiError = [&](const auto& errstr){
-        LOG(message_group::Error, loc, "",
-            "STL line %1$s, %2$s line '%3$s' importing file '%4$s'",
-            lineno, errstr, line, filename);
-      };
+    auto AsciiError = [&](const auto& errstr) {
+      LOG(message_group::Error, loc, "",
+          "STL line %1$s, %2$s line '%3$s' importing file '%4$s'", lineno,
+          errstr, line, filename);
+    };
 
     std::getline(f, line);
     bool reached_end = false;
@@ -154,7 +159,8 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
           if (++i == 3) {
             builder.beginPolygon(3);
             for (int j = 0; j < 3; j++) {
-              builder.addVertex(Vector3d(vdata[j][0], vdata[j][1], vdata[j][2]));
+              builder.addVertex(
+                  Vector3d(vdata[j][0], vdata[j][1], vdata[j][2]));
             }
           }
         } catch (const boost::bad_lexical_cast& blc) {
@@ -169,37 +175,39 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
   } else if (binary && !f.eof() && f.good()) {
     try {
       f.ignore(80 - 5 + 4);
-      while (!f.eof() ) {
+      while (!f.eof()) {
         stl_facet facet;
         try {
           read_stl_facet(f, facet);
         } catch (const std::ios_base::failure& ex) {
-          if (f.eof()) break;
+          if (f.eof())
+            break;
           throw;
         }
-        builder.appendPolygon({
-          Vector3d(facet.data.x1, facet.data.y1, facet.data.z1),
-          Vector3d(facet.data.x2, facet.data.y2, facet.data.z2),
-          Vector3d(facet.data.x3, facet.data.y3, facet.data.z3)
-        });
+        builder.appendPolygon(
+            {Vector3d(facet.data.x1, facet.data.y1, facet.data.z1),
+             Vector3d(facet.data.x2, facet.data.y2, facet.data.z2),
+             Vector3d(facet.data.x3, facet.data.y3, facet.data.z3)});
       }
     } catch (const std::ios_base::failure& ex) {
       int64_t offset = -1;
-      try { offset = f.tellg(); } catch (...) {}
+      try {
+        offset = f.tellg();
+      } catch (...) {
+      }
       if (offset < 0) {
-        LOG(message_group::Error, loc, "",
-            "Binary STL '%1$s' error: %3$s",
+        LOG(message_group::Error, loc, "", "Binary STL '%1$s' error: %3$s",
             filename, ex.what());
       } else {
         LOG(message_group::Error, loc, "",
-            "Binary STL '%1$s' error at byte %2$s: %3$s",
-            filename, offset, ex.what());
+            "Binary STL '%1$s' error at byte %2$s: %3$s", filename, offset,
+            ex.what());
       }
       return PolySet::createEmpty();
     }
   } else {
-    LOG(message_group::Error, loc, "",
-        "STL format not recognized in '%1$s'.", filename);
+    LOG(message_group::Error, loc, "", "STL format not recognized in '%1$s'.",
+        filename);
     return PolySet::createEmpty();
   }
   return builder.build();
diff --git a/src/io/import_svg.cc b/src/io/import_svg.cc
index 8862db569..1ac45cad6 100644
--- a/src/io/import_svg.cc
+++ b/src/io/import_svg.cc
@@ -31,16 +31,16 @@
 #include <string>
 #include <vector>
 
+#include <clipper2/clipper.h>
 #include <Eigen/Core>
 #include <Eigen/Geometry>
-#include <clipper2/clipper.h>
 
 #include "core/AST.h"
 #include "geometry/ClipperUtils.h"
 #include "geometry/Polygon2d.h"
 #include "libsvg/libsvg.h"
-#include "libsvg/svgpage.h"
 #include "libsvg/shape.h"
+#include "libsvg/svgpage.h"
 #include "libsvg/util.h"
 #include "utils/printutils.h"
 
@@ -48,80 +48,91 @@ namespace {
 
 constexpr double INCH_TO_MM = 25.4;
 
-double to_mm(const libsvg::length_t& length, const double viewbox, const bool viewbox_valid, const double dpi)
-{
+double to_mm(const libsvg::length_t& length,
+             const double viewbox,
+             const bool viewbox_valid,
+             const double dpi) {
   switch (length.unit) {
-  case libsvg::unit_t::NONE:
-    return INCH_TO_MM * length.number / dpi;
-  case libsvg::unit_t::PX:
-    return INCH_TO_MM * length.number / 96.0;
-  case libsvg::unit_t::PT:
-    return INCH_TO_MM * length.number / 72.0;
-  case libsvg::unit_t::PC:
-    return INCH_TO_MM * length.number / 6.0;
-  case libsvg::unit_t::IN:
-    return INCH_TO_MM * length.number;
-  case libsvg::unit_t::CM:
-    return 10 * length.number;
-  case libsvg::unit_t::MM:
-    return length.number;
-  case libsvg::unit_t::PERCENT:
-    return viewbox_valid ? INCH_TO_MM * length.number / 100.0 * viewbox / dpi : 0.0;
-  case libsvg::unit_t::UNDEFINED:
-    // If no width/height given, but viewbox is set, then rely on
-    // the DPI value (e.g. Adobe Illustrator does that in older
-    // versions)
-    return viewbox_valid ? INCH_TO_MM * viewbox / dpi : 0.0;
-  default:
-    return viewbox_valid ? viewbox : 0.0;
+    case libsvg::unit_t::NONE:
+      return INCH_TO_MM * length.number / dpi;
+    case libsvg::unit_t::PX:
+      return INCH_TO_MM * length.number / 96.0;
+    case libsvg::unit_t::PT:
+      return INCH_TO_MM * length.number / 72.0;
+    case libsvg::unit_t::PC:
+      return INCH_TO_MM * length.number / 6.0;
+    case libsvg::unit_t::IN:
+      return INCH_TO_MM * length.number;
+    case libsvg::unit_t::CM:
+      return 10 * length.number;
+    case libsvg::unit_t::MM:
+      return length.number;
+    case libsvg::unit_t::PERCENT:
+      return viewbox_valid ? INCH_TO_MM * length.number / 100.0 * viewbox / dpi
+                           : 0.0;
+    case libsvg::unit_t::UNDEFINED:
+      // If no width/height given, but viewbox is set, then rely on
+      // the DPI value (e.g. Adobe Illustrator does that in older
+      // versions)
+      return viewbox_valid ? INCH_TO_MM * viewbox / dpi : 0.0;
+    default:
+      return viewbox_valid ? viewbox : 0.0;
   }
 }
 
-double calc_alignment(const libsvg::align_t alignment, double page_mm, double scale, double viewbox)
-{
+double calc_alignment(const libsvg::align_t alignment,
+                      double page_mm,
+                      double scale,
+                      double viewbox) {
   switch (alignment) {
-  case libsvg::align_t::MID:
-    return page_mm / 2.0 - scale * viewbox / 2.0;
-  case libsvg::align_t::MAX:
-    return page_mm - scale * viewbox;
-  default:
-    return 0.0;
+    case libsvg::align_t::MID:
+      return page_mm / 2.0 - scale * viewbox / 2.0;
+    case libsvg::align_t::MAX:
+      return page_mm - scale * viewbox;
+    default:
+      return 0.0;
   }
 }
 
-} // namespace
-
+}  // namespace
 
-std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
+std::unique_ptr<Polygon2d> import_svg(double fn,
+                                      double fs,
+                                      double fa,
                                       const std::string& filename,
-                                      const boost::optional<std::string>& id, const boost::optional<std::string>& layer,
-                                      const double dpi, const bool center, const Location& loc)
-{
+                                      const boost::optional<std::string>& id,
+                                      const boost::optional<std::string>& layer,
+                                      const double dpi,
+                                      const bool center,
+                                      const Location& loc) {
   try {
     fnContext scadContext(fn, fs, fa);
     if (id) {
-      scadContext.selector = [&scadContext, id, layer](const libsvg::shape *s) {
-          bool layer_match = true;
-          if (layer) {
-            layer_match = false;
-            for (const libsvg::shape *shape = s; shape->get_parent() != nullptr; shape = shape->get_parent()) {
-              if (shape->has_layer() && shape->get_layer() == layer.get()) {
-                layer_match = true;
-                break;
-              }
+      scadContext.selector = [&scadContext, id, layer](const libsvg::shape* s) {
+        bool layer_match = true;
+        if (layer) {
+          layer_match = false;
+          for (const libsvg::shape* shape = s; shape->get_parent() != nullptr;
+               shape = shape->get_parent()) {
+            if (shape->has_layer() && shape->get_layer() == layer.get()) {
+              layer_match = true;
+              break;
             }
           }
-          return scadContext.match(layer_match && s->has_id() && s->get_id() == id.get());
-        };
+        }
+        return scadContext.match(layer_match && s->has_id() &&
+                                 s->get_id() == id.get());
+      };
     } else if (layer) {
-      scadContext.selector = [&scadContext, layer](const libsvg::shape *s) {
-          return scadContext.match(s->has_layer() && s->get_layer() == layer.get());
-        };
+      scadContext.selector = [&scadContext, layer](const libsvg::shape* s) {
+        return scadContext.match(s->has_layer() &&
+                                 s->get_layer() == layer.get());
+      };
     } else {
       // no selection means selecting the root
-      scadContext.selector = [&scadContext](const libsvg::shape *s) {
-          return scadContext.match(s->get_parent() == nullptr);
-        };
+      scadContext.selector = [&scadContext](const libsvg::shape* s) {
+        return scadContext.match(s->get_parent() == nullptr);
+      };
     }
 
     std::string match_args;
@@ -129,13 +140,16 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
       match_args += "id = \"" + id.get() + "\"";
     }
     if (layer) {
-      if (id) match_args += ", ";
+      if (id)
+        match_args += ", ";
       match_args += "layer = \"" + layer.get() + "\"";
     }
 
-    const auto shapes = libsvg::libsvg_read_file(filename.c_str(), (void *) &scadContext);
+    const auto shapes =
+        libsvg::libsvg_read_file(filename.c_str(), (void*)&scadContext);
     if (!match_args.empty() && !scadContext.has_matches()) {
-      LOG(message_group::Warning, loc, "", "import() filter %2$s did not match anything", filename, match_args);
+      LOG(message_group::Warning, loc, "",
+          "import() filter %2$s did not match anything", filename, match_args);
     }
 
     double width_mm = 0.0;
@@ -148,7 +162,7 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
     Eigen::Vector2d viewbox{0.0, 0.0};
 
     for (const auto& shape_ptr : *shapes) {
-      const auto page = dynamic_cast<libsvg::svgpage *>(shape_ptr.get());
+      const auto page = dynamic_cast<libsvg::svgpage*>(shape_ptr.get());
       if (page) {
         const auto w = page->get_width();
         const auto h = page->get_height();
@@ -159,12 +173,14 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
         height_mm = to_mm(h, page->get_viewbox().height, viewbox_valid, dpi);
 
         if (viewbox_valid) {
-          const double px = w.unit == libsvg::unit_t::PERCENT ? w.number / 100.0 : 1.0;
-          const double py = h.unit == libsvg::unit_t::PERCENT ? h.number / 100.0 : 1.0;
-          viewbox << px * page->get_viewbox().x, py *page->get_viewbox().y;
+          const double px =
+              w.unit == libsvg::unit_t::PERCENT ? w.number / 100.0 : 1.0;
+          const double py =
+              h.unit == libsvg::unit_t::PERCENT ? h.number / 100.0 : 1.0;
+          viewbox << px * page->get_viewbox().x, py * page->get_viewbox().y;
 
           scale << width_mm / page->get_viewbox().width,
-            height_mm / page->get_viewbox().height;
+              height_mm / page->get_viewbox().height;
 
           if (alignment.x != libsvg::align_t::NONE) {
             double scaling;
@@ -179,8 +195,10 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
             }
             scale = Eigen::Vector2d{scaling, scaling};
 
-            align << calc_alignment(alignment.x, width_mm, scale.x(), page->get_viewbox().width),
-              calc_alignment(alignment.y, height_mm, scale.y(), page->get_viewbox().height);
+            align << calc_alignment(alignment.x, width_mm, scale.x(),
+                                    page->get_viewbox().width),
+                calc_alignment(alignment.y, height_mm, scale.y(),
+                               page->get_viewbox().height);
           }
         }
       }
@@ -212,13 +230,15 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
           }
           poly->addOutline(outline);
         }
-        if (!poly->isEmpty()) polygons.push_back(poly);
+        if (!poly->isEmpty())
+          polygons.push_back(poly);
       }
     }
     libsvg_free(shapes);
     return ClipperUtils::apply(polygons, Clipper2Lib::ClipType::Union);
   } catch (const std::exception& e) {
-    LOG(message_group::Error, "%1$s, import() at line %2$d", e.what(), loc.firstLine());
+    LOG(message_group::Error, "%1$s, import() at line %2$d", e.what(),
+        loc.firstLine());
     return std::make_unique<Polygon2d>();
   }
 }
diff --git a/src/libsvg/circle.cc b/src/libsvg/circle.cc
index 7627c77d9..2cc6dc9a3 100644
--- a/src/libsvg/circle.cc
+++ b/src/libsvg/circle.cc
@@ -32,9 +32,7 @@ namespace libsvg {
 
 const std::string circle::name("circle");
 
-void
-circle::set_attrs(attr_map_t& attrs, void *context)
-{
+void circle::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["cx"]);
   this->y = parse_double(attrs["cy"]);
@@ -45,15 +43,11 @@ circle::set_attrs(attr_map_t& attrs, void *context)
   path_list.push_back(path);
 }
 
-const std::string
-circle::dump() const
-{
+const std::string circle::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
     << ": r = " << this->r;
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/circle.h b/src/libsvg/circle.h
index f553e51e8..df993c702 100644
--- a/src/libsvg/circle.h
+++ b/src/libsvg/circle.h
@@ -30,23 +30,24 @@
 
 namespace libsvg {
 
-class circle : public shape
-{
-protected:
+class circle : public shape {
+ protected:
   double r{0};
 
-public:
+ public:
   circle() = default;
 
   [[nodiscard]] double get_radius() const { return r; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return circle::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return circle::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new circle(*this); }
+  [[nodiscard]] shape* clone() const override { return new circle(*this); }
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/data.cc b/src/libsvg/data.cc
index 98531218b..c3b60b46e 100644
--- a/src/libsvg/data.cc
+++ b/src/libsvg/data.cc
@@ -31,20 +31,15 @@ namespace libsvg {
 
 const std::string data::name("data");
 
-void
-data::set_attrs(attr_map_t& attrs, void *context)
-{
+void data::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->text = attrs["text"];
 }
 
-const std::string
-data::dump() const
-{
+const std::string data::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": text = '" << this->text << "'";
+  s << get_name() << ": text = '" << this->text << "'";
   return s.str();
 }
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/data.h b/src/libsvg/data.h
index 7b395ce68..a66ccfddd 100644
--- a/src/libsvg/data.h
+++ b/src/libsvg/data.h
@@ -30,23 +30,24 @@
 
 namespace libsvg {
 
-class data : public shape
-{
-private:
+class data : public shape {
+ private:
   std::string text;
 
-public:
+ public:
   data() = default;
 
   [[nodiscard]] const std::string& get_text() const { return text; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return data::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return data::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new data(*this); }
+  [[nodiscard]] shape* clone() const override { return new data(*this); }
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/ellipse.cc b/src/libsvg/ellipse.cc
index e799f125c..520c78054 100644
--- a/src/libsvg/ellipse.cc
+++ b/src/libsvg/ellipse.cc
@@ -24,10 +24,10 @@
  */
 #include "libsvg/ellipse.h"
 
-#include <sstream>
 #include <cstdlib>
-#include <string>
 #include <iostream>
+#include <sstream>
+#include <string>
 
 #include "libsvg/util.h"
 
@@ -35,9 +35,7 @@ namespace libsvg {
 
 const std::string ellipse::name("ellipse");
 
-void
-ellipse::set_attrs(attr_map_t& attrs, void *context)
-{
+void ellipse::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["cx"]);
   this->y = parse_double(attrs["cy"]);
@@ -49,16 +47,11 @@ ellipse::set_attrs(attr_map_t& attrs, void *context)
   path_list.push_back(path);
 }
 
-const std::string
-ellipse::dump() const
-{
+const std::string ellipse::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": rx = " << this->rx
-    << ": ry = " << this->ry;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": rx = " << this->rx << ": ry = " << this->ry;
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/ellipse.h b/src/libsvg/ellipse.h
index 0cadda926..49940b913 100644
--- a/src/libsvg/ellipse.h
+++ b/src/libsvg/ellipse.h
@@ -30,25 +30,26 @@
 
 namespace libsvg {
 
-class ellipse : public shape
-{
-protected:
+class ellipse : public shape {
+ protected:
   double rx{0};
   double ry{0};
 
-public:
+ public:
   ellipse() = default;
 
   [[nodiscard]] double get_radius_x() const { return rx; }
   [[nodiscard]] double get_radius_y() const { return ry; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return ellipse::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return ellipse::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new ellipse(*this); }
+  [[nodiscard]] shape* clone() const override { return new ellipse(*this); }
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/group.cc b/src/libsvg/group.cc
index 7afed16c3..cc5c7aa60 100644
--- a/src/libsvg/group.cc
+++ b/src/libsvg/group.cc
@@ -24,30 +24,23 @@
  */
 #include "libsvg/group.h"
 
-#include <sstream>
 #include <cstdlib>
-#include <string>
 #include <iostream>
-
+#include <sstream>
+#include <string>
 
 namespace libsvg {
 
 const std::string group::name("g");
 
-void
-group::set_attrs(attr_map_t& attrs, void *context)
-{
+void group::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
 }
 
-const std::string
-group::dump() const
-{
+const std::string group::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y;
   return s.str();
 }
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/group.h b/src/libsvg/group.h
index b5cd59e93..40ecc7f22 100644
--- a/src/libsvg/group.h
+++ b/src/libsvg/group.h
@@ -30,22 +30,22 @@
 
 namespace libsvg {
 
-class group : public shape
-{
-protected:
-
-public:
+class group : public shape {
+ protected:
+ public:
   group() = default;
 
   [[nodiscard]] bool is_container() const override { return true; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return group::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return group::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new group(*this); }
+  [[nodiscard]] shape* clone() const override { return new group(*this); }
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/libsvg.cc b/src/libsvg/libsvg.cc
index ffada68dc..fd053ea28 100644
--- a/src/libsvg/libsvg.cc
+++ b/src/libsvg/libsvg.cc
@@ -24,17 +24,16 @@
  */
 #include "libsvg/libsvg.h"
 
-#include <utility>
+#include <libxml/xmlreader.h>
+#include <Eigen/Core>
+#include <Eigen/Geometry>
+#include <boost/format.hpp>
 #include <iostream>
-#include <memory>
 #include <map>
+#include <memory>
 #include <string>
+#include <utility>
 #include <vector>
-#include <Eigen/Core>
-#include <Eigen/Geometry>
-#include <boost/format.hpp>
-#include <libxml/xmlreader.h>
-
 
 #include "libsvg/shape.h"
 #include "libsvg/use.h"
@@ -45,7 +44,7 @@ namespace libsvg {
 
 static bool in_defs = false;
 static shapes_list_t stack;
-static shapes_list_t *shape_list;
+static shapes_list_t* shape_list;
 
 using shapes_defs_list_t = std::map<std::string, std::shared_ptr<shape>>;
 
@@ -60,128 +59,124 @@ static std::string dump_stack() {
   }
   return s.str() + "]";
 }
-#endif // if SVG_DEBUG
+#endif  // if SVG_DEBUG
 
-attr_map_t read_attributes(xmlTextReaderPtr reader)
-{
+attr_map_t read_attributes(xmlTextReaderPtr reader) {
   attr_map_t attrs;
   int attr_count = xmlTextReaderAttributeCount(reader);
   for (int idx = 0; idx < attr_count; ++idx) {
     xmlTextReaderMoveToAttributeNo(reader, idx);
-    const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-    const char *value = reinterpret_cast<const char *>(xmlTextReaderValue(reader));
+    const char* name = reinterpret_cast<const char*>(xmlTextReaderName(reader));
+    const char* value =
+        reinterpret_cast<const char*>(xmlTextReaderValue(reader));
     attrs[name] = value;
   }
   return attrs;
 }
 
-void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list, shapes_list_t *temp_defs_storage, void *context)
-{
-  const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-  if (name == nullptr) name = reinterpret_cast<const char *>(xmlStrdup(BAD_CAST "--"));
+void processNode(xmlTextReaderPtr reader,
+                 shapes_defs_list_t* defs_lookup_list,
+                 shapes_list_t* temp_defs_storage,
+                 void* context) {
+  const char* name = reinterpret_cast<const char*>(xmlTextReaderName(reader));
+  if (name == nullptr)
+    name = reinterpret_cast<const char*>(xmlStrdup(BAD_CAST "--"));
 
   bool isEmpty;
-  xmlChar *value = xmlTextReaderValue(reader);
+  xmlChar* value = xmlTextReaderValue(reader);
   int node_type = xmlTextReaderNodeType(reader);
   switch (node_type) {
-  case XML_READER_TYPE_ELEMENT:
-    isEmpty = xmlTextReaderIsEmptyElement(reader);
-    {
+    case XML_READER_TYPE_ELEMENT:
+      isEmpty = xmlTextReaderIsEmptyElement(reader);
+      {
 #if SVG_DEBUG
-      printf("XML_READER_TYPE_ELEMENT (%s %s): %d %d %s\n",
-             dump_stack().c_str(), name,
-             xmlTextReaderDepth(reader),
-             xmlTextReaderNodeType(reader),
-             value);
+        printf("XML_READER_TYPE_ELEMENT (%s %s): %d %d %s\n",
+               dump_stack().c_str(), name, xmlTextReaderDepth(reader),
+               xmlTextReaderNodeType(reader), value);
 #endif
 
-      if (std::string("defs") == name) {
-        in_defs = true;
-      }
-
-      auto s = std::shared_ptr<shape>(shape::create_from_name(name));
-      if (s) {
-        attr_map_t attrs = read_attributes(reader);
-        if (!stack.empty()) {
-          stack.back()->add_child(s.get());
-        }
-        s->set_attrs(attrs, context);
-        if (s->is_container()) {
-          stack.push_back(s);
+        if (std::string("defs") == name) {
+          in_defs = true;
         }
 
-        //handle the "use" tag
-        if (use::name == s->get_name()) {
-          use *currentuse = dynamic_cast<use *>(s.get());
-          auto id = currentuse->get_href_id();
-          if (!id.empty() && defs_lookup_list->find(id) != defs_lookup_list->end()) {
-            auto to_clone_child = (*defs_lookup_list)[id];
-            auto cloned_children = currentuse->set_clone_child(to_clone_child.get());
-            shape_list->insert(shape_list->end(), cloned_children.begin(), cloned_children.end());
+        auto s = std::shared_ptr<shape>(shape::create_from_name(name));
+        if (s) {
+          attr_map_t attrs = read_attributes(reader);
+          if (!stack.empty()) {
+            stack.back()->add_child(s.get());
+          }
+          s->set_attrs(attrs, context);
+          if (s->is_container()) {
+            stack.push_back(s);
+          }
+
+          // handle the "use" tag
+          if (use::name == s->get_name()) {
+            use* currentuse = dynamic_cast<use*>(s.get());
+            auto id = currentuse->get_href_id();
+            if (!id.empty() &&
+                defs_lookup_list->find(id) != defs_lookup_list->end()) {
+              auto to_clone_child = (*defs_lookup_list)[id];
+              auto cloned_children =
+                  currentuse->set_clone_child(to_clone_child.get());
+              shape_list->insert(shape_list->end(), cloned_children.begin(),
+                                 cloned_children.end());
+            }
           }
-        }
 
-        if (!in_defs) {
-          shape_list->push_back(s);
-        } else {
-          if (!s->get_id_or_default().empty()) {
-            defs_lookup_list->insert(std::make_pair(s->get_id(), s));
+          if (!in_defs) {
+            shape_list->push_back(s);
+          } else {
+            if (!s->get_id_or_default().empty()) {
+              defs_lookup_list->insert(std::make_pair(s->get_id(), s));
+            }
+            temp_defs_storage->push_back(s);
           }
-          temp_defs_storage->push_back(s);
         }
       }
-    }
-    if (!isEmpty) {
-      break;
-    }
-  /* fall through */
-  case XML_READER_TYPE_END_ELEMENT:
-  {
-    if (std::string("defs") == name) {
-      in_defs = false;
-    }
+      if (!isEmpty) {
+        break;
+      }
+    /* fall through */
+    case XML_READER_TYPE_END_ELEMENT: {
+      if (std::string("defs") == name) {
+        in_defs = false;
+      }
 
-    if (std::string("g") == name ||
-        std::string("svg") == name ||
-        std::string("tspan") == name ||
-        std::string("text") == name) {
-      stack.pop_back();
-    }
+      if (std::string("g") == name || std::string("svg") == name ||
+          std::string("tspan") == name || std::string("text") == name) {
+        stack.pop_back();
+      }
 #if SVG_DEBUG
-    printf("XML_READER_TYPE_END_ELEMENT (%s %s): %d %d %s\n",
-           dump_stack().c_str(), name,
-           xmlTextReaderDepth(reader),
-           xmlTextReaderNodeType(reader),
-           value);
+      printf("XML_READER_TYPE_END_ELEMENT (%s %s): %d %d %s\n",
+             dump_stack().c_str(), name, xmlTextReaderDepth(reader),
+             xmlTextReaderNodeType(reader), value);
 #endif
-  }
-  break;
-  case XML_READER_TYPE_TEXT:
-  {
-    attr_map_t attrs;
-    attrs["text"] = reinterpret_cast<const char *>(value);
-    auto s = std::shared_ptr<shape>(shape::create_from_name("data"));
-    if (!stack.empty()) {
-      stack.back()->add_child(s.get());
-    }
-    s->set_attrs(attrs, context);
-    if (!in_defs) {
-      shape_list->push_back(s);
-    } else {
-      temp_defs_storage->push_back(s);
-    }
-  }
-  break;
+    } break;
+    case XML_READER_TYPE_TEXT: {
+      attr_map_t attrs;
+      attrs["text"] = reinterpret_cast<const char*>(value);
+      auto s = std::shared_ptr<shape>(shape::create_from_name("data"));
+      if (!stack.empty()) {
+        stack.back()->add_child(s.get());
+      }
+      s->set_attrs(attrs, context);
+      if (!in_defs) {
+        shape_list->push_back(s);
+      } else {
+        temp_defs_storage->push_back(s);
+      }
+    } break;
   }
 
   xmlFree(value);
-  xmlFree((void *) (name));
+  xmlFree((void*)(name));
 }
 
-int streamFile(const char *filename, void *context)
-{
+int streamFile(const char* filename, void* context) {
   xmlTextReaderPtr reader;
-  // The temp storage is needed for items in a def that don't have an id, but have a parent with an id
+  // The temp storage is needed for items in a def that don't have an id, but
+  // have a parent with an id
   shapes_list_t temp_defs_storage;
   shapes_defs_list_t defs_lookup_list;
 
@@ -196,10 +191,12 @@ int streamFile(const char *filename, void *context)
     }
     xmlFreeTextReader(reader);
     if (ret != 0) {
-      throw SvgException((boost::format("Error parsing file '%1%'") % filename).str());
+      throw SvgException(
+          (boost::format("Error parsing file '%1%'") % filename).str());
     }
   } else {
-    throw SvgException((boost::format("Can't open file '%1%'") % filename).str());
+    throw SvgException(
+        (boost::format("Can't open file '%1%'") % filename).str());
   }
 
   for (const auto& shape : (*shape_list)) {
@@ -209,7 +206,7 @@ int streamFile(const char *filename, void *context)
   return 0;
 }
 
-void dump(int idx, shape *s) {
+void dump(int idx, shape* s) {
   for (int a = 0; a < idx; ++a) {
     std::cout << "  ";
   }
@@ -219,25 +216,21 @@ void dump(int idx, shape *s) {
   }
 }
 
-shapes_list_t *
-libsvg_read_file(const char *filename, void *context)
-{
+shapes_list_t* libsvg_read_file(const char* filename, void* context) {
   shape_list = new shapes_list_t();
   streamFile(filename, context);
 
-//#ifdef DEBUG
-//	if (!shape_list->empty()) {
-//		dump(0, shape_list->front().get());
-//	}
-//#endif
+  // #ifdef DEBUG
+  //	if (!shape_list->empty()) {
+  //		dump(0, shape_list->front().get());
+  //	}
+  // #endif
 
   return shape_list;
 }
 
-void
-libsvg_free(shapes_list_t *shapes)
-{
+void libsvg_free(shapes_list_t* shapes) {
   delete shapes;
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/libsvg.h b/src/libsvg/libsvg.h
index 19910ae45..0915b82cd 100644
--- a/src/libsvg/libsvg.h
+++ b/src/libsvg/libsvg.h
@@ -25,35 +25,31 @@
 #pragma once
 
 #include <exception>
-#include <utility>
 #include <memory>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include "libsvg/shape.h"
 
 namespace libsvg {
 
-class SvgException : public std::exception
-{
-public:
-  SvgException(std::string message) : message(std::move(message)) { }
+class SvgException : public std::exception {
+ public:
+  SvgException(std::string message) : message(std::move(message)) {}
 
-  [[nodiscard]] const char *what() const noexcept override
-  {
+  [[nodiscard]] const char* what() const noexcept override {
     return message.c_str();
   }
 
-private:
+ private:
   std::string message;
 };
 
 using shapes_list_t = std::vector<std::shared_ptr<shape>>;
 
-shapes_list_t *
-libsvg_read_file(const char *filename, void *context);
+shapes_list_t* libsvg_read_file(const char* filename, void* context);
 
-void
-libsvg_free(shapes_list_t *shapes);
+void libsvg_free(shapes_list_t* shapes);
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/line.cc b/src/libsvg/line.cc
index 0c95b18a4..a68038fbe 100644
--- a/src/libsvg/line.cc
+++ b/src/libsvg/line.cc
@@ -32,9 +32,7 @@ namespace libsvg {
 
 const std::string line::name("line");
 
-void
-line::set_attrs(attr_map_t& attrs, void *context)
-{
+void line::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["x1"]);
   this->y = parse_double(attrs["y1"]);
@@ -47,16 +45,11 @@ line::set_attrs(attr_map_t& attrs, void *context)
   offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
 }
 
-const std::string
-line::dump() const
-{
+const std::string line::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x1 = " << this->x
-    << ": y1 = " << this->y
-    << ": x2 = " << this->x2
-    << ": y2 = " << this->y2;
+  s << get_name() << ": x1 = " << this->x << ": y1 = " << this->y
+    << ": x2 = " << this->x2 << ": y2 = " << this->y2;
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/line.h b/src/libsvg/line.h
index c121864fd..9b2323aa9 100644
--- a/src/libsvg/line.h
+++ b/src/libsvg/line.h
@@ -29,25 +29,30 @@
 
 namespace libsvg {
 
-class line : public shape
-{
-private:
+class line : public shape {
+ private:
   double x2{0};
   double y2{0};
 
-public:
+ public:
   line() = default;
 
-  [[nodiscard]] double get_x2() const { return x2; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_y2() const { return y2; } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_x2() const {
+    return x2;
+  }  // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_y2() const {
+    return y2;
+  }  // NOLINT(bugprone-virtual-near-miss)
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return line::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return line::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new line(*this); }
+  [[nodiscard]] shape* clone() const override { return new line(*this); }
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/path.cc b/src/libsvg/path.cc
index f885c78ee..35a241ad8 100644
--- a/src/libsvg/path.cc
+++ b/src/libsvg/path.cc
@@ -25,24 +25,23 @@
 #include "libsvg/path.h"
 
 #include <algorithm>
-#include <sstream>
+#include <cctype>
+#include <cmath>
 #include <cstdlib>
-#include <vector>
-#include <string>
 #include <iostream>
-#include <cmath>
-#include <cctype>
+#include <sstream>
 #include <string>
+#include <vector>
 
 #include <Eigen/Core>
 #include <Eigen/Geometry>
 
-#include <boost/tokenizer.hpp>
 #include <boost/algorithm/string.hpp>
+#include <boost/tokenizer.hpp>
 
-#include "utils/degree_trig.h"
-#include "utils/calc.h"
 #include "libsvg/util.h"
+#include "utils/calc.h"
+#include "utils/degree_trig.h"
 
 namespace libsvg {
 
@@ -72,9 +71,7 @@ const std::string path::name("path");
    PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL t
  */
 
-static double
-vector_angle(double ux, double uy, double vx, double vy)
-{
+static double vector_angle(double ux, double uy, double vx, double vy) {
   double angle = atan2_degrees(vy, vx) - atan2_degrees(uy, ux);
   if (angle < 0) {
     angle += 360;
@@ -82,19 +79,27 @@ vector_angle(double ux, double uy, double vx, double vy)
   return angle;
 }
 
-static inline
-unsigned long CalcFn(double fn, unsigned long minimum) {
+static inline unsigned long CalcFn(double fn, unsigned long minimum) {
   unsigned long result = 3;
-  if (fn > 3.0)     // > 0.0 && > 3
+  if (fn > 3.0)  // > 0.0 && > 3
     result = static_cast<unsigned long>(fn);
-  if (result < minimum) result = minimum;
+  if (result < minimum)
+    result = minimum;
   return result;
 }
 
-void
-path::arc_to(path_t& path, double x1, double y1, double rx, double ry, double x2, double y2, double angle, bool large, bool sweep, void *context)
-{
-  const auto *fValues = reinterpret_cast<const fnContext *>(context);
+void path::arc_to(path_t& path,
+                  double x1,
+                  double y1,
+                  double rx,
+                  double ry,
+                  double x2,
+                  double y2,
+                  double angle,
+                  bool large,
+                  bool sweep,
+                  void* context) {
+  const auto* fValues = reinterpret_cast<const fnContext*>(context);
 
   // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
 
@@ -143,28 +148,39 @@ path::arc_to(path_t& path, double x1, double y1, double rx, double ry, double x2
   }
 
   double rmax = fmax(rx, ry);
-  unsigned long fn = Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
-  fn = (unsigned long) ceil(fn * fabs(delta) / 360.0); // because we are creating a section of an ellipse, not the full ellipse
+  unsigned long fn =
+      Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
+  fn = (unsigned long)ceil(fn * fabs(delta) /
+                           360.0);  // because we are creating a section of an
+                                    // ellipse, not the full ellipse
   unsigned int steps = (std::fabs(delta) * 10.0 / 180) + 4;
-  if (steps < fn) // use the maximum of calculated steps and user specified steps
+  if (steps <
+      fn)  // use the maximum of calculated steps and user specified steps
     steps = fn;
   for (unsigned int a = 0; a <= steps; ++a) {
     double phi = theta + delta * a / steps;
 
-    double xx = cos_rad * cos_degrees(phi) * rx - sin_rad * sin_degrees(phi) * ry;
-    double yy = sin_rad * cos_degrees(phi) * rx + cos_rad * sin_degrees(phi) * ry;
+    double xx =
+        cos_rad * cos_degrees(phi) * rx - sin_rad * sin_degrees(phi) * ry;
+    double yy =
+        sin_rad * cos_degrees(phi) * rx + cos_rad * sin_degrees(phi) * ry;
 
     path.push_back(Eigen::Vector3d(xx + cx, yy + cy, 0));
   }
 }
 
-
-void
-path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double x2, double y2, void *context)
-{
-  // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
-  const auto *fValues = reinterpret_cast<const fnContext *>(context);
-  unsigned long fn = CalcFn(fValues->fn, 20); // preserve the old minimum
+void path::curve_to(path_t& path,
+                    double x,
+                    double y,
+                    double cx1,
+                    double cy1,
+                    double x2,
+                    double y2,
+                    void* context) {
+  // NOTE - this could be done better using a chord length iteration (uniform in
+  // space) to implement $fa (lot of work, little gain)
+  const auto* fValues = reinterpret_cast<const fnContext*>(context);
+  unsigned long fn = CalcFn(fValues->fn, 20);  // preserve the old minimum
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
     const double xx = x * t(a, 2) + cx1 * 2 * t(a, 1) * a + x2 * a * a;
@@ -173,16 +189,26 @@ path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double
   }
 }
 
-void
-path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double cx2, double cy2, double x2, double y2, void *context)
-{
-  // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
-  const auto *fValues = reinterpret_cast<const fnContext *>(context);
-  unsigned long fn = CalcFn(fValues->fn, 20); // preserve the old minimum
+void path::curve_to(path_t& path,
+                    double x,
+                    double y,
+                    double cx1,
+                    double cy1,
+                    double cx2,
+                    double cy2,
+                    double x2,
+                    double y2,
+                    void* context) {
+  // NOTE - this could be done better using a chord length iteration (uniform in
+  // space) to implement $fa (lot of work, little gain)
+  const auto* fValues = reinterpret_cast<const fnContext*>(context);
+  unsigned long fn = CalcFn(fValues->fn, 20);  // preserve the old minimum
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    const double xx = x * t(a, 3) + cx1 * 3 * t(a, 2) * a + cx2 * 3 * t(a, 1) * a * a + x2 * a * a * a;
-    const double yy = y * t(a, 3) + cy1 * 3 * t(a, 2) * a + cy2 * 3 * t(a, 1) * a * a + y2 * a * a * a;
+    const double xx = x * t(a, 3) + cx1 * 3 * t(a, 2) * a +
+                      cx2 * 3 * t(a, 1) * a * a + x2 * a * a * a;
+    const double yy = y * t(a, 3) + cy1 * 3 * t(a, 2) * a +
+                      cy2 * 3 * t(a, 1) * a * a + y2 * a * a * a;
     path.push_back(Eigen::Vector3d(xx, yy, 0));
   }
 }
@@ -191,8 +217,7 @@ path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double
  * Workaround for parsing ",1-23.16.88" where the number split
  * happens implicitly at the dot.
  */
-static std::vector<std::string> split_dots(const std::string& str)
-{
+static std::vector<std::string> split_dots(const std::string& str) {
   std::vector<std::string> result;
   const size_t n = std::count(str.begin(), str.end(), '.');
   if (n < 2) {
@@ -219,9 +244,7 @@ static std::vector<std::string> split_dots(const std::string& str)
   return result;
 }
 
-void
-path::set_attrs(attr_map_t& attrs, void *context)
-{
+void path::set_attrs(attr_map_t& attrs, void* context) {
   std::string commands = "-zmlcqahvstZMLCQAHVST";
 
   shape::set_attrs(attrs, context);
@@ -259,7 +282,6 @@ path::set_attrs(attr_map_t& attrs, void *context)
   std::string pre_exp;
   path_list.push_back(path_t());
   for (const auto& v : path_tokens) {
-
     double p = 0;
     if ((v.length() == 1) && (commands.find(v) != std::string::npos)) {
       if (v[0] == '-') {
@@ -285,240 +307,246 @@ path::set_attrs(attr_map_t& attrs, void *context)
     }
 
     switch (cmd) {
-    case 'a':
-    case 'A':
-      //(rx ry x-axis-rotation large-arc-flag sweep-flag x y)
-      switch (point) {
-      case 0:
-        rx = std::fabs(p);
-        break;
-      case 1:
-        ry = std::fabs(p);
-        break;
-      case 2:
-        angle = p;
-        break;
-      case 3:
-        large = p > 0.5;
-        break;
-      case 4:
-        sweep = p > 0.5;
-        break;
-      case 5:
-        xx = cmd == 'a' ? x + p : p;
-        break;
-      case 6:
-        yy = cmd == 'a' ? y + p : p;
-        arc_to(path_list.back(), x, y, rx, ry, xx, yy, angle, large, sweep, context);
-        x = xx;
-        y = yy;
-        point = -1;
-        last_cmd_cubic_bezier = false;
-        last_cmd_quadratic_bezier = false;
-        break;
-      }
-      break;
-    case 'l':
-    case 'L':
-      switch (point) {
-      case 0:
-        xx = cmd == 'l' ? x + p : p;
-        break;
-      case 1:
-        yy = cmd == 'l' ? y + p : p;
-        path_list.back().push_back(Eigen::Vector3d(xx, yy, 0));
-        x = xx;
-        y = yy;
-        point = -1;
-        last_cmd_cubic_bezier = false;
-        last_cmd_quadratic_bezier = false;
-        break;
-      }
-      break;
-    case 'c':
-    case 'C':
-      switch (point) {
-      case 0:
-        cx1 = p;
-        break;
-      case 1:
-        cy1 = p;
-        break;
-      case 2:
-        cx2 = p;
-        break;
-      case 3:
-        cy2 = p;
-        break;
-      case 4:
-        xx = cmd == 'c' ? x + p : p;
-        break;
-      case 5:
-        yy = cmd == 'c' ? y + p : p;
-        cx1 = cmd == 'c' ? x + cx1 : cx1;
-        cy1 = cmd == 'c' ? y + cy1 : cy1;
-        cx2 = cmd == 'c' ? x + cx2 : cx2;
-        cy2 = cmd == 'c' ? y + cy2 : cy2;
-        curve_to(path_list.back(), x, y, cx1, cy1, cx2, cy2, xx, yy, context);
-        x = xx;
-        y = yy;
-        point = -1;
-        last_cmd_cubic_bezier = true;
-        last_cmd_quadratic_bezier = false;
-        break;
-      }
-      break;
-    case 's':
-    case 'S':
-      switch (point) {
-      case 0:
-        if (last_cmd_cubic_bezier) {
-          Eigen::Vector2d old_control_point(cx2, cy2);
-          Eigen::Vector2d current_point(x, y);
-          Eigen::Vector2d new_control_point = current_point + (current_point - old_control_point);
-          cx1 = new_control_point.x();
-          cy1 = new_control_point.y();
-        } else {
-          cx1 = x;
-          cy1 = y;
+      case 'a':
+      case 'A':
+        //(rx ry x-axis-rotation large-arc-flag sweep-flag x y)
+        switch (point) {
+          case 0:
+            rx = std::fabs(p);
+            break;
+          case 1:
+            ry = std::fabs(p);
+            break;
+          case 2:
+            angle = p;
+            break;
+          case 3:
+            large = p > 0.5;
+            break;
+          case 4:
+            sweep = p > 0.5;
+            break;
+          case 5:
+            xx = cmd == 'a' ? x + p : p;
+            break;
+          case 6:
+            yy = cmd == 'a' ? y + p : p;
+            arc_to(path_list.back(), x, y, rx, ry, xx, yy, angle, large, sweep,
+                   context);
+            x = xx;
+            y = yy;
+            point = -1;
+            last_cmd_cubic_bezier = false;
+            last_cmd_quadratic_bezier = false;
+            break;
         }
-        cx2 = p;
-        break;
-      case 1:
-        cy2 = p;
-        break;
-      case 2:
-        xx = cmd == 's' ? x + p : p;
         break;
-      case 3:
-        yy = cmd == 's' ? y + p : p;
-        cx2 = cmd == 's' ? x + cx2 : cx2;
-        cy2 = cmd == 's' ? y + cy2 : cy2;
-        curve_to(path_list.back(), x, y, cx1, cy1, cx2, cy2, xx, yy, context);
-        x = xx;
-        y = yy;
-        point = -1;
-        last_cmd_cubic_bezier = true;
-        last_cmd_quadratic_bezier = false;
+      case 'l':
+      case 'L':
+        switch (point) {
+          case 0:
+            xx = cmd == 'l' ? x + p : p;
+            break;
+          case 1:
+            yy = cmd == 'l' ? y + p : p;
+            path_list.back().push_back(Eigen::Vector3d(xx, yy, 0));
+            x = xx;
+            y = yy;
+            point = -1;
+            last_cmd_cubic_bezier = false;
+            last_cmd_quadratic_bezier = false;
+            break;
+        }
         break;
-      }
-      break;
-    case 'q':
-    case 'Q':
-      switch (point) {
-      case 0:
-        cx1 = p;
+      case 'c':
+      case 'C':
+        switch (point) {
+          case 0:
+            cx1 = p;
+            break;
+          case 1:
+            cy1 = p;
+            break;
+          case 2:
+            cx2 = p;
+            break;
+          case 3:
+            cy2 = p;
+            break;
+          case 4:
+            xx = cmd == 'c' ? x + p : p;
+            break;
+          case 5:
+            yy = cmd == 'c' ? y + p : p;
+            cx1 = cmd == 'c' ? x + cx1 : cx1;
+            cy1 = cmd == 'c' ? y + cy1 : cy1;
+            cx2 = cmd == 'c' ? x + cx2 : cx2;
+            cy2 = cmd == 'c' ? y + cy2 : cy2;
+            curve_to(path_list.back(), x, y, cx1, cy1, cx2, cy2, xx, yy,
+                     context);
+            x = xx;
+            y = yy;
+            point = -1;
+            last_cmd_cubic_bezier = true;
+            last_cmd_quadratic_bezier = false;
+            break;
+        }
         break;
-      case 1:
-        cy1 = p;
+      case 's':
+      case 'S':
+        switch (point) {
+          case 0:
+            if (last_cmd_cubic_bezier) {
+              Eigen::Vector2d old_control_point(cx2, cy2);
+              Eigen::Vector2d current_point(x, y);
+              Eigen::Vector2d new_control_point =
+                  current_point + (current_point - old_control_point);
+              cx1 = new_control_point.x();
+              cy1 = new_control_point.y();
+            } else {
+              cx1 = x;
+              cy1 = y;
+            }
+            cx2 = p;
+            break;
+          case 1:
+            cy2 = p;
+            break;
+          case 2:
+            xx = cmd == 's' ? x + p : p;
+            break;
+          case 3:
+            yy = cmd == 's' ? y + p : p;
+            cx2 = cmd == 's' ? x + cx2 : cx2;
+            cy2 = cmd == 's' ? y + cy2 : cy2;
+            curve_to(path_list.back(), x, y, cx1, cy1, cx2, cy2, xx, yy,
+                     context);
+            x = xx;
+            y = yy;
+            point = -1;
+            last_cmd_cubic_bezier = true;
+            last_cmd_quadratic_bezier = false;
+            break;
+        }
         break;
-      case 2:
-        xx = cmd == 'q' ? x + p : p;
+      case 'q':
+      case 'Q':
+        switch (point) {
+          case 0:
+            cx1 = p;
+            break;
+          case 1:
+            cy1 = p;
+            break;
+          case 2:
+            xx = cmd == 'q' ? x + p : p;
+            break;
+          case 3:
+            yy = cmd == 'q' ? y + p : p;
+            cx1 = cmd == 'q' ? x + cx1 : cx1;
+            cy1 = cmd == 'q' ? y + cy1 : cy1;
+            curve_to(path_list.back(), x, y, cx1, cy1, xx, yy, context);
+            x = xx;
+            y = yy;
+            point = -1;
+            last_cmd_cubic_bezier = false;
+            last_cmd_quadratic_bezier = true;
+            break;
+        }
         break;
-      case 3:
-        yy = cmd == 'q' ? y + p : p;
-        cx1 = cmd == 'q' ? x + cx1 : cx1;
-        cy1 = cmd == 'q' ? y + cy1 : cy1;
-        curve_to(path_list.back(), x, y, cx1, cy1, xx, yy, context);
-        x = xx;
-        y = yy;
-        point = -1;
-        last_cmd_cubic_bezier = false;
-        last_cmd_quadratic_bezier = true;
+      case 't':
+      case 'T':
+        switch (point) {
+          case 0:
+            if (last_cmd_quadratic_bezier) {
+              Eigen::Vector2d old_control_point(cx1, cy1);
+              Eigen::Vector2d current_point(x, y);
+              Eigen::Vector2d new_control_point =
+                  current_point + (current_point - old_control_point);
+              cx1 = new_control_point.x();
+              cy1 = new_control_point.y();
+            } else {
+              cx1 = x;
+              cy1 = y;
+            }
+            xx = cmd == 't' ? x + p : p;
+            break;
+          case 1:
+            yy = cmd == 't' ? y + p : p;
+            curve_to(path_list.back(), x, y, cx1, cy1, xx, yy, context);
+            x = xx;
+            y = yy;
+            point = -1;
+            last_cmd_cubic_bezier = false;
+            last_cmd_quadratic_bezier = true;
+            break;
+        }
         break;
-      }
-      break;
-    case 't':
-    case 'T':
-      switch (point) {
-      case 0:
-        if (last_cmd_quadratic_bezier) {
-          Eigen::Vector2d old_control_point(cx1, cy1);
-          Eigen::Vector2d current_point(x, y);
-          Eigen::Vector2d new_control_point = current_point + (current_point - old_control_point);
-          cx1 = new_control_point.x();
-          cy1 = new_control_point.y();
-        } else {
-          cx1 = x;
-          cy1 = y;
+      case 'm':
+      case 'M':
+        switch (point) {
+          case 0:
+            xx = cmd == 'm' ? x + p : p;
+            break;
+          case 1:
+            yy = cmd == 'm' ? y + p : p;
+            cmd = cmd == 'm' ? 'l' : 'L';
+
+            path_t path = path_list.back();
+            if (!path_list.back().empty()) {
+              if (is_open_path(path)) {
+                path_list.pop_back();
+                offset_path(path_list, path, get_stroke_width(),
+                            get_stroke_linecap());
+              }
+              path_list.push_back(path_t());
+            }
+
+            path_list.back().push_back(Eigen::Vector3d(xx, yy, 0));
+            x = xx;
+            y = yy;
+            point = -1;
+            last_cmd_cubic_bezier = false;
+            last_cmd_quadratic_bezier = false;
         }
-        xx = cmd == 't' ? x + p : p;
         break;
-      case 1:
-        yy = cmd == 't' ? y + p : p;
-        curve_to(path_list.back(), x, y, cx1, cy1, xx, yy, context);
-        x = xx;
-        y = yy;
-        point = -1;
-        last_cmd_cubic_bezier = false;
-        last_cmd_quadratic_bezier = true;
+      case 'v':
+      case 'V':
+        switch (point) {
+          case 0:
+            y = cmd == 'v' ? y + p : p;
+            path_list.back().push_back(Eigen::Vector3d(x, y, 0));
+            point = -1;
+            last_cmd_cubic_bezier = false;
+            last_cmd_quadratic_bezier = false;
+            break;
+        }
         break;
-      }
-      break;
-    case 'm':
-    case 'M':
-      switch (point) {
-      case 0:
-        xx = cmd == 'm' ? x + p : p;
+      case 'h':
+      case 'H':
+        switch (point) {
+          case 0:
+            x = cmd == 'h' ? x + p : p;
+            path_list.back().push_back(Eigen::Vector3d(x, y, 0));
+            point = -1;
+            last_cmd_cubic_bezier = false;
+            last_cmd_quadratic_bezier = false;
+            break;
+        }
         break;
-      case 1:
-        yy = cmd == 'm' ? y + p : p;
-        cmd = cmd == 'm' ? 'l' : 'L';
-
-        path_t path = path_list.back();
+      case 'z':
+      case 'Z':
         if (!path_list.back().empty()) {
-          if (is_open_path(path)) {
-            path_list.pop_back();
-            offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
-          }
-          path_list.push_back(path_t());
+          Eigen::Vector3d p = path_list.back()[0];
+          path_list.back().push_back(p);
+          x = p.x();
+          y = p.y();
         }
-
-        path_list.back().push_back(Eigen::Vector3d(xx, yy, 0));
-        x = xx;
-        y = yy;
-        point = -1;
-        last_cmd_cubic_bezier = false;
-        last_cmd_quadratic_bezier = false;
-      }
-      break;
-    case 'v':
-    case 'V':
-      switch (point) {
-      case 0:
-        y = cmd == 'v' ? y + p : p;
-        path_list.back().push_back(Eigen::Vector3d(x, y, 0));
-        point = -1;
-        last_cmd_cubic_bezier = false;
-        last_cmd_quadratic_bezier = false;
-        break;
-      }
-      break;
-    case 'h':
-    case 'H':
-      switch (point) {
-      case 0:
-        x = cmd == 'h' ? x + p : p;
-        path_list.back().push_back(Eigen::Vector3d(x, y, 0));
-        point = -1;
+        path_list.push_back(path_t());
+        path_closed = true;
         last_cmd_cubic_bezier = false;
         last_cmd_quadratic_bezier = false;
         break;
-      }
-      break;
-    case 'z':
-    case 'Z':
-      if (!path_list.back().empty()) {
-        Eigen::Vector3d p = path_list.back()[0];
-        path_list.back().push_back(p);
-        x = p.x();
-        y = p.y();
-      }
-      path_list.push_back(path_t());
-      path_closed = true;
-      last_cmd_cubic_bezier = false;
-      last_cmd_quadratic_bezier = false;
-      break;
     }
 
     point++;
@@ -537,22 +565,18 @@ path::set_attrs(attr_map_t& attrs, void *context)
   }
 }
 
-bool
-path::is_open_path(path_t& path) const
-{
+bool path::is_open_path(path_t& path) const {
   const Eigen::Vector3d& p1 = path[0];
   const Eigen::Vector3d& p2 = path.back();
-  double distance = pow(pow(p1.x() - p2.x(), 2) + pow(p1.y() - p2.y(), 2) + pow(p1.z() - p2.z(), 2), 0.5);
+  double distance = pow(pow(p1.x() - p2.x(), 2) + pow(p1.y() - p2.y(), 2) +
+                            pow(p1.z() - p2.z(), 2),
+                        0.5);
   return distance > 0.1;
 }
 
-const std::string
-path::dump() const
-{
+const std::string path::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ", y = " << this->y;
+  s << get_name() << ": x = " << this->x << ", y = " << this->y;
   for (const auto& p : path_list) {
     s << "[";
     for (const auto& v : p) {
@@ -563,4 +587,4 @@ path::dump() const
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/path.h b/src/libsvg/path.h
index 87afec19b..27ec09052 100644
--- a/src/libsvg/path.h
+++ b/src/libsvg/path.h
@@ -30,31 +30,58 @@
 
 namespace libsvg {
 
-class path : public shape
-{
-protected:
+class path : public shape {
+ protected:
   std::string data;
 
-private:
+ private:
   [[nodiscard]] inline double t(double t, int exp) const {
     return std::pow(1.0 - t, exp);
   }
 
   bool is_open_path(path_t& path) const;
-  void arc_to(path_t& path, double x, double y, double rx, double ry, double x2, double y2, double angle, bool large, bool sweep, void *context);
-  void curve_to(path_t& path, double x, double y, double cx1, double cy1, double x2, double y2, void *context);
-  void curve_to(path_t& path, double x, double y, double cx1, double cy1, double cx2, double cy2, double x2, double y2, void *context);
+  void arc_to(path_t& path,
+              double x,
+              double y,
+              double rx,
+              double ry,
+              double x2,
+              double y2,
+              double angle,
+              bool large,
+              bool sweep,
+              void* context);
+  void curve_to(path_t& path,
+                double x,
+                double y,
+                double cx1,
+                double cy1,
+                double x2,
+                double y2,
+                void* context);
+  void curve_to(path_t& path,
+                double x,
+                double y,
+                double cx1,
+                double cy1,
+                double cx2,
+                double cy2,
+                double x2,
+                double y2,
+                void* context);
 
-public:
+ public:
   path() = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return path::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return path::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new path(*this); }
+  [[nodiscard]] shape* clone() const override { return new path(*this); }
 };
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/polygon.cc b/src/libsvg/polygon.cc
index 4dc8aee04..724794963 100644
--- a/src/libsvg/polygon.cc
+++ b/src/libsvg/polygon.cc
@@ -34,9 +34,7 @@ namespace libsvg {
 
 const std::string polygon::name("polygon");
 
-void
-polygon::set_attrs(attr_map_t& attrs, void *context)
-{
+void polygon::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->points = attrs["points"];
 
@@ -63,4 +61,4 @@ polygon::set_attrs(attr_map_t& attrs, void *context)
   path_list.push_back(path);
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/polygon.h b/src/libsvg/polygon.h
index c78299da3..0669b29f9 100644
--- a/src/libsvg/polygon.h
+++ b/src/libsvg/polygon.h
@@ -29,20 +29,21 @@
 
 namespace libsvg {
 
-class polygon : public shape
-{
-private:
+class polygon : public shape {
+ private:
   std::string points;
 
-public:
+ public:
   polygon() = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string& get_name() const override { return polygon::name; }
+  void set_attrs(attr_map_t& attrs, void* context) override;
+  [[nodiscard]] const std::string& get_name() const override {
+    return polygon::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new polygon(*this); }
+  [[nodiscard]] shape* clone() const override { return new polygon(*this); }
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/polyline.cc b/src/libsvg/polyline.cc
index 00e038448..01a099f4c 100644
--- a/src/libsvg/polyline.cc
+++ b/src/libsvg/polyline.cc
@@ -33,9 +33,7 @@ namespace libsvg {
 
 const std::string polyline::name("polyline");
 
-void
-polyline::set_attrs(attr_map_t& attrs, void *context)
-{
+void polyline::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->points = attrs["points"];
 
@@ -60,4 +58,4 @@ polyline::set_attrs(attr_map_t& attrs, void *context)
   offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/polyline.h b/src/libsvg/polyline.h
index 56e47e694..28e6aa8ca 100644
--- a/src/libsvg/polyline.h
+++ b/src/libsvg/polyline.h
@@ -29,20 +29,21 @@
 
 namespace libsvg {
 
-class polyline : public shape
-{
-private:
+class polyline : public shape {
+ private:
   std::string points;
 
-public:
+ public:
   polyline() = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string& get_name() const override { return polyline::name; }
+  void set_attrs(attr_map_t& attrs, void* context) override;
+  [[nodiscard]] const std::string& get_name() const override {
+    return polyline::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new polyline(*this); }
+  [[nodiscard]] shape* clone() const override { return new polyline(*this); }
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/rect.cc b/src/libsvg/rect.cc
index 4732d8907..5b06f9339 100644
--- a/src/libsvg/rect.cc
+++ b/src/libsvg/rect.cc
@@ -24,10 +24,10 @@
  */
 #include "libsvg/rect.h"
 
-#include <sstream>
+#include <cmath>
 #include <cstdlib>
 #include <iostream>
-#include <cmath>
+#include <sstream>
 #include <string>
 
 #include <boost/format.hpp>
@@ -63,9 +63,9 @@ const std::string rect::name("rect");
  * rx is the effective value of the rx attribute converted to user space
  * and y is the value of the y attribute converted to user space
  *
- * 2) perform an absolute horizontal lineto operation to location (x+width-rx,y),
- * where width is the rect element's width attribute converted to user
- * space
+ * 2) perform an absolute horizontal lineto operation to location
+ * (x+width-rx,y), where width is the rect element's width attribute
+ * converted to user space
  *
  * 3) perform an absolute elliptical arc operation to coordinate (x+width,y+ry),
  * where the effective values for the rx and ry attributes on the rect
@@ -78,7 +78,8 @@ const std::string rect::name("rect");
  * where height is the rect element's height attribute converted to user
  * space
  *
- * 5) perform an absolute elliptical arc operation to coordinate (x+width-rx,y+height)
+ * 5) perform an absolute elliptical arc operation to coordinate
+ * (x+width-rx,y+height)
  *
  * 6) perform an absolute horizontal lineto to location (x+rx,y+height)
  *
@@ -88,10 +89,8 @@ const std::string rect::name("rect");
  *
  * 9) perform an absolute elliptical arc operation to coordinate (x+rx,y)
  */
-void
-rect::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context); // NOLINT(bugprone-parent-virtual-call)
+void rect::set_attrs(attr_map_t& attrs, void* context) {
+  shape::set_attrs(attrs, context);  // NOLINT(bugprone-parent-virtual-call)
   this->x = parse_double(attrs["x"]);
   this->y = parse_double(attrs["y"]);
   this->width = parse_double(attrs["width"]);
@@ -115,50 +114,41 @@ rect::set_attrs(attr_map_t& attrs, void *context)
       this->ry = this->height / 2;
     }
 
-    std::string path = boost::str(boost::format(""
-                                                "M %1%,%2% "
-                                                "H %3% "
-                                                "A %4%,%5% 0 0,1 %6%,%7% "
-                                                "V %8% "
-                                                "A %9%,%10% 0 0,1 %11%,%12% "
-                                                "H %13% "
-                                                "A %14%,%15% 0 0,1 %16%,%17% "
-                                                "V %18% "
-                                                "A %19%,%20% 0 0,1 %21%,%22% "
-                                                "z")
-                                  % (x + rx) % y
-                                  % (x + width - rx)
-                                  % rx % ry % (x + width) % (y + ry)
-                                  % (y + height - ry)
-                                  % rx % ry % (x + width - rx) % (y + height)
-                                  % (x + rx)
-                                  % rx % ry % x % (y + height - ry)
-                                  % (y + ry)
-                                  % rx % ry % (x + rx) % y
-                                  );
+    std::string path =
+        boost::str(boost::format(""
+                                 "M %1%,%2% "
+                                 "H %3% "
+                                 "A %4%,%5% 0 0,1 %6%,%7% "
+                                 "V %8% "
+                                 "A %9%,%10% 0 0,1 %11%,%12% "
+                                 "H %13% "
+                                 "A %14%,%15% 0 0,1 %16%,%17% "
+                                 "V %18% "
+                                 "A %19%,%20% 0 0,1 %21%,%22% "
+                                 "z") %
+                   (x + rx) % y % (x + width - rx) % rx % ry % (x + width) %
+                   (y + ry) % (y + height - ry) % rx % ry % (x + width - rx) %
+                   (y + height) % (x + rx) % rx % ry % x % (y + height - ry) %
+                   (y + ry) % rx % ry % (x + rx) % y);
     attrs["d"] = path;
     path::set_attrs(attrs, context);
   } else {
     path_t path;
     path.push_back(Eigen::Vector3d(get_x(), get_y(), 0));
     path.push_back(Eigen::Vector3d(get_x() + get_width(), get_y(), 0));
-    path.push_back(Eigen::Vector3d(get_x() + get_width(), get_y() + get_height(), 0));
+    path.push_back(
+        Eigen::Vector3d(get_x() + get_width(), get_y() + get_height(), 0));
     path.push_back(Eigen::Vector3d(get_x(), get_y() + get_height(), 0));
     path.push_back(Eigen::Vector3d(get_x(), get_y(), 0));
     path_list.push_back(path);
   }
 }
 
-const std::string
-rect::dump() const
-{
+const std::string rect::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": width = " << this->width
-    << ": height = " << this->height;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": width = " << this->width << ": height = " << this->height;
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/rect.h b/src/libsvg/rect.h
index 7130ea178..e9285dedf 100644
--- a/src/libsvg/rect.h
+++ b/src/libsvg/rect.h
@@ -29,15 +29,14 @@
 
 namespace libsvg {
 
-class rect : public path
-{
-protected:
+class rect : public path {
+ protected:
   double width{0};
   double height{0};
   double rx{0};
   double ry{0};
 
-public:
+ public:
   rect() = default;
 
   [[nodiscard]] double get_width() const { return width; }
@@ -45,11 +44,13 @@ public:
   [[nodiscard]] double get_rx() const { return rx; }
   [[nodiscard]] double get_ry() const { return ry; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return rect::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return rect::name;
+  }
 
   static const std::string name;
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/shape.cc b/src/libsvg/shape.cc
index 515aac3c5..e4c8ebea8 100644
--- a/src/libsvg/shape.cc
+++ b/src/libsvg/shape.cc
@@ -24,43 +24,41 @@
  */
 #include "libsvg/shape.h"
 
+#include <cmath>
+#include <cstdio>
 #include <iostream>
 #include <memory>
-#include <cstdio>
-#include <cmath>
 #include <string>
 #include <vector>
 
-#include <boost/tokenizer.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/spirit/include/qi.hpp>
+#include <boost/tokenizer.hpp>
 
 #include <clipper2/clipper.offset.h>
 
 #include "geometry/ClipperUtils.h"
 #include "libsvg/circle.h"
+#include "libsvg/data.h"
 #include "libsvg/ellipse.h"
+#include "libsvg/group.h"
 #include "libsvg/line.h"
-#include "libsvg/text.h"
-#include "libsvg/tspan.h"
-#include "libsvg/data.h"
+#include "libsvg/path.h"
 #include "libsvg/polygon.h"
 #include "libsvg/polyline.h"
 #include "libsvg/rect.h"
 #include "libsvg/svgpage.h"
-#include "libsvg/path.h"
-#include "libsvg/group.h"
+#include "libsvg/text.h"
+#include "libsvg/tspan.h"
 #include "libsvg/use.h"
 
 #include "libsvg/transformation.h"
-#include "utils/degree_trig.h"
 #include "utils/calc.h"
+#include "utils/degree_trig.h"
 
 namespace libsvg {
 
-shape *
-shape::create_from_name(const char *name)
-{
+shape* shape::create_from_name(const char* name) {
   if (circle::name == name) {
     return new circle();
   } else if (ellipse::name == name) {
@@ -92,9 +90,7 @@ shape::create_from_name(const char *name)
   }
 }
 
-void
-shape::set_attrs(attr_map_t& attrs, void *context)
-{
+void shape::set_attrs(attr_map_t& attrs, void* context) {
   if (attrs.find("id") != attrs.end()) {
     this->id = attrs["id"];
   }
@@ -116,17 +112,16 @@ shape::set_attrs(attr_map_t& attrs, void *context)
   }
 
   const std::string inkscape_groupmode = attrs["inkscape:groupmode"];
-  if (inkscape_groupmode == "layer" && attrs.find("inkscape:label") != attrs.end()) {
+  if (inkscape_groupmode == "layer" &&
+      attrs.find("inkscape:label") != attrs.end()) {
     this->layer = attrs["inkscape:label"];
   }
 
-  const auto *ctx = reinterpret_cast<const fnContext *>(context);
+  const auto* ctx = reinterpret_cast<const fnContext*>(context);
   selected = (ctx->selector) ? ctx->selector(this) : false;
 }
 
-const std::string
-shape::get_style(const std::string& name) const
-{
+const std::string shape::get_style(const std::string& name) const {
   std::vector<std::string> styles;
   boost::split(styles, this->style, boost::is_any_of(";"));
 
@@ -145,9 +140,7 @@ shape::get_style(const std::string& name) const
   return std::string();
 }
 
-double
-shape::get_stroke_width() const
-{
+double shape::get_stroke_width() const {
   double stroke_width;
   if (this->stroke_width.empty()) {
     stroke_width = parse_double(get_style("stroke-width"));
@@ -157,9 +150,7 @@ shape::get_stroke_width() const
   return stroke_width < 0.01 ? 1 : stroke_width;
 }
 
-Clipper2Lib::EndType
-shape::get_stroke_linecap() const
-{
+Clipper2Lib::EndType shape::get_stroke_linecap() const {
   std::string cap;
   if (this->stroke_linecap.empty()) {
     cap = get_style("stroke-linecap");
@@ -177,9 +168,7 @@ shape::get_stroke_linecap() const
   return Clipper2Lib::EndType::Butt;
 }
 
-Clipper2Lib::JoinType
-shape::get_stroke_linejoin() const
-{
+Clipper2Lib::JoinType shape::get_stroke_linejoin() const {
   std::string join;
   if (this->stroke_linejoin.empty()) {
     join = get_style("stroke-linejoin");
@@ -196,9 +185,8 @@ shape::get_stroke_linejoin() const
   return Clipper2Lib::JoinType::Miter;
 }
 
-void
-shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape *s)
-{
+void shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices,
+                                       shape* s) {
   std::string transform_arg(s->transform);
 
   boost::replace_all(transform_arg, "matrix", "m");
@@ -214,8 +202,8 @@ shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape
   boost::char_separator<char> sep(" ,()", commands.c_str());
   tokenizer tokens(transform_arg, sep);
 
-  transformation *t = nullptr;
-  std::vector<transformation *> transformations;
+  transformation* t = nullptr;
+  std::vector<transformation*> transformations;
   for (const auto& v : tokens) {
     if ((v.length() == 1) && (commands.find(v) != std::string::npos)) {
       if (t != nullptr) {
@@ -223,27 +211,27 @@ shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape
         t = nullptr;
       }
       switch (v[0]) {
-      case 'm':
-        t = new matrix();
-        break;
-      case 't':
-        t = new translate();
-        break;
-      case 's':
-        t = new scale();
-        break;
-      case 'r':
-        t = new rotate();
-        break;
-      case 'x':
-        t = new skew_x();
-        break;
-      case 'y':
-        t = new skew_y();
-        break;
-      default:
-        std::cout << "unknown transform op " << v << std::endl;
-        t = nullptr;
+        case 'm':
+          t = new matrix();
+          break;
+        case 't':
+          t = new translate();
+          break;
+        case 's':
+          t = new scale();
+          break;
+        case 'r':
+          t = new rotate();
+          break;
+        case 'x':
+          t = new skew_x();
+          break;
+        case 'y':
+          t = new skew_y();
+          break;
+        default:
+          std::cout << "unknown transform op " << v << std::endl;
+          t = nullptr;
       }
     } else {
       if (t) {
@@ -256,28 +244,26 @@ shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape
   }
 
   for (auto it = transformations.rbegin(); it != transformations.rend(); ++it) {
-    transformation *t = *it;
+    transformation* t = *it;
     std::vector<Eigen::Matrix3d> m = t->get_matrices();
     matrices.insert(matrices.begin(), m.rbegin(), m.rend());
     delete t;
   }
 }
 
-bool
-shape::is_excluded() const
-{
-  for (const shape *s = this; s != nullptr; s = s->get_parent()) {
-    if (s->selected) return false;
-    if (s->excluded) return true;
+bool shape::is_excluded() const {
+  for (const shape* s = this; s != nullptr; s = s->get_parent()) {
+    if (s->selected)
+      return false;
+    if (s->excluded)
+      return true;
   }
   return true;
 }
 
-void
-shape::apply_transform()
-{
+void shape::apply_transform() {
   std::vector<Eigen::Matrix3d> matrices;
-  for (shape *s = this; s->get_parent() != nullptr; s = s->get_parent()) {
+  for (shape* s = this; s->get_parent() != nullptr; s = s->get_parent()) {
     collect_transform_matrices(matrices, s);
   }
 
@@ -296,8 +282,10 @@ shape::apply_transform()
   path_list = result_list;
 }
 
-void
-shape::offset_path(path_list_t& path_list, path_t& path, double stroke_width, Clipper2Lib::EndType stroke_linecap) {
+void shape::offset_path(path_list_t& path_list,
+                        path_t& path,
+                        double stroke_width,
+                        Clipper2Lib::EndType stroke_linecap) {
   const int scale_bits = ClipperUtils::scaleBitsFromPrecision();
   const double scale = std::ldexp(1.0, scale_bits);
 
@@ -314,18 +302,26 @@ shape::offset_path(path_list_t& path_list, path_t& path, double stroke_width, Cl
   for (const auto& p : result) {
     path_list.push_back(path_t());
     for (const auto& point : p) {
-      path_list.back().push_back(Eigen::Vector3d(point.x / scale, point.y / scale, 0));
+      path_list.back().push_back(
+          Eigen::Vector3d(point.x / scale, point.y / scale, 0));
     }
-    path_list.back().push_back(Eigen::Vector3d(p[0].x / scale, p[0].y / scale, 0));
+    path_list.back().push_back(
+        Eigen::Vector3d(p[0].x / scale, p[0].y / scale, 0));
   }
 }
 
-void
-shape::draw_ellipse(path_t& path, double x, double y, double rx, double ry, void *context) {
-  const auto *fValues = reinterpret_cast<const fnContext *>(context);
+void shape::draw_ellipse(path_t& path,
+                         double x,
+                         double y,
+                         double rx,
+                         double ry,
+                         void* context) {
+  const auto* fValues = reinterpret_cast<const fnContext*>(context);
   double rmax = fmax(rx, ry);
-  unsigned long fn = Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
-  if (fn < 40) fn = 40;   // preserve the old minimum value
+  unsigned long fn =
+      Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
+  if (fn < 40)
+    fn = 40;  // preserve the old minimum value
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * 360.0 / fn;
     const double xx = rx * sin_degrees(a) + x;
@@ -334,24 +330,24 @@ shape::draw_ellipse(path_t& path, double x, double y, double rx, double ry, void
   }
 }
 
-std::vector<std::shared_ptr<shape>>
-shape::clone_children() {
+std::vector<std::shared_ptr<shape>> shape::clone_children() {
   std::vector<std::shared_ptr<shape>> ret_vector;
-  std::vector<shape *> children_backup = this->get_children();
+  std::vector<shape*> children_backup = this->get_children();
   this->children.clear();
   for (const auto& c : children_backup) {
-    shape *clone = c->clone();
+    shape* clone = c->clone();
     this->add_child(clone);
     auto cloned_children = clone->clone_children();
     ret_vector.push_back(std::shared_ptr<shape>(clone));
-    ret_vector.insert(ret_vector.end(), cloned_children.begin(), cloned_children.end());
+    ret_vector.insert(ret_vector.end(), cloned_children.begin(),
+                      cloned_children.end());
   }
   return ret_vector;
 }
 
-std::ostream& operator<<(std::ostream& os, const shape& s)
-{
-  return os << s.dump() << " | id = '" << s.id.value_or("") << "', transform = '" << s.transform << "'";
+std::ostream& operator<<(std::ostream& os, const shape& s) {
+  return os << s.dump() << " | id = '" << s.id.value_or("")
+            << "', transform = '" << s.transform << "'";
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/shape.h b/src/libsvg/shape.h
index 183bc49b0..29df9ddcb 100644
--- a/src/libsvg/shape.h
+++ b/src/libsvg/shape.h
@@ -24,12 +24,12 @@
  */
 #pragma once
 
-#include <map>
 #include <atomic>
+#include <functional>
+#include <map>
+#include <memory>
 #include <string>
 #include <vector>
-#include <memory>
-#include <functional>
 
 #include <iostream>
 
@@ -44,19 +44,24 @@ namespace libsvg {
 class shape;
 }
 
-// ccox - I don't like putting this here, but the svg library code did not plan ahead for app customization.
-// And this is one of the few sensible places to put it without adding new header files.
+// ccox - I don't like putting this here, but the svg library code did not plan
+// ahead for app customization. And this is one of the few sensible places to
+// put it without adding new header files.
 struct fnContext {
-  fnContext(double fNN, double fSS, double fAA) : fn(fNN), fs(fSS), fa(fAA) {
+  fnContext(double fNN, double fSS, double fAA) : fn(fNN), fs(fSS), fa(fAA) {}
+  bool match(bool val) {
+    if (val)
+      matches++;
+    return val;
   }
-  bool match(bool val) { if (val) matches++; return val; }
   bool has_matches() { return matches.load() > 0; }
 
   double fn;
   double fs;
   double fa;
-  std::function<bool (const libsvg::shape *)> selector;
-private:
+  std::function<bool(const libsvg::shape*)> selector;
+
+ private:
   std::atomic<int> matches{0};
 };
 
@@ -66,13 +71,12 @@ using path_t = std::vector<Eigen::Vector3d>;
 using path_list_t = std::vector<path_t>;
 using attr_map_t = std::map<std::string, std::string>;
 
-class shape
-{
-private:
-  shape *parent{nullptr};
-  std::vector<shape *> children;
+class shape {
+ private:
+  shape* parent{nullptr};
+  std::vector<shape*> children;
 
-protected:
+ protected:
   boost::optional<std::string> id;
   boost::optional<std::string> layer;
   double x{0};
@@ -90,28 +94,51 @@ protected:
   [[nodiscard]] Clipper2Lib::EndType get_stroke_linecap() const;
   [[nodiscard]] Clipper2Lib::JoinType get_stroke_linejoin() const;
   [[nodiscard]] const std::string get_style(const std::string& name) const;
-  void draw_ellipse(path_t& path, double x, double y, double rx, double ry, void *context);
-  void offset_path(path_list_t& path_list, path_t& path, double stroke_width, Clipper2Lib::EndType stroke_linecap);
-  void collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape *s);
-
-public:
+  void draw_ellipse(path_t& path,
+                    double x,
+                    double y,
+                    double rx,
+                    double ry,
+                    void* context);
+  void offset_path(path_list_t& path_list,
+                   path_t& path,
+                   double stroke_width,
+                   Clipper2Lib::EndType stroke_linecap);
+  void collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices,
+                                  shape* s);
+
+ public:
   shape() = default;
   virtual ~shape() = default;
 
-  [[nodiscard]] virtual shape *get_parent() const { return parent; }
-  virtual void set_parent(shape *s) { parent = s; }
-  virtual void add_child(shape *s) { children.push_back(s); s->set_parent(this); }
-  [[nodiscard]] virtual const std::vector<shape *>& get_children() const { return children; }
+  [[nodiscard]] virtual shape* get_parent() const { return parent; }
+  virtual void set_parent(shape* s) { parent = s; }
+  virtual void add_child(shape* s) {
+    children.push_back(s);
+    s->set_parent(this);
+  }
+  [[nodiscard]] virtual const std::vector<shape*>& get_children() const {
+    return children;
+  }
 
   [[nodiscard]] virtual bool has_id() const { return id.is_initialized(); }
   [[nodiscard]] virtual const std::string& get_id() const { return id.get(); }
-  [[nodiscard]] virtual const std::string get_id_or_default(const std::string& def = "") const { return id.get_value_or(def); }
-  [[nodiscard]] virtual bool has_layer() const { return layer.is_initialized(); }
-  [[nodiscard]] virtual const std::string& get_layer() const { return layer.get(); }
+  [[nodiscard]] virtual const std::string get_id_or_default(
+      const std::string& def = "") const {
+    return id.get_value_or(def);
+  }
+  [[nodiscard]] virtual bool has_layer() const {
+    return layer.is_initialized();
+  }
+  [[nodiscard]] virtual const std::string& get_layer() const {
+    return layer.get();
+  }
   [[nodiscard]] virtual double get_x() const { return x; }
   [[nodiscard]] virtual double get_y() const { return y; }
 
-  [[nodiscard]] virtual const path_list_t& get_path_list() const { return path_list; }
+  [[nodiscard]] virtual const path_list_t& get_path_list() const {
+    return path_list;
+  }
 
   [[nodiscard]] virtual bool is_excluded() const;
   [[nodiscard]] virtual bool is_container() const { return false; }
@@ -119,16 +146,16 @@ public:
   virtual void apply_transform();
 
   [[nodiscard]] virtual const std::string& get_name() const = 0;
-  virtual void set_attrs(attr_map_t& attrs, void *context);
+  virtual void set_attrs(attr_map_t& attrs, void* context);
   [[nodiscard]] virtual const std::string dump() const { return ""; }
 
-  static shape *create_from_name(const char *name);
+  static shape* create_from_name(const char* name);
 
-  [[nodiscard]] virtual shape *clone() const = 0;
+  [[nodiscard]] virtual shape* clone() const = 0;
   std::vector<std::shared_ptr<shape>> clone_children();
 
-private:
+ private:
   friend std::ostream& operator<<(std::ostream& os, const shape& s);
 };
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/svgpage.cc b/src/libsvg/svgpage.cc
index 5401dd64a..17e237598 100644
--- a/src/libsvg/svgpage.cc
+++ b/src/libsvg/svgpage.cc
@@ -24,23 +24,19 @@
  */
 #include "libsvg/svgpage.h"
 
-#include <sstream>
 #include <cstdlib>
-#include <string>
 #include <iostream>
-
+#include <sstream>
+#include <string>
 
 namespace libsvg {
 
 const std::string svgpage::name("svg");
 
-svgpage::svgpage() : width({0.0, unit_t::UNDEFINED}), height({0.0, unit_t::UNDEFINED})
-{
-}
+svgpage::svgpage()
+    : width({0.0, unit_t::UNDEFINED}), height({0.0, unit_t::UNDEFINED}) {}
 
-void
-svgpage::set_attrs(attr_map_t& attrs, void *context)
-{
+void svgpage::set_attrs(attr_map_t& attrs, void* context) {
   this->x = 0;
   this->y = 0;
   this->width = parse_length(attrs["width"]);
@@ -48,28 +44,20 @@ svgpage::set_attrs(attr_map_t& attrs, void *context)
   this->viewbox = parse_viewbox(attrs["viewBox"]);
   this->alignment = parse_alignment(attrs["preserveAspectRatio"]);
 
-  const auto *ctx = reinterpret_cast<const fnContext *>(context);
+  const auto* ctx = reinterpret_cast<const fnContext*>(context);
   selected = (ctx->selector) ? ctx->selector(this) : false;
 }
 
-const std::string
-svgpage::dump() const
-{
+const std::string svgpage::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": width = " << this->width
-    << ": height = " << this->height
-    << ": viewbox = " << this->viewbox.x
-    << "," << this->viewbox.y
-    << "," << this->viewbox.width
-    << "," << this->viewbox.height
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": width = " << this->width << ": height = " << this->height
+    << ": viewbox = " << this->viewbox.x << "," << this->viewbox.y << ","
+    << this->viewbox.width << "," << this->viewbox.height
     << (this->viewbox.is_valid ? " (valid)" : " (invalid)")
-    << ": alignment = " << this->alignment.x
-    << "," << this->alignment.y
+    << ": alignment = " << this->alignment.x << "," << this->alignment.y
     << (this->alignment.meet ? " meet" : " slice");
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/svgpage.h b/src/libsvg/svgpage.h
index 7f5f76637..2348510a8 100644
--- a/src/libsvg/svgpage.h
+++ b/src/libsvg/svgpage.h
@@ -30,15 +30,14 @@
 
 namespace libsvg {
 
-class svgpage : public shape
-{
-protected:
+class svgpage : public shape {
+ protected:
   length_t width;
   length_t height;
   viewbox_t viewbox;
   alignment_t alignment;
 
-public:
+ public:
   svgpage();
 
   [[nodiscard]] const length_t& get_width() const { return width; }
@@ -47,13 +46,15 @@ public:
   [[nodiscard]] const alignment_t& get_alignment() const { return alignment; }
   [[nodiscard]] bool is_container() const override { return true; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return svgpage::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return svgpage::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new svgpage(*this); }
+  [[nodiscard]] shape* clone() const override { return new svgpage(*this); }
 };
 
-}
+}  // namespace libsvg
diff --git a/src/libsvg/text.cc b/src/libsvg/text.cc
index 0ebad3c89..b4b5bfeeb 100644
--- a/src/libsvg/text.cc
+++ b/src/libsvg/text.cc
@@ -32,9 +32,7 @@ namespace libsvg {
 
 const std::string text::name("text");
 
-void
-text::set_attrs(attr_map_t& attrs, void *context)
-{
+void text::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["x"]);
   this->y = parse_double(attrs["y"]);
@@ -42,16 +40,11 @@ text::set_attrs(attr_map_t& attrs, void *context)
   this->dy = parse_double(attrs["dy"]);
 }
 
-const std::string
-text::dump() const
-{
+const std::string text::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": dx = " << this->dx
-    << ": dy = " << this->dy;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": dx = " << this->dx << ": dy = " << this->dy;
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/text.h b/src/libsvg/text.h
index ebf75ab3c..2e116716a 100644
--- a/src/libsvg/text.h
+++ b/src/libsvg/text.h
@@ -29,9 +29,8 @@
 
 namespace libsvg {
 
-class text : public shape
-{
-private:
+class text : public shape {
+ private:
   double dx{0};
   double dy{0};
   double rotate{0};
@@ -39,25 +38,33 @@ private:
   std::string font_family;
   int font_size{0};
 
-public:
+ public:
   text() = default;
 
   [[nodiscard]] bool is_container() const override { return true; }
 
-  [[nodiscard]] double get_dx() const { return dx; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_dy() const { return dy; } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dx() const {
+    return dx;
+  }  // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dy() const {
+    return dy;
+  }  // NOLINT(bugprone-virtual-near-miss)
   [[nodiscard]] double get_rotate() const { return rotate; }
   [[nodiscard]] double get_text_length() const { return text_length; }
-  [[nodiscard]] const std::string& get_font_family() const { return font_family; }
+  [[nodiscard]] const std::string& get_font_family() const {
+    return font_family;
+  }
   [[nodiscard]] int get_font_size() const { return font_size; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return text::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return text::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new text(*this); }
+  [[nodiscard]] shape* clone() const override { return new text(*this); }
 };
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/transformation.cc b/src/libsvg/transformation.cc
index 49821e063..6df806872 100644
--- a/src/libsvg/transformation.cc
+++ b/src/libsvg/transformation.cc
@@ -24,25 +24,22 @@
  */
 #include "libsvg/transformation.h"
 
+#include <iostream>
 #include <sstream>
 #include <string>
 #include <vector>
-#include <iostream>
 
 #include "libsvg/util.h"
 #include "utils/degree_trig.h"
 
 namespace libsvg {
 
-void
-transformation::add_arg(const std::string& arg)
-{
+void transformation::add_arg(const std::string& arg) {
   double d = parse_double(arg);
   args.push_back(d);
 }
 
-const std::string
-transformation::get_args() const {
+const std::string transformation::get_args() const {
   std::ostringstream str;
   for (unsigned int a = 0; a < args.size(); ++a) {
     str << ((a == 0) ? "(" : ", ") << args[a];
@@ -51,45 +48,34 @@ transformation::get_args() const {
   return str.str();
 }
 
-matrix::matrix() : transformation("m", "matrix")
-{
-}
+matrix::matrix() : transformation("m", "matrix") {}
 
 /**
  * matrix(<a> <b> <c> <d> <e> <f>), which specifies a transformation in
  * the form of a transformation matrix of six values. matrix(a,b,c,d,e,f)
  * is equivalent to applying the transformation matrix [a b c d e f].
  */
-std::vector<Eigen::Matrix3d>
-matrix::get_matrices()
-{
+std::vector<Eigen::Matrix3d> matrix::get_matrices() {
   if (args.size() != 6) {
     std::cout << "invalid arguments for matrix" << std::endl;
     return {};
   }
 
   Eigen::Matrix3d m;
-  m <<
-    args[0], args[2], args[4],
-    args[1], args[3], args[5],
-    0, 0, 1;
+  m << args[0], args[2], args[4], args[1], args[3], args[5], 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-translate::translate() : transformation("t", "translate")
-{
-}
+translate::translate() : transformation("t", "translate") {}
 
 /**
  * translate(<tx> [<ty>]), which specifies a translation by tx and ty.
  * If <ty> is not provided, it is assumed to be zero.
  */
-std::vector<Eigen::Matrix3d>
-translate::get_matrices()
-{
+std::vector<Eigen::Matrix3d> translate::get_matrices() {
   if ((args.size() < 1) || (args.size() > 2)) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -99,27 +85,20 @@ translate::get_matrices()
   double ty = args.size() > 1 ? args[1] : 0;
 
   Eigen::Matrix3d m;
-  m <<
-    1, 0, tx,
-    0, 1, ty,
-    0, 0, 1;
+  m << 1, 0, tx, 0, 1, ty, 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-scale::scale() : transformation("s", "scale")
-{
-}
+scale::scale() : transformation("s", "scale") {}
 
 /**
  * scale(<sx> [<sy>]), which specifies a scale operation by sx and sy.
  * If <sy> is not provided, it is assumed to be equal to <sx>.
  */
-std::vector<Eigen::Matrix3d>
-scale::get_matrices()
-{
+std::vector<Eigen::Matrix3d> scale::get_matrices() {
   if ((args.size() < 1) || (args.size() > 2)) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -129,19 +108,14 @@ scale::get_matrices()
   double sy = args.size() > 1 ? args[1] : args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    sx,  0, 0,
-    0, sy, 0,
-    0,  0, 1;
+  m << sx, 0, 0, 0, sy, 0, 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-rotate::rotate() : transformation("r", "rotate")
-{
-}
+rotate::rotate() : transformation("r", "rotate") {}
 
 /**
  * rotate(<rotate-angle> [<cx> <cy>]), which specifies a rotation by
@@ -154,9 +128,7 @@ rotate::rotate() : transformation("r", "rotate")
  * the following specification: translate(<cx>, <cy>) rotate(<rotate-angle>)
  * translate(-<cx>, -<cy>).
  */
-std::vector<Eigen::Matrix3d>
-rotate::get_matrices()
-{
+std::vector<Eigen::Matrix3d> rotate::get_matrices() {
   if ((args.size() != 1) && (args.size() != 3)) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -172,10 +144,7 @@ rotate::get_matrices()
 
   if (has_center) {
     Eigen::Matrix3d t;
-    t <<
-      1, 0, -cx,
-      0, 1, -cy,
-      0, 0, 1;
+    t << 1, 0, -cx, 0, 1, -cy, 0, 0, 1;
     result.push_back(t);
   }
 
@@ -183,26 +152,19 @@ rotate::get_matrices()
 
   if (has_center) {
     Eigen::Matrix3d t;
-    t <<
-      1, 0, cx,
-      0, 1, cy,
-      0, 0, 1;
+    t << 1, 0, cx, 0, 1, cy, 0, 0, 1;
     result.push_back(t);
   }
 
   return result;
 }
 
-skew_x::skew_x() : transformation("x", "skew_x")
-{
-}
+skew_x::skew_x() : transformation("x", "skew_x") {}
 
 /**
  * skewX(<skew-angle>), which specifies a skew transformation along the x-axis.
  */
-std::vector<Eigen::Matrix3d>
-skew_x::get_matrices()
-{
+std::vector<Eigen::Matrix3d> skew_x::get_matrices() {
   if (args.size() != 1) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -211,26 +173,19 @@ skew_x::get_matrices()
   double angle = args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    1, tan_degrees(angle), 0,
-    0, 1,                  0,
-    0, 0,                  1;
+  m << 1, tan_degrees(angle), 0, 0, 1, 0, 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-skew_y::skew_y() : transformation("y", "skew_y")
-{
-}
+skew_y::skew_y() : transformation("y", "skew_y") {}
 
 /**
  * skewY(<skew-angle>), which specifies a skew transformation along the y-axis.
  */
-std::vector<Eigen::Matrix3d>
-skew_y::get_matrices()
-{
+std::vector<Eigen::Matrix3d> skew_y::get_matrices() {
   if (args.size() != 1) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -239,14 +194,11 @@ skew_y::get_matrices()
   double angle = args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    1, 0, 0,
-    tan_degrees(angle), 1, 0,
-    0, 0, 1;
+  m << 1, 0, 0, tan_degrees(angle), 1, 0, 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/transformation.h b/src/libsvg/transformation.h
index d1c46a4e0..77625c06d 100644
--- a/src/libsvg/transformation.h
+++ b/src/libsvg/transformation.h
@@ -24,8 +24,8 @@
  */
 #pragma once
 
-#include <utility>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include <Eigen/Core>
@@ -33,16 +33,17 @@
 
 namespace libsvg {
 
-class transformation
-{
-private:
+class transformation {
+ private:
   const std::string op;
   const std::string name;
-protected:
+
+ protected:
   std::vector<double> args;
 
-public:
-  transformation(std::string op, std::string name) : op(std::move(op)), name(std::move(name)) { }
+ public:
+  transformation(std::string op, std::string name)
+      : op(std::move(op)), name(std::move(name)) {}
   virtual ~transformation() = default;
 
   [[nodiscard]] const std::string& get_op() const { return op; }
@@ -53,52 +54,46 @@ public:
   virtual std::vector<Eigen::Matrix3d> get_matrices() = 0;
 };
 
-class matrix : public transformation
-{
-public:
+class matrix : public transformation {
+ public:
   matrix();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class translate : public transformation
-{
-public:
+class translate : public transformation {
+ public:
   translate();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class scale : public transformation
-{
-public:
+class scale : public transformation {
+ public:
   scale();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class rotate : public transformation
-{
-public:
+class rotate : public transformation {
+ public:
   rotate();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class skew_x : public transformation
-{
-public:
+class skew_x : public transformation {
+ public:
   skew_x();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class skew_y : public transformation
-{
-public:
+class skew_y : public transformation {
+ public:
   skew_y();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/tspan.cc b/src/libsvg/tspan.cc
index e54287b14..a0192c9e6 100644
--- a/src/libsvg/tspan.cc
+++ b/src/libsvg/tspan.cc
@@ -33,9 +33,7 @@ namespace libsvg {
 
 const std::string tspan::name("tspan");
 
-void
-tspan::set_attrs(attr_map_t& attrs, void *context)
-{
+void tspan::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["x"]);
   this->y = parse_double(attrs["y"]);
@@ -43,16 +41,11 @@ tspan::set_attrs(attr_map_t& attrs, void *context)
   this->dy = parse_double(attrs["dy"]);
 }
 
-const std::string
-tspan::dump() const
-{
+const std::string tspan::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": dx = " << this->dx
-    << ": dy = " << this->dy;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": dx = " << this->dx << ": dy = " << this->dy;
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/tspan.h b/src/libsvg/tspan.h
index d6ea4a23e..942db58d6 100644
--- a/src/libsvg/tspan.h
+++ b/src/libsvg/tspan.h
@@ -29,9 +29,8 @@
 
 namespace libsvg {
 
-class tspan : public shape
-{
-private:
+class tspan : public shape {
+ private:
   double dx{0};
   double dy{0};
   double rotate{0};
@@ -39,25 +38,33 @@ private:
   std::string font_family;
   int font_size{0};
 
-public:
+ public:
   tspan() = default;
 
   [[nodiscard]] bool is_container() const override { return true; }
 
-  [[nodiscard]] double get_dx() const { return dx; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_dy() const { return dy; } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dx() const {
+    return dx;
+  }  // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dy() const {
+    return dy;
+  }  // NOLINT(bugprone-virtual-near-miss)
   [[nodiscard]] double get_rotate() const { return rotate; }
   [[nodiscard]] double get_text_length() const { return text_length; }
-  [[nodiscard]] const std::string& get_font_family() const { return font_family; }
+  [[nodiscard]] const std::string& get_font_family() const {
+    return font_family;
+  }
   [[nodiscard]] int get_font_size() const { return font_size; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return tspan::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return tspan::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new tspan(*this); }
+  [[nodiscard]] shape* clone() const override { return new tspan(*this); }
 };
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/use.cc b/src/libsvg/use.cc
index 50f281f86..a591aa4d2 100644
--- a/src/libsvg/use.cc
+++ b/src/libsvg/use.cc
@@ -24,10 +24,10 @@
  */
 #include "libsvg/use.h"
 
-#include <sstream>
-#include <memory>
 #include <cstdlib>
 #include <iostream>
+#include <memory>
+#include <sstream>
 #include <string>
 #include <vector>
 
@@ -37,15 +37,14 @@ namespace libsvg {
 
 const std::string use::name("use");
 
-void
-use::set_attrs(attr_map_t& attrs, void *context)
-{
+void use::set_attrs(attr_map_t& attrs, void* context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["x"]);
   this->y = parse_double(attrs["y"]);
 
-  //Note: width, and height have no effect on use elements, unless the element referenced has a viewbox - i.e. they only have an effect when use refers to a svg or symbol element.
-  //Lets store them, but I am not going to use them.
+  // Note: width, and height have no effect on use elements, unless the element
+  // referenced has a viewbox - i.e. they only have an effect when use refers to
+  // a svg or symbol element. Lets store them, but I am not going to use them.
   this->width = parse_double(attrs["width"]);
   this->height = parse_double(attrs["height"]);
 
@@ -57,43 +56,38 @@ use::set_attrs(attr_map_t& attrs, void *context)
   if (this->href != temp_href) {
     this->href = temp_href;
     if (href.rfind('#', 0) != 0) {
-      printf("<use> can only use references to ids in the href field (starting with #). Error in element type %s with id: %s\n", this->get_name().c_str(), this->get_id_or_default().c_str());
+      printf(
+          "<use> can only use references to ids in the href field (starting "
+          "with #). Error in element type %s with id: %s\n",
+          this->get_name().c_str(), this->get_id_or_default().c_str());
     }
   }
 
-  //apply the x/y coordinates to all the children by using a transform
+  // apply the x/y coordinates to all the children by using a transform
   std::stringstream s;
   s << this->transform << " translate(" << this->x << "," << this->y << ")";
   this->transform = s.str();
 }
 
-const std::string
-use::get_href_id() const
-{
+const std::string use::get_href_id() const {
   if (href.rfind('#', 0) != 0) {
     return {};
   }
-  return href.substr(1); //remove the #
+  return href.substr(1);  // remove the #
 }
 
-std::vector<std::shared_ptr<shape>>
-use::set_clone_child(shape *child)
-{
-  shape *copy = child->clone();
+std::vector<std::shared_ptr<shape>> use::set_clone_child(shape* child) {
+  shape* copy = child->clone();
   copy->set_parent(this);
   auto cloned_objects = copy->clone_children();
   cloned_objects.insert(cloned_objects.begin(), std::shared_ptr<shape>(copy));
   return cloned_objects;
 }
 
-const std::string
-use::dump() const
-{
+const std::string use::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y;
   return s.str();
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/use.h b/src/libsvg/use.h
index 2e65b742a..9626c75b0 100644
--- a/src/libsvg/use.h
+++ b/src/libsvg/use.h
@@ -24,28 +24,29 @@
  */
 #pragma once
 
-#include <vector>
-#include <string>
 #include <memory>
+#include <string>
+#include <vector>
 #include "libsvg/shape.h"
 
 namespace libsvg {
 
-class use : public shape
-{
-protected:
+class use : public shape {
+ protected:
   std::string href;
   double width;
   double height;
 
-public:
+ public:
   use() = default;
 
   [[nodiscard]] bool is_container() const override { return false; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t& attrs, void* context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return use::name; }
+  [[nodiscard]] const std::string& get_name() const override {
+    return use::name;
+  }
 
   static const std::string name;
 
@@ -53,9 +54,9 @@ public:
   [[nodiscard]] const std::string get_href_id() const;
 
   // I'm hoping here something else can find the href for us.
-  std::vector<std::shared_ptr<shape>> set_clone_child(shape *child);
+  std::vector<std::shared_ptr<shape>> set_clone_child(shape* child);
 
-  [[nodiscard]] shape *clone() const override { return new use(*this); }
+  [[nodiscard]] shape* clone() const override { return new use(*this); }
 };
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/util.cc b/src/libsvg/util.cc
index d18db191e..cc1aa3921 100644
--- a/src/libsvg/util.cc
+++ b/src/libsvg/util.cc
@@ -24,26 +24,25 @@
  */
 #include "libsvg/util.h"
 
-#include <ostream>
 #include <boost/spirit/include/qi.hpp>
+#include <ostream>
 
 #include <string>
 #include <vector>
 
-// include fusion headers for Ubuntu trusty, everything later seems happy without
+// include fusion headers for Ubuntu trusty, everything later seems happy
+// without
 #include <boost/fusion/adapted/struct/adapt_struct.hpp>
 #include <boost/fusion/include/adapt_struct.hpp>
 
-
-BOOST_FUSION_ADAPT_STRUCT(libsvg::length_struct, (double, number)(std::string, unit))
+BOOST_FUSION_ADAPT_STRUCT(libsvg::length_struct,
+                          (double, number)(std::string, unit))
 
 namespace libsvg {
 
 namespace qi = boost::spirit::qi;
 
-double
-parse_double(const std::string& number)
-{
+double parse_double(const std::string& number) {
   std::string::const_iterator iter = number.begin(), end = number.end();
 
   qi::real_parser<double, qi::real_policies<double>> double_parser;
@@ -54,9 +53,7 @@ parse_double(const std::string& number)
   return result && iter == end ? d : 0;
 }
 
-static unit_t
-get_unit(const std::string& value)
-{
+static unit_t get_unit(const std::string& value) {
   if (value == "em") {
     return unit_t::EM;
   } else if (value == "ex") {
@@ -80,9 +77,7 @@ get_unit(const std::string& value)
   }
 }
 
-const length_t
-parse_length(const std::string& value)
-{
+const length_t parse_length(const std::string& value) {
   std::string::const_iterator it = value.begin(), end = value.end();
 
   qi::rule<std::string::const_iterator, length_struct(), qi::space_type> length;
@@ -91,7 +86,9 @@ parse_length(const std::string& value)
 
   length = number >> -unit;
   number = qi::double_;
-  unit = qi::string("em") | qi::string("ex") | qi::string("px") | qi::string("in") | qi::string("cm") | qi::string("mm") | qi::string("pt") | qi::string("pc") | qi::string("%");
+  unit = qi::string("em") | qi::string("ex") | qi::string("px") |
+         qi::string("in") | qi::string("cm") | qi::string("mm") |
+         qi::string("pt") | qi::string("pc") | qi::string("%");
 
   libsvg::length_struct parsed;
   qi::phrase_parse(it, end, length, qi::space, parsed);
@@ -105,12 +102,11 @@ parse_length(const std::string& value)
   return result;
 }
 
-const viewbox_t
-parse_viewbox(const std::string& value)
-{
+const viewbox_t parse_viewbox(const std::string& value) {
   std::string::const_iterator it = value.begin(), end = value.end();
 
-  qi::rule<std::string::const_iterator, std::vector<double>(), qi::space_type> viewbox;
+  qi::rule<std::string::const_iterator, std::vector<double>(), qi::space_type>
+      viewbox;
   qi::rule<std::string::const_iterator, double()> number;
   qi::rule<std::string::const_iterator> sep;
 
@@ -122,7 +118,8 @@ parse_viewbox(const std::string& value)
   qi::phrase_parse(it, end, viewbox, qi::space, parsed);
 
   viewbox_t result{0.0, 0.0, 0.0, 0.0, false};
-  if ((it != value.begin()) && (it == end) && (parsed.size() == 4) && (parsed[2] >= 0.0) && (parsed[3] >= 0.0)) {
+  if ((it != value.begin()) && (it == end) && (parsed.size() == 4) &&
+      (parsed[2] >= 0.0) && (parsed[3] >= 0.0)) {
     result.x = parsed[0];
     result.y = parsed[1];
     result.width = parsed[2];
@@ -133,22 +130,24 @@ parse_viewbox(const std::string& value)
   return result;
 }
 
-const alignment_t
-parse_alignment(const std::string& value)
-{
+const alignment_t parse_alignment(const std::string& value) {
   std::string::const_iterator it = value.begin(), end = value.end();
 
-  qi::rule<std::string::const_iterator, std::vector<std::string>(), qi::space_type> alignment;
+  qi::rule<std::string::const_iterator, std::vector<std::string>(),
+           qi::space_type>
+      alignment;
   qi::rule<std::string::const_iterator, std::vector<char>()> defer;
   qi::rule<std::string::const_iterator, std::vector<char>()> align;
   qi::rule<std::string::const_iterator, std::vector<char>()> meet_or_slice;
 
-  alignment = -qi::as_string[defer] >> qi::as_string[align] >> -qi::as_string[meet_or_slice];
+  alignment = -qi::as_string[defer] >> qi::as_string[align] >>
+              -qi::as_string[meet_or_slice];
   defer = qi::string("defer");
-  align = qi::string("none")
-    | qi::string("xMinYMin") | qi::string("xMidYMin") | qi::string("xMaxYMin")
-    | qi::string("xMinYMid") | qi::string("xMidYMid") | qi::string("xMaxYMid")
-    | qi::string("xMinYMax") | qi::string("xMidYMax") | qi::string("xMaxYMax");
+  align = qi::string("none") | qi::string("xMinYMin") | qi::string("xMidYMin") |
+          qi::string("xMaxYMin") | qi::string("xMinYMid") |
+          qi::string("xMidYMid") | qi::string("xMaxYMid") |
+          qi::string("xMinYMax") | qi::string("xMidYMax") |
+          qi::string("xMaxYMax");
   meet_or_slice = qi::string("meet") | qi::string("slice");
 
   std::vector<std::string> parsed;
@@ -202,71 +201,68 @@ parse_alignment(const std::string& value)
   return result;
 }
 
-std::ostream& operator<<(std::ostream& stream, const unit_t& unit)
-{
+std::ostream& operator<<(std::ostream& stream, const unit_t& unit) {
   switch (unit) {
-  case unit_t::EM:
-    stream << "em";
-    break;
-  case unit_t::EX:
-    stream << "ex";
-    break;
-  case unit_t::PX:
-    stream << "px";
-    break;
-  case unit_t::IN:
-    stream << "in";
-    break;
-  case unit_t::CM:
-    stream << "cm";
-    break;
-  case unit_t::MM:
-    stream << "mm";
-    break;
-  case unit_t::PT:
-    stream << "pt";
-    break;
-  case unit_t::PC:
-    stream << "pc";
-    break;
-  case unit_t::PERCENT:
-    stream << "%";
-    break;
-  case unit_t::NONE:
-    break;
-  case unit_t::UNDEFINED:
-    stream << " (invalid)";
-    break;
+    case unit_t::EM:
+      stream << "em";
+      break;
+    case unit_t::EX:
+      stream << "ex";
+      break;
+    case unit_t::PX:
+      stream << "px";
+      break;
+    case unit_t::IN:
+      stream << "in";
+      break;
+    case unit_t::CM:
+      stream << "cm";
+      break;
+    case unit_t::MM:
+      stream << "mm";
+      break;
+    case unit_t::PT:
+      stream << "pt";
+      break;
+    case unit_t::PC:
+      stream << "pc";
+      break;
+    case unit_t::PERCENT:
+      stream << "%";
+      break;
+    case unit_t::NONE:
+      break;
+    case unit_t::UNDEFINED:
+      stream << " (invalid)";
+      break;
   }
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const length_t& length)
-{
+std::ostream& operator<<(std::ostream& stream, const length_t& length) {
   stream << length.number << length.unit;
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const align_t& align)
-{
+std::ostream& operator<<(std::ostream& stream, const align_t& align) {
   switch (align) {
-  case align_t::MIN:
-    stream << "min";
-    break;
-  case align_t::MID:
-    stream << "mid";
-    break;
-  case align_t::MAX:
-    stream << "max";
-    break;
-  case align_t::NONE:
-    stream << "none";
-    break;
-  case align_t::UNDEFINED:
-    stream << "undefined";
-    break;
+    case align_t::MIN:
+      stream << "min";
+      break;
+    case align_t::MID:
+      stream << "mid";
+      break;
+    case align_t::MAX:
+      stream << "max";
+      break;
+    case align_t::NONE:
+      stream << "none";
+      break;
+    case align_t::UNDEFINED:
+      stream << "undefined";
+      break;
   }
   return stream;
 }
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/libsvg/util.h b/src/libsvg/util.h
index c8973fd2f..057c24cc1 100644
--- a/src/libsvg/util.h
+++ b/src/libsvg/util.h
@@ -79,4 +79,4 @@ std::ostream& operator<<(std::ostream& stream, const unit_t& unit);
 std::ostream& operator<<(std::ostream& stream, const length_t& length);
 std::ostream& operator<<(std::ostream& stream, const align_t& align);
 
-} // namespace libsvg
+}  // namespace libsvg
diff --git a/src/openscad.cc b/src/openscad.cc
index b9be46a5b..cc77bb752 100644
--- a/src/openscad.cc
+++ b/src/openscad.cc
@@ -27,9 +27,10 @@
 #include "openscad.h"
 
 #ifdef _WIN32
-#include <io.h>
 #include <fcntl.h>
+#include <io.h>
 #endif
+#include <libintl.h>
 #include <array>
 #include <clocale>
 #include <cstddef>
@@ -42,7 +43,6 @@
 #include <iostream>
 #include <istream>
 #include <iterator>
-#include <libintl.h>
 #include <map>
 #include <memory>
 #include <ostream>
@@ -75,21 +75,23 @@
 #include <CGAL/assertions_behaviour.h>
 #endif
 
+#include "Feature.h"
+#include "LibraryInfo.h"
+#include "RenderStatistic.h"
 #include "core/AST.h"
 #include "core/BuiltinContext.h"
 #include "core/Builtins.h"
-#include "core/Context.h"
 #include "core/CSGTreeEvaluator.h"
+#include "core/Context.h"
+#include "core/EvaluationSession.h"
+#include "core/RenderVariables.h"
+#include "core/ScopeContext.h"
+#include "core/Settings.h"
 #include "core/customizer/CommentParser.h"
 #include "core/customizer/ParameterObject.h"
 #include "core/customizer/ParameterSet.h"
-#include "core/EvaluationSession.h"
 #include "core/node.h"
 #include "core/parsersettings.h"
-#include "core/RenderVariables.h"
-#include "core/ScopeContext.h"
-#include "core/Settings.h"
-#include "Feature.h"
 #include "geometry/Geometry.h"
 #include "geometry/GeometryEvaluator.h"
 #include "geometry/GeometryUtils.h"
@@ -100,14 +102,12 @@
 #include "glview/RenderSettings.h"
 #include "handle_dep.h"
 #include "io/export.h"
-#include "LibraryInfo.h"
 #include "openscad_gui.h"
 #include "openscad_mimalloc.h"
 #include "platform/PlatformUtils.h"
-#include "RenderStatistic.h"
+#include "utils/StackCheck.h"
 #include "utils/exceptions.h"
 #include "utils/printutils.h"
-#include "utils/StackCheck.h"
 
 #ifdef ENABLE_PYTHON
 #include "python/python_public.h"
@@ -125,27 +125,24 @@ bool arg_info = false;
 
 }  // namespace
 
-class Echostream
-{
-public:
-  Echostream(std::ostream& stream) : stream(stream)
-  {
+class Echostream {
+ public:
+  Echostream(std::ostream& stream) : stream(stream) {
     set_output_handler(&Echostream::output, nullptr, this);
   }
-  Echostream(const std::string& filename) : fstream(filename), stream(fstream)
-  {
+  Echostream(const std::string& filename) : fstream(filename), stream(fstream) {
     set_output_handler(&Echostream::output, nullptr, this);
   }
-  static void output(const Message& msgObj, void *userdata)
-  {
-    auto self = static_cast<Echostream *>(userdata);
+  static void output(const Message& msgObj, void* userdata) {
+    auto self = static_cast<Echostream*>(userdata);
     self->stream << msgObj.str() << "\n";
   }
   ~Echostream() {
-    if (fstream.is_open()) fstream.close();
+    if (fstream.is_open())
+      fstream.close();
   }
 
-private:
+ private:
   std::ofstream fstream;
   std::ostream& stream;
 };
@@ -156,8 +153,7 @@ struct AnimateArgs {
   unsigned shard = 1;
 };
 
-struct CommandLine
-{
+struct CommandLine {
   const bool is_stdin;
   const std::string& filename;
   const bool is_stdout;
@@ -180,24 +176,26 @@ namespace {
 #define TOSTRING(x) STRINGIFY(x)
 
 #ifndef OPENSCAD_NOGUI
-bool useGUI()
-{
+bool useGUI() {
 #ifdef Q_OS_X11
   // see <http://qt.nokia.com/doc/4.5/qapplication.html#QApplication-2>:
-  // On X11, the window system is initialized if GUIenabled is true. If GUIenabled
-  // is false, the application does not connect to the X server. On Windows and
-  // Macintosh, currently the window system is always initialized, regardless of the
-  // value of GUIenabled. This may change in future versions of Qt.
+  // On X11, the window system is initialized if GUIenabled is true. If
+  // GUIenabled is false, the application does not connect to the X server. On
+  // Windows and Macintosh, currently the window system is always initialized,
+  // regardless of the value of GUIenabled. This may change in future versions
+  // of Qt.
   return getenv("DISPLAY") != 0;
 #else
   return true;
 #endif
 }
-#endif // OPENSCAD_NOGUI
+#endif  // OPENSCAD_NOGUI
 
-bool checkAndExport(const std::shared_ptr<const Geometry>& root_geom, unsigned dimensions,
-                    ExportInfo& exportInfo, const bool is_stdout, const std::string& filename)
-{
+bool checkAndExport(const std::shared_ptr<const Geometry>& root_geom,
+                    unsigned dimensions,
+                    ExportInfo& exportInfo,
+                    const bool is_stdout,
+                    const std::string& filename) {
   if (root_geom->getDimension() != dimensions) {
     LOG("Current top level object is not a %1$dD object.", dimensions);
     return false;
@@ -215,15 +213,18 @@ bool checkAndExport(const std::shared_ptr<const Geometry>& root_geom, unsigned d
   return true;
 }
 
-void help(const char *arg0, const po::options_description& desc, bool failure = false)
-{
+void help(const char* arg0,
+          const po::options_description& desc,
+          bool failure = false) {
   const fs::path progpath(arg0);
-  LOG("Usage: %1$s [options] file.scad\n%2$s", progpath.filename().string(), desc);
+  LOG("Usage: %1$s [options] file.scad\n%2$s", progpath.filename().string(),
+      desc);
   exit(failure ? 1 : 0);
 }
 
 template <std::size_t size>
-void help_export(const std::array<const Settings::SettingsEntryBase *, size>& options) {
+void help_export(
+    const std::array<const Settings::SettingsEntryBase*, size>& options) {
   LOG("Section '%1$s':", options.at(0)->category());
 
   for (const auto option : options) {
@@ -232,8 +233,7 @@ void help_export(const std::array<const Settings::SettingsEntryBase *, size>& op
   }
 }
 
-void help_export()
-{
+void help_export() {
   LOG("OpenSCAD version %1$s\n", TOSTRING(OPENSCAD_VERSION));
   LOG("List of settings that can be given using the -O option using the");
   LOG("format '<section>/<key>=value', e.g.:");
@@ -243,14 +243,12 @@ void help_export()
   exit(0);
 }
 
-void version()
-{
+void version() {
   LOG("OpenSCAD version %1$s", TOSTRING(OPENSCAD_VERSION));
   exit(0);
 }
 
-int info()
-{
+int info() {
   std::cout << LibraryInfo::info() << "\n\n";
 
   try {
@@ -265,11 +263,13 @@ int info()
 }
 
 template <typename F>
-bool with_output(const bool is_stdout, const std::string& filename, const F& f, std::ios::openmode mode = std::ios::out)
-{
+bool with_output(const bool is_stdout,
+                 const std::string& filename,
+                 const F& f,
+                 std::ios::openmode mode = std::ios::out) {
   if (is_stdout) {
 #ifdef _WIN32
-    if ((mode& std::ios::binary) != 0) {
+    if ((mode & std::ios::binary) != 0) {
       _setmode(_fileno(stdout), _O_BINARY);
     }
 #endif
@@ -314,8 +314,7 @@ AnimateArgs get_animate(const po::variables_map& vm) {
   return animate;
 }
 
-Camera get_camera(const po::variables_map& vm)
-{
+Camera get_camera(const po::variables_map& vm) {
   Camera camera;
 
   if (vm.count("camera")) {
@@ -332,7 +331,8 @@ Camera get_camera(const po::variables_map& vm)
         LOG("Camera setup requires numbers as parameters");
       }
     } else {
-      LOG("Camera setup requires either 7 numbers for Gimbal Camera or 6 numbers for Vector Camera");
+      LOG("Camera setup requires either 7 numbers for Gimbal Camera or 6 "
+          "numbers for Vector Camera");
       exit(1);
     }
   } else {
@@ -381,18 +381,22 @@ Camera get_camera(const po::variables_map& vm)
   return camera;
 }
 
-int do_export(const CommandLine& cmd, const RenderVariables& render_variables, FileFormat export_format, SourceFile *root_file)
-{
+int do_export(const CommandLine& cmd,
+              const RenderVariables& render_variables,
+              FileFormat export_format,
+              SourceFile* root_file) {
   auto filename_str = fs::path(cmd.output_file).generic_string();
   // Avoid possibility of fs::absolute throwing when passed an empty path
-  auto fpath = cmd.filename.empty() ? fs::current_path() : fs::absolute(fs::path(cmd.filename));
+  auto fpath = cmd.filename.empty() ? fs::current_path()
+                                    : fs::absolute(fs::path(cmd.filename));
   auto fparent = fpath.parent_path();
 
   // set CWD relative to source file
   fs::current_path(fparent);
 
   EvaluationSession session{fparent.string()};
-  ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
+  ContextHandle<BuiltinContext> builtin_context{
+      Context::create<BuiltinContext>(&session)};
   render_variables.applyToContext(builtin_context);
 
 #ifdef DEBUG
@@ -408,9 +412,10 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     absolute_root_node = python_result_node;
   } else {
 #endif
-  absolute_root_node = root_file->instantiate(*builtin_context, &file_context);
+    absolute_root_node =
+        root_file->instantiate(*builtin_context, &file_context);
 #ifdef ENABLE_PYTHON
-}
+  }
 #endif
 
   Camera camera = cmd.camera;
@@ -423,12 +428,13 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
 
   // Do we have an explicit root node (! modifier)?
   std::shared_ptr<const AbstractNode> root_node;
-  const Location *nextLocation = nullptr;
+  const Location* nextLocation = nullptr;
   if (!(root_node = find_root_tag(absolute_root_node, &nextLocation))) {
     root_node = absolute_root_node;
   }
   if (nextLocation) {
-    LOG(message_group::Warning, *nextLocation, builtin_context->documentRoot(), "More than one Root Modifier (!)");
+    LOG(message_group::Warning, *nextLocation, builtin_context->documentRoot(),
+        "More than one Root Modifier (!)");
   }
   Tree tree(root_node, fparent.string());
 
@@ -438,31 +444,36 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     // statements become relative. But unfortunately they become relative to
     // the current working dir and neither to the location of the input nor
     // the output.
-    fs::current_path(fparent); // Force exported filenames to be relative to document path
-    with_output(cmd.is_stdout, filename_str, [&tree, root_node](std::ostream& stream) {
-        stream << tree.getString(*root_node, "\t") << "\n";
-      });
+    fs::current_path(
+        fparent);  // Force exported filenames to be relative to document path
+    with_output(cmd.is_stdout, filename_str,
+                [&tree, root_node](std::ostream& stream) {
+                  stream << tree.getString(*root_node, "\t") << "\n";
+                });
     fs::current_path(cmd.original_path);
   } else if (export_format == FileFormat::AST) {
-    fs::current_path(fparent); // Force exported filenames to be relative to document path
+    fs::current_path(
+        fparent);  // Force exported filenames to be relative to document path
     with_output(cmd.is_stdout, filename_str, [root_file](std::ostream& stream) {
-        stream << root_file->dump("");
-      });
+      stream << root_file->dump("");
+    });
     fs::current_path(cmd.original_path);
   } else if (export_format == FileFormat::PARAM) {
-    with_output(cmd.is_stdout, filename_str, [&root_file, &fpath](std::ostream& stream) {
-        export_param(root_file, fpath, stream);
-      });
+    with_output(cmd.is_stdout, filename_str,
+                [&root_file, &fpath](std::ostream& stream) {
+                  export_param(root_file, fpath, stream);
+                });
   } else if (export_format == FileFormat::TERM) {
     CSGTreeEvaluator csgRenderer(tree);
     auto root_raw_term = csgRenderer.buildCSGTree(*root_node);
-    with_output(cmd.is_stdout, filename_str, [root_raw_term](std::ostream& stream) {
-        if (!root_raw_term || root_raw_term->isEmptySet()) {
-          stream << "No top-level CSG object\n";
-        } else {
-          stream << root_raw_term->dump() << "\n";
-        }
-      });
+    with_output(cmd.is_stdout, filename_str,
+                [root_raw_term](std::ostream& stream) {
+                  if (!root_raw_term || root_raw_term->isEmptySet()) {
+                    stream << "No top-level CSG object\n";
+                  } else {
+                    stream << root_raw_term->dump() << "\n";
+                  }
+                });
   } else if (export_format == FileFormat::ECHO) {
     // echo -> don't need to evaluate any geometry
   } else {
@@ -471,23 +482,32 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     GeometryEvaluator geomevaluator(tree);
     std::unique_ptr<OffscreenView> glview;
     std::shared_ptr<const Geometry> root_geom;
-    if ((export_format == FileFormat::ECHO || export_format == FileFormat::PNG) && (cmd.viewOptions.renderer == RenderType::OPENCSG || cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)) {
+    if ((export_format == FileFormat::ECHO ||
+         export_format == FileFormat::PNG) &&
+        (cmd.viewOptions.renderer == RenderType::OPENCSG ||
+         cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)) {
       // OpenCSG or throwntogether png -> just render a preview
       glview = prepare_preview(tree, cmd.viewOptions, camera);
-      if (!glview) return 1;
+      if (!glview)
+        return 1;
     } else {
       // Force creation of concrete geometry (mostly for testing)
-      // FIXME: Consider adding MANIFOLD as a valid --render argument and ViewOption, to be able to distinguish from CGAL
+      // FIXME: Consider adding MANIFOLD as a valid --render argument and
+      // ViewOption, to be able to distinguish from CGAL
 
       constexpr bool allownef = true;
       root_geom = geomevaluator.evaluateGeometry(*tree.root(), allownef);
-      if (!root_geom) root_geom = std::make_shared<PolySet>(3);
-      if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC && root_geom->getDimension() == 3) {
-        if (auto geomlist = std::dynamic_pointer_cast<const GeometryList>(root_geom)) {
+      if (!root_geom)
+        root_geom = std::make_shared<PolySet>(3);
+      if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC &&
+          root_geom->getDimension() == 3) {
+        if (auto geomlist =
+                std::dynamic_pointer_cast<const GeometryList>(root_geom)) {
           auto flatlist = geomlist->flatten();
           for (auto& child : flatlist) {
             if (child.second->getDimension() == 3) {
-              child.second = GeometryUtils::getBackendSpecificGeometry(child.second);
+              child.second =
+                  GeometryUtils::getBackendSpecificGeometry(child.second);
             }
           }
           root_geom = std::make_shared<GeometryList>(flatlist);
@@ -500,33 +520,42 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     }
 
     const std::string input_filename = cmd.is_stdin ? "<stdin>" : cmd.filename;
-    const int dim = fileformat::is3D(export_format) ? 3 : fileformat::is2D(export_format) ? 2 : 0;
-    ExportInfo exportInfo = createExportInfo(export_format, fileformat::info(export_format), input_filename, &cmd.camera, cmd.exportOptions);
-    if (dim > 0 && !checkAndExport(root_geom, dim, exportInfo, cmd.is_stdout, filename_str)) {
+    const int dim = fileformat::is3D(export_format)   ? 3
+                    : fileformat::is2D(export_format) ? 2
+                                                      : 0;
+    ExportInfo exportInfo =
+        createExportInfo(export_format, fileformat::info(export_format),
+                         input_filename, &cmd.camera, cmd.exportOptions);
+    if (dim > 0 && !checkAndExport(root_geom, dim, exportInfo, cmd.is_stdout,
+                                   filename_str)) {
       return 1;
     }
 
     if (export_format == FileFormat::PNG) {
       bool success = true;
-      bool const wrote = with_output(cmd.is_stdout, filename_str, [&success, &root_geom, &cmd, &camera, &glview](std::ostream& stream) {
-          if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC || cmd.viewOptions.renderer == RenderType::GEOMETRY) {
-            success = export_png(root_geom, cmd.viewOptions, camera, stream);
-          } else {
-            success = export_png(*glview, stream);
-          }
-        }, std::ios::out | std::ios::binary);
+      bool const wrote = with_output(
+          cmd.is_stdout, filename_str,
+          [&success, &root_geom, &cmd, &camera, &glview](std::ostream& stream) {
+            if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC ||
+                cmd.viewOptions.renderer == RenderType::GEOMETRY) {
+              success = export_png(root_geom, cmd.viewOptions, camera, stream);
+            } else {
+              success = export_png(*glview, stream);
+            }
+          },
+          std::ios::out | std::ios::binary);
       if (!success || !wrote) {
         return 1;
       }
     }
 
-    renderStatistic.printAll(root_geom, camera, cmd.summaryOptions, cmd.summaryFile);
+    renderStatistic.printAll(root_geom, camera, cmd.summaryOptions,
+                             cmd.summaryFile);
   }
   return 0;
 }
 
-int cmdline(const CommandLine& cmd)
-{
+int cmdline(const CommandLine& cmd) {
   FileFormat export_format;
 
   // Determine output file format and assign it to formatName
@@ -535,11 +564,14 @@ int cmdline(const CommandLine& cmd)
   } else {
     // else extract format from file extension
     const auto path = fs::path(cmd.output_file);
-    std::string suffix = path.has_extension() ? path.extension().generic_string().substr(1) : "";
+    std::string suffix =
+        path.has_extension() ? path.extension().generic_string().substr(1) : "";
     boost::algorithm::to_lower(suffix);
 
     if (!fileformat::fromIdentifier(suffix, export_format)) {
-      LOG("Invalid suffix %1$s. Either add a valid suffix or specify one using the --export-format option.", suffix);
+      LOG("Invalid suffix %1$s. Either add a valid suffix or specify one using "
+          "the --export-format option.",
+          suffix);
       return 1;
     }
   }
@@ -547,11 +579,13 @@ int cmdline(const CommandLine& cmd)
   // Do some minimal checking of output directory before rendering (issue #432)
   auto output_dir = fs::path(cmd.output_file).parent_path();
   if (output_dir.empty()) {
-    // If output_file_str has no directory prefix, set output directory to current directory.
+    // If output_file_str has no directory prefix, set output directory to
+    // current directory.
     output_dir = fs::current_path();
   }
   if (!fs::is_directory(output_dir)) {
-    LOG("\n'%1$s' is not a directory for output file %2$s - Skipping\n", output_dir.generic_string(), cmd.output_file);
+    LOG("\n'%1$s' is not a directory for output file %2$s - Skipping\n",
+        output_dir.generic_string(), cmd.output_file);
     return 1;
   }
 
@@ -559,12 +593,14 @@ int cmdline(const CommandLine& cmd)
 
   std::shared_ptr<Echostream> echostream;
   if (export_format == FileFormat::ECHO) {
-    echostream.reset(cmd.is_stdout ? new Echostream(std::cout) : new Echostream(cmd.output_file));
+    echostream.reset(cmd.is_stdout ? new Echostream(std::cout)
+                                   : new Echostream(cmd.output_file));
   }
 
   std::string text;
   if (cmd.is_stdin) {
-    text = std::string((std::istreambuf_iterator<char>(std::cin)), std::istreambuf_iterator<char>());
+    text = std::string((std::istreambuf_iterator<char>(std::cin)),
+                       std::istreambuf_iterator<char>());
   } else {
     std::ifstream ifs(cmd.filename);
     if (!ifs.is_open()) {
@@ -572,15 +608,18 @@ int cmdline(const CommandLine& cmd)
       return 1;
     }
     handle_dep(cmd.filename);
-    text = std::string((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
+    text = std::string((std::istreambuf_iterator<char>(ifs)),
+                       std::istreambuf_iterator<char>());
   }
 
 #ifdef ENABLE_PYTHON
   python_active = false;
   if (cmd.filename.c_str() != NULL) {
     if (boost::algorithm::ends_with(cmd.filename, ".py")) {
-      if (python_trusted == true) python_active = true;
-      else LOG("Python is not enabled");
+      if (python_trusted == true)
+        python_active = true;
+      else
+        LOG("Python is not enabled");
     }
   }
 
@@ -588,15 +627,16 @@ int cmdline(const CommandLine& cmd)
     auto fulltext_py = text;
     initPython(PlatformUtils::applicationPath(), 0.0);
     auto error = evaluatePython(fulltext_py, false);
-    if (error.size() > 0)LOG(error.c_str());
+    if (error.size() > 0)
+      LOG(error.c_str());
     text = "\n";
   }
-#endif // ifdef ENABLE_PYTHON
+#endif  // ifdef ENABLE_PYTHON
   text += "\n\x03\n" + commandline_commands;
 
-  SourceFile *root_file = nullptr;
+  SourceFile* root_file = nullptr;
   if (!parse(root_file, text, cmd.filename, cmd.filename, false)) {
-    delete root_file; // parse failed
+    delete root_file;  // parse failed
     root_file = nullptr;
   }
   if (!root_file) {
@@ -622,11 +662,11 @@ int cmdline(const CommandLine& cmd)
   root_file->handleDependencies();
 
   RenderVariables render_variables = {
-    .preview = fileformat::canPreview(export_format)
-      ? (cmd.viewOptions.renderer == RenderType::OPENCSG
-         || cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)
-      : false,
-    .camera = cmd.camera,
+      .preview = fileformat::canPreview(export_format)
+                     ? (cmd.viewOptions.renderer == RenderType::OPENCSG ||
+                        cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)
+                     : false,
+      .camera = cmd.camera,
   };
 
   if (cmd.animate.frames == 0) {
@@ -634,10 +674,10 @@ int cmdline(const CommandLine& cmd)
     return do_export(cmd, render_variables, export_format, root_file);
   } else {
     // export the requested number of animated frames
-    const unsigned start_frame = ((cmd.animate.shard - 1) * cmd.animate.frames)
-      / cmd.animate.num_shards;
-    const unsigned limit_frame = (cmd.animate.shard * cmd.animate.frames)
-      / cmd.animate.num_shards;
+    const unsigned start_frame =
+        ((cmd.animate.shard - 1) * cmd.animate.frames) / cmd.animate.num_shards;
+    const unsigned limit_frame =
+        (cmd.animate.shard * cmd.animate.frames) / cmd.animate.num_shards;
     for (unsigned frame = start_frame; frame < limit_frame; ++frame) {
       render_variables.time = frame * (1.0 / cmd.animate.frames);
 
@@ -656,7 +696,8 @@ int cmdline(const CommandLine& cmd)
       CommandLine frame_cmd = cmd;
       frame_cmd.output_file = frame_str;
 
-      int const r = do_export(frame_cmd, render_variables, export_format, root_file);
+      int const r =
+          do_export(frame_cmd, render_variables, export_format, root_file);
       if (r != 0) {
         return r;
       }
@@ -667,33 +708,36 @@ int cmdline(const CommandLine& cmd)
 }
 
 template <class Seq, typename ToString>
-static std::string str_join(const Seq& seq, const std::string& sep, const ToString& toString)
-{
+static std::string str_join(const Seq& seq,
+                            const std::string& sep,
+                            const ToString& toString) {
   return boost::algorithm::join(boost::adaptors::transform(seq, toString), sep);
 }
 
-static bool flagConvert(const std::string& str){
+static bool flagConvert(const std::string& str) {
   if (str == "1" || boost::iequals(str, "on") || boost::iequals(str, "true")) {
     return true;
   }
-  if (str == "0" || boost::iequals(str, "off") || boost::iequals(str, "false")) {
+  if (str == "0" || boost::iequals(str, "off") ||
+      boost::iequals(str, "false")) {
     return false;
   }
   throw std::runtime_error("");
   return false;
 }
 
-static std::tuple<std::string, std::string> simple_split(const std::string& str, const char c)
-{
+static std::tuple<std::string, std::string> simple_split(const std::string& str,
+                                                         const char c) {
   const auto idx = str.find_first_of(c);
-  if (idx == std::string::npos)return {};
+  if (idx == std::string::npos)
+    return {};
   const auto first = str.substr(0, idx);
   const auto second = str.substr(idx + 1);
   return {first, second};
 }
 
-static CmdLineExportOptions convert_export_options(const po::variables_map& vm)
-{
+static CmdLineExportOptions convert_export_options(
+    const po::variables_map& vm) {
   if (vm.count("O") == 0) {
     return {};
   }
@@ -708,10 +752,10 @@ static CmdLineExportOptions convert_export_options(const po::variables_map& vm)
   return map;
 }
 
-} // namespace
+}  // namespace
 
-void set_render_color_scheme(const std::string& color_scheme, const bool exit_if_not_found)
-{
+void set_render_color_scheme(const std::string& color_scheme,
+                             const bool exit_if_not_found) {
   if (color_scheme.empty()) {
     return;
   }
@@ -726,7 +770,8 @@ void set_render_color_scheme(const std::string& color_scheme, const bool exit_if
 
     exit(1);
   } else {
-    LOG("Unknown color scheme '%1$s', using default '%2$s'.", arg_colorscheme, ColorMap::inst()->defaultColorSchemeName());
+    LOG("Unknown color scheme '%1$s', using default '%2$s'.", arg_colorscheme,
+        ColorMap::inst()->defaultColorSchemeName());
   }
 }
 
@@ -745,19 +790,17 @@ void localization_init() {
     bind_textdomain_codeset("openscad", "UTF-8");
     textdomain("openscad");
   } else {
-    LOG("Could not initialize localization (application path is '%1$s').", PlatformUtils::applicationPath());
+    LOG("Could not initialize localization (application path is '%1$s').",
+        PlatformUtils::applicationPath());
   }
 }
 
-
-
 #ifdef Q_OS_MACOS
-std::pair<std::string, std::string> customSyntax(const std::string& s)
-{
-  if (s.find("-psn_") == 0) return {"psn", s.substr(5)};
+std::pair<std::string, std::string> customSyntax(const std::string& s) {
+  if (s.find("-psn_") == 0)
+    return {"psn", s.substr(5)};
 #else
-std::pair<std::string, std::string> customSyntax(const std::string&)
-{
+std::pair<std::string, std::string> customSyntax(const std::string&) {
 #endif
 
   return {};
@@ -765,24 +808,25 @@ std::pair<std::string, std::string> customSyntax(const std::string&)
 /*!
    This makes boost::program_option parse comma-separated values
  */
-struct CommaSeparatedVector
-{
+struct CommaSeparatedVector {
   std::vector<std::string> values;
 
-  friend std::istream& operator>>(std::istream& in, CommaSeparatedVector& value) {
+  friend std::istream& operator>>(std::istream& in,
+                                  CommaSeparatedVector& value) {
     std::string token;
     in >> token;
-    // NOLINTNEXTLINE(*NewDeleteLeaks) LLVM bug https://github.com/llvm/llvm-project/issues/40486
+    // NOLINTNEXTLINE(*NewDeleteLeaks) LLVM bug
+    // https://github.com/llvm/llvm-project/issues/40486
     boost::split(value.values, token, boost::is_any_of(","));
     return in;
   }
 };
 
 // OpenSCAD
-int main(int argc, char **argv)
-{
+int main(int argc, char** argv) {
 #if defined(ENABLE_CGAL) && defined(USE_MIMALLOC)
-  // call init_mimalloc before any GMP variables are initialized. (defined in src/openscad_mimalloc.h)
+  // call init_mimalloc before any GMP variables are initialized. (defined in
+  // src/openscad_mimalloc.h)
   init_mimalloc();
 #endif
 
@@ -791,16 +835,19 @@ int main(int argc, char **argv)
 
 #ifdef Q_OS_MACOS
   bool isGuiLaunched = getenv("GUI_LAUNCHED") != nullptr;
-  auto nslog = [](const Message& msg, void *userdata) {
-      CocoaUtils::nslog(msg.msg, userdata);
-    };
-  if (isGuiLaunched) set_output_handler(nslog, nullptr, nullptr);
+  auto nslog = [](const Message& msg, void* userdata) {
+    CocoaUtils::nslog(msg.msg, userdata);
+  };
+  if (isGuiLaunched)
+    set_output_handler(nslog, nullptr, nullptr);
 #else
   PlatformUtils::ensureStdIO();
 #endif
 
 #ifndef __EMSCRIPTEN__
-  const auto applicationPath = weakly_canonical(boost::dll::program_location()).parent_path().generic_string();
+  const auto applicationPath = weakly_canonical(boost::dll::program_location())
+                                   .parent_path()
+                                   .generic_string();
 #else
   const auto applicationPath = boost::dll::fs::current_path();
 #endif
@@ -816,7 +863,8 @@ int main(int argc, char **argv)
 #endif
 
 #ifdef ENABLE_CGAL
-  // Always throw exceptions from CGAL, so we can catch instead of crashing on bad geometry.
+  // Always throw exceptions from CGAL, so we can catch instead of crashing on
+  // bad geometry.
   CGAL::set_error_behaviour(CGAL::THROW_EXCEPTION);
   CGAL::set_warning_behaviour(CGAL::THROW_EXCEPTION);
 #endif
@@ -825,76 +873,130 @@ int main(int argc, char **argv)
   auto original_path = fs::current_path();
 
   std::vector<std::string> output_files;
-  const char *deps_output_file = nullptr;
+  const char* deps_output_file = nullptr;
   boost::optional<FileFormat> export_format;
 
   ViewOptions viewOptions{};
   po::options_description desc("Allowed options");
-  desc.add_options()
-  ("export-format", po::value<std::string> (), "overrides format of exported scad file when using option '-o', arg can be any of its supported file extensions.  For ASCII stl export, specify 'asciistl', and for binary stl export, specify 'binstl'.  ASCII export is the current stl default, but binary stl is planned as the future default so asciistl should be explicitly specified in scripts when needed.\n")
-  ("o,o", po::value<std::vector<std::string>> (), "output specified file instead of running the GUI. The file extension specifies the type: stl, off, wrl, amf, 3mf, csg, dxf, svg, pdf, png, echo, ast, term, nef3, nefdbg, param, pov. May be used multiple times for different exports. Use '-' for stdout.\n")
-  ("O,O", po::value<std::vector<std::string>> (), "pass settings value to the file export using the format section/key=value, e.g export-pdf/paper-size=a3. Use --help-export to list all available settings.")
-  ("D,D", po::value<std::vector<std::string>> (), "var=val -pre-define variables")
-  ("p,p", po::value<std::string> (), "customizer parameter file")
-  ("P,P", po::value<std::string> (), "customizer parameter set")
+  desc.add_options()(
+      "export-format", po::value<std::string>(),
+      "overrides format of exported scad file when using option '-o', arg can "
+      "be any of its supported file extensions.  For ASCII stl export, specify "
+      "'asciistl', and for binary stl export, specify 'binstl'.  ASCII export "
+      "is the current stl default, but binary stl is planned as the future "
+      "default so asciistl should be explicitly specified in scripts when "
+      "needed.\n")(
+      "o,o", po::value<std::vector<std::string>>(),
+      "output specified file instead of running the GUI. The file extension "
+      "specifies the type: stl, off, wrl, amf, 3mf, csg, dxf, svg, pdf, png, "
+      "echo, ast, term, nef3, nefdbg, param, pov. May be used multiple times "
+      "for different exports. Use '-' for stdout.\n")(
+      "O,O", po::value<std::vector<std::string>>(),
+      "pass settings value to the file export using the format "
+      "section/key=value, e.g export-pdf/paper-size=a3. Use --help-export to "
+      "list all available settings.")("D,D",
+                                      po::value<std::vector<std::string>>(),
+                                      "var=val -pre-define variables")(
+      "p,p", po::value<std::string>(), "customizer parameter file")(
+      "P,P", po::value<std::string>(), "customizer parameter set")
 #ifdef ENABLE_EXPERIMENTAL
-  ("enable", po::value<std::vector<std::string>> (), ("enable experimental features (specify 'all' for enabling all available features): " +
-                                                      str_join(boost::make_iterator_range(Feature::begin(), Feature::end()), " | ",
-                                                               [](const Feature *feature) {
-    return feature->get_name();
-  }) +
-                                                               "\n").c_str())
+      ("enable", po::value<std::vector<std::string>>(),
+       ("enable experimental features (specify 'all' for enabling all "
+        "available features): " +
+        str_join(boost::make_iterator_range(Feature::begin(), Feature::end()),
+                 " | ",
+                 [](const Feature* feature) { return feature->get_name(); }) +
+        "\n")
+           .c_str())
 #endif
-  ("help,h", "print this help message and exit")
-    ("help-export", "print list of export parameters and values that can be set via -O")
-    ("version,v", "print the version")
-    ("info", "print information about the build process\n")
-
-    ("camera", po::value<std::string>(), "camera parameters when exporting png: =translate_x,y,z,rot_x,y,z,dist or =eye_x,y,z,center_x,y,z")
-    ("autocenter", "adjust camera to look at object's center")
-    ("viewall", "adjust camera to fit object")
-    ("backend", po::value<std::string>(), "3D rendering backend to use: 'CGAL' (old/slow) [default] or 'Manifold' (new/fast)")
-    ("imgsize", po::value<std::string>(), "=width,height of exported png")
-    ("render", po::value<std::string>()->implicit_value(""), "for full geometry evaluation when exporting png")
-    ("preview", po::value<std::string>()->implicit_value(""), "[=throwntogether] -for ThrownTogether preview png")
-    ("animate", po::value<unsigned>(), "export N animated frames")
-    ("animate_sharding", po::value<std::string>(), "Parameter <shard>/<num_shards> - Divide work into <num_shards> and only output frames for <shard>. E.g. 2/5 only outputs the second 1/5 of frames. Use to parallelize work on multiple cores or machines.")
-    ("view", po::value<CommaSeparatedVector>(), ("=view options: " + boost::algorithm::join(viewOptions.names(), " | ")).c_str())
-    ("projection", po::value<std::string>(), "=(o)rtho or (p)erspective when exporting png")
-    ("csglimit", po::value<unsigned int>(), "=n -stop rendering at n CSG elements when exporting png")
-    ("summary", po::value<std::vector<std::string>>(), "enable additional render summary and statistics: all | cache | time | camera | geometry | bounding-box | area")
-    ("summary-file", po::value<std::string>(), "output summary information in JSON format to the given file, using '-' outputs to stdout")
-    ("colorscheme", po::value<std::string>(), ("=colorscheme: " +
-                                               str_join(ColorMap::inst()->colorSchemeNames(), " | ",
-                                                        [](const std::string& colorScheme) {
-                                                        return (colorScheme == ColorMap::inst()->defaultColorSchemeName() ? "*" : "") + colorScheme;
-    }) +
-                                               "\n").c_str())
-    ("d,d", po::value<std::string>(), "deps_file -generate a dependency file for make")
-    ("m,m", po::value<std::string>(), "make_cmd -runs make_cmd file if file is missing")
-    ("quiet,q", "quiet mode (don't print anything *except* errors)")
-    ("hardwarnings", "Stop on the first warning")
-    ("trace-depth", po::value<unsigned int>(), "=n, maximum number of trace messages")
-    ("trace-usermodule-parameters", po::value<std::string>(), "=true/false, configure the output of user module parameters in a trace")
-    ("check-parameters", po::value<std::string>(), "=true/false, configure the parameter check for user modules and functions")
-    ("check-parameter-ranges", po::value<std::string>(), "=true/false, configure the parameter range check for builtin modules")
-    ("debug", po::value<std::string>(), "special debug info - specify 'all' or a set of source file names")
+          ("help,h", "print this help message and exit")(
+              "help-export",
+              "print list of export parameters and values that can be set via "
+              "-O")("version,v", "print the version")(
+              "info", "print information about the build process\n")
+
+              ("camera", po::value<std::string>(),
+               "camera parameters when exporting png: "
+               "=translate_x,y,z,rot_x,y,z,dist or =eye_x,y,z,center_x,y,z")(
+                  "autocenter", "adjust camera to look at object's center")(
+                  "viewall", "adjust camera to fit object")(
+                  "backend", po::value<std::string>(),
+                  "3D rendering backend to use: 'CGAL' (old/slow) [default] or "
+                  "'Manifold' (new/fast)")("imgsize", po::value<std::string>(),
+                                           "=width,height of exported png")(
+                  "render", po::value<std::string>()->implicit_value(""),
+                  "for full geometry evaluation when exporting png")(
+                  "preview", po::value<std::string>()->implicit_value(""),
+                  "[=throwntogether] -for ThrownTogether preview png")(
+                  "animate", po::value<unsigned>(), "export N animated frames")(
+                  "animate_sharding", po::value<std::string>(),
+                  "Parameter <shard>/<num_shards> - Divide work into "
+                  "<num_shards> and only output frames for <shard>. E.g. 2/5 "
+                  "only outputs the second 1/5 of frames. Use to parallelize "
+                  "work on multiple cores or machines.")(
+                  "view", po::value<CommaSeparatedVector>(),
+                  ("=view options: " +
+                   boost::algorithm::join(viewOptions.names(), " | "))
+                      .c_str())("projection", po::value<std::string>(),
+                                "=(o)rtho or (p)erspective when exporting png")(
+                  "csglimit", po::value<unsigned int>(),
+                  "=n -stop rendering at n CSG elements when exporting png")(
+                  "summary", po::value<std::vector<std::string>>(),
+                  "enable additional render summary and statistics: all | "
+                  "cache | time | camera | geometry | bounding-box | area")(
+                  "summary-file", po::value<std::string>(),
+                  "output summary information in JSON format to the given "
+                  "file, using '-' outputs to stdout")(
+                  "colorscheme", po::value<std::string>(),
+                  ("=colorscheme: " +
+                   str_join(ColorMap::inst()->colorSchemeNames(), " | ",
+                            [](const std::string& colorScheme) {
+                              return (colorScheme ==
+                                              ColorMap::inst()
+                                                  ->defaultColorSchemeName()
+                                          ? "*"
+                                          : "") +
+                                     colorScheme;
+                            }) +
+                   "\n")
+                      .c_str())(
+                  "d,d", po::value<std::string>(),
+                  "deps_file -generate a dependency file for make")(
+                  "m,m", po::value<std::string>(),
+                  "make_cmd -runs make_cmd file if file is missing")(
+                  "quiet,q",
+                  "quiet mode (don't print anything *except* errors)")(
+                  "hardwarnings", "Stop on the first warning")(
+                  "trace-depth", po::value<unsigned int>(),
+                  "=n, maximum number of trace messages")(
+                  "trace-usermodule-parameters", po::value<std::string>(),
+                  "=true/false, configure the output of user module parameters "
+                  "in a trace")("check-parameters", po::value<std::string>(),
+                                "=true/false, configure the parameter check "
+                                "for user modules and functions")(
+                  "check-parameter-ranges", po::value<std::string>(),
+                  "=true/false, configure the parameter range check for "
+                  "builtin modules")("debug", po::value<std::string>(),
+                                     "special debug info - specify 'all' or a "
+                                     "set of source file names")
 #ifdef ENABLE_PYTHON
-  ("trust-python",  "Trust python")
-    ("python-module", po::value<std::string>(), "=module Call pip python module")
+                  ("trust-python", "Trust python")(
+                      "python-module", po::value<std::string>(),
+                      "=module Call pip python module")
 #endif
-  ;
+      ;
 
 #ifdef ENABLE_GUI_TESTS
-  desc.add_options()("run-all-gui-tests", "special gui testing mode - run all the tests");
+  desc.add_options()("run-all-gui-tests",
+                     "special gui testing mode - run all the tests");
 #endif
 
   po::options_description hidden("Hidden options");
   hidden.add_options()
 #ifdef Q_OS_MACOS
-  ("psn", po::value<std::string>(), "process serial number")
+      ("psn", po::value<std::string>(), "process serial number")
 #endif
-  ("input-file", po::value<std::vector<std::string>>(), "input file");
+          ("input-file", po::value<std::vector<std::string>>(), "input file");
 
   po::positional_options_description p;
   p.add("input-file", -1);
@@ -904,8 +1006,13 @@ int main(int argc, char **argv)
 
   po::variables_map vm;
   try {
-    po::store(po::command_line_parser(argc, argv).options(all_options).positional(p).extra_parser(customSyntax).run(), vm);
-  } catch (const std::exception& e) { // Catches e.g. unknown options
+    po::store(po::command_line_parser(argc, argv)
+                  .options(all_options)
+                  .positional(p)
+                  .extra_parser(customSyntax)
+                  .run(),
+              vm);
+  } catch (const std::exception& e) {  // Catches e.g. unknown options
     LOG("%1$s\n", e.what());
     help(argv[0], desc, true);
   }
@@ -930,7 +1037,7 @@ int main(int argc, char **argv)
     }
     return pythonRunModule(applicationPath, vm[pymod].as<std::string>(), args);
   }
-#endif // ifdef ENABLE_PYTHON
+#endif  // ifdef ENABLE_PYTHON
   if (vm.count("quiet")) {
     OpenSCAD::quiet = true;
   }
@@ -942,8 +1049,9 @@ int main(int argc, char **argv)
   if (vm.count("traceDepth")) {
     OpenSCAD::traceDepth = vm["traceDepth"].as<unsigned int>();
   }
-  std::map<std::string, bool *> flags;
-  flags.insert(std::make_pair("trace-usermodule-parameters", &OpenSCAD::traceUsermoduleParameters));
+  std::map<std::string, bool*> flags;
+  flags.insert(std::make_pair("trace-usermodule-parameters",
+                              &OpenSCAD::traceUsermoduleParameters));
   flags.insert(std::make_pair("check-parameters", &OpenSCAD::parameterCheck));
   flags.insert(std::make_pair("check-parameter-ranges", &OpenSCAD::rangeCheck));
   for (const auto& flag : flags) {
@@ -958,26 +1066,36 @@ int main(int argc, char **argv)
     }
   }
 
-  if (vm.count("help")) help(argv[0], desc);
-  if (vm.count("help-export")) help_export();
-  if (vm.count("version")) version();
-  if (vm.count("info")) arg_info = true;
+  if (vm.count("help"))
+    help(argv[0], desc);
+  if (vm.count("help-export"))
+    help_export();
+  if (vm.count("version"))
+    version();
+  if (vm.count("info"))
+    arg_info = true;
   if (vm.count("backend")) {
-    RenderSettings::inst()->backend3D = renderBackend3DFromString(vm["backend"].as<std::string>());
+    RenderSettings::inst()->backend3D =
+        renderBackend3DFromString(vm["backend"].as<std::string>());
   }
 
   if (vm.count("preview")) {
-    if (vm["preview"].as<std::string>() == "throwntogether") viewOptions.renderer = RenderType::THROWNTOGETHER;
+    if (vm["preview"].as<std::string>() == "throwntogether")
+      viewOptions.renderer = RenderType::THROWNTOGETHER;
   } else if (vm.count("render")) {
-    // Note: "cgal" is here for backwards compatibility, can probably be removed soon
-    if (vm["render"].as<std::string>() == "cgal" || vm["render"].as<std::string>() == "force") {
+    // Note: "cgal" is here for backwards compatibility, can probably be removed
+    // soon
+    if (vm["render"].as<std::string>() == "cgal" ||
+        vm["render"].as<std::string>() == "force") {
       viewOptions.renderer = RenderType::BACKEND_SPECIFIC;
     } else {
       viewOptions.renderer = RenderType::GEOMETRY;
     }
   }
 
-  viewOptions.previewer = (viewOptions.renderer == RenderType::THROWNTOGETHER) ? Previewer::THROWNTOGETHER : Previewer::OPENCSG;
+  viewOptions.previewer = (viewOptions.renderer == RenderType::THROWNTOGETHER)
+                              ? Previewer::THROWNTOGETHER
+                              : Previewer::OPENCSG;
   if (vm.count("view")) {
     const auto& viewOptionValues = vm["view"].as<CommaSeparatedVector>();
 
@@ -985,24 +1103,29 @@ int main(int argc, char **argv)
       try {
         viewOptions[option] = true;
       } catch (const std::out_of_range& e) {
-        LOG("Unknown --view option '%1$s' ignored. Use -h to list available options.", option);
+        LOG("Unknown --view option '%1$s' ignored. Use -h to list available "
+            "options.",
+            option);
       }
     }
   }
 
   if (vm.count("csglimit")) {
-    RenderSettings::inst()->openCSGTermLimit = vm["csglimit"].as<unsigned int>();
+    RenderSettings::inst()->openCSGTermLimit =
+        vm["csglimit"].as<unsigned int>();
   }
 
   if (vm.count("o")) {
     output_files = vm["o"].as<std::vector<std::string>>();
   }
   if (vm.count("d")) {
-    if (deps_output_file) help(argv[0], desc, true);
+    if (deps_output_file)
+      help(argv[0], desc, true);
     deps_output_file = vm["d"].as<std::string>().c_str();
   }
   if (vm.count("m")) {
-    if (make_command) help(argv[0], desc, true);
+    if (make_command)
+      help(argv[0], desc, true);
     make_command = vm["m"].as<std::string>().c_str();
   }
 
@@ -1054,7 +1177,9 @@ int main(int argc, char **argv)
       export_format.emplace(format);
 
     } else {
-      LOG("Unknown --export-format option '%1$s'.  Use -h to list available options.", format_str);
+      LOG("Unknown --export-format option '%1$s'.  Use -h to list available "
+          "options.",
+          format_str);
       return 1;
     }
   }
@@ -1077,13 +1202,15 @@ int main(int argc, char **argv)
   PRINTDB("Application location detected as %s", applicationPath);
 
   auto cmdlinemode = false;
-  if (!output_files.empty()) { // cmd-line mode
+  if (!output_files.empty()) {  // cmd-line mode
     cmdlinemode = true;
-    if (!inputFiles.size()) help(argv[0], desc, true);
+    if (!inputFiles.size())
+      help(argv[0], desc, true);
   }
 
   if (arg_info || cmdlinemode) {
-    if (inputFiles.size() > 1) help(argv[0], desc, true);
+    if (inputFiles.size() > 1)
+      help(argv[0], desc, true);
     try {
       parser_init();
       localization_init();
@@ -1097,21 +1224,22 @@ int main(int argc, char **argv)
           const std::string output_file = is_stdout ? "<stdout>" : filename;
           const auto export_options = convert_export_options(vm);
           const CommandLine cmd{
-            is_stdin,
-            input_file,
-            is_stdout,
-            output_file,
-            original_path,
-            parameterFile,
-            parameterSet,
-            viewOptions,
-            camera,
-            export_format,
-            export_options,
-            animate,
-            vm.count("summary") ? vm["summary"].as<std::vector<std::string>>() : std::vector<std::string>{},
-            vm.count("summary-file") ? vm["summary-file"].as<std::string>() : ""
-          };
+              is_stdin,
+              input_file,
+              is_stdout,
+              output_file,
+              original_path,
+              parameterFile,
+              parameterSet,
+              viewOptions,
+              camera,
+              export_format,
+              export_options,
+              animate,
+              vm.count("summary") ? vm["summary"].as<std::vector<std::string>>()
+                                  : std::vector<std::string>{},
+              vm.count("summary-file") ? vm["summary-file"].as<std::string>()
+                                       : ""};
           rc |= cmdline(cmd);
         }
       }
@@ -1133,7 +1261,7 @@ int main(int argc, char **argv)
       LOG("Ignoring --export-format option");
     }
     std::string gui_test = "none";
-    if (vm.count("run-all-gui-tests")){
+    if (vm.count("run-all-gui-tests")) {
       gui_test = "all";
     }
     rc = gui(inputFiles, original_path, argc, argv, gui_test);
diff --git a/src/openscad.h b/src/openscad.h
index 44532c01c..0e19d29dc 100644
--- a/src/openscad.h
+++ b/src/openscad.h
@@ -29,7 +29,11 @@
 #include <string>
 #include <utility>
 
-extern bool parse(class SourceFile *&file, const std::string& text, const std::string& filename, const std::string& mainFile, int debug);
+extern bool parse(class SourceFile*& file,
+                  const std::string& text,
+                  const std::string& filename,
+                  const std::string& mainFile,
+                  int debug);
 
 extern std::string commandline_commands;
 
@@ -37,4 +41,5 @@ extern std::string commandline_commands;
 std::pair<std::string, std::string> customSyntax(const std::string& s);
 
 void localization_init();
-void set_render_color_scheme(const std::string& color_scheme, const bool exit_if_not_found);
+void set_render_color_scheme(const std::string& color_scheme,
+                             const bool exit_if_not_found);
diff --git a/src/openscad_gui.cc b/src/openscad_gui.cc
index aab0cf49e..2c3136a2e 100644
--- a/src/openscad_gui.cc
+++ b/src/openscad_gui.cc
@@ -25,13 +25,11 @@
  */
 
 #include "openscad_gui.h"
-#include <memory>
 #include <filesystem>
+#include <memory>
 #include <string>
 #include <vector>
 
-#include <QtGlobal>
-#include <Qt>
 #include <QDialog>
 #include <QDir>
 #include <QFileInfo>
@@ -40,13 +38,15 @@
 #include <QIcon>
 #include <QObject>
 #include <QPalette>
-#include <QStyleHints>
 #include <QStringList>
+#include <QStyleHints>
+#include <Qt>
 #include <QtConcurrentRun>
+#include <QtGlobal>
 
-#include "core/parsersettings.h"
-#include "core/Settings.h"
 #include "FontCache.h"
+#include "core/Settings.h"
+#include "core/parsersettings.h"
 #include "geometry/Geometry.h"
 #include "gui/AppleEvents.h"
 #include "gui/input/InputDriverManager.h"
@@ -92,7 +92,8 @@ namespace {
 //
 // For applying a color change, e.g. highlighting the background of an input
 // field, see:
-// UIUtils::blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend)
+// UIUtils::blendForBackgroundColorStyleSheet(const QColor& input, const QColor&
+// blend)
 
 bool isDarkMode() {
 #if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
@@ -103,17 +104,18 @@ bool isDarkMode() {
   const auto& text = defaultPalette.color(QPalette::WindowText);
   const auto& window = defaultPalette.color(QPalette::Window);
   return text.lightness() > window.lightness();
-#endif // QT_VERSION
+#endif  // QT_VERSION
 }
 
-}
+}  // namespace
 
 namespace {
 
 // Only if "fileName" is not absolute, prepend the "absoluteBase".
 QString assemblePath(const std::filesystem::path& absoluteBaseDir,
                      const std::string& fileName) {
-  if (fileName.empty()) return "";
+  if (fileName.empty())
+    return "";
   auto qsDir = QString::fromLocal8Bit(absoluteBaseDir.generic_string().c_str());
   auto qsFile = QString::fromLocal8Bit(fileName.c_str());
   // if qsfile is absolute, dir is ignored. (see documentation of QFileInfo)
@@ -121,30 +123,28 @@ QString assemblePath(const std::filesystem::path& absoluteBaseDir,
   return fileInfo.absoluteFilePath();
 }
 
-
-void dialogThreadFunc(FontCacheInitializer *initializer)
-{
+void dialogThreadFunc(FontCacheInitializer* initializer) {
   initializer->run();
 }
 
-void dialogInitHandler(FontCacheInitializer *initializer, void *)
-{
+void dialogInitHandler(FontCacheInitializer* initializer, void*) {
   QFutureWatcher<void> futureWatcher;
-  QObject::connect(&futureWatcher, &QFutureWatcher<void>::finished, scadApp, &OpenSCADApp::hideFontCacheDialog);
+  QObject::connect(&futureWatcher, &QFutureWatcher<void>::finished, scadApp,
+                   &OpenSCADApp::hideFontCacheDialog);
 
-  auto future = QtConcurrent::run([initializer] {
-      return dialogThreadFunc(initializer);
-    });
+  auto future = QtConcurrent::run(
+      [initializer] { return dialogThreadFunc(initializer); });
   futureWatcher.setFuture(future);
 
   // We don't always get the started() signal, so we start manually
   QMetaObject::invokeMethod(scadApp, "showFontCacheDialog");
 
-  // Block, in case we're in a separate thread, or the dialog was closed by the user
+  // Block, in case we're in a separate thread, or the dialog was closed by the
+  // user
   futureWatcher.waitForFinished();
 
-  // We don't always receive the finished signal. We still need the signal to break
-  // out of the exec() though.
+  // We don't always receive the finished signal. We still need the signal to
+  // break out of the exec() though.
   QMetaObject::invokeMethod(scadApp, "hideFontCacheDialog");
 }
 
@@ -153,12 +153,16 @@ void registerDefaultIcon(QString applicationFilePath) {
   // Not using cached instance here, so this needs to be in a
   // separate scope to ensure the QSettings instance is released
   // directly after use.
-  QSettings reg_setting(QLatin1String("HKEY_CURRENT_USER"), QSettings::NativeFormat);
-  auto appPath = QDir::toNativeSeparators(applicationFilePath + QLatin1String(",1"));
-  reg_setting.setValue(QLatin1String("Software/Classes/OpenSCAD_File/DefaultIcon/Default"), QVariant(appPath));
+  QSettings reg_setting(QLatin1String("HKEY_CURRENT_USER"),
+                        QSettings::NativeFormat);
+  auto appPath =
+      QDir::toNativeSeparators(applicationFilePath + QLatin1String(",1"));
+  reg_setting.setValue(
+      QLatin1String("Software/Classes/OpenSCAD_File/DefaultIcon/Default"),
+      QVariant(appPath));
 }
 #else
-void registerDefaultIcon(const QString&) { }
+void registerDefaultIcon(const QString&) {}
 #endif
 
 }  // namespace
@@ -169,14 +173,16 @@ void registerDefaultIcon(const QString&) { }
 #define DESKTOP_FILENAME "openscad"
 #endif
 
-int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& original_path, int argc, char **argv, const std::string& gui_test)
-{
+int gui(std::vector<std::string>& inputFiles,
+        const std::filesystem::path& original_path,
+        int argc,
+        char** argv,
+        const std::string& gui_test) {
   OpenSCADApp app(argc, argv);
   // remove ugly frames in the QStatusBar when using additional widgets
   app.setStyleSheet(
-    "QStatusBar::item { border: 0px solid black; }"
-    "* { font-size: 9pt }"
-    );
+      "QStatusBar::item { border: 0px solid black; }"
+      "* { font-size: 9pt }");
   QIcon::setThemeName(isDarkMode() ? "chokusen-dark" : "chokusen");
 
   // set up groups for QSettings
@@ -215,9 +221,10 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
   registerDefaultIcon(app.applicationFilePath());
 
 #ifdef OPENSCAD_UPDATER
-  AutoUpdater *updater = new SparkleAutoUpdater;
+  AutoUpdater* updater = new SparkleAutoUpdater;
   AutoUpdater::setUpdater(updater);
-  if (updater->automaticallyChecksForUpdates()) updater->checkForUpdates();
+  if (updater->automaticallyChecksForUpdates())
+    updater->checkForUpdates();
   updater->init();
 #endif
 
@@ -251,11 +258,11 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
   }
 
   QStringList inputFilesList;
-  for (const auto& infile: inputFiles) {
+  for (const auto& infile : inputFiles) {
     inputFilesList.append(assemblePath(original_path, infile));
   }
   new MainWindow(inputFilesList);
-  QObject::connect(&app, &QCoreApplication::aboutToQuit, [](){
+  QObject::connect(&app, &QCoreApplication::aboutToQuit, []() {
     QSettingsCached{}.release();
 #ifdef Q_OS_MACOS
     CocoaUtils::endApplication();
@@ -271,7 +278,8 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
 #ifdef ENABLE_SPNAV
   if (Settings::Settings::inputEnableDriverSPNAV.value()) {
     auto spaceNavDriver = new SpaceNavInputDriver();
-    bool spaceNavDominantAxisOnly = Settings::Settings::inputEnableDriverHIDAPI.value();
+    bool spaceNavDominantAxisOnly =
+        Settings::Settings::inputEnableDriverHIDAPI.value();
     spaceNavDriver->setDominantAxisOnly(spaceNavDominantAxisOnly);
     InputDriverManager::instance()->registerDriver(spaceNavDriver);
   }
@@ -300,19 +308,19 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
 #endif
 
 #ifdef ENABLE_GUI_TESTS
-  // Adds a singleshot timer that will be executed when the application will be started.
-  // the timer validates that each mainwindow respects the expected UX behavior.
-  if (gui_test != "none"){
-    QTimer::singleShot(0, [&]()
-    {
+  // Adds a singleshot timer that will be executed when the application will be
+  // started. the timer validates that each mainwindow respects the expected UX
+  // behavior.
+  if (gui_test != "none") {
+    QTimer::singleShot(0, [&]() {
       int failureCount = 0;
-      for (auto w : app.windowManager.getWindows()){
+      for (auto w : app.windowManager.getWindows()) {
         failureCount += runAllTest(w);
       }
       app.exit(failureCount);
     });
   }
-#endif // ENABLE_GUI_TESTS
+#endif  // ENABLE_GUI_TESTS
 
   InputDriverManager::instance()->init();
   return app.exec();
diff --git a/src/openscad_gui.h b/src/openscad_gui.h
index fec7c48d6..9f197c526 100644
--- a/src/openscad_gui.h
+++ b/src/openscad_gui.h
@@ -31,4 +31,8 @@
 
 #include <filesystem>
 
-int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& original_path, int argc, char **argv, const std::string&);
+int gui(std::vector<std::string>& inputFiles,
+        const std::filesystem::path& original_path,
+        int argc,
+        char** argv,
+        const std::string&);
diff --git a/src/openscad_mimalloc.h b/src/openscad_mimalloc.h
index 562157e26..203b83bee 100644
--- a/src/openscad_mimalloc.h
+++ b/src/openscad_mimalloc.h
@@ -2,21 +2,28 @@
 
 #ifdef USE_MIMALLOC
 
-#if 0 // defined(_WIN32) && defined(MI_LINK_SHARED)
+#if 0  // defined(_WIN32) && defined(MI_LINK_SHARED)
 // mimalloc doesn't support static override of malloc on Windows.
 // This include causes crashes if mimalloc is statically linked.
-  #include <mimalloc-new-delete.h>
+#include <mimalloc-new-delete.h>
 #else
-  #include <mimalloc.h>
+#include <mimalloc.h>
 #endif
 
 #if defined(ENABLE_CGAL)
 #include <cstddef>
-// gmp requires function signature with extra oldsize parameters for some reason.
-inline void *gmp_realloc(void *ptr, size_t /*oldsize*/, size_t newsize) { return mi_realloc(ptr, newsize); }
-inline void gmp_free(void *ptr, size_t /*oldsize*/) { mi_free(ptr); }
-  #include <gmp.h>
-inline void init_mimalloc() { mp_set_memory_functions(mi_malloc, gmp_realloc, gmp_free); }
-#endif // ENABLE_CGAL
+// gmp requires function signature with extra oldsize parameters for some
+// reason.
+inline void* gmp_realloc(void* ptr, size_t /*oldsize*/, size_t newsize) {
+  return mi_realloc(ptr, newsize);
+}
+inline void gmp_free(void* ptr, size_t /*oldsize*/) {
+  mi_free(ptr);
+}
+#include <gmp.h>
+inline void init_mimalloc() {
+  mp_set_memory_functions(mi_malloc, gmp_realloc, gmp_free);
+}
+#endif  // ENABLE_CGAL
 
-#endif // USE_MIMALLOC
+#endif  // USE_MIMALLOC
diff --git a/src/platform/CocoaUtils.h b/src/platform/CocoaUtils.h
index 234622ac7..582a2e59a 100644
--- a/src/platform/CocoaUtils.h
+++ b/src/platform/CocoaUtils.h
@@ -2,9 +2,8 @@
 
 #include <string>
 
-class CocoaUtils
-{
-public:
+class CocoaUtils {
+ public:
   static void endApplication();
-  static void nslog(const std::string& str, void *userdata);
+  static void nslog(const std::string& str, void* userdata);
 };
diff --git a/src/platform/PlatformUtils-posix.cc b/src/platform/PlatformUtils-posix.cc
index b7c32bb39..aba6bda30 100644
--- a/src/platform/PlatformUtils-posix.cc
+++ b/src/platform/PlatformUtils-posix.cc
@@ -1,25 +1,24 @@
-#include <iterator>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <unistd.h>
+#include <fstream>
 #include <ios>
+#include <iterator>
 #include <mutex>
 #include <string>
-#include <fstream>
-#include <unistd.h>
-#include <sys/resource.h>
-#include <sys/utsname.h>
 
-#include <boost/regex.hpp>
 #include <boost/algorithm/string.hpp>
+#include <boost/regex.hpp>
 #include <filesystem>
 
-#include "version.h"
 #include "platform/PlatformUtils.h"
+#include "version.h"
 
 namespace fs = std::filesystem;
 
 static std::mutex user_agent_mutex;
 
-static std::string readText(const std::string& path)
-{
+static std::string readText(const std::string& path) {
   std::ifstream s{path.c_str()};
   s.seekg(0, std::ios::end);
   if (s.fail() || s.tellg() > 4096) {
@@ -27,18 +26,18 @@ static std::string readText(const std::string& path)
   }
   s.seekg(0, std::ios::beg);
 
-  std::string text{(std::istreambuf_iterator<char>(s)), std::istreambuf_iterator<char>()};
+  std::string text{(std::istreambuf_iterator<char>(s)),
+                   std::istreambuf_iterator<char>()};
   return text;
 }
 
 // see http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
-static fs::path getXdgConfigDir()
-{
-  const char *xdg_env = getenv("XDG_CONFIG_HOME");
+static fs::path getXdgConfigDir() {
+  const char* xdg_env = getenv("XDG_CONFIG_HOME");
   if (xdg_env && fs::exists(fs::path{xdg_env})) {
     return fs::path{xdg_env};
   } else {
-    const char *home = getenv("HOME");
+    const char* home = getenv("HOME");
     if (home) {
       return fs::path{home} / ".config";
     }
@@ -52,8 +51,7 @@ static fs::path getXdgConfigDir()
 // user-dirs.dirs file generated by the xdg-user-dirs-update tool. Missing
 // is any handling of shell style quotes so this may fail with unusual
 // setup.
-static std::string getXdgUserDir(const std::string& dir)
-{
+static std::string getXdgUserDir(const std::string& dir) {
   const fs::path config_dir = getXdgConfigDir() / "user-dirs.dirs";
   const std::string user_dirs{readText(config_dir.generic_string())};
 
@@ -66,20 +64,18 @@ static std::string getXdgUserDir(const std::string& dir)
   return "";
 }
 
-std::string PlatformUtils::pathSeparatorChar()
-{
+std::string PlatformUtils::pathSeparatorChar() {
   return ":";
 }
 
-std::string PlatformUtils::userDocumentsPath()
-{
+std::string PlatformUtils::userDocumentsPath() {
   fs::path user_documents_path;
 
-  const char *xdg_env = getenv("XDG_DOCUMENTS_DIR");
+  const char* xdg_env = getenv("XDG_DOCUMENTS_DIR");
   if (xdg_env && fs::exists(fs::path(xdg_env))) {
     user_documents_path = fs::path(xdg_env);
   } else {
-    const char *home = getenv("HOME");
+    const char* home = getenv("HOME");
     if (home) {
       fs::path home_path{home};
       const auto user_dirs = getXdgUserDir("XDG_DOCUMENTS_DIR");
@@ -98,9 +94,8 @@ std::string PlatformUtils::userDocumentsPath()
   return "";
 }
 
-std::string PlatformUtils::documentsPath()
-{
-  const char *home = getenv("HOME");
+std::string PlatformUtils::documentsPath() {
+  const char* home = getenv("HOME");
   if (home) {
     fs::path docpath(home);
     docpath = docpath / ".local" / "share";
@@ -110,8 +105,7 @@ std::string PlatformUtils::documentsPath()
   }
 }
 
-std::string PlatformUtils::userConfigPath()
-{
+std::string PlatformUtils::userConfigPath() {
   const fs::path config_path{getXdgConfigDir() / OPENSCAD_FOLDER_NAME};
 
   if (fs::is_directory(config_path)) {
@@ -121,8 +115,7 @@ std::string PlatformUtils::userConfigPath()
   return "";
 }
 
-unsigned long PlatformUtils::stackLimit()
-{
+unsigned long PlatformUtils::stackLimit() {
 #ifndef __EMSCRIPTEN__
   struct rlimit limit;
 
@@ -141,7 +134,7 @@ unsigned long PlatformUtils::stackLimit()
       return limit.rlim_max - STACK_BUFFER_SIZE;
     }
   }
-#endif // __EMSCRIPTEN__
+#endif  // __EMSCRIPTEN__
 
   return STACK_LIMIT_DEFAULT;
 }
@@ -152,8 +145,7 @@ unsigned long PlatformUtils::stackLimit()
  * @see http://www.freedesktop.org/software/systemd/man/os-release.html
  * @return the PRETTY_NAME from the os-release file or an empty string.
  */
-static const std::string checkOsRelease()
-{
+static const std::string checkOsRelease() {
   std::string os_release(readText("/etc/os-release"));
 
   boost::smatch results;
@@ -165,8 +157,7 @@ static const std::string checkOsRelease()
   return "";
 }
 
-static const std::string checkEtcIssue()
-{
+static const std::string checkEtcIssue() {
   std::string issue(readText("/etc/issue"));
 
   boost::regex nl("\n.*$");
@@ -178,8 +169,7 @@ static const std::string checkEtcIssue()
   return issue;
 }
 
-static const std::string detectDistribution()
-{
+static const std::string detectDistribution() {
   std::string osrelease = checkOsRelease();
   if (!osrelease.empty()) {
     return osrelease;
@@ -193,8 +183,7 @@ static const std::string detectDistribution()
   return "";
 }
 
-static const std::string get_distribution(const std::string& separator)
-{
+static const std::string get_distribution(const std::string& separator) {
   std::string result;
   std::string distribution = detectDistribution();
   if (!distribution.empty()) {
@@ -204,8 +193,7 @@ static const std::string get_distribution(const std::string& separator)
   return result;
 }
 
-static const std::string get_system_info(bool extended = true)
-{
+static const std::string get_system_info(bool extended = true) {
   std::string result;
 
   struct utsname osinfo;
@@ -226,8 +214,7 @@ static const std::string get_system_info(bool extended = true)
   return result;
 }
 
-const std::string PlatformUtils::user_agent()
-{
+const std::string PlatformUtils::user_agent() {
   static std::string result;
 
   std::lock_guard<std::mutex> lock(user_agent_mutex);
@@ -244,8 +231,7 @@ const std::string PlatformUtils::user_agent()
   return result;
 }
 
-const std::string PlatformUtils::sysinfo(bool extended)
-{
+const std::string PlatformUtils::sysinfo(bool extended) {
   std::string result;
 
   result += get_system_info(true);
diff --git a/src/platform/PlatformUtils-win.cc b/src/platform/PlatformUtils-win.cc
index 0243ece1d..9f55ddc68 100644
--- a/src/platform/PlatformUtils-win.cc
+++ b/src/platform/PlatformUtils-win.cc
@@ -2,18 +2,18 @@
 
 #include <filesystem>
 #include <ios>
-#include <string>
 #include <map>
+#include <string>
 
-#include "utils/printutils.h"
 #include "utils/findversion.h"
+#include "utils/printutils.h"
 #ifndef _WIN32_WINNT
 #define _WIN32_WINNT 0x0501
 #endif
 #undef NOGDI
 #include <windows.h>
 #ifndef _WIN32_IE
-#define _WIN32_IE 0x0501 // SHGFP_TYPE_CURRENT
+#define _WIN32_IE 0x0501  // SHGFP_TYPE_CURRENT
 #endif
 
 // Ugly hack to disable definitions in shobjidl.h which use unavailable
@@ -24,14 +24,12 @@
 
 #include "version.h"
 
-std::string PlatformUtils::pathSeparatorChar()
-{
+std::string PlatformUtils::pathSeparatorChar() {
   return ";";
 }
 
 // convert from windows api w_char strings (usually utf16) to utf8 std::string
-std::string winapi_wstr_to_utf8(std::wstring wstr)
-{
+std::string winapi_wstr_to_utf8(std::wstring wstr) {
   UINT CodePage = CP_UTF8;
   DWORD dwFlags = 0;
   LPCWSTR lpWideCharStr = &wstr[0];
@@ -42,16 +40,19 @@ std::string winapi_wstr_to_utf8(std::wstring wstr)
   LPBOOL lpUsedDefaultChar = nullptr;
 
   int numbytes = WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr,
-                                     cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
+                                     cchWideChar, lpMultiByteStr, cbMultiByte,
+                                     lpDefaultChar, lpUsedDefaultChar);
 
-  // LOG(message_group::NONE,,"utf16 to utf8 conversion: numbytes %1$i",numbytes);
+  // LOG(message_group::NONE,,"utf16 to utf8 conversion: numbytes
+  // %1$i",numbytes);
 
   std::string utf8_str(numbytes, 0);
   lpMultiByteStr = &utf8_str[0];
   cbMultiByte = numbytes;
 
   int result = WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr,
-                                   cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
+                                   cchWideChar, lpMultiByteStr, cbMultiByte,
+                                   lpDefaultChar, lpUsedDefaultChar);
 
   if (result != numbytes) {
     DWORD errcode = GetLastError();
@@ -62,9 +63,9 @@ std::string winapi_wstr_to_utf8(std::wstring wstr)
   return utf8_str;
 }
 
-// see http://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx
-static const std::string getFolderPath(int nFolder)
-{
+// see
+// http://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx
+static const std::string getFolderPath(int nFolder) {
   std::wstring path(MAX_PATH, 0);
 
   HWND hwndOwner = 0;
@@ -75,7 +76,7 @@ static const std::string getFolderPath(int nFolder)
   int result = SHGetFolderPathW(hwndOwner, nFolder, hToken, dwFlags, pszPath);
 
   if (result == S_OK) {
-    path = std::wstring(path.c_str() ); // strip extra nullptrs
+    path = std::wstring(path.c_str());  // strip extra nullptrs
     // Use std::filesystem to decide how to convert from wstring
     // to string. Normally the path encoding is system local and
     // we don't want to force conversion to UTF-8.
@@ -85,8 +86,7 @@ static const std::string getFolderPath(int nFolder)
   return "";
 }
 
-std::string PlatformUtils::userDocumentsPath()
-{
+std::string PlatformUtils::userDocumentsPath() {
   return documentsPath();
 }
 
@@ -95,8 +95,7 @@ std::string PlatformUtils::userDocumentsPath()
 // In Vista, 7, 8+ this is 'c:\users\username\documents'
 // This code may have problems with unusual dir types in Vista because
 // Mingw does not provide access to the updated SHGetKnownFolderPath
-std::string PlatformUtils::documentsPath()
-{
+std::string PlatformUtils::documentsPath() {
   const std::string retval = getFolderPath(CSIDL_PERSONAL);
   if (retval.empty()) {
     LOG(message_group::Error, "Could not find My Documents location");
@@ -104,8 +103,7 @@ std::string PlatformUtils::documentsPath()
   return retval;
 }
 
-std::string PlatformUtils::userConfigPath()
-{
+std::string PlatformUtils::userConfigPath() {
   const std::string retval = getFolderPath(CSIDL_LOCAL_APPDATA);
   if (retval.empty()) {
     LOG(message_group::Error, "Could not find Local AppData location");
@@ -113,23 +111,23 @@ std::string PlatformUtils::userConfigPath()
   return retval + std::string("/") + PlatformUtils::OPENSCAD_FOLDER_NAME;
 }
 
-unsigned long PlatformUtils::stackLimit()
-{
+unsigned long PlatformUtils::stackLimit() {
   return STACK_LIMIT_DEFAULT;
 }
 
 // NOLINTNEXTLINE(modernize-use-using)
-typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);
+typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);
 
-// see http://msdn.microsoft.com/en-us/library/windows/desktop/ms684139%28v=vs.85%29.aspx
-static BOOL IsWow64()
-{
+// see
+// http://msdn.microsoft.com/en-us/library/windows/desktop/ms684139%28v=vs.85%29.aspx
+static BOOL IsWow64() {
   BOOL bIsWow64 = FALSE;
 
-  //IsWow64Process is not available on all supported versions of Windows.
-  //Use GetModuleHandle to get a handle to the DLL that contains the function
-  //and GetProcAddress to get a pointer to the function if available.
-  LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");
+  // IsWow64Process is not available on all supported versions of Windows.
+  // Use GetModuleHandle to get a handle to the DLL that contains the function
+  // and GetProcAddress to get a pointer to the function if available.
+  LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
+      GetModuleHandle(TEXT("kernel32")), "IsWow64Process");
 
   if (nullptr != fnIsWow64Process) {
     if (!fnIsWow64Process(GetCurrentProcess(), &bIsWow64)) {
@@ -139,8 +137,7 @@ static BOOL IsWow64()
   return bIsWow64;
 }
 
-const std::string PlatformUtils::user_agent()
-{
+const std::string PlatformUtils::user_agent() {
   std::string result;
 
   result += "OpenSCAD/";
@@ -152,13 +149,12 @@ const std::string PlatformUtils::user_agent()
   return result;
 }
 
-const std::string PlatformUtils::sysinfo(bool extended)
-{
+const std::string PlatformUtils::sysinfo(bool extended) {
   std::string result;
 
   SYSTEM_INFO si;
   GetSystemInfo(&si);
-  std::map<WORD, const char *> archs;
+  std::map<WORD, const char*> archs;
   archs[PROCESSOR_ARCHITECTURE_AMD64] = "x86_64";
   archs[PROCESSOR_ARCHITECTURE_ARM] = "arm";
   archs[PROCESSOR_ARCHITECTURE_ARM64] = "arm64";
@@ -177,7 +173,8 @@ const std::string PlatformUtils::sysinfo(bool extended)
       majorVersion = 11;
     }
     boost::format fmt("Microsoft Windows %d (%d.%d.%d) %s");
-    fmt % majorVersion % osinfo.dwMajorVersion % osinfo.dwMinorVersion % osinfo.dwBuildNumber % archs[si.wProcessorArchitecture];
+    fmt % majorVersion % osinfo.dwMajorVersion % osinfo.dwMinorVersion %
+        osinfo.dwBuildNumber % archs[si.wProcessorArchitecture];
     result += fmt.str();
   }
 
@@ -212,30 +209,32 @@ const std::string PlatformUtils::sysinfo(bool extended)
 
 #ifdef USE_MIMALLOC
 #include <mimalloc.h>
-// mimalloc needs an output handler that references stderr after we mess with it.
-static void mi_output(const char *msg, void *arg) {
+// mimalloc needs an output handler that references stderr after we mess with
+// it.
+static void mi_output(const char* msg, void* arg) {
   fputs(msg, stderr);
 }
 #endif
 
 // attach to parent console if standard IO handles not available
 // It may be good idea to redirect the output to file(s) here in some future.
-void PlatformUtils::ensureStdIO(void)
-{
+void PlatformUtils::ensureStdIO(void) {
   // Preserve existing handles whenever available.
   // HANDLE hRead = (HANDLE)_get_osfhandle(_fileno(stdin));
   HANDLE hWrite = (HANDLE)_get_osfhandle(_fileno(stdout));
   HANDLE hError = (HANDLE)_get_osfhandle(_fileno(stderr));
 
-  if (/* INVALID_HANDLE_VALUE == hRead || */ INVALID_HANDLE_VALUE == hWrite || INVALID_HANDLE_VALUE == hError) {
-
+  if (/* INVALID_HANDLE_VALUE == hRead || */ INVALID_HANDLE_VALUE == hWrite ||
+      INVALID_HANDLE_VALUE == hError) {
     // I see nothing to do about error(s) here.
     if (AttachConsole(ATTACH_PARENT_PROCESS)) {
-
       // Let CRT machinery performs proper setup.
-      // if (INVALID_HANDLE_VALUE == hRead) (void)_wfreopen(L"CONIN$",  L"rt", stdin);
-      if (INVALID_HANDLE_VALUE == hWrite) (void)_wfreopen(L"CONOUT$",  L"wt", stdout);
-      if (INVALID_HANDLE_VALUE == hError) (void)_wfreopen(L"CONOUT$",  L"wt", stderr);
+      // if (INVALID_HANDLE_VALUE == hRead) (void)_wfreopen(L"CONIN$",  L"rt",
+      // stdin);
+      if (INVALID_HANDLE_VALUE == hWrite)
+        (void)_wfreopen(L"CONOUT$", L"wt", stdout);
+      if (INVALID_HANDLE_VALUE == hError)
+        (void)_wfreopen(L"CONOUT$", L"wt", stderr);
 
       std::ios_base::sync_with_stdio();
     }
diff --git a/src/platform/PlatformUtils.cc b/src/platform/PlatformUtils.cc
index ab43b267a..5158cc5af 100644
--- a/src/platform/PlatformUtils.cc
+++ b/src/platform/PlatformUtils.cc
@@ -1,10 +1,10 @@
 #include "platform/PlatformUtils.h"
 
-#include <filesystem>
-#include <stdexcept>
 #include <cstdint>
 #include <cstdlib>
+#include <filesystem>
 #include <iomanip>
+#include <stdexcept>
 #include <string>
 #include <vector>
 
@@ -23,50 +23,46 @@ namespace {
 bool path_initialized = false;
 std::string applicationpath;
 std::string resourcespath;
-}
+}  // namespace
 
-const char *PlatformUtils::OPENSCAD_FOLDER_NAME = "OpenSCAD";
+const char* PlatformUtils::OPENSCAD_FOLDER_NAME = "OpenSCAD";
 
-static std::string lookupResourcesPath()
-{
+static std::string lookupResourcesPath() {
   fs::path resourcedir(applicationpath);
-  PRINTDB("Looking up resource folder with application path '%s'", resourcedir.generic_string().c_str());
+  PRINTDB("Looking up resource folder with application path '%s'",
+          resourcedir.generic_string().c_str());
 
 #ifdef __APPLE__
-  const char *searchpath[] = {
-    "../Resources", // Resources can be bundled on Mac.
-    "../../..", // Dev location
-    "../../../..", // Test location (cmake)
-    "..",   // Test location
-    RESOURCE_FOLDER("../share/openscad"), // Unix mode
-    nullptr
-  };
+  const char* searchpath[] = {
+      "../Resources",                        // Resources can be bundled on Mac.
+      "../../..",                            // Dev location
+      "../../../..",                         // Test location (cmake)
+      "..",                                  // Test location
+      RESOURCE_FOLDER("../share/openscad"),  // Unix mode
+      nullptr};
 #else
 #ifdef _WIN32
-  const char *searchpath[] = {
-    ".", // Release location
-    RESOURCE_FOLDER("../share/openscad"), // MSYS2 location
-    "..", // Dev location
-    nullptr
-  };
+  const char* searchpath[] = {
+      ".",                                   // Release location
+      RESOURCE_FOLDER("../share/openscad"),  // MSYS2 location
+      "..",                                  // Dev location
+      nullptr};
 #else
-  const char *searchpath[] = {
-    RESOURCE_FOLDER("../share/openscad"),
-    RESOURCE_FOLDER("../../share/openscad"),
-    ".",
-    "..",
-    "../..",
-    nullptr
-  };
-#endif // ifdef _WIN32
-#endif // ifdef __APPLE__
+  const char* searchpath[] = {RESOURCE_FOLDER("../share/openscad"),
+                              RESOURCE_FOLDER("../../share/openscad"),
+                              ".",
+                              "..",
+                              "../..",
+                              nullptr};
+#endif  // ifdef _WIN32
+#endif  // ifdef __APPLE__
 
   fs::path tmpdir;
   for (int a = 0; searchpath[a] != nullptr; ++a) {
     tmpdir = resourcedir / searchpath[a];
 
-    // The resource folder is the folder which contains "color-schemes" (as well as
-    // "examples" and "locale", and optionally "libraries" and "fonts")
+    // The resource folder is the folder which contains "color-schemes" (as well
+    // as "examples" and "locale", and optionally "libraries" and "fonts")
     const fs::path checkdir = tmpdir / "color-schemes";
     PRINTDB("Checking '%s'", checkdir.generic_string().c_str());
 
@@ -86,23 +82,21 @@ static std::string lookupResourcesPath()
   return result;
 }
 
-void PlatformUtils::registerApplicationPath(const std::string& apppath)
-{
+void PlatformUtils::registerApplicationPath(const std::string& apppath) {
   applicationpath = apppath;
   resourcespath = lookupResourcesPath();
   path_initialized = true;
 }
 
-std::string PlatformUtils::applicationPath()
-{
+std::string PlatformUtils::applicationPath() {
   if (!path_initialized) {
-    throw std::runtime_error("PlatformUtils::applicationPath(): application path not initialized!");
+    throw std::runtime_error(
+        "PlatformUtils::applicationPath(): application path not initialized!");
   }
   return applicationpath;
 }
 
-bool PlatformUtils::createUserLibraryPath()
-{
+bool PlatformUtils::createUserLibraryPath() {
   std::string path = PlatformUtils::userLibraryPath();
   bool OK = false;
   try {
@@ -119,20 +113,22 @@ bool PlatformUtils::createUserLibraryPath()
   return OK;
 }
 
-std::string PlatformUtils::userPath(const std::string& name)
-{
+std::string PlatformUtils::userPath(const std::string& name) {
   fs::path path;
   try {
     std::string pathstr = PlatformUtils::documentsPath();
-    if (pathstr == "") return "";
+    if (pathstr == "")
+      return "";
     path = fs::path(pathstr);
-    if (!fs::exists(path)) return "";
+    if (!fs::exists(path))
+      return "";
 #ifndef __EMSCRIPTEN__
     path = fs::canonical(path);
 #endif
     // LOG(message_group::NONE,,"path size %1$i",fs::stringy(path).size());
     // LOG(message_group::NONE,,"lib path found: [%1$s]",path);
-    if (path.empty()) return "";
+    if (path.empty())
+      return "";
     path /= OPENSCAD_FOLDER_NAME;
     path /= name;
     // LOG(message_group::NONE,,"Appended path %1$s",path);
@@ -143,28 +139,28 @@ std::string PlatformUtils::userPath(const std::string& name)
   return path.generic_string();
 }
 
-std::string PlatformUtils::userLibraryPath()
-{
+std::string PlatformUtils::userLibraryPath() {
   return userPath("libraries");
 }
 
-std::string PlatformUtils::userExamplesPath()
-{
+std::string PlatformUtils::userExamplesPath() {
   return userPath("examples");
 }
 
-std::string PlatformUtils::backupPath()
-{
+std::string PlatformUtils::backupPath() {
   fs::path path;
   try {
     std::string pathstr = PlatformUtils::documentsPath();
-    if (pathstr == "") return "";
+    if (pathstr == "")
+      return "";
     path = fs::path(pathstr);
-    if (!fs::exists(path)) return "";
+    if (!fs::exists(path))
+      return "";
 #ifndef __EMSCRIPTEN__
     path = fs::canonical(path);
 #endif
-    if (path.empty()) return "";
+    if (path.empty())
+      return "";
     path /= OPENSCAD_FOLDER_NAME;
     path /= "backups";
   } catch (const fs::filesystem_error& ex) {
@@ -173,8 +169,7 @@ std::string PlatformUtils::backupPath()
   return path.generic_string();
 }
 
-bool PlatformUtils::createBackupPath()
-{
+bool PlatformUtils::createBackupPath() {
   std::string path = PlatformUtils::backupPath();
   bool OK = false;
   try {
@@ -191,16 +186,15 @@ bool PlatformUtils::createBackupPath()
 }
 
 // This is the built-in read-only resources path
-std::string PlatformUtils::resourceBasePath()
-{
+std::string PlatformUtils::resourceBasePath() {
   if (!path_initialized) {
-    throw std::runtime_error("PlatformUtils::resourcesPath(): application path not initialized!");
+    throw std::runtime_error(
+        "PlatformUtils::resourcesPath(): application path not initialized!");
   }
   return resourcespath;
 }
 
-fs::path PlatformUtils::resourcePath(const std::string& resource)
-{
+fs::path PlatformUtils::resourcePath(const std::string& resource) {
   fs::path base(resourceBasePath());
   if (!fs::is_directory(base)) {
     return {};
@@ -214,10 +208,9 @@ fs::path PlatformUtils::resourcePath(const std::string& resource)
   return resource_dir;
 }
 
-int PlatformUtils::setenv(const char *name, const char *value, int overwrite)
-{
+int PlatformUtils::setenv(const char* name, const char* value, int overwrite) {
 #if defined(_WIN32)
-  const char *ptr = getenv(name);
+  const char* ptr = getenv(name);
   if ((overwrite == 0) && (ptr != nullptr)) {
     return 0;
   }
@@ -230,9 +223,8 @@ int PlatformUtils::setenv(const char *name, const char *value, int overwrite)
 #endif
 }
 
-std::string PlatformUtils::toMemorySizeString(uint64_t bytes, int digits)
-{
-  static const char *units[] = { "B", "kB", "MB", "GB", "TB", nullptr };
+std::string PlatformUtils::toMemorySizeString(uint64_t bytes, int digits) {
+  static const char* units[] = {"B", "kB", "MB", "GB", "TB", nullptr};
 
   int idx = 0;
   double val = bytes;
diff --git a/src/platform/PlatformUtils.h b/src/platform/PlatformUtils.h
index 266624f91..ee54db5cf 100644
--- a/src/platform/PlatformUtils.h
+++ b/src/platform/PlatformUtils.h
@@ -1,17 +1,18 @@
 #pragma once
 
-#include <cstdint>
 #include <cstddef>
+#include <cstdint>
 #include <string>
 
 #include <filesystem>
 namespace fs = std::filesystem;
 
 static constexpr size_t STACK_BUFFER_SIZE = 128ul * 1024ul;
-static constexpr size_t STACK_LIMIT_DEFAULT = size_t{STACKSIZE} - STACK_BUFFER_SIZE;
+static constexpr size_t STACK_LIMIT_DEFAULT =
+    size_t{STACKSIZE} - STACK_BUFFER_SIZE;
 
 namespace PlatformUtils {
-extern const char *OPENSCAD_FOLDER_NAME;
+extern const char* OPENSCAD_FOLDER_NAME;
 
 void registerApplicationPath(const std::string& applicationpath);
 std::string applicationPath();
@@ -90,7 +91,7 @@ const std::string user_agent();
  * @param value the value to set for the environment variable.
  * @return 0 on success.
  */
-int setenv(const char *name, const char *value, int overwrite);
+int setenv(const char* name, const char* value, int overwrite);
 
 /**
  * Return system defined stack limit. If the system does not define
@@ -119,4 +120,4 @@ void ensureStdIO();
  * a given number of digits.
  */
 std::string toMemorySizeString(uint64_t bytes, int digits);
-} // namespace PlatformUtils
+}  // namespace PlatformUtils
diff --git a/src/python/pyfunctions.cc b/src/python/pyfunctions.cc
index db2742011..7d50633a3 100644
--- a/src/python/pyfunctions.cc
+++ b/src/python/pyfunctions.cc
@@ -25,45 +25,41 @@
  */
 
 #include <Python.h>
-#include "python/pyopenscad.h"
-#include "core/primitives.h"
-#include "core/CsgOpNode.h"
+#include "core/CgalAdvNode.h"
 #include "core/ColorNode.h"
 #include "core/ColorUtil.h"
-#include "core/TransformNode.h"
+#include "core/CsgOpNode.h"
+#include "core/ImportNode.h"
 #include "core/LinearExtrudeNode.h"
-#include "core/RotateExtrudeNode.h"
-#include "core/CgalAdvNode.h"
-#include "core/RoofNode.h"
+#include "core/OffsetNode.h"
+#include "core/ProjectionNode.h"
 #include "core/RenderNode.h"
+#include "core/RoofNode.h"
+#include "core/RotateExtrudeNode.h"
 #include "core/SurfaceNode.h"
 #include "core/TextNode.h"
-#include "core/OffsetNode.h"
-#include "core/ProjectionNode.h"
-#include "core/ImportNode.h"
+#include "core/TransformNode.h"
 #include "core/Tree.h"
+#include "core/primitives.h"
+#include "geometry/GeometryEvaluator.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
-#include "geometry/GeometryEvaluator.h"
-#include "utils/degree_trig.h"
-#include "io/fileutils.h"
 #include "handle_dep.h"
+#include "io/fileutils.h"
+#include "python/pyopenscad.h"
+#include "utils/degree_trig.h"
 
-
-PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_cube(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<CubeNode>(instance);
 
-  char *kwlist[] = {"size", "center", NULL};
-  PyObject *size = NULL;
-
-  PyObject *center = NULL;
+  char* kwlist[] = {"size", "center", NULL};
+  PyObject* size = NULL;
 
+  PyObject* center = NULL;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist,
-                                   &size,
-                                   &center)){
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist, &size,
+                                   &center)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing cube(size)");
     return NULL;
   }
@@ -79,9 +75,11 @@ PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs)
     return NULL;
   }
   node->center = false;
-  if (center == Py_False || center == NULL)  ;
-  else if (center == Py_True){
-    for (int i = 0; i < 3; i++)node->center = true;
+  if (center == Py_False || center == NULL)
+    ;
+  else if (center == Py_True) {
+    for (int i = 0; i < 3; i++)
+      node->center = true;
   } else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
@@ -89,22 +87,20 @@ PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_sphere(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<SphereNode>(instance);
 
-  char *kwlist[] = {"r", "d", "fn", "fa", "fs", NULL};
+  char* kwlist[] = {"r", "d", "fn", "fa", "fs", NULL};
   double r = NAN;
-  PyObject *rp = nullptr;
+  PyObject* rp = nullptr;
   double d = NAN;
   double fn = NAN, fa = NAN, fs = NAN;
 
   double vr = 1;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Odddd", kwlist,
-                                   &rp, &d, &fn, &fa, &fs
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Odddd", kwlist, &rp, &d, &fn,
+                                   &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing sphere(r|d)");
     return NULL;
   }
@@ -118,7 +114,8 @@ PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
     }
     vr = r;
     if (!isnan(d)) {
-      PyErr_SetString(PyExc_TypeError, "Cant specify r and d at the same time for sphere");
+      PyErr_SetString(PyExc_TypeError,
+                      "Cant specify r and d at the same time for sphere");
       return NULL;
     }
   }
@@ -131,21 +128,24 @@ PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->r = vr;
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_cylinder(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<CylinderNode>(instance);
 
-  char *kwlist[] = {"h", "r1", "r2", "center",  "r", "d", "d1", "d2",  "fn", "fa", "fs", NULL};
+  char* kwlist[] = {"h",  "r1", "r2", "center", "r",  "d",
+                    "d1", "d2", "fn", "fa",     "fs", NULL};
   double h = NAN;
   double r = NAN;
   double r1 = NAN;
@@ -156,12 +156,14 @@ PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
 
   double fn = NAN, fa = NAN, fs = NAN;
 
-  PyObject *center = NULL;
+  PyObject* center = NULL;
   double vr1 = 1, vr2 = 1, vh = 1;
 
-
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|dddOddddddd", kwlist, &h, &r1, &r2, &center, &r, &d, &d1, &d2, &fn, &fa, &fs)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing cylinder(h,r|r1+r2|d1+d2)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|dddOddddddd", kwlist, &h,
+                                   &r1, &r2, &center, &r, &d, &d1, &d2, &fn,
+                                   &fa, &fs)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing cylinder(h,r|r1+r2|d1+d2)");
     return NULL;
   }
 
@@ -193,28 +195,38 @@ PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
   }
 
   if (!isnan(r1) && !isnan(r2)) {
-    vr1 = r1; vr2 = r2;
+    vr1 = r1;
+    vr2 = r2;
   } else if (!isnan(r1) && isnan(r2)) {
-    vr1 = r1; vr2 = r1;
+    vr1 = r1;
+    vr2 = r1;
   } else if (!isnan(d1) && !isnan(d2)) {
-    vr1 = d1 / 2.0; vr2 = d2 / 2.0;
+    vr1 = d1 / 2.0;
+    vr2 = d2 / 2.0;
   } else if (!isnan(r)) {
-    vr1 = r; vr2 = r;
+    vr1 = r;
+    vr2 = r;
   } else if (!isnan(d)) {
-    vr1 = d / 2.0; vr2 = d / 2.0;
+    vr1 = d / 2.0;
+    vr2 = d / 2.0;
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->r1 = vr1;
   node->r2 = vr2;
   node->h = vh;
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
@@ -223,34 +235,32 @@ PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_polyhedron(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   unsigned int i, j, pointIndex;
   auto node = std::make_shared<PolyhedronNode>(instance);
 
-  char *kwlist[] = {"points", "faces", "convexity", "triangles", NULL};
-  PyObject *points = NULL;
-  PyObject *faces = NULL;
+  char* kwlist[] = {"points", "faces", "convexity", "triangles", NULL};
+  PyObject* points = NULL;
+  PyObject* faces = NULL;
   int convexity = 2;
-  PyObject *triangles = NULL;
+  PyObject* triangles = NULL;
 
-  PyObject *element;
+  PyObject* element;
   Vector3d point;
 
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O!|iO!", kwlist,
-                                   &PyList_Type, &points,
-                                   &PyList_Type, &faces,
-                                   &convexity,
-                                   &PyList_Type, &triangles
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing polyhedron(points, faces)");
+                                   &PyList_Type, &points, &PyList_Type, &faces,
+                                   &convexity, &PyList_Type, &triangles)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing polyhedron(points, faces)");
     return NULL;
   }
 
   if (points != NULL && PyList_Check(points)) {
     if (PyList_Size(points) == 0) {
-      PyErr_SetString(PyExc_TypeError, "There must at least be one point in the polyhedron");
+      PyErr_SetString(PyExc_TypeError,
+                      "There must at least be one point in the polyhedron");
       return NULL;
     }
     for (i = 0; i < PyList_Size(points); i++) {
@@ -261,22 +271,25 @@ PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
         point[2] = PyFloat_AsDouble(PyList_GetItem(element, 2));
         node->points.push_back(point);
       } else {
-        PyErr_SetString(PyExc_TypeError, "Coordinate must exactly contain 3 numbers");
+        PyErr_SetString(PyExc_TypeError,
+                        "Coordinate must exactly contain 3 numbers");
         return NULL;
       }
-
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polyhedron Points must be a list of coordinates");
+    PyErr_SetString(PyExc_TypeError,
+                    "Polyhedron Points must be a list of coordinates");
     return NULL;
   }
 
   if (triangles != NULL) {
     faces = triangles;
-//	LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in future releases. Use polyhedron(faces=[]) instead.");
+    //	LOG(message_group::Deprecated, inst->location(),
+    //parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in
+    //future releases. Use polyhedron(faces=[]) instead.");
   }
 
-  if (faces != NULL && PyList_Check(faces) ) {
+  if (faces != NULL && PyList_Check(faces)) {
     if (PyList_Size(faces) == 0) {
       PyErr_SetString(PyExc_TypeError, "must specify at least 1 face");
       return NULL;
@@ -288,7 +301,8 @@ PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
         for (j = 0; j < PyList_Size(element); j++) {
           pointIndex = PyLong_AsLong(PyList_GetItem(element, j));
           if (pointIndex < 0 || pointIndex >= node->points.size()) {
-            PyErr_SetString(PyExc_TypeError, "Polyhedron Point Index out of range");
+            PyErr_SetString(PyExc_TypeError,
+                            "Polyhedron Point Index out of range");
             return NULL;
           }
           face.push_back(pointIndex);
@@ -296,41 +310,41 @@ PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
         if (face.size() >= 3) {
           node->faces.push_back(std::move(face));
         } else {
-          PyErr_SetString(PyExc_TypeError, "Polyhedron Face must sepcify at least 3 indices");
+          PyErr_SetString(PyExc_TypeError,
+                          "Polyhedron Face must sepcify at least 3 indices");
           return NULL;
         }
 
       } else {
-        PyErr_SetString(PyExc_TypeError, "Polyhedron Face must be a list of indices");
+        PyErr_SetString(PyExc_TypeError,
+                        "Polyhedron Face must be a list of indices");
         return NULL;
       }
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polyhedron faces must be a list of indices");
+    PyErr_SetString(PyExc_TypeError,
+                    "Polyhedron faces must be a list of indices");
     return NULL;
   }
 
-
   node->convexity = convexity;
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_square(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<SquareNode>(instance);
 
-  char *kwlist[] = {"dim", "center", NULL};
-  PyObject *dim = NULL;
+  char* kwlist[] = {"dim", "center", NULL};
+  PyObject* dim = NULL;
 
-  PyObject *center = NULL;
+  PyObject* center = NULL;
   double z = NAN;
 
-
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist,
-                                   &dim,
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist, &dim,
                                    &center)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing square(dim)");
     return NULL;
@@ -341,8 +355,10 @@ PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
       return NULL;
     }
   }
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
@@ -350,19 +366,19 @@ PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
-PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_circle(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<CircleNode>(instance);
 
-  char *kwlist[] = {"r", "d", "fn", "fa", "fs", NULL};
+  char* kwlist[] = {"r", "d", "fn", "fa", "fs", NULL};
   double r = NAN;
   double d = NAN;
   double fn = NAN, fa = NAN, fs = NAN;
 
   double vr = 1;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddddd", kwlist, &r, &d, &fn, &fa, &fs)) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddddd", kwlist, &r, &d, &fn,
+                                   &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing circle(r|d)");
     return NULL;
   }
@@ -374,7 +390,8 @@ PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
     }
     vr = r;
     if (!isnan(d)) {
-      PyErr_SetString(PyExc_TypeError, "Cant specify r and d at the same time for circle");
+      PyErr_SetString(PyExc_TypeError,
+                      "Cant specify r and d at the same time for circle");
       return NULL;
     }
   }
@@ -386,43 +403,42 @@ PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
     vr = d / 2.0;
   }
 
-
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->r = vr;
 
-
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
-PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_polygon(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   unsigned int i, j, pointIndex;
   auto node = std::make_shared<PolygonNode>(instance);
 
-  char *kwlist[] = {"points", "paths", "convexity", NULL};
-  PyObject *points = NULL;
-  PyObject *paths = NULL;
+  char* kwlist[] = {"points", "paths", "convexity", NULL};
+  PyObject* points = NULL;
+  PyObject* paths = NULL;
   int convexity = 2;
 
-  PyObject *element;
+  PyObject* element;
   Vector2d point;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|O!i", kwlist,
-                                   &PyList_Type, &points,
-                                   &PyList_Type, &paths,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing polygon(points,paths)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|O!i", kwlist, &PyList_Type,
+                                   &points, &PyList_Type, &paths, &convexity)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing polygon(points,paths)");
     return NULL;
   }
 
-  if (points != NULL && PyList_Check(points) ) {
+  if (points != NULL && PyList_Check(points)) {
     if (PyList_Size(points) == 0) {
-      PyErr_SetString(PyExc_TypeError, "There must at least be one point in the polygon");
+      PyErr_SetString(PyExc_TypeError,
+                      "There must at least be one point in the polygon");
       return NULL;
     }
     for (i = 0; i < PyList_Size(points); i++) {
@@ -432,19 +448,21 @@ PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
         point[1] = PyFloat_AsDouble(PyList_GetItem(element, 1));
         node->points.push_back(point);
       } else {
-        PyErr_SetString(PyExc_TypeError, "Coordinate must exactly contain 2 numbers");
+        PyErr_SetString(PyExc_TypeError,
+                        "Coordinate must exactly contain 2 numbers");
         return NULL;
       }
-
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polygon points must be a list of coordinates");
+    PyErr_SetString(PyExc_TypeError,
+                    "Polygon points must be a list of coordinates");
     return NULL;
   }
 
-  if (paths != NULL && PyList_Check(paths) ) {
+  if (paths != NULL && PyList_Check(paths)) {
     if (PyList_Size(paths) == 0) {
-      PyErr_SetString(PyExc_TypeError, "must specify at least 1 path when specified");
+      PyErr_SetString(PyExc_TypeError,
+                      "must specify at least 1 path when specified");
       return NULL;
     }
     for (i = 0; i < PyList_Size(paths); i++) {
@@ -454,47 +472,55 @@ PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
         for (j = 0; j < PyList_Size(element); j++) {
           pointIndex = PyLong_AsLong(PyList_GetItem(element, j));
           if (pointIndex < 0 || pointIndex >= node->points.size()) {
-            PyErr_SetString(PyExc_TypeError, "Polyhedron Point Index out of range");
+            PyErr_SetString(PyExc_TypeError,
+                            "Polyhedron Point Index out of range");
             return NULL;
           }
           path.push_back(pointIndex);
         }
         node->paths.push_back(std::move(path));
       } else {
-        PyErr_SetString(PyExc_TypeError, "Polygon path must be a list of indices");
+        PyErr_SetString(PyExc_TypeError,
+                        "Polygon path must be a list of indices");
         return NULL;
       }
     }
   }
 
   node->convexity = convexity;
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-int python_tomatrix(PyObject *pyt, Matrix4d& mat)
-{
-  if (pyt == nullptr)return 1;
+int python_tomatrix(PyObject* pyt, Matrix4d& mat) {
+  if (pyt == nullptr)
+    return 1;
   PyObject *row, *cell;
   double val;
-  if (!PyList_Check(pyt))return 1; // TODO crash wenn pyt eine funktion ist
-  if (PyList_Size(pyt) != 4)return 1;
+  if (!PyList_Check(pyt))
+    return 1;  // TODO crash wenn pyt eine funktion ist
+  if (PyList_Size(pyt) != 4)
+    return 1;
   for (int i = 0; i < 4; i++) {
     row = PyList_GetItem(pyt, i);
-    if (!PyList_Check(row))return 1;
-    if (PyList_Size(row) != 4)return 1;
+    if (!PyList_Check(row))
+      return 1;
+    if (PyList_Size(row) != 4)
+      return 1;
     for (int j = 0; j < 4; j++) {
       cell = PyList_GetItem(row, j);
-      if (python_numberval(cell, &val))return 1;
+      if (python_numberval(cell, &val))
+        return 1;
       mat(i, j) = val;
     }
   }
   return 0;
 }
-PyObject *python_frommatrix(const Matrix4d& mat) {
-  PyObject *pyo = PyList_New(4);
-  PyObject *row;
+PyObject* python_frommatrix(const Matrix4d& mat) {
+  PyObject* pyo = PyList_New(4);
+  PyObject* row;
   for (int i = 0; i < 4; i++) {
     row = PyList_New(4);
     for (int j = 0; j < 4; j++)
@@ -504,32 +530,31 @@ PyObject *python_frommatrix(const Matrix4d& mat) {
   return pyo;
 }
 
-
-PyObject *python_matrix_scale(PyObject *mat, Vector3d scalevec)
-{
+PyObject* python_matrix_scale(PyObject* mat, Vector3d scalevec) {
   Transform3d matrix = Transform3d::Identity();
   matrix.scale(scalevec);
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix(mat, raw))
+    return nullptr;
   Vector3d n;
   for (int i = 0; i < 3; i++) {
-    n = Vector3d(raw(0, i), raw(1, i), raw(2, i)); // TODO fix
+    n = Vector3d(raw(0, i), raw(1, i), raw(2, i));  // TODO fix
     n = matrix * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw(j, i) = n[j];
   }
   return python_frommatrix(raw);
 }
 
-
-PyObject *python_scale_sub(PyObject *obj, Vector3d scalevec)
-{
-  PyObject *mat = python_matrix_scale(obj, scalevec);
-  if (mat != nullptr)return mat;
+PyObject* python_scale_sub(PyObject* obj, Vector3d scalevec) {
+  PyObject* mat = python_matrix_scale(obj, scalevec);
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   auto node = std::make_shared<TransformNode>(instance, "scale");
-  PyObject *child_dict;
+  PyObject* child_dict;
   child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in scale");
@@ -537,84 +562,83 @@ PyObject *python_scale_sub(PyObject *obj, Vector3d scalevec)
   }
   node->matrix.scale(scalevec);
   node->children.push_back(child);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyObject *value1 = python_matrix_scale(value, scalevec);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      PyObject* value1 = python_matrix_scale(value, scalevec);
+      if (value1 != nullptr)
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_scale_core(PyObject *obj, PyObject *val_v)
-{
-
+PyObject* python_scale_core(PyObject* obj, PyObject* val_v) {
   double x = 1, y = 1, z = 1;
   if (python_vectorval(val_v, 2, 3, &x, &y, &z)) {
-    PyErr_SetString(PyExc_TypeError, "Invalid vector specifiaction in scale, use 1 to 3 ordinates.");
+    PyErr_SetString(
+        PyExc_TypeError,
+        "Invalid vector specifiaction in scale, use 1 to 3 ordinates.");
     return NULL;
   }
   Vector3d scalevec(x, y, z);
 
   if (OpenSCAD::rangeCheck) {
-    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 || !std::isfinite(scalevec[0])|| !std::isfinite(scalevec[1])|| !std::isfinite(scalevec[2])) {
-//      LOG(message_group::Warning, instance->location(), parameters.documentRoot(), "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
+    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 ||
+        !std::isfinite(scalevec[0]) || !std::isfinite(scalevec[1]) ||
+        !std::isfinite(scalevec[2])) {
+      //      LOG(message_group::Warning, instance->location(),
+      //      parameters.documentRoot(), "scale(%1$s)",
+      //      parameters["v"].toEchoStringNoThrow());
     }
   }
 
   return python_scale_sub(obj, scalevec);
 }
 
-
-
-PyObject *python_scale(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "v", NULL};
-  PyObject *obj = NULL;
-  PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist,
-                                   &obj,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing scale(object, scale)");
+PyObject* python_scale(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "v", NULL};
+  PyObject* obj = NULL;
+  PyObject* val_v = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist, &obj, &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing scale(object, scale)");
     return NULL;
   }
   return python_scale_core(obj, val_v);
 }
 
-PyObject *python_oo_scale(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"v", NULL};
-  PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing scale(object, scale)");
+PyObject* python_oo_scale(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"v", NULL};
+  PyObject* val_v = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing scale(object, scale)");
     return NULL;
   }
   return python_scale_core(obj, val_v);
 }
-PyObject *python_matrix_rot(PyObject *mat, Matrix3d rotvec)
-{
+PyObject* python_matrix_rot(PyObject* mat, Matrix3d rotvec) {
   Transform3d matrix = Transform3d::Identity();
   matrix.rotate(rotvec);
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix(mat, raw))
+    return nullptr;
   Vector3d n;
   for (int i = 0; i < 4; i++) {
     n = Vector3d(raw(0, i), raw(1, i), raw(2, i));
     n = matrix * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw(j, i) = n[j];
   }
   return python_frommatrix(raw);
 }
 
-
-PyObject *python_rotate_sub(PyObject *obj, Vector3d vec3, double angle)
-{
+PyObject* python_rotate_sub(PyObject* obj, Vector3d vec3, double angle) {
   Matrix3d M;
   if (isnan(angle)) {
     double sx = 0, sy = 0, sz = 0;
@@ -636,20 +660,21 @@ PyObject *python_rotate_sub(PyObject *obj, Vector3d vec3, double angle)
       cx = cos_degrees(a);
     }
 
-    M << cy * cz,  cz * sx * sy - cx * sz,   cx * cz * sy + sx * sz,
-      cy *sz,  cx *cz + sx * sy * sz,  -cz * sx + cx * sy * sz,
-      -sy,       cy *sx,                  cx *cy;
+    M << cy * cz, cz * sx * sy - cx * sz, cx * cz * sy + sx * sz, cy * sz,
+        cx * cz + sx * sy * sz, -cz * sx + cx * sy * sz, -sy, cy * sx, cx * cy;
   } else {
     M = angle_axis_degrees(angle, vec3);
   }
-  PyObject *mat = python_matrix_rot(obj, M);
-  if (mat != nullptr)return mat;
+  PyObject* mat = python_matrix_rot(obj, M);
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
   auto node = std::make_shared<TransformNode>(instance, "rotate");
 
-  PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  PyObject* child_dict;
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &child_dict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in rotate");
     return NULL;
@@ -657,29 +682,35 @@ PyObject *python_rotate_sub(PyObject *obj, Vector3d vec3, double angle)
   node->matrix.rotate(M);
 
   node->children.push_back(child);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyObject *value1 = python_matrix_rot(value, M);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      PyObject* value1 = python_matrix_rot(value, M);
+      if (value1 != nullptr)
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_rotate_core(PyObject *obj, PyObject *val_a, PyObject *val_v)
-{
+PyObject* python_rotate_core(PyObject* obj, PyObject* val_a, PyObject* val_v) {
   Vector3d vec3(0, 0, 0);
   double angle;
   if (val_a != nullptr && PyList_Check(val_a) && val_v == nullptr) {
-    if (PyList_Size(val_a) >= 1)vec3[0] = PyFloat_AsDouble(PyList_GetItem(val_a, 0));
-    if (PyList_Size(val_a) >= 2)vec3[1] = PyFloat_AsDouble(PyList_GetItem(val_a, 1));
-    if (PyList_Size(val_a) >= 3)vec3[2] = PyFloat_AsDouble(PyList_GetItem(val_a, 2));
+    if (PyList_Size(val_a) >= 1)
+      vec3[0] = PyFloat_AsDouble(PyList_GetItem(val_a, 0));
+    if (PyList_Size(val_a) >= 2)
+      vec3[1] = PyFloat_AsDouble(PyList_GetItem(val_a, 1));
+    if (PyList_Size(val_a) >= 3)
+      vec3[2] = PyFloat_AsDouble(PyList_GetItem(val_a, 2));
     return python_rotate_sub(obj, vec3, NAN);
-  } else if (val_a != nullptr && val_v != nullptr && !python_numberval(val_a, &angle) && PyList_Check(val_v) && PyList_Size(val_v) == 3) {
+  } else if (val_a != nullptr && val_v != nullptr &&
+             !python_numberval(val_a, &angle) && PyList_Check(val_v) &&
+             PyList_Size(val_v) == 3) {
     vec3[0] = PyFloat_AsDouble(PyList_GetItem(val_v, 0));
     vec3[1] = PyFloat_AsDouble(PyList_GetItem(val_v, 1));
     vec3[2] = PyFloat_AsDouble(PyList_GetItem(val_v, 2));
@@ -689,76 +720,79 @@ PyObject *python_rotate_core(PyObject *obj, PyObject *val_a, PyObject *val_v)
   return nullptr;
 }
 
-PyObject *python_rotate(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "a", "v", nullptr};
-  PyObject *val_a = nullptr;
-  PyObject *val_v = nullptr;
-  PyObject *obj = nullptr;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist, &obj, &val_a, &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate(object, vec3)");
+PyObject* python_rotate(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "a", "v", nullptr};
+  PyObject* val_a = nullptr;
+  PyObject* val_v = nullptr;
+  PyObject* obj = nullptr;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist, &obj, &val_a,
+                                   &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing rotate(object, vec3)");
     return NULL;
   }
   return python_rotate_core(obj, val_a, val_v);
 }
 
-PyObject *python_oo_rotate(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"a", "v", nullptr};
-  PyObject *val_a = nullptr;
-  PyObject *val_v = nullptr;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &val_a, &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate(object, vec3)");
+PyObject* python_oo_rotate(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"a", "v", nullptr};
+  PyObject* val_a = nullptr;
+  PyObject* val_v = nullptr;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &val_a,
+                                   &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing rotate(object, vec3)");
     return NULL;
   }
   return python_rotate_core(obj, val_a, val_v);
 }
 
-
-PyObject *python_matrix_mirror(PyObject *mat, Matrix4d m)
-{
+PyObject* python_matrix_mirror(PyObject* mat, Matrix4d m) {
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix(mat, raw))
+    return nullptr;
   Vector4d n;
   for (int i = 0; i < 3; i++) {
     n = Vector4d(raw(0, i), raw(1, i), raw(2, i), 0);
     n = m * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw(j, i) = n[j];
   }
   return python_frommatrix(raw);
 }
 
-
-PyObject *python_mirror_sub(PyObject *obj, Matrix4d& m)
-{
-  PyObject *mat = python_matrix_mirror(obj, m);
-  if (mat != nullptr)return mat;
+PyObject* python_mirror_sub(PyObject* obj, Matrix4d& m) {
+  PyObject* mat = python_matrix_mirror(obj, m);
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
   auto node = std::make_shared<TransformNode>(instance, "mirror");
   node->matrix = m;
-  PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  PyObject* child_dict;
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &child_dict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in mirror");
     return NULL;
   }
   node->children.push_back(child);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyObject *value1 = python_matrix_mirror(value, m);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      PyObject* value1 = python_matrix_mirror(value, m);
+      if (value1 != nullptr)
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_mirror_core(PyObject *obj, PyObject *val_v)
-{
+PyObject* python_mirror_core(PyObject* obj, PyObject* val_v) {
   Vector3d mirrorvec;
   double x = 1.0, y = 0.0, z = 0.0;
   if (python_vectorval(val_v, 2, 3, &x, &y, &z)) {
@@ -770,102 +804,100 @@ PyObject *python_mirror_core(PyObject *obj, PyObject *val_v)
   // z /= sqrt(x*x + y*y + z*z)
   Matrix4d m = Matrix4d::Identity();
   if (x != 0.0 || y != 0.0 || z != 0.0) {
-    // skip using sqrt to normalize the vector since each element of matrix contributes it with two multiplied terms
-    // instead just divide directly within each matrix element
-    // simplified calculation leads to less float errors
+    // skip using sqrt to normalize the vector since each element of matrix
+    // contributes it with two multiplied terms instead just divide directly
+    // within each matrix element simplified calculation leads to less float
+    // errors
     double a = x * x + y * y + z * z;
 
-    m << 1 - 2 * x * x / a, -2 * y * x / a, -2 * z * x / a, 0,
-      -2 * x * y / a, 1 - 2 * y * y / a, -2 * z * y / a, 0,
-      -2 * x * z / a, -2 * y * z / a, 1 - 2 * z * z / a, 0,
-      0, 0, 0, 1;
+    m << 1 - 2 * x * x / a, -2 * y * x / a, -2 * z * x / a, 0, -2 * x * y / a,
+        1 - 2 * y * y / a, -2 * z * y / a, 0, -2 * x * z / a, -2 * y * z / a,
+        1 - 2 * z * z / a, 0, 0, 0, 0, 1;
   }
   return python_mirror_sub(obj, m);
 }
 
-PyObject *python_mirror(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "v", NULL};
+PyObject* python_mirror(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "v", NULL};
 
-  PyObject *obj = NULL;
-  PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist,
-                                   &obj,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing mirror(object, vec3)");
+  PyObject* obj = NULL;
+  PyObject* val_v = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist, &obj, &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing mirror(object, vec3)");
     return NULL;
   }
   return python_mirror_core(obj, val_v);
 }
 
-PyObject *python_oo_mirror(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"v", NULL};
+PyObject* python_oo_mirror(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"v", NULL};
 
-  PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing mirror(object, vec3)");
+  PyObject* val_v = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing mirror(object, vec3)");
     return NULL;
   }
   return python_mirror_core(obj, val_v);
 }
 
-PyObject *python_matrix_trans(PyObject *mat, Vector3d transvec)
-{
+PyObject* python_matrix_trans(PyObject* mat, Vector3d transvec) {
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
-  for (int i = 0; i < 3; i++)raw(i, 3) += transvec[i];
+  if (python_tomatrix(mat, raw))
+    return nullptr;
+  for (int i = 0; i < 3; i++)
+    raw(i, 3) += transvec[i];
   return python_frommatrix(raw);
 }
 
-PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode);
-PyObject *python_translate_core(PyObject *obj, PyObject *v)
-{
-  if (v == nullptr)return obj;
+PyObject* python_nb_sub_vec3(PyObject* arg1, PyObject* arg2, int mode);
+PyObject* python_translate_core(PyObject* obj, PyObject* v) {
+  if (v == nullptr)
+    return obj;
   return python_nb_sub_vec3(obj, v, 0);
 }
 
-PyObject *python_translate(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "v", NULL};
-  PyObject *obj = NULL;
-  PyObject *v = NULL;
+PyObject* python_translate(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "v", NULL};
+  PyObject* obj = NULL;
+  PyObject* v = NULL;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &obj, &v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing translate(object,vec3)");
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing translate(object,vec3)");
     return NULL;
   }
   return python_translate_core(obj, v);
 }
 
-PyObject *python_oo_translate(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"v", NULL};
-  PyObject *v = NULL;
+PyObject* python_oo_translate(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"v", NULL};
+  PyObject* v = NULL;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O", kwlist, &v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing translate(object,vec3)");
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing translate(object,vec3)");
     return NULL;
   }
   return python_translate_core(obj, v);
 }
 
-PyObject *python_multmatrix_sub(PyObject *pyobj, PyObject *pymat, int div)
-{
+PyObject* python_multmatrix_sub(PyObject* pyobj, PyObject* pymat, int div) {
   Matrix4d mat;
   if (!python_tomatrix(pymat, mat)) {
     double w = mat(3, 3);
-    if (w != 1.0) mat = mat / w;
+    if (w != 1.0)
+      mat = mat / w;
   } else {
     PyErr_SetString(PyExc_TypeError, "Matrix vector should be 4x4 array");
     return NULL;
   }
-  if (div){
+  if (div) {
     auto tmp = mat.inverse().eval();
     mat = tmp;
   }
 
   Matrix4d objmat;
-  if (!python_tomatrix(pyobj, objmat)){
+  if (!python_tomatrix(pyobj, objmat)) {
     objmat = mat * objmat;
     return python_frommatrix(objmat);
   }
@@ -873,92 +905,89 @@ PyObject *python_multmatrix_sub(PyObject *pyobj, PyObject *pymat, int div)
   DECLARE_INSTANCE
   auto node = std::make_shared<TransformNode>(instance, "multmatrix");
   std::shared_ptr<AbstractNode> child;
-  PyObject *child_dict;
+  PyObject* child_dict;
   child = PyOpenSCADObjectToNodeMulti(pyobj, &child_dict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in multmatrix");
     return NULL;
   }
 
-
   node->matrix = mat;
   node->children.push_back(child);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
       Matrix4d raw;
-      if (python_tomatrix(value, raw))return nullptr;
-      PyObject *value1 = python_frommatrix(node->matrix * raw);
-      if (value1 != nullptr)PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      if (python_tomatrix(value, raw))
+        return nullptr;
+      PyObject* value1 = python_frommatrix(node->matrix * raw);
+      if (value1 != nullptr)
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_multmatrix(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "m", NULL};
-  PyObject *obj = NULL;
-  PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist,
-                                   &obj,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing multmatrix(object, vec16)");
+PyObject* python_multmatrix(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "m", NULL};
+  PyObject* obj = NULL;
+  PyObject* mat = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist, &obj,
+                                   &PyList_Type, &mat)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing multmatrix(object, vec16)");
     return NULL;
   }
   return python_multmatrix_sub(obj, mat, 0);
 }
 
-PyObject *python_oo_multmatrix(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"m", NULL};
-  PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing multmatrix(object, vec16)");
+PyObject* python_oo_multmatrix(PyObject* obj,
+                               PyObject* args,
+                               PyObject* kwargs) {
+  char* kwlist[] = {"m", NULL};
+  PyObject* mat = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist, &PyList_Type,
+                                   &mat)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing multmatrix(object, vec16)");
     return NULL;
   }
   return python_multmatrix_sub(obj, mat, 0);
 }
 
-PyObject *python_divmatrix(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "m", NULL};
-  PyObject *obj = NULL;
-  PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist,
-                                   &obj,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing divmatrix(object, vec16)");
+PyObject* python_divmatrix(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "m", NULL};
+  PyObject* obj = NULL;
+  PyObject* mat = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist, &obj,
+                                   &PyList_Type, &mat)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing divmatrix(object, vec16)");
     return NULL;
   }
   return python_multmatrix_sub(obj, mat, 1);
 }
 
-PyObject *python_oo_divmatrix(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"m", NULL};
-  PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing divmatrix(object, vec16)");
+PyObject* python_oo_divmatrix(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"m", NULL};
+  PyObject* mat = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist, &PyList_Type,
+                                   &mat)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing divmatrix(object, vec16)");
     return NULL;
   }
   return python_multmatrix_sub(obj, mat, 1);
 }
 
-PyObject *python_show_core(PyObject *obj)
-{
-  PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+PyObject* python_show_core(PyObject* obj) {
+  PyObject* child_dict;
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &child_dict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in show");
     return NULL;
@@ -967,50 +996,45 @@ PyObject *python_show_core(PyObject *obj)
   return Py_None;
 }
 
-PyObject *python_show(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  PyObject *obj = NULL;
-  char *kwlist[] = {"obj", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &obj
-                                   )) {
+PyObject* python_show(PyObject* self, PyObject* args, PyObject* kwargs) {
+  PyObject* obj = NULL;
+  char* kwlist[] = {"obj", NULL};
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &obj)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing output(object)");
     return NULL;
   }
   return python_show_core(obj);
 }
 
-PyObject *python_oo_show(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist
-                                   )) {
+PyObject* python_oo_show(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {NULL};
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing output(object)");
     return NULL;
   }
   return python_show_core(obj);
 }
 
-PyObject *python__getitem__(PyObject *obj, PyObject *key)
-{
-  PyOpenSCADObject *self = (PyOpenSCADObject *) obj;
+PyObject* python__getitem__(PyObject* obj, PyObject* key) {
+  PyOpenSCADObject* self = (PyOpenSCADObject*)obj;
   if (self->dict == nullptr) {
     return nullptr;
   }
-  PyObject *result = PyDict_GetItem(self->dict, key);
-  if (result == NULL){
-    PyObject *dummy_dict;
-    std::shared_ptr<AbstractNode> node = PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
-    PyObject *keyname = PyUnicode_AsEncodedString(key, "utf-8", "~");
+  PyObject* result = PyDict_GetItem(self->dict, key);
+  if (result == NULL) {
+    PyObject* dummy_dict;
+    std::shared_ptr<AbstractNode> node =
+        PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
+    PyObject* keyname = PyUnicode_AsEncodedString(key, "utf-8", "~");
     std::string keystr = PyBytes_AS_STRING(keyname);
     result = Py_None;
-  } else Py_INCREF(result);
+  } else
+    Py_INCREF(result);
   return result;
 }
 
-int python__setitem__(PyObject *dict, PyObject *key, PyObject *v)
-{
-  PyOpenSCADObject *self = (PyOpenSCADObject *) dict;
+int python__setitem__(PyObject* dict, PyObject* key, PyObject* v) {
+  PyOpenSCADObject* self = (PyOpenSCADObject*)dict;
   if (self->dict == NULL) {
     return 0;
   }
@@ -1019,10 +1043,8 @@ int python__setitem__(PyObject *dict, PyObject *key, PyObject *v)
   return 0;
 }
 
-
-PyObject *python_color_core(PyObject *obj, PyObject *color, double alpha)
-{
-  PyObject *child_dict;
+PyObject* python_color_core(PyObject* obj, PyObject* color, double alpha) {
+  PyObject* child_dict;
   std::shared_ptr<AbstractNode> child;
   child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
   if (child == NULL) {
@@ -1034,10 +1056,11 @@ PyObject *python_color_core(PyObject *obj, PyObject *color, double alpha)
 
   Vector4d col(0, 0, 0, alpha);
   if (!python_vectorval(color, 3, 4, &col[0], &col[1], &col[2], &col[3])) {
-    node->color.setRgba(float(col[0]), float(col[1]), float(col[2]), float(col[3]));
+    node->color.setRgba(float(col[0]), float(col[1]), float(col[2]),
+                        float(col[3]));
   } else if (PyUnicode_Check(color)) {
-    PyObject *value = PyUnicode_AsEncodedString(color, "utf-8", "~");
-    char *colorname = PyBytes_AS_STRING(value);
+    PyObject* value = PyUnicode_AsEncodedString(color, "utf-8", "~");
+    char* colorname = PyBytes_AS_STRING(value);
     const auto color = OpenSCAD::parse_color(colorname);
     if (color) {
       node->color = *color;
@@ -1053,70 +1076,64 @@ PyObject *python_color_core(PyObject *obj, PyObject *color, double alpha)
 
   node->children.push_back(child);
 
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_color(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "c", "alpha", NULL};
-  PyObject *obj = NULL;
-  PyObject *color = NULL;
+PyObject* python_color(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "c", "alpha", NULL};
+  PyObject* obj = NULL;
+  PyObject* color = NULL;
   double alpha = 1.0;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|Od", kwlist,
-                                   &obj,
-                                   &color, &alpha
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|Od", kwlist, &obj, &color,
+                                   &alpha)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing color");
     return NULL;
   }
   return python_color_core(obj, color, alpha);
 }
 
-PyObject *python_oo_color(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"c", "alpha", NULL};
-  PyObject *color = NULL;
+PyObject* python_oo_color(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"c", "alpha", NULL};
+  PyObject* color = NULL;
   double alpha = 1.0;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Od", kwlist,
-                                   &color, &alpha
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Od", kwlist, &color,
+                                   &alpha)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing color");
     return NULL;
   }
   return python_color_core(obj, color, alpha);
 }
 
-PyObject *python_mesh_core(PyObject *obj, bool tessellate)
-{
-  PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+PyObject* python_mesh_core(PyObject* obj, bool tessellate) {
+  PyObject* dummydict;
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &dummydict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in mesh \n");
     return NULL;
   }
   Tree tree(child, "");
   GeometryEvaluator geomevaluator(tree);
-  std::shared_ptr<const Geometry> geom = geomevaluator.evaluateGeometry(*tree.root(), true);
+  std::shared_ptr<const Geometry> geom =
+      geomevaluator.evaluateGeometry(*tree.root(), true);
   std::shared_ptr<const PolySet> ps = PolySetUtils::getGeometryAsPolySet(geom);
 
-
-  if (ps != nullptr){
+  if (ps != nullptr) {
     if (tessellate == true) {
       ps = PolySetUtils::tessellate_faces(*ps);
     }
     // Now create Python Point array
-    PyObject *ptarr = PyList_New(ps->vertices.size());
+    PyObject* ptarr = PyList_New(ps->vertices.size());
     for (unsigned int i = 0; i < ps->vertices.size(); i++) {
-      PyObject *coord = PyList_New(3);
+      PyObject* coord = PyList_New(3);
       for (int j = 0; j < 3; j++)
         PyList_SetItem(coord, j, PyFloat_FromDouble(ps->vertices[i][j]));
       PyList_SetItem(ptarr, i, coord);
@@ -1124,9 +1141,9 @@ PyObject *python_mesh_core(PyObject *obj, bool tessellate)
     }
     Py_XINCREF(ptarr);
     // Now create Python Point array
-    PyObject *polarr = PyList_New(ps->indices.size());
+    PyObject* polarr = PyList_New(ps->indices.size());
     for (unsigned int i = 0; i < ps->indices.size(); i++) {
-      PyObject *face = PyList_New(ps->indices[i].size());
+      PyObject* face = PyList_New(ps->indices[i].size());
       for (unsigned int j = 0; j < ps->indices[i].size(); j++)
         PyList_SetItem(face, j, PyLong_FromLong(ps->indices[i][j]));
       PyList_SetItem(polarr, i, face);
@@ -1134,7 +1151,7 @@ PyObject *python_mesh_core(PyObject *obj, bool tessellate)
     }
     Py_XINCREF(polarr);
 
-    PyObject *result = PyTuple_New(2);
+    PyObject* result = PyTuple_New(2);
     PyTuple_SetItem(result, 0, ptarr);
     PyTuple_SetItem(result, 1, polarr);
 
@@ -1142,13 +1159,13 @@ PyObject *python_mesh_core(PyObject *obj, bool tessellate)
   }
   if (auto polygon2d = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     const std::vector<Outline2d> outlines = polygon2d->outlines();
-    PyObject *pyth_outlines = PyList_New(outlines.size());
+    PyObject* pyth_outlines = PyList_New(outlines.size());
     for (unsigned int i = 0; i < outlines.size(); i++) {
       const Outline2d& outline = outlines[i];
-      PyObject *pyth_outline = PyList_New(outline.vertices.size());
+      PyObject* pyth_outline = PyList_New(outline.vertices.size());
       for (unsigned int j = 0; j < outline.vertices.size(); j++) {
         Vector2d pt = outline.vertices[j];
-        PyObject *pyth_pt = PyList_New(2);
+        PyObject* pyth_pt = PyList_New(2);
         for (int k = 0; k < 2; k++)
           PyList_SetItem(pyth_pt, k, PyFloat_FromDouble(pt[k]));
         PyList_SetItem(pyth_outline, j, pyth_pt);
@@ -1160,11 +1177,10 @@ PyObject *python_mesh_core(PyObject *obj, bool tessellate)
   return Py_None;
 }
 
-PyObject *python_mesh(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "triangulate", NULL};
-  PyObject *obj = NULL;
-  PyObject *tess = NULL;
+PyObject* python_mesh(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "triangulate", NULL};
+  PyObject* obj = NULL;
+  PyObject* tess = NULL;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &obj, &tess)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
     return NULL;
@@ -1172,10 +1188,9 @@ PyObject *python_mesh(PyObject *self, PyObject *args, PyObject *kwargs)
   return python_mesh_core(obj, tess == Py_True);
 }
 
-PyObject *python_oo_mesh(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = { "triangulate", NULL};
-  PyObject *tess = NULL;
+PyObject* python_oo_mesh(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"triangulate", NULL};
+  PyObject* tess = NULL;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O", kwlist, &tess)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
     return NULL;
@@ -1183,198 +1198,254 @@ PyObject *python_oo_mesh(PyObject *obj, PyObject *args, PyObject *kwargs)
   return python_mesh_core(obj, tess == Py_True);
 }
 
-PyObject *rotate_extrude_core(PyObject *obj,  int convexity, double scale, double angle, PyObject *twist, PyObject *origin, PyObject *offset, PyObject *vp, char *method, double fn, double fa, double fs)
-{
+PyObject* rotate_extrude_core(PyObject* obj,
+                              int convexity,
+                              double scale,
+                              double angle,
+                              PyObject* twist,
+                              PyObject* origin,
+                              PyObject* offset,
+                              PyObject* vp,
+                              char* method,
+                              double fn,
+                              double fa,
+                              double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   auto node = std::make_shared<RotateExtrudeNode>(instance);
-  if (1){
-    PyObject *dummydict;
+  if (1) {
+    PyObject* dummydict;
     child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
     if (child == NULL) {
-      PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in rotate_extrude\n");
+      PyErr_SetString(PyExc_TypeError,
+                      "Invalid type for  Object in rotate_extrude\n");
       return NULL;
     }
     node->children.push_back(child);
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->convexity = convexity;
 
   double dummy;
   Vector3d v(0, 0, 0);
-  if (vp != nullptr && !python_vectorval(vp, 3, 3, &v[0], &v[1], &v[2], &dummy)){
+  if (vp != nullptr &&
+      !python_vectorval(vp, 3, 3, &v[0], &v[1], &v[2], &dummy)) {
   }
 
-  if (node->convexity <= 0) node->convexity = 2;
-  if (node->angle <= -360)  node->angle = 360;
+  if (node->convexity <= 0)
+    node->convexity = 2;
+  if (node->angle <= -360)
+    node->angle = 360;
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_rotate_extrude(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  PyObject *obj = NULL;
+PyObject* python_rotate_extrude(PyObject* self,
+                                PyObject* args,
+                                PyObject* kwargs) {
+  PyObject* obj = NULL;
   int convexity = 1;
   double scale = 1.0;
   double angle = 360.0;
-  PyObject *twist = NULL;
-  PyObject *v = NULL;
-  char *method = NULL;
-  PyObject *origin = NULL;
-  PyObject *offset = NULL;
+  PyObject* twist = NULL;
+  PyObject* v = NULL;
+  char* method = NULL;
+  PyObject* origin = NULL;
+  PyObject* offset = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
   get_fnas(fn, fa, fs);
-  char *kwlist[] = {"obj", "convexity", "scale", "angle", "twist", "origin", "offset", "v", "method", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|iddOOOOsddd", kwlist,
-                                   &obj, &convexity, &scale, &angle, &twist, &origin, &offset, &v, &method, &fn, &fa, &fs)){
-
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate_extrude(object,...)");
+  char* kwlist[] = {"obj",    "convexity", "scale", "angle",  "twist",
+                    "origin", "offset",    "v",     "method", "fn",
+                    "fa",     "fs",        NULL};
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|iddOOOOsddd", kwlist, &obj,
+                                   &convexity, &scale, &angle, &twist, &origin,
+                                   &offset, &v, &method, &fn, &fa, &fs)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing rotate_extrude(object,...)");
     return NULL;
   }
-  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin, offset, v, method, fn, fa, fs);
+  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin,
+                             offset, v, method, fn, fa, fs);
 }
 
-PyObject *python_oo_rotate_extrude(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_oo_rotate_extrude(PyObject* obj,
+                                   PyObject* args,
+                                   PyObject* kwargs) {
   int convexity = 1;
   double scale = 1.0;
   double angle = 360.0;
-  PyObject *twist = NULL;
-  PyObject *origin = NULL;
-  PyObject *offset = NULL;
+  PyObject* twist = NULL;
+  PyObject* origin = NULL;
+  PyObject* offset = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
   get_fnas(fn, fa, fs);
-  PyObject *v = NULL;
-  char *method = NULL;
-  char *kwlist[] = {"convexity", "scale", "angle", "twist", "origin", "offset", "v", "method", "fn", "fa", "fs", NULL};
+  PyObject* v = NULL;
+  char* method = NULL;
+  char* kwlist[] = {"convexity", "scale",  "angle", "twist", "origin", "offset",
+                    "v",         "method", "fn",    "fa",    "fs",     NULL};
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iddOOOOsddd", kwlist,
-                                   &convexity, &scale, &angle, &twist, &origin, &offset, &v, &method, &fn, &fa, &fs)){
-
+                                   &convexity, &scale, &angle, &twist, &origin,
+                                   &offset, &v, &method, &fn, &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
-  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin, offset, v, method, fn, fa, fs);
+  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin,
+                             offset, v, method, fn, fa, fs);
 }
 
-PyObject *linear_extrude_core(PyObject *obj, PyObject *height, int convexity, PyObject *origin, PyObject *scale, PyObject *center, int slices, int segments, PyObject *twist, double fn, double fa, double fs)
-{
+PyObject* linear_extrude_core(PyObject* obj,
+                              PyObject* height,
+                              int convexity,
+                              PyObject* origin,
+                              PyObject* scale,
+                              PyObject* center,
+                              int slices,
+                              int segments,
+                              PyObject* twist,
+                              double fn,
+                              double fa,
+                              double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   auto node = std::make_shared<LinearExtrudeNode>(instance);
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (1){
-    PyObject *dummydict;
+  if (1) {
+    PyObject* dummydict;
     child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
     if (child == NULL) {
-      PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in linear_extrude\n");
+      PyErr_SetString(PyExc_TypeError,
+                      "Invalid type for  Object in linear_extrude\n");
       return NULL;
     }
     node->children.push_back(child);
   }
 
-
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   Vector3d height_vec(0, 0, 0);
   double dummy;
   if (!python_numberval(height, &height_vec[2])) {
     node->height = height_vec;
-  } else if (!python_vectorval(height, 3, 3, &height_vec[0], &height_vec[1], &height_vec[2], &dummy)) {
+  } else if (!python_vectorval(height, 3, 3, &height_vec[0], &height_vec[1],
+                               &height_vec[2], &dummy)) {
     node->height = height_vec;
   }
 
   node->convexity = convexity;
 
-  node->scale_x = 1.0; node->scale_y = 1.0;
+  node->scale_x = 1.0;
+  node->scale_y = 1.0;
   if (scale != NULL && PyList_Check(scale) && PyList_Size(scale) == 2) {
     node->scale_x = PyFloat_AsDouble(PyList_GetItem(scale, 0));
     node->scale_y = PyFloat_AsDouble(PyList_GetItem(scale, 1));
   }
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
 
   node->slices = slices;
-  node->has_slices = slices != 1?1:0;
+  node->has_slices = slices != 1 ? 1 : 0;
 
   node->segments = segments;
-  node->has_segments = segments != 1?1:0;
+  node->has_segments = segments != 1 ? 1 : 0;
 
   if (twist != NULL) {
     node->twist = PyFloat_AsDouble(twist);
     node->has_twist = 1;
-  } else node->has_twist = 0;
+  } else
+    node->has_twist = 0;
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_linear_extrude(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  PyObject *obj = NULL;
-  PyObject *height = NULL;
+PyObject* python_linear_extrude(PyObject* self,
+                                PyObject* args,
+                                PyObject* kwargs) {
+  PyObject* obj = NULL;
+  PyObject* height = NULL;
   int convexity = 1;
-  PyObject *origin = NULL;
-  PyObject *scale = NULL;
-  PyObject *center = NULL;
+  PyObject* origin = NULL;
+  PyObject* scale = NULL;
+  PyObject* center = NULL;
   int slices = 1;
   int segments = 0;
-  PyObject *twist = NULL;
+  PyObject* twist = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
 
-  char *kwlist[] = {"obj", "height", "convexity", "origin", "scale", "center", "slices", "segments", "twist", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OiOOOiiOddd", kwlist,
-                                   &obj, &height, &convexity, &origin, &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)){
+  char* kwlist[] = {"obj",    "height", "convexity", "origin", "scale",
+                    "center", "slices", "segments",  "twist",  "fn",
+                    "fa",     "fs",     NULL};
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OiOOOiiOddd", kwlist, &obj,
+                                   &height, &convexity, &origin, &scale,
+                                   &center, &slices, &segments, &twist, &fn,
+                                   &fs, &fs)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
 
-  return linear_extrude_core(obj, height, convexity, origin, scale, center, slices, segments, twist, fn, fa, fs);
+  return linear_extrude_core(obj, height, convexity, origin, scale, center,
+                             slices, segments, twist, fn, fa, fs);
 }
 
-PyObject *python_oo_linear_extrude(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  PyObject *height = NULL;
+PyObject* python_oo_linear_extrude(PyObject* obj,
+                                   PyObject* args,
+                                   PyObject* kwargs) {
+  PyObject* height = NULL;
   int convexity = 1;
-  PyObject *origin = NULL;
-  PyObject *scale = NULL;
-  PyObject *center = NULL;
+  PyObject* origin = NULL;
+  PyObject* scale = NULL;
+  PyObject* center = NULL;
   int slices = 1;
   int segments = 0;
-  PyObject *twist = NULL;
+  PyObject* twist = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
 
-  char *kwlist[] = {"height", "convexity", "origin", "scale", "center", "slices", "segments", "twist", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OiOOOiiOddd", kwlist,
-                                   &height, &convexity, &origin, &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)){
+  char* kwlist[] = {"height", "convexity", "origin",   "scale",
+                    "center", "slices",    "segments", "twist",
+                    "fn",     "fa",        "fs",       NULL};
+  if (!PyArg_ParseTupleAndKeywords(
+          args, kwargs, "|OiOOOiiOddd", kwlist, &height, &convexity, &origin,
+          &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
 
-  return linear_extrude_core(obj, height, convexity, origin, scale, center, slices, segments, twist, fn, fa, fs);
+  return linear_extrude_core(obj, height, convexity, origin, scale, center,
+                             slices, segments, twist, fn, fa, fs);
 }
-PyObject *python_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenSCADOperator mode)
-{
+PyObject* python_csg_sub(PyObject* self,
+                         PyObject* args,
+                         PyObject* kwargs,
+                         OpenSCADOperator mode) {
   DECLARE_INSTANCE
   int i;
 
   auto node = std::make_shared<CsgOpNode>(instance, mode);
-  PyObject *obj;
-  std::vector<PyObject *> child_dict;
+  PyObject* obj;
+  std::vector<PyObject*> child_dict;
   std::shared_ptr<AbstractNode> child;
   for (i = 0; i < PyTuple_Size(args); i++) {
     obj = PyTuple_GetItem(args, i);
-    PyObject *dict = nullptr;
+    PyObject* dict = nullptr;
     child = PyOpenSCADObjectToNodeMulti(obj, &dict);
     if (dict != nullptr) {
       child_dict.push_back(dict);
@@ -1383,136 +1454,153 @@ PyObject *python_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenS
       node->children.push_back(child);
     } else {
       switch (mode) {
-      case OpenSCADOperator::UNION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing union. arguments must be solids or arrays.");
-        return nullptr;
-        break;
-      case OpenSCADOperator::DIFFERENCE:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing difference. arguments must be solids or arrays.");
-        return nullptr;
-        break;
-      case OpenSCADOperator::INTERSECTION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing intersection. arguments must be solids or arrays.");
-        return nullptr;
-        break;
-      case OpenSCADOperator::MINKOWSKI:
-        break;
-      case OpenSCADOperator::HULL:
-        break;
-      case OpenSCADOperator::FILL:
-        break;
-      case OpenSCADOperator::RESIZE:
-        break;
+        case OpenSCADOperator::UNION:
+          PyErr_SetString(PyExc_TypeError,
+                          "Error during parsing union. arguments must be "
+                          "solids or arrays.");
+          return nullptr;
+          break;
+        case OpenSCADOperator::DIFFERENCE:
+          PyErr_SetString(PyExc_TypeError,
+                          "Error during parsing difference. arguments must be "
+                          "solids or arrays.");
+          return nullptr;
+          break;
+        case OpenSCADOperator::INTERSECTION:
+          PyErr_SetString(PyExc_TypeError,
+                          "Error during parsing intersection. arguments must "
+                          "be solids or arrays.");
+          return nullptr;
+          break;
+        case OpenSCADOperator::MINKOWSKI:
+          break;
+        case OpenSCADOperator::HULL:
+          break;
+        case OpenSCADOperator::FILL:
+          break;
+        case OpenSCADOperator::RESIZE:
+          break;
       }
       return NULL;
     }
   }
 
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
-  for (int i = child_dict.size() - 1; i >= 0; i--){ // merge from back  to give 1st child most priority
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  for (int i = child_dict.size() - 1; i >= 0;
+       i--) {  // merge from back  to give 1st child most priority
     auto& dict = child_dict[i];
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(dict, &pos, &key, &value)) {
-      PyObject *value1 = PyUnicode_AsEncodedString(key, "utf-8", "~");
-      const char *value_str = PyBytes_AS_STRING(value1);
-      PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      PyObject* value1 = PyUnicode_AsEncodedString(key, "utf-8", "~");
+      const char* value_str = PyBytes_AS_STRING(value1);
+      PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_union(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_union(PyObject* self, PyObject* args, PyObject* kwargs) {
   return python_csg_sub(self, args, kwargs, OpenSCADOperator::UNION);
 }
 
-PyObject *python_difference(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_difference(PyObject* self, PyObject* args, PyObject* kwargs) {
   return python_csg_sub(self, args, kwargs, OpenSCADOperator::DIFFERENCE);
 }
 
-PyObject *python_intersection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_intersection(PyObject* self,
+                              PyObject* args,
+                              PyObject* kwargs) {
   return python_csg_sub(self, args, kwargs, OpenSCADOperator::INTERSECTION);
 }
 
-
-PyObject *python_oo_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenSCADOperator mode)
-{
+PyObject* python_oo_csg_sub(PyObject* self,
+                            PyObject* args,
+                            PyObject* kwargs,
+                            OpenSCADOperator mode) {
   DECLARE_INSTANCE
   int i;
 
   auto node = std::make_shared<CsgOpNode>(instance, mode);
 
-
-  PyObject *obj;
-  PyObject *child_dict;
-  PyObject *dummy_dict;
+  PyObject* obj;
+  PyObject* child_dict;
+  PyObject* dummy_dict;
   std::shared_ptr<AbstractNode> child;
 
   child = PyOpenSCADObjectToNodeMulti(self, &child_dict);
-  if (child != NULL)node->children.push_back(child);
+  if (child != NULL)
+    node->children.push_back(child);
 
   for (i = 0; i < PyTuple_Size(args); i++) {
     obj = PyTuple_GetItem(args, i);
-    if (i == 0)child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
-    else child = PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
+    if (i == 0)
+      child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+    else
+      child = PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
     if (child != NULL) {
       node->children.push_back(child);
     } else {
       switch (mode) {
-      case OpenSCADOperator::UNION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing union. arguments must be solids or arrays.");
-        break;
-      case OpenSCADOperator::DIFFERENCE:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing difference. arguments must be solids or arrays.");
-        break;
-      case OpenSCADOperator::INTERSECTION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing intersection. arguments must be solids or arrays.");
-        break;
-      case OpenSCADOperator::MINKOWSKI:
-        break;
-      case OpenSCADOperator::HULL:
-        break;
-      case OpenSCADOperator::FILL:
-        break;
-      case OpenSCADOperator::RESIZE:
-        break;
+        case OpenSCADOperator::UNION:
+          PyErr_SetString(PyExc_TypeError,
+                          "Error during parsing union. arguments must be "
+                          "solids or arrays.");
+          break;
+        case OpenSCADOperator::DIFFERENCE:
+          PyErr_SetString(PyExc_TypeError,
+                          "Error during parsing difference. arguments must be "
+                          "solids or arrays.");
+          break;
+        case OpenSCADOperator::INTERSECTION:
+          PyErr_SetString(PyExc_TypeError,
+                          "Error during parsing intersection. arguments must "
+                          "be solids or arrays.");
+          break;
+        case OpenSCADOperator::MINKOWSKI:
+          break;
+        case OpenSCADOperator::HULL:
+          break;
+        case OpenSCADOperator::FILL:
+          break;
+        case OpenSCADOperator::RESIZE:
+          break;
       }
       return NULL;
     }
   }
 
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
   return pyresult;
 }
 
-PyObject *python_oo_union(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_oo_union(PyObject* self, PyObject* args, PyObject* kwargs) {
   return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::UNION);
 }
 
-PyObject *python_oo_difference(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_oo_difference(PyObject* self,
+                               PyObject* args,
+                               PyObject* kwargs) {
   return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::DIFFERENCE);
 }
 
-PyObject *python_oo_intersection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_oo_intersection(PyObject* self,
+                                 PyObject* args,
+                                 PyObject* kwargs) {
   return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::INTERSECTION);
 }
 
-PyObject *python_nb_sub(PyObject *arg1, PyObject *arg2, OpenSCADOperator mode)
-{
+PyObject* python_nb_sub(PyObject* arg1, PyObject* arg2, OpenSCADOperator mode) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child[2];
-  PyObject *child_dict[2];
-
-  if (arg1 == Py_None && mode == OpenSCADOperator::UNION)return arg2;
-  if (arg2 == Py_None && mode == OpenSCADOperator::UNION)return arg1;
-  if (arg2 == Py_None && mode == OpenSCADOperator::DIFFERENCE)return arg1;
+  PyObject* child_dict[2];
 
+  if (arg1 == Py_None && mode == OpenSCADOperator::UNION)
+    return arg2;
+  if (arg2 == Py_None && mode == OpenSCADOperator::UNION)
+    return arg1;
+  if (arg2 == Py_None && mode == OpenSCADOperator::DIFFERENCE)
+    return arg1;
 
   child[0] = PyOpenSCADObjectToNodeMulti(arg1, &child_dict[0]);
   if (child[0] == NULL) {
@@ -1527,24 +1615,27 @@ PyObject *python_nb_sub(PyObject *arg1, PyObject *arg2, OpenSCADOperator mode)
   auto node = std::make_shared<CsgOpNode>(instance, mode);
   node->children.push_back(child[0]);
   node->children.push_back(child[1]);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
   for (int i = 1; i >= 0; i--) {
     if (child_dict[i] != nullptr) {
       PyObject *key, *value;
       Py_ssize_t pos = 0;
       while (PyDict_Next(child_dict[i], &pos, &key, &value)) {
-        PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
       }
     }
   }
   return pyresult;
 }
 
-PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: translate, 1: scale, 2: translateneg, 3=translate-exp
+PyObject* python_nb_sub_vec3(
+    PyObject* arg1,
+    PyObject* arg2,
+    int mode)  // 0: translate, 1: scale, 2: translateneg, 3=translate-exp
 {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
-  PyObject *child_dict;
+  PyObject* child_dict;
 
   child = PyOpenSCADObjectToNodeMulti(arg1, &child_dict);
   std::vector<Vector3d> vecs;
@@ -1552,8 +1643,9 @@ PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: tra
   vecs = python_vectors(arg2, 2, 3);
 
   if (mode == 0 && vecs.size() == 1) {
-    PyObject *mat = python_matrix_trans(arg1, vecs[0]);
-    if (mat != nullptr)return mat;
+    PyObject* mat = python_matrix_trans(arg1, vecs[0]);
+    if (mat != nullptr)
+      return mat;
   }
 
   if (vecs.size() > 0) {
@@ -1564,21 +1656,26 @@ PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: tra
     std::vector<std::shared_ptr<TransformNode>> nodes;
     for (size_t j = 0; j < vecs.size(); j++) {
       auto node = std::make_shared<TransformNode>(instance, "transform");
-      if (mode == 0 || mode == 3)node->matrix.translate(vecs[j]);
-      if (mode == 1)node->matrix.scale(vecs[j]);
-      if (mode == 2)node->matrix.translate(-vecs[j]);
+      if (mode == 0 || mode == 3)
+        node->matrix.translate(vecs[j]);
+      if (mode == 1)
+        node->matrix.scale(vecs[j]);
+      if (mode == 2)
+        node->matrix.translate(-vecs[j]);
       node->children.push_back(child);
       nodes.push_back(node);
     }
     if (nodes.size() == 1) {
-      PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, nodes[0]);
+      PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, nodes[0]);
       if (child_dict != nullptr) {
         PyObject *key, *value;
         Py_ssize_t pos = 0;
         while (PyDict_Next(child_dict, &pos, &key, &value)) {
-          PyObject *value1 = python_matrix_trans(value, vecs[0]);
-          if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-          else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+          PyObject* value1 = python_matrix_trans(value, vecs[0]);
+          if (value1 != nullptr)
+            PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value1);
+          else
+            PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
         }
       }
       return pyresult;
@@ -1588,31 +1685,41 @@ PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: tra
   return NULL;
 }
 
-PyObject *python_nb_add(PyObject *arg1, PyObject *arg2) { return python_nb_sub_vec3(arg1, arg2, 0); }  // translate
-PyObject *python_nb_mul(PyObject *arg1, PyObject *arg2) { return python_nb_sub_vec3(arg1, arg2, 1); } // scale
-PyObject *python_nb_or(PyObject *arg1, PyObject *arg2) { return python_nb_sub(arg1, arg2,  OpenSCADOperator::UNION); }
-PyObject *python_nb_subtract(PyObject *arg1, PyObject *arg2)
-{
+PyObject* python_nb_add(PyObject* arg1, PyObject* arg2) {
+  return python_nb_sub_vec3(arg1, arg2, 0);
+}  // translate
+PyObject* python_nb_mul(PyObject* arg1, PyObject* arg2) {
+  return python_nb_sub_vec3(arg1, arg2, 1);
+}  // scale
+PyObject* python_nb_or(PyObject* arg1, PyObject* arg2) {
+  return python_nb_sub(arg1, arg2, OpenSCADOperator::UNION);
+}
+PyObject* python_nb_subtract(PyObject* arg1, PyObject* arg2) {
   double dmy;
   if (PyList_Check(arg2) && PyList_Size(arg2) > 0) {
-    PyObject *sub = PyList_GetItem(arg2, 0);
-    if (!python_numberval(sub, &dmy) || PyList_Check(sub)){
+    PyObject* sub = PyList_GetItem(arg2, 0);
+    if (!python_numberval(sub, &dmy) || PyList_Check(sub)) {
       return python_nb_sub_vec3(arg1, arg2, 2);
     }
   }
-  return python_nb_sub(arg1, arg2,  OpenSCADOperator::DIFFERENCE); // if its solid
+  return python_nb_sub(arg1, arg2,
+                       OpenSCADOperator::DIFFERENCE);  // if its solid
+}
+PyObject* python_nb_and(PyObject* arg1, PyObject* arg2) {
+  return python_nb_sub(arg1, arg2, OpenSCADOperator::INTERSECTION);
 }
-PyObject *python_nb_and(PyObject *arg1, PyObject *arg2) { return python_nb_sub(arg1, arg2,  OpenSCADOperator::INTERSECTION); }
 
-PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs, CgalAdvType mode)
-{
+PyObject* python_csg_adv_sub(PyObject* self,
+                             PyObject* args,
+                             PyObject* kwargs,
+                             CgalAdvType mode) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   int i;
-  PyObject *dummydict;
+  PyObject* dummydict;
 
   auto node = std::make_shared<CgalAdvNode>(instance, mode);
-  PyObject *obj;
+  PyObject* obj;
   for (i = 0; i < PyTuple_Size(args); i++) {
     obj = PyTuple_GetItem(args, i);
     child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
@@ -1620,16 +1727,20 @@ PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs, C
       node->children.push_back(child);
     } else {
       switch (mode) {
-      case CgalAdvType::HULL:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing hull. arguments must be solids or arrays.");
-        break;
-      case CgalAdvType::FILL:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing fill. arguments must be solids or arrays.");
-        break;
-      case CgalAdvType::RESIZE:
-        break;
-      case CgalAdvType::MINKOWSKI:
-        break;
+        case CgalAdvType::HULL:
+          PyErr_SetString(
+              PyExc_TypeError,
+              "Error during parsing hull. arguments must be solids or arrays.");
+          break;
+        case CgalAdvType::FILL:
+          PyErr_SetString(
+              PyExc_TypeError,
+              "Error during parsing fill. arguments must be solids or arrays.");
+          break;
+        case CgalAdvType::RESIZE:
+          break;
+        case CgalAdvType::MINKOWSKI:
+          break;
       }
       return NULL;
     }
@@ -1638,8 +1749,7 @@ PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs, C
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_minkowski(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_minkowski(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   int i;
@@ -1647,15 +1757,13 @@ PyObject *python_minkowski(PyObject *self, PyObject *args, PyObject *kwargs)
   int convexity = 2;
 
   auto node = std::make_shared<CgalAdvNode>(instance, CgalAdvType::MINKOWSKI);
-  char *kwlist[] = { "obj", "convexity", NULL };
-  PyObject *objs = NULL;
-  PyObject *obj;
-  PyObject *dummydict;
+  char* kwlist[] = {"obj", "convexity", NULL};
+  PyObject* objs = NULL;
+  PyObject* obj;
+  PyObject* dummydict;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|i", kwlist,
-                                   &PyList_Type, &objs,
-                                   &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|i", kwlist, &PyList_Type,
+                                   &objs, &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing minkowski(object)");
     return NULL;
   }
@@ -1675,25 +1783,23 @@ PyObject *python_minkowski(PyObject *self, PyObject *args, PyObject *kwargs)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-
-
-PyObject *python_hull(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_hull(PyObject* self, PyObject* args, PyObject* kwargs) {
   return python_csg_adv_sub(self, args, kwargs, CgalAdvType::HULL);
 }
 
-PyObject *python_fill(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_fill(PyObject* self, PyObject* args, PyObject* kwargs) {
   return python_csg_adv_sub(self, args, kwargs, CgalAdvType::FILL);
 }
 
-PyObject *python_resize_core(PyObject *obj, PyObject *newsize, PyObject *autosize, int convexity)
-{
+PyObject* python_resize_core(PyObject* obj,
+                             PyObject* newsize,
+                             PyObject* autosize,
+                             int convexity) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
   auto node = std::make_shared<CgalAdvNode>(instance, CgalAdvType::RESIZE);
-  PyObject *dummydict;
+  PyObject* dummydict;
   child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in resize");
@@ -1730,51 +1836,50 @@ PyObject *python_resize_core(PyObject *obj, PyObject *newsize, PyObject *autosiz
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_resize(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = { "obj", "newsize", "auto", "convexity", NULL };
-  PyObject *obj;
-  PyObject *newsize = NULL;
-  PyObject *autosize = NULL;
+PyObject* python_resize(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "newsize", "auto", "convexity", NULL};
+  PyObject* obj;
+  PyObject* newsize = NULL;
+  PyObject* autosize = NULL;
   int convexity = 2;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O!O!i", kwlist,
-                                   &obj,
-                                   &PyList_Type, &newsize,
-                                   &PyList_Type, &autosize,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing resize(object,vec3)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O!O!i", kwlist, &obj,
+                                   &PyList_Type, &newsize, &PyList_Type,
+                                   &autosize, &convexity)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing resize(object,vec3)");
     return NULL;
   }
   return python_resize_core(obj, newsize, autosize, convexity);
 }
 
-PyObject *python_oo_resize(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"newsize", "auto", "convexity", NULL };
-  PyObject *newsize = NULL;
-  PyObject *autosize = NULL;
+PyObject* python_oo_resize(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"newsize", "auto", "convexity", NULL};
+  PyObject* newsize = NULL;
+  PyObject* autosize = NULL;
   int convexity = 2;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O!O!i", kwlist,
-                                   &PyList_Type, &newsize,
-                                   &PyList_Type, &autosize,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing resize(object,vec3)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O!O!i", kwlist, &PyList_Type,
+                                   &newsize, &PyList_Type, &autosize,
+                                   &convexity)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing resize(object,vec3)");
     return NULL;
   }
   return python_resize_core(obj, newsize, autosize, convexity);
 }
 
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-PyObject *python_roof_core(PyObject *obj, const char *method, int convexity, double fn, double fa, double fs)
-{
+PyObject* python_roof_core(PyObject* obj,
+                           const char* method,
+                           int convexity,
+                           double fn,
+                           double fa,
+                           double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   auto node = std::make_shared<RoofNode>(instance);
-  PyObject *dummydict;
+  PyObject* dummydict;
   child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in roof");
@@ -1782,9 +1887,12 @@ PyObject *python_roof_core(PyObject *obj, const char *method, int convexity, dou
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->fa = std::max(node->fa, 0.01);
   node->fs = std::max(node->fs, 0.01);
@@ -1799,116 +1907,112 @@ PyObject *python_roof_core(PyObject *obj, const char *method, int convexity, dou
     node->method = method;
     // method can only be one of...
     if (node->method != "voronoi" && node->method != "straight") {
-//      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-//          "Unknown roof method '" + node->method + "'. Using 'voronoi'.");
+      //      LOG(message_group::Warning, inst->location(),
+      //      parameters.documentRoot(),
+      //          "Unknown roof method '" + node->method + "'. Using
+      //          'voronoi'.");
       node->method = "voronoi";
     }
   }
 
   double tmp_convexity = convexity;
   node->convexity = static_cast<int>(tmp_convexity);
-  if (node->convexity <= 0) node->convexity = 1;
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
   node->children.push_back(child);
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_roof(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_roof(PyObject* self, PyObject* args, PyObject* kwargs) {
   double fn = NAN, fa = NAN, fs = NAN;
-  char *kwlist[] = {"obj", "method", "convexity", "fn", "fa", "fs", NULL};
-  PyObject *obj = NULL;
-  const char *method = NULL;
+  char* kwlist[] = {"obj", "method", "convexity", "fn", "fa", "fs", NULL};
+  PyObject* obj = NULL;
+  const char* method = NULL;
   int convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sdddd", kwlist,
-                                   &obj,
-                                   &method, convexity,
-                                   &fn, &fa, &fs
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sdddd", kwlist, &obj,
+                                   &method, convexity, &fn, &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing roof(object)");
     return NULL;
   }
   return python_roof_core(obj, method, convexity, fn, fa, fs);
 }
 
-PyObject *python_oo_roof(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_oo_roof(PyObject* obj, PyObject* args, PyObject* kwargs) {
   double fn = NAN, fa = NAN, fs = NAN;
-  char *kwlist[] = {"method", "convexity", "fn", "fa", "fs", NULL};
-  const char *method = NULL;
+  char* kwlist[] = {"method", "convexity", "fn", "fa", "fs", NULL};
+  const char* method = NULL;
   int convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sdddd", kwlist,
-                                   &method, convexity,
-                                   &fn, &fa, &fs
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sdddd", kwlist, &method,
+                                   convexity, &fn, &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing roof(object)");
     return NULL;
   }
   return python_roof_core(obj, method, convexity, fn, fa, fs);
 }
-#endif // if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
+#endif  // if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
 
-PyObject *python_render_core(PyObject *obj, int convexity)
-{
+PyObject* python_render_core(PyObject* obj, int convexity) {
   DECLARE_INSTANCE
   auto node = std::make_shared<RenderNode>(instance);
 
-  PyObject *dummydict;
+  PyObject* dummydict;
   std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNode(obj, &dummydict);
   node->convexity = convexity;
   node->children.push_back(child);
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_render(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "convexity", NULL};
-  PyObject *obj = NULL;
+PyObject* python_render(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "convexity", NULL};
+  PyObject* obj = NULL;
   long convexity = 2;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|i", kwlist,
-                                   &PyOpenSCADType, &obj,
-                                   &convexity
-                                   )) {
+                                   &PyOpenSCADType, &obj, &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing render(object)");
     return NULL;
   }
   return python_render_core(obj, convexity);
 }
 
-PyObject *python_oo_render(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"convexity", NULL};
+PyObject* python_oo_render(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"convexity", NULL};
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i", kwlist,
-                                   &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i", kwlist, &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing render(object)");
     return NULL;
   }
   return python_render_core(obj, convexity);
 }
 
-PyObject *python_surface_core(const char *file, PyObject *center, PyObject *invert, int convexity)
-{
+PyObject* python_surface_core(const char* file,
+                              PyObject* center,
+                              PyObject* invert,
+                              int convexity) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
   auto node = std::make_shared<SurfaceNode>(instance);
 
   std::string fileval = file == NULL ? "" : file;
-  std::string filename = lookup_file(fileval, instance->location().filePath().parent_path().string(), "");
+  std::string filename = lookup_file(
+      fileval, instance->location().filePath().parent_path().string(), "");
   node->filename = filename;
   handle_dep(fs::path(filename).generic_string());
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
   node->convexity = 2;
-  if (invert == Py_True)   node->invert = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (invert == Py_True)
+    node->invert = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for invert parameter");
     return NULL;
@@ -1917,16 +2021,14 @@ PyObject *python_surface_core(const char *file, PyObject *center, PyObject *inve
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_surface(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"file", "center", "convexity", "invert", NULL};
-  const char *file = NULL;
-  PyObject *center = NULL;
-  PyObject *invert = NULL;
+PyObject* python_surface(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"file", "center", "convexity", "invert", NULL};
+  const char* file = NULL;
+  PyObject* center = NULL;
+  PyObject* invert = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|OlO", kwlist,
-                                   &file, &center, &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|OlO", kwlist, &file,
+                                   &center, &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing surface(object)");
     return NULL;
   }
@@ -1934,26 +2036,25 @@ PyObject *python_surface(PyObject *self, PyObject *args, PyObject *kwargs)
   return python_surface_core(file, center, invert, convexity);
 }
 
-PyObject *python_text(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_text(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<TextNode>(instance);
 
-  char *kwlist[] = {"text", "size", "font", "spacing", "direction", "language", "script", "halign", "valign", "fn", "fa", "fs", NULL};
+  char* kwlist[] = {"text",     "size",   "font",   "spacing", "direction",
+                    "language", "script", "halign", "valign",  "fn",
+                    "fa",       "fs",     NULL};
 
   double size = 1.0, spacing = 1.0;
   double fn = NAN, fa = NAN, fs = NAN;
 
   get_fnas(fn, fa, fs);
 
-  const char *text = "", *font = NULL, *direction = "ltr", *language = "en", *script = "latin", *valign = "baseline", *halign = "left";
+  const char *text = "", *font = NULL, *direction = "ltr", *language = "en",
+             *script = "latin", *valign = "baseline", *halign = "left";
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|dsdsssssddd", kwlist,
-                                   &text, &size, &font,
-                                   &spacing, &direction, &language,
-                                   &script, &halign, &valign,
-                                   &fn, &fa, &fs
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(
+          args, kwargs, "s|dsdsssssddd", kwlist, &text, &size, &font, &spacing,
+          &direction, &language, &script, &halign, &valign, &fn, &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing text(string, ...))");
     return NULL;
   }
@@ -1962,41 +2063,47 @@ PyObject *python_text(PyObject *self, PyObject *args, PyObject *kwargs)
   node->params.set_fa(fa);
   node->params.set_fs(fs);
   node->params.set_size(size);
-  if (text != NULL) node->params.set_text(text);
+  if (text != NULL)
+    node->params.set_text(text);
   node->params.set_spacing(spacing);
-  if (font != NULL) node->params.set_font(font);
-  if (direction != NULL) node->params.set_direction(direction);
-  if (language != NULL) node->params.set_language(language);
-  if (script != NULL) node->params.set_script(script);
-  if (valign != NULL) node->params.set_halign(halign);
-  if (halign != NULL) node->params.set_valign(valign);
+  if (font != NULL)
+    node->params.set_font(font);
+  if (direction != NULL)
+    node->params.set_direction(direction);
+  if (language != NULL)
+    node->params.set_language(language);
+  if (script != NULL)
+    node->params.set_script(script);
+  if (valign != NULL)
+    node->params.set_halign(halign);
+  if (halign != NULL)
+    node->params.set_valign(valign);
   node->params.set_loc(instance->location());
 
-/*
-   node->params.set_documentPath(session->documentRoot());
-   }
- */
+  /*
+     node->params.set_documentPath(session->documentRoot());
+     }
+   */
   node->params.detect_properties();
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_textmetrics(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<TextNode>(instance);
 
-  char *kwlist[] = {"text", "size", "font", "spacing", "direction", "language", "script", "halign", "valign", NULL};
+  char* kwlist[] = {"text",     "size",   "font",   "spacing", "direction",
+                    "language", "script", "halign", "valign",  NULL};
 
   double size = 1.0, spacing = 1.0;
 
-  const char *text = "", *font = NULL, *direction = "ltr", *language = "en", *script = "latin", *valign = "baseline", *halign = "left";
+  const char *text = "", *font = NULL, *direction = "ltr", *language = "en",
+             *script = "latin", *valign = "baseline", *halign = "left";
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|dsdsssss", kwlist,
-                                   &text, &size, &font,
-                                   &spacing, &direction, &language,
-                                   &script, &valign, &halign
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|dsdsssss", kwlist, &text,
+                                   &size, &font, &spacing, &direction,
+                                   &language, &script, &valign, &halign)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing textmetrics");
     return NULL;
   }
@@ -2004,14 +2111,21 @@ PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
   FreetypeRenderer::Params ftparams;
 
   ftparams.set_size(size);
-  if (text != NULL) ftparams.set_text(text);
+  if (text != NULL)
+    ftparams.set_text(text);
   ftparams.set_spacing(spacing);
-  if (font != NULL) ftparams.set_font(font);
-  if (direction != NULL) ftparams.set_direction(direction);
-  if (language != NULL) ftparams.set_language(language);
-  if (script != NULL) ftparams.set_script(script);
-  if (valign != NULL) ftparams.set_halign(halign);
-  if (halign != NULL) ftparams.set_valign(valign);
+  if (font != NULL)
+    ftparams.set_font(font);
+  if (direction != NULL)
+    ftparams.set_direction(direction);
+  if (language != NULL)
+    ftparams.set_language(language);
+  if (script != NULL)
+    ftparams.set_script(script);
+  if (valign != NULL)
+    ftparams.set_halign(halign);
+  if (halign != NULL)
+    ftparams.set_valign(valign);
   ftparams.set_loc(instance->location());
 
   FreetypeRenderer::TextMetrics metrics(ftparams);
@@ -2019,23 +2133,23 @@ PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
     PyErr_SetString(PyExc_TypeError, "Invalid Metric");
     return NULL;
   }
-  PyObject *offset = PyList_New(2);
+  PyObject* offset = PyList_New(2);
   PyList_SetItem(offset, 0, PyFloat_FromDouble(metrics.x_offset));
   PyList_SetItem(offset, 1, PyFloat_FromDouble(metrics.y_offset));
 
-  PyObject *advance = PyList_New(2);
+  PyObject* advance = PyList_New(2);
   PyList_SetItem(advance, 0, PyFloat_FromDouble(metrics.advance_x));
   PyList_SetItem(advance, 1, PyFloat_FromDouble(metrics.advance_y));
 
-  PyObject *position = PyList_New(2);
+  PyObject* position = PyList_New(2);
   PyList_SetItem(position, 0, PyFloat_FromDouble(metrics.bbox_x));
   PyList_SetItem(position, 1, PyFloat_FromDouble(metrics.bbox_y));
 
-  PyObject *dims = PyList_New(2);
+  PyObject* dims = PyList_New(2);
   PyList_SetItem(dims, 0, PyFloat_FromDouble(metrics.bbox_w));
   PyList_SetItem(dims, 1, PyFloat_FromDouble(metrics.bbox_h));
 
-  PyObject *dict;
+  PyObject* dict;
   dict = PyDict_New();
   PyDict_SetItemString(dict, "ascent", PyFloat_FromDouble(metrics.ascent));
   PyDict_SetItemString(dict, "descent", PyFloat_FromDouble(metrics.descent));
@@ -2043,26 +2157,34 @@ PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
   PyDict_SetItemString(dict, "advance", advance);
   PyDict_SetItemString(dict, "position", position);
   PyDict_SetItemString(dict, "size", dims);
-  return (PyObject *)dict;
+  return (PyObject*)dict;
 }
 
-PyObject *python_offset_core(PyObject *obj, double r, double delta, PyObject *chamfer, double fn, double fa, double fs)
-{
+PyObject* python_offset_core(PyObject* obj,
+                             double r,
+                             double delta,
+                             PyObject* chamfer,
+                             double fn,
+                             double fa,
+                             double fs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<OffsetNode>(instance);
 
-  PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  PyObject* dummydict;
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &dummydict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in offset");
     return NULL;
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
-
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->delta = 1;
   node->chamfer = false;
@@ -2075,7 +2197,8 @@ PyObject *python_offset_core(PyObject *obj, double r, double delta, PyObject *ch
     if (chamfer == Py_True) {
       node->chamfer = true;
       node->join_type = Clipper2Lib::JoinType::Square;
-    } else if (chamfer == Py_False || chamfer == NULL) node->chamfer = 0;
+    } else if (chamfer == Py_False || chamfer == NULL)
+      node->chamfer = 0;
     else {
       PyErr_SetString(PyExc_TypeError, "Unknown Value for chamfer parameter");
       return NULL;
@@ -2085,46 +2208,43 @@ PyObject *python_offset_core(PyObject *obj, double r, double delta, PyObject *ch
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_offset(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "r", "delta", "chamfer", "fn", "fa", "fs", NULL};
-  PyObject *obj = NULL;
+PyObject* python_offset(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "r", "delta", "chamfer", "fn", "fa", "fs", NULL};
+  PyObject* obj = NULL;
   double r = NAN, delta = NAN;
-  PyObject *chamfer = NULL;
+  PyObject* chamfer = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|ddOddd", kwlist,
-                                   &obj,
-                                   &r, &delta, &chamfer,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing offset(object,r,delta)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|ddOddd", kwlist, &obj, &r,
+                                   &delta, &chamfer, &fn, &fa, &fs)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing offset(object,r,delta)");
     return NULL;
   }
   return python_offset_core(obj, r, delta, chamfer, fn, fa, fs);
 }
 
-PyObject *python_oo_offset(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"r", "delta", "chamfer", "fn", "fa", "fs", NULL};
+PyObject* python_oo_offset(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"r", "delta", "chamfer", "fn", "fa", "fs", NULL};
   double r = NAN, delta = NAN;
-  PyObject *chamfer = NULL;
+  PyObject* chamfer = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddOddd", kwlist,
-                                   &r, &delta, &chamfer,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing offset(object,r,delta)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddOddd", kwlist, &r, &delta,
+                                   &chamfer, &fn, &fa, &fs)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing offset(object,r,delta)");
     return NULL;
   }
   return python_offset_core(obj, r, delta, chamfer, fn, fa, fs);
 }
 
-PyObject *python_projection_core(PyObject *obj, const char *cutmode, int convexity)
-{
+PyObject* python_projection_core(PyObject* obj,
+                                 const char* cutmode,
+                                 int convexity) {
   DECLARE_INSTANCE
   auto node = std::make_shared<ProjectionNode>(instance);
-  PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  PyObject* dummydict;
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &dummydict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in projection");
     return NULL;
@@ -2132,55 +2252,51 @@ PyObject *python_projection_core(PyObject *obj, const char *cutmode, int convexi
 
   node->convexity = convexity;
   node->cut_mode = 0;
-  if (cutmode != NULL && !strcasecmp(cutmode, "cut")) node->cut_mode = 1;
+  if (cutmode != NULL && !strcasecmp(cutmode, "cut"))
+    node->cut_mode = 1;
 
   node->children.push_back(child);
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_projection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "cut", "convexity", NULL};
-  PyObject *obj = NULL;
-  const char *cutmode = NULL;
+PyObject* python_projection(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "cut", "convexity", NULL};
+  PyObject* obj = NULL;
+  const char* cutmode = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sl", kwlist,
-                                   &obj,
-                                   &cutmode, &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sl", kwlist, &obj, &cutmode,
+                                   &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing projection(object)");
     return NULL;
   }
   return python_projection_core(obj, cutmode, convexity);
 }
 
-PyObject *python_oo_projection(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"cut", "convexity", NULL};
-  const char *cutmode = NULL;
+PyObject* python_oo_projection(PyObject* obj,
+                               PyObject* args,
+                               PyObject* kwargs) {
+  char* kwlist[] = {"cut", "convexity", NULL};
+  const char* cutmode = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sl", kwlist,
-                                   &cutmode, &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sl", kwlist, &cutmode,
+                                   &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing projection(object)");
     return NULL;
   }
   return python_projection_core(obj, cutmode, convexity);
 }
 
-PyObject *python_group(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject* python_group(PyObject* self, PyObject* args, PyObject* kwargs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
   auto node = std::make_shared<GroupNode>(instance);
 
-  char *kwlist[] = {"obj", NULL};
-  PyObject *obj = NULL;
-  PyObject *dummydict;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyOpenSCADType, &obj
-                                   )) {
+  char* kwlist[] = {"obj", NULL};
+  PyObject* obj = NULL;
+  PyObject* dummydict;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist, &PyOpenSCADType,
+                                   &obj)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing group(group)");
     return NULL;
   }
@@ -2190,14 +2306,16 @@ PyObject *python_group(PyObject *self, PyObject *args, PyObject *kwargs)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_align_core(PyObject *obj, PyObject *pyrefmat, PyObject *pydstmat)
-{
+PyObject* python_align_core(PyObject* obj,
+                            PyObject* pyrefmat,
+                            PyObject* pydstmat) {
   if (obj->ob_type != &PyOpenSCADType) {
     PyErr_SetString(PyExc_TypeError, "Must specify Object as 1st parameter");
     return nullptr;
   }
-  PyObject *child_dict = nullptr;
-  std::shared_ptr<AbstractNode> dstnode = PyOpenSCADObjectToNode(obj, &child_dict);
+  PyObject* child_dict = nullptr;
+  std::shared_ptr<AbstractNode> dstnode =
+      PyOpenSCADObjectToNode(obj, &child_dict);
   if (dstnode == nullptr) {
     PyErr_SetString(PyExc_TypeError, "Invalid align object");
     return Py_None;
@@ -2208,189 +2326,220 @@ PyObject *python_align_core(PyObject *obj, PyObject *pyrefmat, PyObject *pydstma
   Matrix4d mat;
   Matrix4d MT = Matrix4d::Identity();
 
-  if (!python_tomatrix(pyrefmat, mat))MT = MT * mat;
-  if (!python_tomatrix(pydstmat, mat))MT = MT * mat.inverse();
+  if (!python_tomatrix(pyrefmat, mat))
+    MT = MT * mat;
+  if (!python_tomatrix(pydstmat, mat))
+    MT = MT * mat.inverse();
 
   multmatnode->matrix = MT;
 
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, multmatnode);
+  PyObject* pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, multmatnode);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      if (!python_tomatrix(value, mat)){
+      if (!python_tomatrix(value, mat)) {
         mat = MT * mat;
-        PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, python_frommatrix(mat));
-      } else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key,
+                       python_frommatrix(mat));
+      } else
+        PyDict_SetItem(((PyOpenSCADObject*)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_align(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"obj", "refmat", "objmat", NULL};
-  PyObject *obj = NULL;
-  PyObject *pyrefmat = NULL;
-  PyObject *pyobjmat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist,
-                                   &obj,
-                                   &pyrefmat,
-                                   &pyobjmat
-                                   )) {
+PyObject* python_align(PyObject* self, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"obj", "refmat", "objmat", NULL};
+  PyObject* obj = NULL;
+  PyObject* pyrefmat = NULL;
+  PyObject* pyobjmat = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist, &obj,
+                                   &pyrefmat, &pyobjmat)) {
     PyErr_SetString(PyExc_TypeError, "Error during align");
     return NULL;
   }
   return python_align_core(obj, pyrefmat, pyobjmat);
 }
 
-PyObject *python_oo_align(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"refmat", "objmat", NULL};
-  PyObject *pyrefmat = NULL;
-  PyObject *pyobjmat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist,
-                                   &pyrefmat,
-                                   &pyobjmat
-                                   )) {
+PyObject* python_oo_align(PyObject* obj, PyObject* args, PyObject* kwargs) {
+  char* kwlist[] = {"refmat", "objmat", NULL};
+  PyObject* pyrefmat = NULL;
+  PyObject* pyobjmat = NULL;
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &pyrefmat,
+                                   &pyobjmat)) {
     PyErr_SetString(PyExc_TypeError, "Error during align");
     return NULL;
   }
   return python_align_core(obj, pyrefmat, pyobjmat);
 }
 
-
-PyObject *python_str(PyObject *self) {
+PyObject* python_str(PyObject* self) {
   std::ostringstream stream;
-  PyObject *dummydict;
+  PyObject* dummydict;
   std::shared_ptr<AbstractNode> node = PyOpenSCADObjectToNode(self, &dummydict);
-  if (node != nullptr)stream << "OpenSCAD (" << (int) node->index() << ")";
-  else stream << "Invalid OpenSCAD Object";
+  if (node != nullptr)
+    stream << "OpenSCAD (" << (int)node->index() << ")";
+  else
+    stream << "Invalid OpenSCAD Object";
 
   return PyUnicode_FromStringAndSize(stream.str().c_str(), stream.str().size());
 }
 
 PyMethodDef PyOpenSCADFunctions[] = {
-  {"square", (PyCFunction) python_square, METH_VARARGS | METH_KEYWORDS, "Create Square."},
-  {"circle", (PyCFunction) python_circle, METH_VARARGS | METH_KEYWORDS, "Create Circle."},
-  {"polygon", (PyCFunction) python_polygon, METH_VARARGS | METH_KEYWORDS, "Create Polygon."},
-  {"text", (PyCFunction) python_text, METH_VARARGS | METH_KEYWORDS, "Create Text."},
-  {"textmetrics", (PyCFunction) python_textmetrics, METH_VARARGS | METH_KEYWORDS, "Get textmetrics."},
-  {"cube", (PyCFunction) python_cube, METH_VARARGS | METH_KEYWORDS, "Create Cube."},
-  {"cylinder", (PyCFunction) python_cylinder, METH_VARARGS | METH_KEYWORDS, "Create Cylinder."},
-  {"sphere", (PyCFunction) python_sphere, METH_VARARGS | METH_KEYWORDS, "Create Sphere."},
-  {"polyhedron", (PyCFunction) python_polyhedron, METH_VARARGS | METH_KEYWORDS, "Create Polyhedron."},
-  {"translate", (PyCFunction) python_translate, METH_VARARGS | METH_KEYWORDS, "Move  Object."},
-  {"rotate", (PyCFunction) python_rotate, METH_VARARGS | METH_KEYWORDS, "Rotate Object."},
-  {"scale", (PyCFunction) python_scale, METH_VARARGS | METH_KEYWORDS, "Scale Object."},
-  {"mirror", (PyCFunction) python_mirror, METH_VARARGS | METH_KEYWORDS, "Mirror Object."},
-  {"multmatrix", (PyCFunction) python_multmatrix, METH_VARARGS | METH_KEYWORDS, "Multmatrix Object."},
-  {"divmatrix", (PyCFunction) python_divmatrix, METH_VARARGS | METH_KEYWORDS, "Divmatrix Object."},
-  {"offset", (PyCFunction) python_offset, METH_VARARGS | METH_KEYWORDS, "Offset Object."},
+    {"square", (PyCFunction)python_square, METH_VARARGS | METH_KEYWORDS,
+     "Create Square."},
+    {"circle", (PyCFunction)python_circle, METH_VARARGS | METH_KEYWORDS,
+     "Create Circle."},
+    {"polygon", (PyCFunction)python_polygon, METH_VARARGS | METH_KEYWORDS,
+     "Create Polygon."},
+    {"text", (PyCFunction)python_text, METH_VARARGS | METH_KEYWORDS,
+     "Create Text."},
+    {"textmetrics", (PyCFunction)python_textmetrics,
+     METH_VARARGS | METH_KEYWORDS, "Get textmetrics."},
+    {"cube", (PyCFunction)python_cube, METH_VARARGS | METH_KEYWORDS,
+     "Create Cube."},
+    {"cylinder", (PyCFunction)python_cylinder, METH_VARARGS | METH_KEYWORDS,
+     "Create Cylinder."},
+    {"sphere", (PyCFunction)python_sphere, METH_VARARGS | METH_KEYWORDS,
+     "Create Sphere."},
+    {"polyhedron", (PyCFunction)python_polyhedron, METH_VARARGS | METH_KEYWORDS,
+     "Create Polyhedron."},
+    {"translate", (PyCFunction)python_translate, METH_VARARGS | METH_KEYWORDS,
+     "Move  Object."},
+    {"rotate", (PyCFunction)python_rotate, METH_VARARGS | METH_KEYWORDS,
+     "Rotate Object."},
+    {"scale", (PyCFunction)python_scale, METH_VARARGS | METH_KEYWORDS,
+     "Scale Object."},
+    {"mirror", (PyCFunction)python_mirror, METH_VARARGS | METH_KEYWORDS,
+     "Mirror Object."},
+    {"multmatrix", (PyCFunction)python_multmatrix, METH_VARARGS | METH_KEYWORDS,
+     "Multmatrix Object."},
+    {"divmatrix", (PyCFunction)python_divmatrix, METH_VARARGS | METH_KEYWORDS,
+     "Divmatrix Object."},
+    {"offset", (PyCFunction)python_offset, METH_VARARGS | METH_KEYWORDS,
+     "Offset Object."},
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  {"roof", (PyCFunction) python_roof, METH_VARARGS | METH_KEYWORDS, "Roof Object."},
+    {"roof", (PyCFunction)python_roof, METH_VARARGS | METH_KEYWORDS,
+     "Roof Object."},
 #endif
-  {"color", (PyCFunction) python_color, METH_VARARGS | METH_KEYWORDS, "Color Object."},
-  {"show", (PyCFunction) python_show, METH_VARARGS | METH_KEYWORDS, "Show the result."},
-  {"linear_extrude", (PyCFunction) python_linear_extrude, METH_VARARGS | METH_KEYWORDS, "Linear_extrude Object."},
-  {"rotate_extrude", (PyCFunction) python_rotate_extrude, METH_VARARGS | METH_KEYWORDS, "Rotate_extrude Object."},
-  {"union", (PyCFunction) python_union, METH_VARARGS | METH_KEYWORDS, "Union Object."},
-  {"difference", (PyCFunction) python_difference, METH_VARARGS | METH_KEYWORDS, "Difference Object."},
-  {"intersection", (PyCFunction) python_intersection, METH_VARARGS | METH_KEYWORDS, "Intersection Object."},
-  {"hull", (PyCFunction) python_hull, METH_VARARGS | METH_KEYWORDS, "Hull Object."},
-  {"minkowski", (PyCFunction) python_minkowski, METH_VARARGS | METH_KEYWORDS, "Minkowski Object."},
-  {"fill", (PyCFunction) python_fill, METH_VARARGS | METH_KEYWORDS, "Fill Object."},
-  {"resize", (PyCFunction) python_resize, METH_VARARGS | METH_KEYWORDS, "Resize Object."},
-  {"projection", (PyCFunction) python_projection, METH_VARARGS | METH_KEYWORDS, "Projection Object."},
-  {"surface", (PyCFunction) python_surface, METH_VARARGS | METH_KEYWORDS, "Surface Object."},
-  {"mesh", (PyCFunction) python_mesh, METH_VARARGS | METH_KEYWORDS, "exports mesh."},
-  {"render", (PyCFunction) python_render, METH_VARARGS | METH_KEYWORDS, "Render Object."},
-  {"align", (PyCFunction) python_align, METH_VARARGS | METH_KEYWORDS, "Align Object to another."},
-  {NULL, NULL, 0, NULL}
-};
+    {"color", (PyCFunction)python_color, METH_VARARGS | METH_KEYWORDS,
+     "Color Object."},
+    {"show", (PyCFunction)python_show, METH_VARARGS | METH_KEYWORDS,
+     "Show the result."},
+    {"linear_extrude", (PyCFunction)python_linear_extrude,
+     METH_VARARGS | METH_KEYWORDS, "Linear_extrude Object."},
+    {"rotate_extrude", (PyCFunction)python_rotate_extrude,
+     METH_VARARGS | METH_KEYWORDS, "Rotate_extrude Object."},
+    {"union", (PyCFunction)python_union, METH_VARARGS | METH_KEYWORDS,
+     "Union Object."},
+    {"difference", (PyCFunction)python_difference, METH_VARARGS | METH_KEYWORDS,
+     "Difference Object."},
+    {"intersection", (PyCFunction)python_intersection,
+     METH_VARARGS | METH_KEYWORDS, "Intersection Object."},
+    {"hull", (PyCFunction)python_hull, METH_VARARGS | METH_KEYWORDS,
+     "Hull Object."},
+    {"minkowski", (PyCFunction)python_minkowski, METH_VARARGS | METH_KEYWORDS,
+     "Minkowski Object."},
+    {"fill", (PyCFunction)python_fill, METH_VARARGS | METH_KEYWORDS,
+     "Fill Object."},
+    {"resize", (PyCFunction)python_resize, METH_VARARGS | METH_KEYWORDS,
+     "Resize Object."},
+    {"projection", (PyCFunction)python_projection, METH_VARARGS | METH_KEYWORDS,
+     "Projection Object."},
+    {"surface", (PyCFunction)python_surface, METH_VARARGS | METH_KEYWORDS,
+     "Surface Object."},
+    {"mesh", (PyCFunction)python_mesh, METH_VARARGS | METH_KEYWORDS,
+     "exports mesh."},
+    {"render", (PyCFunction)python_render, METH_VARARGS | METH_KEYWORDS,
+     "Render Object."},
+    {"align", (PyCFunction)python_align, METH_VARARGS | METH_KEYWORDS,
+     "Align Object to another."},
+    {NULL, NULL, 0, NULL}};
 
 #define OO_METHOD_ENTRY(name, desc) \
-        {#name, (PyCFunction) python_oo_ ## name, METH_VARARGS | METH_KEYWORDS, desc},
+  {#name, (PyCFunction)python_oo_##name, METH_VARARGS | METH_KEYWORDS, desc},
 
 PyMethodDef PyOpenSCADMethods[] = {
-  OO_METHOD_ENTRY(translate, "Move Object")
-  OO_METHOD_ENTRY(rotate, "Rotate Object")
-
-  OO_METHOD_ENTRY(union, "Union Object")
-  OO_METHOD_ENTRY(difference, "Difference Object")
-  OO_METHOD_ENTRY(intersection, "Intersection Object")
-  OO_METHOD_ENTRY(scale, "Scale Object")
-  OO_METHOD_ENTRY(mirror, "Mirror Object")
-  OO_METHOD_ENTRY(multmatrix, "Multmatrix Object")
-  OO_METHOD_ENTRY(divmatrix, "Divmatrix Object")
-  OO_METHOD_ENTRY(offset, "Offset Object")
+    OO_METHOD_ENTRY(translate, "Move Object") OO_METHOD_ENTRY(rotate,
+                                                              "Rotate Object")
+
+        OO_METHOD_ENTRY(union, "Union Object") OO_METHOD_ENTRY(
+            difference,
+            "Difference Object") OO_METHOD_ENTRY(intersection,
+                                                 "Intersection Object")
+            OO_METHOD_ENTRY(scale, "Scale Object") OO_METHOD_ENTRY(
+                mirror,
+                "Mirror Object") OO_METHOD_ENTRY(multmatrix,
+                                                 "Multmatrix Object")
+                OO_METHOD_ENTRY(divmatrix, "Divmatrix Object") OO_METHOD_ENTRY(
+                    offset,
+                    "Offset Object")
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  OO_METHOD_ENTRY(roof, "Roof Object")
+                    OO_METHOD_ENTRY(roof, "Roof Object")
 #endif
-  OO_METHOD_ENTRY(color, "Color Object")
-  OO_METHOD_ENTRY(linear_extrude, "Linear_extrude Object")
-  OO_METHOD_ENTRY(rotate_extrude, "Rotate_extrude Object")
-  OO_METHOD_ENTRY(resize, "Resize Object")
-
-  OO_METHOD_ENTRY(mesh, "Mesh Object")
-  OO_METHOD_ENTRY(align, "Align Object to another")
-
-  OO_METHOD_ENTRY(show, "Show Object")
-  OO_METHOD_ENTRY(projection, "Projection Object")
-  OO_METHOD_ENTRY(render, "Render Object")
-  {
-    NULL, NULL, 0, NULL
-  }
-};
-
-PyNumberMethods PyOpenSCADNumbers =
-{
-  python_nb_add,    //binaryfunc nb_add
-  python_nb_subtract,   //binaryfunc nb_subtract
-  python_nb_mul,    //binaryfunc nb_multiply
-  0,        //binaryfunc nb_remainder
-  0,        //binaryfunc nb_divmod
-  0,        //ternaryfunc nb_power
-  0,        //unaryfunc nb_negative
-  0,        //unaryfunc nb_positive
-  0,        //unaryfunc nb_absolute
-  0,        //inquiry nb_bool
-  0,          //unaryfunc nb_invert
-  0,        //binaryfunc nb_lshift
-  0,        //binaryfunc nb_rshift
-  python_nb_and,    //binaryfunc nb_and
-  0,        //binaryfunc nb_xor
-  python_nb_or,     //binaryfunc nb_or
-  0,        //unaryfunc nb_int
-  0,        //void *nb_reserved
-  0,        //unaryfunc nb_float
-
-  0,        //binaryfunc nb_inplace_add
-  0,        //binaryfunc nb_inplace_subtract
-  0,        //binaryfunc nb_inplace_multiply
-  0,        //binaryfunc nb_inplace_remainder
-  0,        //ternaryfunc nb_inplace_power
-  0,        //binaryfunc nb_inplace_lshift
-  0,        //binaryfunc nb_inplace_rshift
-  0,        //binaryfunc nb_inplace_and
-  0,        //binaryfunc nb_inplace_xor
-  0,        //binaryfunc nb_inplace_or
-
-  0,        //binaryfunc nb_floor_divide
-  0,        //binaryfunc nb_true_divide
-  0,        //binaryfunc nb_inplace_floor_divide
-  0,        //binaryfunc nb_inplace_true_divide
-
-  0,        //unaryfunc nb_index
-
-  0,        //binaryfunc nb_matrix_multiply
-  0         //binaryfunc nb_inplace_matrix_multiply
-};
-
-PyMappingMethods PyOpenSCADMapping =
-{
-  0,
-  python__getitem__,
-  python__setitem__
+                        OO_METHOD_ENTRY(color, "Color Object") OO_METHOD_ENTRY(
+                            linear_extrude,
+                            "Linear_extrude Object")
+                            OO_METHOD_ENTRY(rotate_extrude,
+                                            "Rotate_extrude Object")
+                                OO_METHOD_ENTRY(resize, "Resize Object")
+
+                                    OO_METHOD_ENTRY(mesh, "Mesh Object")
+                                        OO_METHOD_ENTRY(
+                                            align,
+                                            "Align Object to another")
+
+                                            OO_METHOD_ENTRY(show, "Show Object")
+                                                OO_METHOD_ENTRY(
+                                                    projection,
+                                                    "Projection Object")
+                                                    OO_METHOD_ENTRY(
+                                                        render,
+                                                        "Render Object"){
+                                                        NULL, NULL, 0, NULL}};
+
+PyNumberMethods PyOpenSCADNumbers = {
+    python_nb_add,       // binaryfunc nb_add
+    python_nb_subtract,  // binaryfunc nb_subtract
+    python_nb_mul,       // binaryfunc nb_multiply
+    0,                   // binaryfunc nb_remainder
+    0,                   // binaryfunc nb_divmod
+    0,                   // ternaryfunc nb_power
+    0,                   // unaryfunc nb_negative
+    0,                   // unaryfunc nb_positive
+    0,                   // unaryfunc nb_absolute
+    0,                   // inquiry nb_bool
+    0,                   // unaryfunc nb_invert
+    0,                   // binaryfunc nb_lshift
+    0,                   // binaryfunc nb_rshift
+    python_nb_and,       // binaryfunc nb_and
+    0,                   // binaryfunc nb_xor
+    python_nb_or,        // binaryfunc nb_or
+    0,                   // unaryfunc nb_int
+    0,                   // void *nb_reserved
+    0,                   // unaryfunc nb_float
+
+    0,  // binaryfunc nb_inplace_add
+    0,  // binaryfunc nb_inplace_subtract
+    0,  // binaryfunc nb_inplace_multiply
+    0,  // binaryfunc nb_inplace_remainder
+    0,  // ternaryfunc nb_inplace_power
+    0,  // binaryfunc nb_inplace_lshift
+    0,  // binaryfunc nb_inplace_rshift
+    0,  // binaryfunc nb_inplace_and
+    0,  // binaryfunc nb_inplace_xor
+    0,  // binaryfunc nb_inplace_or
+
+    0,  // binaryfunc nb_floor_divide
+    0,  // binaryfunc nb_true_divide
+    0,  // binaryfunc nb_inplace_floor_divide
+    0,  // binaryfunc nb_inplace_true_divide
+
+    0,  // unaryfunc nb_index
+
+    0,  // binaryfunc nb_matrix_multiply
+    0   // binaryfunc nb_inplace_matrix_multiply
 };
 
+PyMappingMethods PyOpenSCADMapping = {0, python__getitem__, python__setitem__};
diff --git a/src/python/pymod.cc b/src/python/pymod.cc
index 57fa81458..63dc25fb9 100644
--- a/src/python/pymod.cc
+++ b/src/python/pymod.cc
@@ -25,10 +25,10 @@
  */
 #include <Python.h>
 
-#include <string>
-#include <vector>
 #include <cstdlib>
 #include <filesystem>
+#include <string>
+#include <vector>
 
 #include "core/Settings.h"
 #include "platform/PlatformUtils.h"
@@ -39,8 +39,7 @@ namespace fs = std::filesystem;
 
 using SP = Settings::SettingsPython;
 
-std::string venvBinDirFromSettings()
-{
+std::string venvBinDirFromSettings() {
   const auto& venv = fs::path(SP::pythonVirtualEnv.value()) / "bin";
   if (fs::is_directory(venv)) {
     return venv.generic_string();
@@ -48,8 +47,7 @@ std::string venvBinDirFromSettings()
   return "";
 }
 
-int pythonRunArgs(int argc, char **argv)
-{
+int pythonRunArgs(int argc, char** argv) {
   PyStatus status;
 
   PyConfig config;
@@ -76,9 +74,8 @@ fail:
   Py_ExitStatusException(status);
 }
 
-int pythonCreateVenv(const std::string& path)
-{
-  int result = pythonRunModule("", "venv", { path });
+int pythonCreateVenv(const std::string& path) {
+  int result = pythonRunModule("", "venv", {path});
   if (result != 0) {
     return result;
   }
@@ -88,7 +85,7 @@ int pythonCreateVenv(const std::string& path)
   // no good for any later runs.
   // To fix that, we point the link to the magic /proc/self/exe
   // so it can always just call itself as the python interpreter.
-  const char *appdirenv = getenv("APPDIR");
+  const char* appdirenv = getenv("APPDIR");
   if (getenv("APPIMAGE") != nullptr && appdirenv != nullptr) {
     // Assume we are running as AppImage
     const std::string appdir = appdirenv;
@@ -112,9 +109,9 @@ int pythonCreateVenv(const std::string& path)
   return 0;
 }
 
-int pythonRunModule(const std::string& appPath, const std::string& module,
-                    const std::vector<std::string>& args)
-{
+int pythonRunModule(const std::string& appPath,
+                    const std::string& module,
+                    const std::vector<std::string>& args) {
   PyStatus status;
   const auto name = "openscad-python";
   const auto exe = PlatformUtils::applicationPath() + "/" + name;
diff --git a/src/python/pyopenscad.cc b/src/python/pyopenscad.cc
index 71f522efb..30dfdaf2b 100644
--- a/src/python/pyopenscad.cc
+++ b/src/python/pyopenscad.cc
@@ -26,45 +26,46 @@
 #include <Python.h>
 #include <filesystem>
 
-#include "pyopenscad.h"
 #include "core/CsgOpNode.h"
 #include "platform/PlatformUtils.h"
+#include "pyopenscad.h"
 
 namespace fs = std::filesystem;
 
-extern "C" PyObject *PyInit_openscad(void);
+extern "C" PyObject* PyInit_openscad(void);
 
 bool python_active;
 bool python_trusted;
 
-void PyObjectDeleter(PyObject *pObject) { Py_XDECREF(pObject); }
+void PyObjectDeleter(PyObject* pObject) {
+  Py_XDECREF(pObject);
+}
 
 PyObjectUniquePtr pythonInitDict(nullptr, PyObjectDeleter);
 PyObjectUniquePtr pythonMainModule(nullptr, PyObjectDeleter);
 std::list<std::string> pythonInventory;
 bool pythonDryRun = false;
-std::shared_ptr<AbstractNode> python_result_node = nullptr; /* global result veriable containing the python created result */
-PyObject *python_result_obj = nullptr;
+std::shared_ptr<AbstractNode> python_result_node =
+    nullptr; /* global result veriable containing the python created result */
+PyObject* python_result_obj = nullptr;
 bool pythonMainModuleInitialized = false;
 
-void PyOpenSCADObject_dealloc(PyOpenSCADObject *self)
-{
+void PyOpenSCADObject_dealloc(PyOpenSCADObject* self) {
   Py_XDECREF(self->dict);
-  Py_TYPE(self)->tp_free((PyObject *)self);
+  Py_TYPE(self)->tp_free((PyObject*)self);
 }
 
-PyObject *PyOpenSCADObject_alloc(PyTypeObject *cls, Py_ssize_t nitems)
-{
-  PyObject *self = PyType_GenericAlloc(cls, nitems);
-  ((PyOpenSCADObject *)self)->dict = PyDict_New();
-  PyObject *origin = PyList_New(4);
+PyObject* PyOpenSCADObject_alloc(PyTypeObject* cls, Py_ssize_t nitems) {
+  PyObject* self = PyType_GenericAlloc(cls, nitems);
+  ((PyOpenSCADObject*)self)->dict = PyDict_New();
+  PyObject* origin = PyList_New(4);
   for (int i = 0; i < 4; i++) {
-    PyObject *row = PyList_New(4);
+    PyObject* row = PyList_New(4);
     for (int j = 0; j < 4; j++)
-      PyList_SetItem(row, j, PyFloat_FromDouble(i == j?1.0:0.0));
+      PyList_SetItem(row, j, PyFloat_FromDouble(i == j ? 1.0 : 0.0));
     PyList_SetItem(origin, i, row);
   }
-  PyDict_SetItemString(((PyOpenSCADObject *)self)->dict, "origin", origin);
+  PyDict_SetItemString(((PyOpenSCADObject*)self)->dict, "origin", origin);
   Py_XDECREF(origin);
   return self;
 }
@@ -73,8 +74,9 @@ PyObject *PyOpenSCADObject_alloc(PyTypeObject *cls, Py_ssize_t nitems)
  *  allocates a new PyOpenSCAD Object including its internal dictionary
  */
 
-static PyObject *PyOpenSCADObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
-{
+static PyObject* PyOpenSCADObject_new(PyTypeObject* type,
+                                      PyObject* args,
+                                      PyObject* kwds) {
   return PyOpenSCADObject_alloc(&PyOpenSCADType, 0);
 }
 
@@ -82,85 +84,92 @@ static PyObject *PyOpenSCADObject_new(PyTypeObject *type, PyObject *args, PyObje
  *  allocates a new PyOpenSCAD to store an existing OpenSCAD Abstract Node
  */
 
-PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type, const std::shared_ptr<AbstractNode>& node)
-{
-  PyOpenSCADObject *self;
-  self = (PyOpenSCADObject *)  type->tp_alloc(type, 0);
+PyObject* PyOpenSCADObjectFromNode(PyTypeObject* type,
+                                   const std::shared_ptr<AbstractNode>& node) {
+  PyOpenSCADObject* self;
+  self = (PyOpenSCADObject*)type->tp_alloc(type, 0);
   if (self != nullptr) {
     Py_XINCREF(self);
     self->node = node;
-    return (PyObject *)self;
+    return (PyObject*)self;
   }
   return nullptr;
 }
 
-PyThreadState *tstate = nullptr;
+PyThreadState* tstate = nullptr;
 
-void python_lock(void){
-  if (tstate != nullptr && pythonInitDict != nullptr)PyEval_RestoreThread(tstate);
+void python_lock(void) {
+  if (tstate != nullptr && pythonInitDict != nullptr)
+    PyEval_RestoreThread(tstate);
 }
 
 void python_unlock(void) {
-  if (pythonInitDict != nullptr)tstate = PyEval_SaveThread();
+  if (pythonInitDict != nullptr)
+    tstate = PyEval_SaveThread();
 }
 /*
  *  extracts Absrtract Node from PyOpenSCAD Object
  */
 
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *obj, PyObject **dict)
-{
-  std::shared_ptr<AbstractNode> result = ((PyOpenSCADObject *) obj)->node;
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject* obj,
+                                                     PyObject** dict) {
+  std::shared_ptr<AbstractNode> result = ((PyOpenSCADObject*)obj)->node;
   if (result.use_count() > 2) {
     result = result->clone();
   }
-  *dict = ((PyOpenSCADObject *) obj)->dict;
+  *dict = ((PyOpenSCADObject*)obj)->dict;
   return result;
 }
 
-std::string python_version(void)
-{
+std::string python_version(void) {
   std::ostringstream stream;
-  stream << "Python " << PY_MAJOR_VERSION << "." << PY_MINOR_VERSION << "." << PY_MICRO_VERSION;
+  stream << "Python " << PY_MAJOR_VERSION << "." << PY_MINOR_VERSION << "."
+         << PY_MICRO_VERSION;
   return stream.str();
 }
 
 /*
- * same as  python_more_obj but always returns only one AbstractNode by creating an UNION operation
+ * same as  python_more_obj but always returns only one AbstractNode by creating
+ * an UNION operation
  */
 
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *objs, PyObject **dict)
-{
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject* objs,
+                                                          PyObject** dict) {
   std::shared_ptr<AbstractNode> result;
   if (Py_TYPE(objs) == &PyOpenSCADType) {
-    result = ((PyOpenSCADObject *) objs)->node;
+    result = ((PyOpenSCADObject*)objs)->node;
     if (result.use_count() > 2) {
       result = result->clone();
     }
-    *dict = ((PyOpenSCADObject *) objs)->dict;
+    *dict = ((PyOpenSCADObject*)objs)->dict;
   } else if (PyList_Check(objs)) {
     DECLARE_INSTANCE
     auto node = std::make_shared<CsgOpNode>(instance, OpenSCADOperator::UNION);
 
     int n = PyList_Size(objs);
     for (int i = 0; i < n; i++) {
-      PyObject *obj = PyList_GetItem(objs, i);
+      PyObject* obj = PyList_GetItem(objs, i);
       if (Py_TYPE(obj) == &PyOpenSCADType) {
         std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNode(obj, dict);
         node->children.push_back(child);
-      } else return nullptr;
+      } else
+        return nullptr;
     }
     result = node;
-  } else result = nullptr;
+  } else
+    result = nullptr;
   return result;
 }
 
-
-int python_numberval(PyObject *number, double *result)
-{
-  if (number == nullptr)return 1;
-  if (number == Py_False)return 1;
-  if (number == Py_True)return 1;
-  if (number == Py_None)return 1;
+int python_numberval(PyObject* number, double* result) {
+  if (number == nullptr)
+    return 1;
+  if (number == Py_False)
+    return 1;
+  if (number == Py_True)
+    return 1;
+  if (number == Py_None)
+    return 1;
   if (PyFloat_Check(number)) {
     *result = PyFloat_AsDouble(number);
     return 0;
@@ -176,53 +185,66 @@ int python_numberval(PyObject *number, double *result)
  * Tries to extract an 3D vector out of a python list
  */
 
-int python_vectorval(PyObject *vec, int minval, int maxval, double *x, double *y, double *z, double *w)
-{
-  if (w != NULL) *w = 0;
+int python_vectorval(PyObject* vec,
+                     int minval,
+                     int maxval,
+                     double* x,
+                     double* y,
+                     double* z,
+                     double* w) {
+  if (w != NULL)
+    *w = 0;
   if (PyList_Check(vec)) {
-    if (PyList_Size(vec) < minval || PyList_Size(vec) > maxval)return 1;
+    if (PyList_Size(vec) < minval || PyList_Size(vec) > maxval)
+      return 1;
 
     if (PyList_Size(vec) >= 1) {
-      if (python_numberval(PyList_GetItem(vec, 0), x)) return 1;
+      if (python_numberval(PyList_GetItem(vec, 0), x))
+        return 1;
     }
     if (PyList_Size(vec) >= 2) {
-      if (python_numberval(PyList_GetItem(vec, 1), y)) return 1;
+      if (python_numberval(PyList_GetItem(vec, 1), y))
+        return 1;
     }
     if (PyList_Size(vec) >= 3) {
-      if (python_numberval(PyList_GetItem(vec, 2), z)) return 1;
+      if (python_numberval(PyList_GetItem(vec, 2), z))
+        return 1;
     }
     if (PyList_Size(vec) >= 4 && w != NULL) {
-      if (python_numberval(PyList_GetItem(vec, 3), w)) return 1;
+      if (python_numberval(PyList_GetItem(vec, 3), w))
+        return 1;
     }
     return 0;
   }
   if (!python_numberval(vec, x)) {
     *y = *x;
     *z = *x;
-    if (w != NULL)*w = *x;
+    if (w != NULL)
+      *w = *x;
     return 0;
   }
   return 1;
 }
 
-std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
-{
+std::vector<Vector3d> python_vectors(PyObject* vec, int mindim, int maxdim) {
   std::vector<Vector3d> results;
   if (PyList_Check(vec)) {
     // check if its a valid vec<Vector3d>
     int valid = 1;
     for (int i = 0; valid && i < PyList_Size(vec); i++) {
-      PyObject *item = PyList_GetItem(vec, i);
-      if (!PyList_Check(item))valid = 0;
+      PyObject* item = PyList_GetItem(vec, i);
+      if (!PyList_Check(item))
+        valid = 0;
     }
     if (valid) {
       for (int j = 0; valid && j < PyList_Size(vec); j++) {
         Vector3d result(0, 0, 0);
-        PyObject *item = PyList_GetItem(vec, j);
+        PyObject* item = PyList_GetItem(vec, j);
         if (PyList_Size(item) >= mindim && PyList_Size(item) <= maxdim) {
           for (int i = 0; i < PyList_Size(item); i++) {
             if (PyList_Size(item) > i) {
-              if (python_numberval(PyList_GetItem(item, i), &result[i])) return results; // Error
+              if (python_numberval(PyList_GetItem(item, i), &result[i]))
+                return results;  // Error
             }
           }
         }
@@ -234,7 +256,8 @@ std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
     if (PyList_Size(vec) >= mindim && PyList_Size(vec) <= maxdim) {
       for (int i = 0; i < PyList_Size(vec); i++) {
         if (PyList_Size(vec) > i) {
-          if (python_numberval(PyList_GetItem(vec, i), &result[i])) return results; // Error
+          if (python_numberval(PyList_GetItem(vec, i), &result[i]))
+            return results;  // Error
         }
       }
     }
@@ -246,7 +269,7 @@ std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
     result[2] = result[1];
     results.push_back(result);
   }
-  return results; // Error
+  return results;  // Error
 }
 
 /*
@@ -254,29 +277,33 @@ std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
  */
 
 void get_fnas(double& fn, double& fa, double& fs) {
-  PyObject *mainModule = PyImport_AddModule("__main__");
-  if (mainModule == nullptr) return;
+  PyObject* mainModule = PyImport_AddModule("__main__");
+  if (mainModule == nullptr)
+    return;
   fn = 0;
   fa = 12;
   fs = 2;
 
   if (PyObject_HasAttrString(mainModule, "fn")) {
-    PyObjectUniquePtr varFn(PyObject_GetAttrString(mainModule, "fn"), PyObjectDeleter);
-    if (varFn.get() != nullptr){
+    PyObjectUniquePtr varFn(PyObject_GetAttrString(mainModule, "fn"),
+                            PyObjectDeleter);
+    if (varFn.get() != nullptr) {
       fn = PyFloat_AsDouble(varFn.get());
     }
   }
 
   if (PyObject_HasAttrString(mainModule, "fa")) {
-    PyObjectUniquePtr varFa(PyObject_GetAttrString(mainModule, "fa"), PyObjectDeleter);
-    if (varFa.get() != nullptr){
+    PyObjectUniquePtr varFa(PyObject_GetAttrString(mainModule, "fa"),
+                            PyObjectDeleter);
+    if (varFa.get() != nullptr) {
       fa = PyFloat_AsDouble(varFa.get());
     }
   }
 
-  PyObjectUniquePtr varFs(PyObject_GetAttrString(mainModule, "fs"), PyObjectDeleter);
+  PyObjectUniquePtr varFs(PyObject_GetAttrString(mainModule, "fs"),
+                          PyObjectDeleter);
   if (PyObject_HasAttrString(mainModule, "fs")) {
-    if (varFs.get() != nullptr){
+    if (varFs.get() != nullptr) {
       fs = PyFloat_AsDouble(varFs.get());
     }
   }
@@ -286,32 +313,36 @@ void get_fnas(double& fn, double& fa, double& fs) {
  * Type specific init function. nothing special here
  */
 
-static int PyOpenSCADInit(PyOpenSCADObject *self, PyObject *args, PyObject *kwds)
-{
+static int PyOpenSCADInit(PyOpenSCADObject* self,
+                          PyObject* args,
+                          PyObject* kwds) {
   (void)self;
   (void)args;
   (void)kwds;
   return 0;
 }
 
-void python_catch_error(std::string& errorstr)
-{
-  PyObject *pyExcType;
-  PyObject *pyExcValue;
-  PyObject *pyExcTraceback;
+void python_catch_error(std::string& errorstr) {
+  PyObject* pyExcType;
+  PyObject* pyExcValue;
+  PyObject* pyExcTraceback;
   PyErr_Fetch(&pyExcType, &pyExcValue, &pyExcTraceback);
   PyErr_NormalizeException(&pyExcType, &pyExcValue, &pyExcTraceback);
-  if (pyExcType != nullptr) Py_XDECREF(pyExcType);
+  if (pyExcType != nullptr)
+    Py_XDECREF(pyExcType);
 
-  if (pyExcValue != nullptr){
+  if (pyExcValue != nullptr) {
     PyObjectUniquePtr str_exc_value(PyObject_Repr(pyExcValue), PyObjectDeleter);
-    PyObjectUniquePtr pyExcValueStr(PyUnicode_AsEncodedString(str_exc_value.get(), "utf-8", "~"), PyObjectDeleter);
-    char *suberror = PyBytes_AS_STRING(pyExcValueStr.get());
-    if (suberror != nullptr) errorstr += suberror;
+    PyObjectUniquePtr pyExcValueStr(
+        PyUnicode_AsEncodedString(str_exc_value.get(), "utf-8", "~"),
+        PyObjectDeleter);
+    char* suberror = PyBytes_AS_STRING(pyExcValueStr.get());
+    if (suberror != nullptr)
+      errorstr += suberror;
     Py_XDECREF(pyExcValue);
   }
   if (pyExcTraceback != nullptr) {
-    auto *tb_o = (PyTracebackObject *)pyExcTraceback;
+    auto* tb_o = (PyTracebackObject*)pyExcTraceback;
     int line_num = tb_o->tb_lineno;
     errorstr += " in line ";
     errorstr += std::to_string(line_num);
@@ -319,58 +350,76 @@ void python_catch_error(std::string& errorstr)
   }
 }
 
-void initPython(const std::string& binDir, double time)
-{
+void initPython(const std::string& binDir, double time) {
   const auto name = "openscad-python";
   const auto exe = binDir + "/" + name;
   if (pythonInitDict) { /* If already initialized, undo to reinitialize after */
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    PyObject *maindict = PyModule_GetDict(pythonMainModule.get());
+    PyObject* maindict = PyModule_GetDict(pythonMainModule.get());
     while (PyDict_Next(maindict, &pos, &key, &value)) {
-      PyObjectUniquePtr key_(PyUnicode_AsEncodedString(key, "utf-8", "~"), PyObjectDeleter);
-      if (key_ == nullptr)continue;
-      const char *key_str = PyBytes_AS_STRING(key_.get());
-      if (key_str == nullptr)continue;
-      if (std::find(std::begin(pythonInventory), std::end(pythonInventory), key_str) == std::end(pythonInventory)){
-        if (strlen(key_str) < 4 || strncmp(key_str, "stat", 4) != 0){
+      PyObjectUniquePtr key_(PyUnicode_AsEncodedString(key, "utf-8", "~"),
+                             PyObjectDeleter);
+      if (key_ == nullptr)
+        continue;
+      const char* key_str = PyBytes_AS_STRING(key_.get());
+      if (key_str == nullptr)
+        continue;
+      if (std::find(std::begin(pythonInventory), std::end(pythonInventory),
+                    key_str) == std::end(pythonInventory)) {
+        if (strlen(key_str) < 4 || strncmp(key_str, "stat", 4) != 0) {
           PyDict_DelItemString(maindict, key_str);
         }
       }
       // bug in  PyDict_GetItemString, thus iterating
       if (strcmp(key_str, "sys") == 0) {
-        PyObject *sysdict = PyModule_GetDict(value);
-        if (sysdict == nullptr) continue;
+        PyObject* sysdict = PyModule_GetDict(value);
+        if (sysdict == nullptr)
+          continue;
         // get builtin_module_names
         PyObject *key1, *value1;
         Py_ssize_t pos1 = 0;
         while (PyDict_Next(sysdict, &pos1, &key1, &value1)) {
-          PyObjectUniquePtr key1_(PyUnicode_AsEncodedString(key1, "utf-8", "~"), PyObjectDeleter);
-          if (key1_ == nullptr)continue;
-          const char *key1_str = PyBytes_AS_STRING(key1_.get());
+          PyObjectUniquePtr key1_(PyUnicode_AsEncodedString(key1, "utf-8", "~"),
+                                  PyObjectDeleter);
+          if (key1_ == nullptr)
+            continue;
+          const char* key1_str = PyBytes_AS_STRING(key1_.get());
           if (strcmp(key1_str, "modules") == 0) {
             PyObject *key2, *value2;
             Py_ssize_t pos2 = 0;
             while (PyDict_Next(value1, &pos2, &key2, &value2)) {
-              PyObjectUniquePtr key2_(PyUnicode_AsEncodedString(key2, "utf-8", "~"), PyObjectDeleter);
-              if (key2_ == nullptr)continue;
-              const char *key2_str = PyBytes_AS_STRING(key2_.get());
-              if (key2_str == nullptr) continue;
-              if (!PyModule_Check(value2)) continue;
-
-              PyObject *modrepr = PyObject_Repr(value2);
-              PyObject *modreprobj = PyUnicode_AsEncodedString(modrepr, "utf-8", "~");
-              const char *modreprstr = PyBytes_AS_STRING(modreprobj);
-              if (modreprstr == nullptr) continue;
-              if (strstr(modreprstr, "(frozen)") != nullptr) continue;
-              if (strstr(modreprstr, "(built-in)") != nullptr) continue;
-              if (strstr(modreprstr, "/encodings/") != nullptr) continue;
-              if (strstr(modreprstr, "_frozen_") != nullptr) continue;
-              if (strstr(modreprstr, "site-packages") != nullptr) continue;
-              if (strstr(modreprstr, "usr/lib") != nullptr) continue;
+              PyObjectUniquePtr key2_(
+                  PyUnicode_AsEncodedString(key2, "utf-8", "~"),
+                  PyObjectDeleter);
+              if (key2_ == nullptr)
+                continue;
+              const char* key2_str = PyBytes_AS_STRING(key2_.get());
+              if (key2_str == nullptr)
+                continue;
+              if (!PyModule_Check(value2))
+                continue;
+
+              PyObject* modrepr = PyObject_Repr(value2);
+              PyObject* modreprobj =
+                  PyUnicode_AsEncodedString(modrepr, "utf-8", "~");
+              const char* modreprstr = PyBytes_AS_STRING(modreprobj);
+              if (modreprstr == nullptr)
+                continue;
+              if (strstr(modreprstr, "(frozen)") != nullptr)
+                continue;
+              if (strstr(modreprstr, "(built-in)") != nullptr)
+                continue;
+              if (strstr(modreprstr, "/encodings/") != nullptr)
+                continue;
+              if (strstr(modreprstr, "_frozen_") != nullptr)
+                continue;
+              if (strstr(modreprstr, "site-packages") != nullptr)
+                continue;
+              if (strstr(modreprstr, "usr/lib") != nullptr)
+                continue;
 
               PyDict_DelItem(value1, key2);
-
             }
           }
         }
@@ -380,7 +429,8 @@ void initPython(const std::string& binDir, double time)
     PyPreConfig preconfig;
     PyPreConfig_InitPythonConfig(&preconfig);
     Py_PreInitialize(&preconfig);
-//    PyEval_InitThreads(); // https://stackoverflow.com/questions/47167251/pygilstate-ensure-causing-deadlock
+    //    PyEval_InitThreads(); //
+    //    https://stackoverflow.com/questions/47167251/pygilstate-ensure-causing-deadlock
 
     PyImport_AppendInittab("openscad", &PyInit_openscad);
     PyConfig config;
@@ -394,22 +444,24 @@ void initPython(const std::string& binDir, double time)
     stream << PlatformUtils::applicationPath() << "\\..\\libraries\\python";
 #else
     char sepchar = ':';
-    const auto pythonXY = "python" + std::to_string(PY_MAJOR_VERSION) + "." + std::to_string(PY_MINOR_VERSION);
+    const auto pythonXY = "python" + std::to_string(PY_MAJOR_VERSION) + "." +
+                          std::to_string(PY_MINOR_VERSION);
     const std::array<std::string, 5> paths = {
-      "../libraries/python",
-      "../lib/" + pythonXY,
-      "../python/lib/" + pythonXY,
-      "../Frameworks/" + pythonXY,
-      "../Frameworks/" + pythonXY + "/site-packages",
+        "../libraries/python",
+        "../lib/" + pythonXY,
+        "../python/lib/" + pythonXY,
+        "../Frameworks/" + pythonXY,
+        "../Frameworks/" + pythonXY + "/site-packages",
     };
     for (const auto& path : paths) {
-      const auto p = fs::path(PlatformUtils::applicationPath() + fs::path::preferred_separator + path);
+      const auto p = fs::path(PlatformUtils::applicationPath() +
+                              fs::path::preferred_separator + path);
       if (fs::is_directory(p)) {
         stream << sep << fs::absolute(p).generic_string();
         sep = sepchar;
       }
     }
-#endif // ifdef _WIN32
+#endif  // ifdef _WIN32
     stream << sep << PlatformUtils::userLibraryPath();
     stream << sepchar << ".";
 
@@ -427,36 +479,39 @@ void initPython(const std::string& binDir, double time)
     pythonMainModuleInitialized = pythonMainModule != nullptr;
     pythonInitDict.reset(PyModule_GetDict(pythonMainModule.get()));
     PyInit_PyOpenSCAD();
-    PyRun_String("from builtins import *\n", Py_file_input, pythonInitDict.get(), pythonInitDict.get());
+    PyRun_String("from builtins import *\n", Py_file_input,
+                 pythonInitDict.get(), pythonInitDict.get());
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    PyObject *maindict = PyModule_GetDict(pythonMainModule.get());
+    PyObject* maindict = PyModule_GetDict(pythonMainModule.get());
     while (PyDict_Next(maindict, &pos, &key, &value)) {
-      PyObjectUniquePtr key1(PyUnicode_AsEncodedString(key, "utf-8", "~"), PyObjectDeleter);
-      const char *key_str = PyBytes_AsString(key1.get());
-      if (key_str != NULL)pythonInventory.push_back(key_str);
+      PyObjectUniquePtr key1(PyUnicode_AsEncodedString(key, "utf-8", "~"),
+                             PyObjectDeleter);
+      const char* key_str = PyBytes_AsString(key1.get());
+      if (key_str != NULL)
+        pythonInventory.push_back(key_str);
     }
-
   }
   std::ostringstream stream;
   stream << "t=" << time;
-  PyRun_String(stream.str().c_str(), Py_file_input, pythonInitDict.get(), pythonInitDict.get());
+  PyRun_String(stream.str().c_str(), Py_file_input, pythonInitDict.get(),
+               pythonInitDict.get());
 }
 
-void finishPython(void)
-{
-}
+void finishPython(void) {}
 
-std::string evaluatePython(const std::string& code, bool dry_run)
-{
+std::string evaluatePython(const std::string& code, bool dry_run) {
   std::string error;
   python_result_node = nullptr;
   PyObjectUniquePtr pyExcValue(nullptr, PyObjectDeleter);
   PyObjectUniquePtr pyExcTraceback(nullptr, PyObjectDeleter);
-  /* special python code to catch errors from stdout and stderr and make them available in OpenSCAD console */
+  /* special python code to catch errors from stdout and stderr and make them
+   * available in OpenSCAD console */
   pythonDryRun = dry_run;
-  if (!pythonMainModuleInitialized)return "Python not initialized";
-  const char *python_init_code = "\
+  if (!pythonMainModuleInitialized)
+    return "Python not initialized";
+  const char* python_init_code =
+      "\
 import sys\n\
 class InputCatcher:\n\
    def __init__(self):\n\
@@ -484,7 +539,8 @@ sys.stdin = catcher_in\n\
 sys.stdout = catcher_out\n\
 sys.stderr = catcher_err\n\
 ";
-  const char *python_exit_code = "\
+  const char* python_exit_code =
+      "\
 sys.stdin = stdin_bak\n\
 sys.stdout = stdout_bak\n\
 sys.stderr = stderr_bak\n\
@@ -492,120 +548,123 @@ sys.stderr = stderr_bak\n\
 
   PyRun_SimpleString(python_init_code);
   PyObjectUniquePtr result(nullptr, PyObjectDeleter);
-  result.reset(PyRun_String(code.c_str(), Py_file_input, pythonInitDict.get(), pythonInitDict.get()));   /* actual code is run here */
-
+  result.reset(
+      PyRun_String(code.c_str(), Py_file_input, pythonInitDict.get(),
+                   pythonInitDict.get())); /* actual code is run here */
 
   if (result == nullptr) {
     PyErr_Print();
     error = "";
     python_catch_error(error);
   }
-  for (int i = 0; i < 2; i++){
+  for (int i = 0; i < 2; i++) {
     PyObjectUniquePtr catcher(nullptr, PyObjectDeleter);
-    catcher.reset(PyObject_GetAttrString(pythonMainModule.get(), i == 1?"catcher_err":"catcher_out"));
-    if (catcher == nullptr) continue;
+    catcher.reset(PyObject_GetAttrString(
+        pythonMainModule.get(), i == 1 ? "catcher_err" : "catcher_out"));
+    if (catcher == nullptr)
+      continue;
     PyObjectUniquePtr command_output(nullptr, PyObjectDeleter);
     command_output.reset(PyObject_GetAttrString(catcher.get(), "data"));
 
-    PyObjectUniquePtr command_output_value(nullptr,  PyObjectDeleter);
-    command_output_value.reset(PyUnicode_AsEncodedString(command_output.get(), "utf-8", "~"));
-    const char *command_output_bytes = PyBytes_AS_STRING(command_output_value.get());
-    if (command_output_bytes != nullptr && *command_output_bytes != '\0'){
-      if (i == 1) error += command_output_bytes; /* output to console */
-      else LOG(command_output_bytes);   /* error to LOG */
+    PyObjectUniquePtr command_output_value(nullptr, PyObjectDeleter);
+    command_output_value.reset(
+        PyUnicode_AsEncodedString(command_output.get(), "utf-8", "~"));
+    const char* command_output_bytes =
+        PyBytes_AS_STRING(command_output_value.get());
+    if (command_output_bytes != nullptr && *command_output_bytes != '\0') {
+      if (i == 1)
+        error += command_output_bytes; /* output to console */
+      else
+        LOG(command_output_bytes); /* error to LOG */
     }
   }
   PyRun_SimpleString(python_exit_code);
   return error;
 }
 /*
- * the magical Python Type descriptor for an OpenSCAD Object. Adding more fields makes the type more powerful
+ * the magical Python Type descriptor for an OpenSCAD Object. Adding more fields
+ * makes the type more powerful
  */
 
+int python__setitem__(PyObject* dict, PyObject* key, PyObject* v);
+PyObject* python__getitem__(PyObject* dict, PyObject* key);
 
-int python__setitem__(PyObject *dict, PyObject *key, PyObject *v);
-PyObject *python__getitem__(PyObject *dict, PyObject *key);
-
-PyObject *python__getattro__(PyObject *dict, PyObject *key)
-{
-  PyObject *result = python__getitem__(dict, key);
-  if (result == Py_None || result == nullptr) result = PyObject_GenericGetAttr(dict, key);
+PyObject* python__getattro__(PyObject* dict, PyObject* key) {
+  PyObject* result = python__getitem__(dict, key);
+  if (result == Py_None || result == nullptr)
+    result = PyObject_GenericGetAttr(dict, key);
   return result;
 }
 
-int python__setattro__(PyObject *dict, PyObject *key, PyObject *v)
-{
+int python__setattro__(PyObject* dict, PyObject* key, PyObject* v) {
   return python__setitem__(dict, key, v);
 }
 
-
 PyTypeObject PyOpenSCADType = {
-  PyVarObject_HEAD_INIT(nullptr, 0)
-  "PyOpenSCAD",                     /* tp_name */
-  sizeof(PyOpenSCADObject),         /* tp_basicsize */
-  0,                                /* tp_itemsize */
-  (destructor) PyOpenSCADObject_dealloc,    /* tp_dealloc */
-  0,                                /* vectorcall_offset */
-  0,                                /* tp_getattr */
-  0,                                /* tp_setattr */
-  0,                                /* tp_as_async */
-  python_str,                       /* tp_repr */
-  &PyOpenSCADNumbers,               /* tp_as_number */
-  0,                                /* tp_as_sequence */
-  &PyOpenSCADMapping,               /* tp_as_mapping */
-  0,                                /* tp_hash  */
-  0,                                /* tp_call */
-  python_str,                       /* tp_str */
-  python__getattro__,             /* tp_getattro */
-  python__setattro__,         /* tp_setattro */
-  0,                                /* tp_as_buffer */
-  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
-  "PyOpenSCAD Object",                /* tp_doc */
-  0,                                /* tp_traverse */
-  0,                                /* tp_clear */
-  0,                                /* tp_richcompare */
-  0,                                /* tp_weaklistoffset */
-  0,                                /* tp_iter */
-  0,                                /* tp_iternext */
-  PyOpenSCADMethods,                  /* tp_methods */
-  0,                      /* tp_members */
-  0,                                /* tp_getset */
-  0,                                /* tp_base */
-  0,                                /* tp_dict */
-  0,                                /* tp_descr_get */
-  0,                                /* tp_descr_set */
-  0,                                /* tp_dictoffset */
-  (initproc) PyOpenSCADInit,            /* tp_init */
-  PyOpenSCADObject_alloc,           /* tp_alloc */
-  PyOpenSCADObject_new,                   /* tp_new */
-};
-
-
-
-static PyModuleDef OpenSCADModule = {
-  PyModuleDef_HEAD_INIT,
-  "openscad",
-  "OpenSCAD Python Module",
-  -1,
-  PyOpenSCADFunctions,
-  NULL, NULL, NULL, NULL
+    PyVarObject_HEAD_INIT(nullptr, 0) "PyOpenSCAD", /* tp_name */
+    sizeof(PyOpenSCADObject),                       /* tp_basicsize */
+    0,                                              /* tp_itemsize */
+    (destructor)PyOpenSCADObject_dealloc,           /* tp_dealloc */
+    0,                                              /* vectorcall_offset */
+    0,                                              /* tp_getattr */
+    0,                                              /* tp_setattr */
+    0,                                              /* tp_as_async */
+    python_str,                                     /* tp_repr */
+    &PyOpenSCADNumbers,                             /* tp_as_number */
+    0,                                              /* tp_as_sequence */
+    &PyOpenSCADMapping,                             /* tp_as_mapping */
+    0,                                              /* tp_hash  */
+    0,                                              /* tp_call */
+    python_str,                                     /* tp_str */
+    python__getattro__,                             /* tp_getattro */
+    python__setattro__,                             /* tp_setattro */
+    0,                                              /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,       /* tp_flags */
+    "PyOpenSCAD Object",                            /* tp_doc */
+    0,                                              /* tp_traverse */
+    0,                                              /* tp_clear */
+    0,                                              /* tp_richcompare */
+    0,                                              /* tp_weaklistoffset */
+    0,                                              /* tp_iter */
+    0,                                              /* tp_iternext */
+    PyOpenSCADMethods,                              /* tp_methods */
+    0,                                              /* tp_members */
+    0,                                              /* tp_getset */
+    0,                                              /* tp_base */
+    0,                                              /* tp_dict */
+    0,                                              /* tp_descr_get */
+    0,                                              /* tp_descr_set */
+    0,                                              /* tp_dictoffset */
+    (initproc)PyOpenSCADInit,                       /* tp_init */
+    PyOpenSCADObject_alloc,                         /* tp_alloc */
+    PyOpenSCADObject_new,                           /* tp_new */
 };
 
-extern "C" PyObject *PyInit_openscad(void)
-{
+static PyModuleDef OpenSCADModule = {PyModuleDef_HEAD_INIT,
+                                     "openscad",
+                                     "OpenSCAD Python Module",
+                                     -1,
+                                     PyOpenSCADFunctions,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL};
+
+extern "C" PyObject* PyInit_openscad(void) {
   return PyModule_Create(&OpenSCADModule);
 }
 
-PyMODINIT_FUNC PyInit_PyOpenSCAD(void)
-{
-  PyObject *m;
+PyMODINIT_FUNC PyInit_PyOpenSCAD(void) {
+  PyObject* m;
 
-  if (PyType_Ready(&PyOpenSCADType) < 0) return NULL;
+  if (PyType_Ready(&PyOpenSCADType) < 0)
+    return NULL;
 
   m = PyInit_openscad();
-  if (m == NULL) return NULL;
+  if (m == NULL)
+    return NULL;
 
   Py_INCREF(&PyOpenSCADType);
-  PyModule_AddObject(m, "openscad", (PyObject *)&PyOpenSCADType);
+  PyModule_AddObject(m, "openscad", (PyObject*)&PyOpenSCADType);
   return m;
 }
diff --git a/src/python/pyopenscad.h b/src/python/pyopenscad.h
index 53e05507b..3f71d5358 100644
--- a/src/python/pyopenscad.h
+++ b/src/python/pyopenscad.h
@@ -1,45 +1,53 @@
 #include <Python.h>
 #include <memory>
-#include "python_public.h"
-#include "geometry/Polygon2d.h"
-#include "core/node.h"
-#include "core/function.h"
 #include "core/ScopeContext.h"
 #include "core/UserModule.h"
+#include "core/function.h"
+#include "core/node.h"
+#include "geometry/Polygon2d.h"
+#include "python_public.h"
 
 #pragma GCC diagnostic ignored "-Wwrite-strings"
 
-#define DECLARE_INSTANCE  std::string instance_name; \
-        AssignmentList inst_asslist; \
-        ModuleInstantiation *instance = new ModuleInstantiation(instance_name, inst_asslist, Location::NONE);
-
+#define DECLARE_INSTANCE          \
+  std::string instance_name;      \
+  AssignmentList inst_asslist;    \
+  ModuleInstantiation* instance = \
+      new ModuleInstantiation(instance_name, inst_asslist, Location::NONE);
 
 typedef struct {
-  PyObject_HEAD
-  std::shared_ptr<AbstractNode> node;
-  PyObject *dict;
+  PyObject_HEAD std::shared_ptr<AbstractNode> node;
+  PyObject* dict;
   /* Type-specific fields go here. */
 } PyOpenSCADObject;
 
-void PyObjectDeleter(PyObject *pObject);
-using PyObjectUniquePtr = std::unique_ptr<PyObject, decltype(PyObjectDeleter )&>;
+void PyObjectDeleter(PyObject* pObject);
+using PyObjectUniquePtr = std::unique_ptr<PyObject, decltype(PyObjectDeleter)&>;
 
 PyMODINIT_FUNC PyInit_PyOpenSCAD(void);
-int python_vectorval(PyObject *vec, int minarg, int maxarg, double *x, double *y, double *z, double *w = NULL);
-PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type, const std::shared_ptr<AbstractNode>& node);
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *object);
-
+int python_vectorval(PyObject* vec,
+                     int minarg,
+                     int maxarg,
+                     double* x,
+                     double* y,
+                     double* z,
+                     double* w = NULL);
+PyObject* PyOpenSCADObjectFromNode(PyTypeObject* type,
+                                   const std::shared_ptr<AbstractNode>& node);
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject* object);
 
 extern PyTypeObject PyOpenSCADType;
 extern std::shared_ptr<AbstractNode> python_result_node;
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *object, PyObject **dict);
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *object, PyObject **dict);
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject* object,
+                                                     PyObject** dict);
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject* object,
+                                                          PyObject** dict);
 extern std::string trusted_edit_document_name;
 extern std::string untrusted_edit_document_name;
-std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim);
-int python_numberval(PyObject *number, double *result);
+std::vector<Vector3d> python_vectors(PyObject* vec, int mindim, int maxdim);
+int python_numberval(PyObject* number, double* result);
 void get_fnas(double& fn, double& fa, double& fs);
-PyObject *python_str(PyObject *self);
+PyObject* python_str(PyObject* self);
 
 extern PyNumberMethods PyOpenSCADNumbers;
 extern PyMappingMethods PyOpenSCADMapping;
diff --git a/src/python/python_public.h b/src/python/python_public.h
index e7c8f8288..04546ed1f 100644
--- a/src/python/python_public.h
+++ b/src/python/python_public.h
@@ -13,7 +13,9 @@ void python_unlock(void);
 
 extern std::shared_ptr<AbstractNode> python_result_node;
 
-int pythonRunArgs(int argc, char **argv);
+int pythonRunArgs(int argc, char** argv);
 int pythonCreateVenv(const std::string& path);
-int pythonRunModule(const std::string& appPath, const std::string& module, const std::vector<std::string>& args);
+int pythonRunModule(const std::string& appPath,
+                    const std::string& module,
+                    const std::vector<std::string>& args);
 std::string venvBinDirFromSettings();
diff --git a/src/utils/StackCheck.h b/src/utils/StackCheck.h
index 76be28b4f..686711acf 100644
--- a/src/utils/StackCheck.h
+++ b/src/utils/StackCheck.h
@@ -3,21 +3,19 @@
 #include <cstdlib>
 #include "platform/PlatformUtils.h"
 
-class StackCheck
-{
-public:
-  static StackCheck& inst()
-  {
+class StackCheck {
+ public:
+  static StackCheck& inst() {
     static StackCheck instance;
     return instance;
   }
 
   inline bool check() { return size() >= limit; }
 
-private:
+ private:
   StackCheck() : limit(PlatformUtils::stackLimit()) {
     unsigned char c;
-    ptr = &c; // NOLINT(*StackAddressEscape)
+    ptr = &c;  // NOLINT(*StackAddressEscape)
   }
   inline unsigned long size() {
     unsigned char c;
@@ -25,5 +23,5 @@ private:
   }
 
   unsigned long limit;
-  unsigned char *ptr;
+  unsigned char* ptr;
 };
diff --git a/src/utils/boost-utils.h b/src/utils/boost-utils.h
index 04c24d50a..49671d0af 100644
--- a/src/utils/boost-utils.h
+++ b/src/utils/boost-utils.h
@@ -17,8 +17,8 @@ BOOST_TRIBOOL_THIRD_STATE(unknown)
    For positive overflow, return max of Tout template type
    For negative overflow, return min of Tout template type
    On other conversion failures, return 0. */
-template <class Tout, class Tin> Tout boost_numeric_cast(Tin input)
-{
+template <class Tout, class Tin>
+Tout boost_numeric_cast(Tin input) {
   Tout result = 0;
   std::ostringstream status;
   status.str("ok");
@@ -35,11 +35,10 @@ template <class Tout, class Tin> Tout boost_numeric_cast(Tin input)
     result = 0;
   }
   if (status.str() != "ok") {
-    LOG(message_group::Warning, "Problem converting this number: %1$s", std::to_string(input));
+    LOG(message_group::Warning, "Problem converting this number: %1$s",
+        std::to_string(input));
     LOG(message_group::Warning, "%1$s", status.str());
     LOG(message_group::Warning, "setting result to %1$u", result);
   }
   return result;
 }
-
-
diff --git a/src/utils/calc.cc b/src/utils/calc.cc
index 3d4a50804..3c64f43f7 100644
--- a/src/utils/calc.cc
+++ b/src/utils/calc.cc
@@ -25,9 +25,9 @@
  */
 #include "utils/calc.h"
 
-#include <cmath>
-#include <cassert>
 #include <algorithm>
+#include <cassert>
+#include <cmath>
 
 #include "geometry/Grid.h"
 #include "utils/degree_trig.h"
@@ -41,23 +41,23 @@ double Calc::lerp(double a, double b, double t) {
    Returns the number of subdivision of a whole circle, given radius and
    the three special variables $fn, $fs and $fa
  */
-int Calc::get_fragments_from_r(double r, double fn, double fs, double fa)
-{
-  // FIXME: It would be better to refuse to create an object. Let's do more strict error handling
-  // in future versions of OpenSCAD
-  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return 3;
-  if (fn > 0.0) return static_cast<int>(fn >= 3 ? fn : 3);
+int Calc::get_fragments_from_r(double r, double fn, double fs, double fa) {
+  // FIXME: It would be better to refuse to create an object. Let's do more
+  // strict error handling in future versions of OpenSCAD
+  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn))
+    return 3;
+  if (fn > 0.0)
+    return static_cast<int>(fn >= 3 ? fn : 3);
   return static_cast<int>(ceil(fmax(fmin(360.0 / fa, r * 2 * M_PI / fs), 5)));
 }
 
 /*
    https://mathworld.wolfram.com/Helix.html
-   For a helix defined as:         F(t) = [r*cost(t), r*sin(t), c*t]  for t in [0,T)
-   The helical arc length is          L = T * sqrt(r^2 + c^2)
-   Where its pitch is             pitch = 2*PI*c
-   Pitch is also height per turn: pitch = height / (twist/360)
-   Solving for c gives                c = height / (twist*PI/180)
-   Where (twist*PI/180) is just twist in radians, aka "T"
+   For a helix defined as:         F(t) = [r*cost(t), r*sin(t), c*t]  for t in
+   [0,T) The helical arc length is          L = T * sqrt(r^2 + c^2) Where its
+   pitch is             pitch = 2*PI*c Pitch is also height per turn: pitch =
+   height / (twist/360) Solving for c gives                c = height /
+   (twist*PI/180) Where (twist*PI/180) is just twist in radians, aka "T"
  */
 static double helix_arc_length(double r_sqr, double height, double twist) {
   const double T = twist * M_DEG2RAD;
@@ -69,19 +69,25 @@ static double helix_arc_length(double r_sqr, double height, double twist) {
    Returns the number of slices for a linear_extrude with twist.
    Given height, twist, and the three special variables $fn, $fs and $fa
  */
-int Calc::get_helix_slices(double r_sqr, double height, double twist, double fn, double fs, double fa)
-{
+int Calc::get_helix_slices(double r_sqr,
+                           double height,
+                           double twist,
+                           double fn,
+                           double fs,
+                           double fa) {
   twist = fabs(twist);
   // 180 twist per slice is worst case, guaranteed non-manifold.
   // Make sure we have at least 3 slices per 360 twist
   const int min_slices = std::max(static_cast<int>(ceil(twist / 120.0)), 1);
-  if (sqrt(r_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+  if (sqrt(r_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn))
+    return min_slices;
   if (fn > 0.0) {
     const int fn_slices = static_cast<int>(ceil(twist / 360.0 * fn));
     return std::max(fn_slices, min_slices);
   }
   const int fa_slices = static_cast<int>(ceil(twist / fa));
-  const int fs_slices = static_cast<int>(ceil(helix_arc_length(r_sqr, height, twist) / fs));
+  const int fs_slices =
+      static_cast<int>(ceil(helix_arc_length(r_sqr, height, twist) / fs));
   return std::max(std::min(fa_slices, fs_slices), min_slices);
 }
 
@@ -98,11 +104,18 @@ static double archimedes_length(double a, double theta) {
   return 0.5 * a * (theta * sqrt(1 + theta * theta) + asinh(theta));
 }
 
-int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, double scale, double fn, double fs, double fa) {
+int Calc::get_conical_helix_slices(double r_sqr,
+                                   double height,
+                                   double twist,
+                                   double scale,
+                                   double fn,
+                                   double fs,
+                                   double fa) {
   twist = fabs(twist);
   const double r = sqrt(r_sqr);
   const int min_slices = std::max(static_cast<int>(ceil(twist / 120.0)), 1);
-  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn))
+    return min_slices;
   if (fn > 0.0) {
     const int fn_slices = static_cast<int>(ceil(twist * fn / 360));
     return std::max(fn_slices, min_slices);
@@ -120,8 +133,9 @@ int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, do
    |\                  |____|/
    | \                 |    / 1x  (Z=0)
    |  \                |   /
-   |___\ 0.66x (Z=h)   |  /            t is angle of our arc section (twist, in rads)
-   |   |\              | /             E is angle_end (total triangle base length)
+   |___\ 0.66x (Z=h)   |  /            t is angle of our arc section (twist, in
+   rads) |   |\              | /             E is angle_end (total triangle base
+   length)
    |___|_\  1x (Z=0)   |/ 0x           S is angle_start
          t
 
@@ -138,10 +152,13 @@ int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, do
     assert(false && "Don't calculate conical slices on non-scaled extrude!");
   }
   const double angle_start = angle_end - rads;
-  const double a = r / angle_end; // spiral scale coefficient
-  const double spiral_length = archimedes_length(a, angle_end) - archimedes_length(a, angle_start);
-  // Treat (flat spiral_length,extrusion height) as (base,height) of a right triangle to get diagonal length.
-  const double total_length = sqrt(spiral_length * spiral_length + height * height);
+  const double a = r / angle_end;  // spiral scale coefficient
+  const double spiral_length =
+      archimedes_length(a, angle_end) - archimedes_length(a, angle_start);
+  // Treat (flat spiral_length,extrusion height) as (base,height) of a right
+  // triangle to get diagonal length.
+  const double total_length =
+      sqrt(spiral_length * spiral_length + height * height);
 
   const int fs_slices = static_cast<int>(ceil(total_length / fs));
   const int fa_slices = static_cast<int>(ceil(twist / fa));
@@ -153,17 +170,22 @@ int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, do
     Either use $fn directly as slices,
     or divide the longest diagonal vertex extrude path by $fs
 
-    dr_sqr - the largest 2D delta (before/after scaling) for all vertices, squared.
-    note: $fa is not considered since no twist
-          scale is not passed in since it was already used to calculate the largest delta.
+    dr_sqr - the largest 2D delta (before/after scaling) for all vertices,
+   squared. note: $fa is not considered since no twist scale is not passed in
+   since it was already used to calculate the largest delta.
  */
-int Calc::get_diagonal_slices(double delta_sqr, double height, double fn, double fs) {
+int Calc::get_diagonal_slices(double delta_sqr,
+                              double height,
+                              double fn,
+                              double fs) {
   constexpr int min_slices = 1;
-  if (sqrt(delta_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+  if (sqrt(delta_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn))
+    return min_slices;
   if (fn > 0.0) {
     const int fn_slices = static_cast<int>(fn);
     return std::max(fn_slices, min_slices);
   }
-  const int fs_slices = static_cast<int>(ceil(sqrt(delta_sqr + height * height) / fs));
+  const int fs_slices =
+      static_cast<int>(ceil(sqrt(delta_sqr + height * height) / fs));
   return std::max(fs_slices, min_slices);
 }
diff --git a/src/utils/calc.h b/src/utils/calc.h
index 7ab8c48c1..16d408fde 100644
--- a/src/utils/calc.h
+++ b/src/utils/calc.h
@@ -3,7 +3,18 @@
 namespace Calc {
 double lerp(double a, double b, double t);
 int get_fragments_from_r(double r, double fn, double fs, double fa);
-int get_helix_slices(double r_sqr, double h, double twist, double fn, double fs, double fa);
-int get_conical_helix_slices(double r, double height, double twist, double scale, double fn, double fs, double fa);
+int get_helix_slices(double r_sqr,
+                     double h,
+                     double twist,
+                     double fn,
+                     double fs,
+                     double fa);
+int get_conical_helix_slices(double r,
+                             double height,
+                             double twist,
+                             double scale,
+                             double fn,
+                             double fs,
+                             double fa);
 int get_diagonal_slices(double delta_sqr, double height, double fn, double fs);
-}
+}  // namespace Calc
diff --git a/src/utils/degree_trig.cc b/src/utils/degree_trig.cc
index ebee92b8b..78935d4fc 100644
--- a/src/utils/degree_trig.cc
+++ b/src/utils/degree_trig.cc
@@ -36,13 +36,11 @@
 // Trigonometry function taking degrees, accurate for 30, 45, 60 and 90, etc.
 //
 
-static inline double rad2deg(double x)
-{
+static inline double rad2deg(double x) {
   return x * M_RAD2DEG;
 }
 
-static inline double deg2rad(double x)
-{
+static inline double deg2rad(double x) {
   return x * M_DEG2RAD;
 }
 
@@ -50,14 +48,13 @@ static inline double deg2rad(double x)
 // comment/undefine it to disable domain check
 #define TRIG_HUGE_VAL ((1L << 26) * 360.0 * (1L << 26))
 
-double sin_degrees(double x)
-{
+double sin_degrees(double x) {
   // use positive tests because of possible Inf/NaN
   if (x < 360.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+      if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
     const double revolutions = floor(x / 360.0);
@@ -71,29 +68,32 @@ double sin_degrees(double x)
   }
 #endif
   const bool oppose = x >= 180.0;
-  if (oppose) x -= 180.0;
-  if (x > 90.0) x = 180.0 - x;
+  if (oppose)
+    x -= 180.0;
+  if (x > 90.0)
+    x = 180.0 - x;
   if (x < 45.0) {
-    if (x == 30.0) x = 0.5;
-    else x = sin(deg2rad(x));
+    if (x == 30.0)
+      x = 0.5;
+    else
+      x = sin(deg2rad(x));
   } else if (x == 45.0) {
     x = M_SQRT1_2;
   } else if (x == 60.0) {
     x = M_SQRT3_4;
-  } else { // Inf/Nan would fall here
+  } else {  // Inf/Nan would fall here
     x = cos(deg2rad(90.0 - x));
   }
   return oppose ? -x : x;
 }
 
-double cos_degrees(double x)
-{
+double cos_degrees(double x) {
   // use positive tests because of possible Inf/NaN
   if (x < 360.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+      if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
     const double revolutions = floor(x / 360.0);
@@ -107,33 +107,35 @@ double cos_degrees(double x)
   }
 #endif
   bool oppose = x >= 180.0;
-  if (oppose) x -= 180.0;
+  if (oppose)
+    x -= 180.0;
   if (x > 90.0) {
     x = 180.0 - x;
     oppose = !oppose;
   }
   if (x > 45.0) {
-    if (x == 60.0) x = 0.5;
-    else x = sin(deg2rad(90.0 - x));
+    if (x == 60.0)
+      x = 0.5;
+    else
+      x = sin(deg2rad(90.0 - x));
   } else if (x == 45.0) {
     x = M_SQRT1_2;
   } else if (x == 30.0) {
     x = M_SQRT3_4;
-  } else { // Inf/Nan would fall here
+  } else {  // Inf/Nan would fall here
     x = cos(deg2rad(x));
   }
   return oppose ? -x : x;
 }
 
-double tan_degrees(double x)
-{
+double tan_degrees(double x) {
   const int cycles = floor((x) / 180.0);
   // use positive tests because of possible Inf/NaN
   if (x < 180.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+      if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
     x -= 180.0 * cycles;
@@ -146,7 +148,8 @@ double tan_degrees(double x)
   }
 #endif
   const bool oppose = x > 90.0;
-  if (oppose) x = 180.0 - x;
+  if (oppose)
+    x = 180.0 - x;
   if (x == 0.0) {
     x = (cycles % 2) == 0 ? 0.0 : -0.0;
   } else if (x == 30.0) {
@@ -156,9 +159,8 @@ double tan_degrees(double x)
   } else if (x == 60.0) {
     x = M_SQRT3;
   } else if (x == 90.0) {
-    x = (cycles % 2) == 0 ?
-      std::numeric_limits<double>::infinity() :
-      -std::numeric_limits<double>::infinity();
+    x = (cycles % 2) == 0 ? std::numeric_limits<double>::infinity()
+                          : -std::numeric_limits<double>::infinity();
   } else {
     x = tan(deg2rad(x));
   }
@@ -167,41 +169,41 @@ double tan_degrees(double x)
 //
 // Inverse trig
 //
-double asin_degrees(double x)
-{
+double asin_degrees(double x) {
   const auto degs = rad2deg(asin(x));
   const auto whole = round(degs);
-  if (sin_degrees(whole) == x) return whole;
+  if (sin_degrees(whole) == x)
+    return whole;
   return degs;
 }
-double acos_degrees(double x)
-{
+double acos_degrees(double x) {
   const auto degs = rad2deg(acos(x));
   const auto whole = round(degs);
-  if (cos_degrees(whole) == x) return whole;
+  if (cos_degrees(whole) == x)
+    return whole;
   return degs;
 }
-double atan_degrees(double x)
-{
+double atan_degrees(double x) {
   const auto degs = rad2deg(atan(x));
   const auto whole = round(degs);
-  if (tan_degrees(whole) == x) return whole;
+  if (tan_degrees(whole) == x)
+    return whole;
   return degs;
 }
-double atan2_degrees(double y, double x)
-{
+double atan2_degrees(double y, double x) {
   const auto degs = rad2deg(atan2(y, x));
   const auto whole = round(degs);
-  if (fabs(degs - whole) < 3.0E-14) return whole;
+  if (fabs(degs - whole) < 3.0E-14)
+    return whole;
   return degs;
 }
 //
 // Rotation_matrix_from_axis_and_angle
 //
-Matrix3d angle_axis_degrees(double a, Vector3d v)
-{
+Matrix3d angle_axis_degrees(double a, Vector3d v) {
   Matrix3d M{Matrix3d::Identity()};
-  // Formula from https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
+  // Formula from
+  // https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
   // We avoid dividing by the square root of the magnitude as much as possible
   // to minimise rounding errors.
   const auto s = sin_degrees(a);
@@ -210,23 +212,19 @@ Matrix3d angle_axis_degrees(double a, Vector3d v)
   if (m > 0) {
     const Vector3d Cv = v * ((1 - c) / m);
     const Vector3d us = v.normalized() * s;
-    M << Cv[0] * v[0] + c,     Cv[1] * v[0] - us[2], Cv[2] * v[0] + us[1],
-      Cv[0] * v[1] + us[2], Cv[1] * v[1] + c,     Cv[2] * v[1] - us[0],
-      Cv[0] * v[2] - us[1], Cv[1] * v[2] + us[0], Cv[2] * v[2] + c;
+    M << Cv[0] * v[0] + c, Cv[1] * v[0] - us[2], Cv[2] * v[0] + us[1],
+        Cv[0] * v[1] + us[2], Cv[1] * v[1] + c, Cv[2] * v[1] - us[0],
+        Cv[0] * v[2] - us[1], Cv[1] * v[2] + us[0], Cv[2] * v[2] + c;
   }
   return M;
 }
 //
 // 2D rotation matrix from angle in degrees
 //
-Matrix3d rotate_degrees(double angle)
-{
+Matrix3d rotate_degrees(double angle) {
   Eigen::Matrix3d m;
   const auto s = sin_degrees(angle);
   const auto c = cos_degrees(angle);
-  m <<
-    c, -s,  0,
-    s,  c,  0,
-    0,  0,  1;
+  m << c, -s, 0, s, c, 0, 0, 0, 1;
   return m;
 }
diff --git a/src/utils/degree_trig.h b/src/utils/degree_trig.h
index 35781b4df..d49a35bd8 100644
--- a/src/utils/degree_trig.h
+++ b/src/utils/degree_trig.h
@@ -29,9 +29,11 @@
 #pragma once
 #include "geometry/linalg.h"
 
-constexpr double M_SQRT3 = 1.73205080756887719318;    /* sqrt(3)   */
-constexpr double M_SQRT3_4 = 0.86602540378443859659;  /* sqrt(3/4) == sqrt(3)/2 */
-constexpr double M_SQRT1_3 = 0.57735026918962573106;  /* sqrt(1/3) == sqrt(3)/3 */
+constexpr double M_SQRT3 = 1.73205080756887719318; /* sqrt(3)   */
+constexpr double M_SQRT3_4 =
+    0.86602540378443859659; /* sqrt(3/4) == sqrt(3)/2 */
+constexpr double M_SQRT1_3 =
+    0.57735026918962573106; /* sqrt(1/3) == sqrt(3)/3 */
 constexpr double M_RAD2DEG = 57.2957795130823208767;  /* 180/PI */
 constexpr double M_DEG2RAD = 0.017453292519943295769; /* PI/180 */
 
diff --git a/src/utils/exceptions.h b/src/utils/exceptions.h
index 515d63c6e..0363f7c0f 100644
--- a/src/utils/exceptions.h
+++ b/src/utils/exceptions.h
@@ -1,71 +1,76 @@
 #pragma once
 
 #include <stdexcept>
-#include <utility>
 #include <string>
+#include <utility>
 
 #include "core/AST.h"
 #include "utils/printutils.h"
 
-class EvaluationException : public std::runtime_error
-{
-public:
-  EvaluationException(const std::string& what_arg) : std::runtime_error(what_arg), traceDepth(OpenSCAD::traceDepth) {}
+class EvaluationException : public std::runtime_error {
+ public:
+  EvaluationException(const std::string& what_arg)
+      : std::runtime_error(what_arg), traceDepth(OpenSCAD::traceDepth) {}
 
-public:
+ public:
   int traceDepth = 0;
 };
 
-class AssertionFailedException : public EvaluationException
-{
-public:
-  AssertionFailedException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+class AssertionFailedException : public EvaluationException {
+ public:
+  AssertionFailedException(const std::string& what_arg, Location loc)
+      : EvaluationException(what_arg), loc(std::move(loc)) {}
 
-public:
+ public:
   Location loc;
 };
 
-class RecursionException : public EvaluationException
-{
-public:
-  static RecursionException create(const std::string& recursiontype, const std::string& name, const Location& loc) {
-    return RecursionException{STR("Recursion detected calling ", recursiontype, " '", name, "'"), loc};
+class RecursionException : public EvaluationException {
+ public:
+  static RecursionException create(const std::string& recursiontype,
+                                   const std::string& name,
+                                   const Location& loc) {
+    return RecursionException{
+        STR("Recursion detected calling ", recursiontype, " '", name, "'"),
+        loc};
   }
 
-public:
+ public:
   Location loc;
 
-private:
-  RecursionException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+ private:
+  RecursionException(const std::string& what_arg, Location loc)
+      : EvaluationException(what_arg), loc(std::move(loc)) {}
 };
 
-class LoopCntException : public EvaluationException
-{
-public:
+class LoopCntException : public EvaluationException {
+ public:
   static LoopCntException create(const std::string& type, const Location& loc) {
     return LoopCntException{STR(type, " loop counter exceeded limit"), loc};
   }
 
-public:
+ public:
   Location loc;
 
-private:
-  LoopCntException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+ private:
+  LoopCntException(const std::string& what_arg, Location loc)
+      : EvaluationException(what_arg), loc(std::move(loc)) {}
 };
 
-class VectorEchoStringException : public EvaluationException
-{
-public:
+class VectorEchoStringException : public EvaluationException {
+ public:
   static VectorEchoStringException create() {
-    return VectorEchoStringException{"Stack exhausted while trying to convert a vector to EchoString"};
+    return VectorEchoStringException{
+        "Stack exhausted while trying to convert a vector to EchoString"};
   }
 
-private:
-  VectorEchoStringException(const std::string& what_arg) : EvaluationException(what_arg) {}
+ private:
+  VectorEchoStringException(const std::string& what_arg)
+      : EvaluationException(what_arg) {}
 };
 
-class HardWarningException : public EvaluationException
-{
-public:
-  HardWarningException(const std::string& what_arg) : EvaluationException(what_arg) {}
+class HardWarningException : public EvaluationException {
+ public:
+  HardWarningException(const std::string& what_arg)
+      : EvaluationException(what_arg) {}
 };
diff --git a/src/utils/hash.cc b/src/utils/hash.cc
index eb41124a2..fcfc65009 100644
--- a/src/utils/hash.cc
+++ b/src/utils/hash.cc
@@ -17,25 +17,28 @@ std::size_t hash<Vector3d>::operator()(const Vector3d& s) const {
 std::size_t hash<Vector3l>::operator()(const Vector3l& s) const {
   return Eigen::hash_value(s);
 }
-}
+}  // namespace std
 
 namespace Eigen {
 
 size_t hash_value(Vector3f const& v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine(seed, v[i]);
   return seed;
 }
 
 size_t hash_value(Vector3d const& v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine(seed, v[i]);
   return seed;
 }
 
 size_t hash_value(Eigen::Matrix<int64_t, 3, 1> const& v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine(seed, v[i]);
   return seed;
 }
-}
+}  // namespace Eigen
diff --git a/src/utils/hash.h b/src/utils/hash.h
index cfd03d8eb..977fa9fc5 100644
--- a/src/utils/hash.h
+++ b/src/utils/hash.h
@@ -10,13 +10,22 @@
 using Vector3l = Eigen::Matrix<int64_t, 3, 1>;
 
 namespace std {
-template <> struct hash<Vector3f> { std::size_t operator()(const Vector3f& s) const; };
-template <> struct hash<Vector3d> { std::size_t operator()(const Vector3d& s) const; };
-template <> struct hash<Vector3l> { std::size_t operator()(const Vector3l& s) const; };
-}
+template <>
+struct hash<Vector3f> {
+  std::size_t operator()(const Vector3f& s) const;
+};
+template <>
+struct hash<Vector3d> {
+  std::size_t operator()(const Vector3d& s) const;
+};
+template <>
+struct hash<Vector3l> {
+  std::size_t operator()(const Vector3l& s) const;
+};
+}  // namespace std
 
 namespace Eigen {
 size_t hash_value(Vector3f const& v);
 size_t hash_value(Vector3d const& v);
 size_t hash_value(Vector3l const& v);
-}
+}  // namespace Eigen
diff --git a/src/utils/parallel.h b/src/utils/parallel.h
index 0b4e0ebb4..bc1c8c459 100644
--- a/src/utils/parallel.h
+++ b/src/utils/parallel.h
@@ -11,7 +11,8 @@
 
 template <class InputIterator, class OutputIterator, class Operation>
 void parallelizable_transform(const InputIterator begin1,
-                              const InputIterator end1, OutputIterator out,
+                              const InputIterator end1,
+                              OutputIterator out,
                               const Operation& op) {
 #if ENABLE_TBB
   if (!getenv("OPENSCAD_NO_PARALLEL")) {
@@ -26,7 +27,9 @@ void parallelizable_transform(const InputIterator begin1,
   std::transform(begin1, end1, out, op);
 }
 
-template <class Container1, class Container2, class OutputIterator,
+template <class Container1,
+          class Container2,
+          class OutputIterator,
           class Operation>
 void parallelizable_cross_product_transform(const Container1& cont1,
                                             const Container2& cont2,
@@ -39,8 +42,7 @@ void parallelizable_cross_product_transform(const Container1& cont1,
       decltype(*cont2.begin()) second;
       ReferencePair(decltype(*cont1.begin()) first,
                     decltype(*cont2.begin()) second)
-        : first(first), second(second) {
-      }
+          : first(first), second(second) {}
     };
     std::vector<ReferencePair> pairs;
     pairs.reserve(cont1.size() * cont2.size());
@@ -50,13 +52,11 @@ void parallelizable_cross_product_transform(const Container1& cont1,
       }
     }
     parallelizable_transform(
-      pairs.begin(), pairs.end(), out,
-      [&](const auto& pair) {
-      return op(pair.first, pair.second);
-    });
+        pairs.begin(), pairs.end(), out,
+        [&](const auto& pair) { return op(pair.first, pair.second); });
     return;
   }
-#endif // if ENABLE_TBB
+#endif  // if ENABLE_TBB
   for (const auto& v1 : cont1) {
     for (const auto& v2 : cont2) {
       *(out++) = op(v1, v2);
diff --git a/src/utils/printutils.cc b/src/utils/printutils.cc
index 747cb906d..dde674a05 100644
--- a/src/utils/printutils.cc
+++ b/src/utils/printutils.cc
@@ -19,8 +19,8 @@ namespace fs = std::filesystem;
 
 std::set<std::string> printedDeprecations;
 std::list<std::string> print_messages_stack;
-OutputHandlerFunc *outputhandler = nullptr;
-void *outputhandler_data = nullptr;
+OutputHandlerFunc* outputhandler = nullptr;
+void* outputhandler_data = nullptr;
 std::string OpenSCAD::debug("");
 bool OpenSCAD::quiet = false;
 bool OpenSCAD::hardwarnings = false;
@@ -32,7 +32,7 @@ bool OpenSCAD::rangeCheck = false;
 namespace {
 
 std::list<struct Message> log_messages_stack;
-OutputHandlerFunc2 *outputhandler2 = nullptr;
+OutputHandlerFunc2* outputhandler2 = nullptr;
 boost::circular_buffer<std::string> lastmessages(5);
 boost::circular_buffer<struct Message> lastlogmessages(5);
 
@@ -42,34 +42,31 @@ bool deferred;
 
 }  // namespace
 
-void set_output_handler(OutputHandlerFunc *newhandler, OutputHandlerFunc2 *newhandler2, void *userdata)
-{
+void set_output_handler(OutputHandlerFunc* newhandler,
+                        OutputHandlerFunc2* newhandler2,
+                        void* userdata) {
   outputhandler = newhandler;
   outputhandler2 = newhandler2;
   outputhandler_data = userdata;
 }
 
-void no_exceptions_for_warnings()
-{
+void no_exceptions_for_warnings() {
   no_throw = true;
   deferred = false;
 }
 
-bool would_have_thrown()
-{
+bool would_have_thrown() {
   const auto would_throw = deferred;
   no_throw = false;
   deferred = false;
   return would_throw;
 }
 
-void print_messages_push()
-{
+void print_messages_push() {
   print_messages_stack.emplace_back();
 }
 
-void print_messages_pop()
-{
+void print_messages_pop() {
   const std::string msg = print_messages_stack.back();
   print_messages_stack.pop_back();
   if (print_messages_stack.size() > 0 && !msg.empty()) {
@@ -80,9 +77,9 @@ void print_messages_pop()
   }
 }
 
-void PRINT(const Message& msgObj)
-{
-  if (msgObj.msg.empty() && msgObj.group != message_group::Echo) return;
+void PRINT(const Message& msgObj) {
+  if (msgObj.msg.empty() && msgObj.group != message_group::Echo)
+    return;
 
   if (print_messages_stack.size() > 0) {
     if (!print_messages_stack.back().empty()) {
@@ -93,26 +90,30 @@ void PRINT(const Message& msgObj)
 
   PRINT_NOCACHE(msgObj);
 
-  //to error log
-  if (outputhandler2 &&
-      !(msgObj.group == message_group::NONE || msgObj.group == message_group::Echo || msgObj.group == message_group::Trace)) {
-
+  // to error log
+  if (outputhandler2 && !(msgObj.group == message_group::NONE ||
+                          msgObj.group == message_group::Echo ||
+                          msgObj.group == message_group::Trace)) {
     outputhandler2(msgObj, outputhandler_data);
   }
 }
 
-void PRINT_NOCACHE(const Message& msgObj)
-{
-  if (msgObj.msg.empty() && msgObj.group != message_group::Echo) return;
+void PRINT_NOCACHE(const Message& msgObj) {
+  if (msgObj.msg.empty() && msgObj.group != message_group::Echo)
+    return;
 
   const auto msg = msgObj.str();
 
-  if (msgObj.group == message_group::Warning || msgObj.group == message_group::Error || msgObj.group == message_group::Trace) {
+  if (msgObj.group == message_group::Warning ||
+      msgObj.group == message_group::Error ||
+      msgObj.group == message_group::Trace) {
     size_t i;
     for (i = 0; i < lastmessages.size(); ++i) {
-      if (lastmessages[i] != msg) break;
+      if (lastmessages[i] != msg)
+        break;
     }
-    if (i == 5) return; // Suppress output after 5 equal ERROR or WARNING outputs.
+    if (i == 5)
+      return;  // Suppress output after 5 equal ERROR or WARNING outputs.
     lastmessages.push_back(msg);
   }
   if (!deferred)
@@ -124,17 +125,20 @@ void PRINT_NOCACHE(const Message& msgObj)
       }
     }
   if (!std::current_exception()) {
-    if ((OpenSCAD::hardwarnings && msgObj.group == message_group::Warning) || (no_throw && msgObj.group == message_group::Error)) {
-      if (no_throw) deferred = true;
-      else throw HardWarningException(msgObj.msg);
+    if ((OpenSCAD::hardwarnings && msgObj.group == message_group::Warning) ||
+        (no_throw && msgObj.group == message_group::Error)) {
+      if (no_throw)
+        deferred = true;
+      else
+        throw HardWarningException(msgObj.msg);
     }
   }
 }
 
-void PRINTDEBUG(const std::string& filename, const std::string& msg)
-{
+void PRINTDEBUG(const std::string& filename, const std::string& msg) {
   // see printutils.h for usage instructions
-  if (OpenSCAD::debug == "") return;
+  if (OpenSCAD::debug == "")
+    return;
   const std::string shortfname = fs::path(filename).stem().generic_string();
   std::string lowshortfname(shortfname);
   boost::algorithm::to_lower(lowshortfname);
@@ -142,99 +146,92 @@ void PRINTDEBUG(const std::string& filename, const std::string& msg)
   boost::algorithm::to_lower(lowdebug);
   if (OpenSCAD::debug == "all" ||
       lowdebug.find(lowshortfname) != std::string::npos) {
-    const Message msgObj{shortfname + ": " + msg, message_group::NONE, Location::NONE, ""};
+    const Message msgObj{shortfname + ": " + msg, message_group::NONE,
+                         Location::NONE, ""};
     PRINT_NOCACHE(msgObj);
   }
 }
 
-const std::string& quoted_string(const std::string& str)
-{
+const std::string& quoted_string(const std::string& str) {
   static std::string buf;
   buf = str;
   boost::replace_all(buf, "\n", "\\n");
   return buf;
 }
 
-std::string two_digit_exp_format(std::string doublestr)
-{
+std::string two_digit_exp_format(std::string doublestr) {
 #ifdef _WIN32
   size_t exppos = doublestr.find('e');
   if (exppos != std::string::npos) {
     exppos += 2;
-    if (doublestr[exppos] == '0') doublestr.erase(exppos, 1);
+    if (doublestr[exppos] == '0')
+      doublestr.erase(exppos, 1);
   }
 #endif
   return doublestr;
 }
 
-std::string two_digit_exp_format(double x)
-{
+std::string two_digit_exp_format(double x) {
   return two_digit_exp_format(std::to_string(x));
 }
 
-void resetSuppressedMessages()
-{
+void resetSuppressedMessages() {
   printedDeprecations.clear();
   lastmessages.clear();
 }
 
-std::string getGroupName(const enum message_group& group)
-{
+std::string getGroupName(const enum message_group& group) {
   switch (group) {
-  case message_group::NONE:
-  case message_group::Warning:
-  case message_group::UI_Warning:
-    return "WARNING";
-  case message_group::Error:
-  case message_group::UI_Error:
-    return "ERROR";
-  case message_group::Font_Warning:
-    return "FONT-WARNING";
-  case message_group::Export_Warning:
-    return "EXPORT-WARNING";
-  case message_group::Export_Error:
-    return "EXPORT-ERROR";
-  case message_group::Parser_Error:
-    return "PARSER-ERROR";
-  case message_group::Trace:
-    return "TRACE";
-  case message_group::Deprecated:
-    return "DEPRECATED";
-  case message_group::Echo:
-    return "ECHO";
-  default:
-    assert(false && "Unhandled message group name");
-    return "";
+    case message_group::NONE:
+    case message_group::Warning:
+    case message_group::UI_Warning:
+      return "WARNING";
+    case message_group::Error:
+    case message_group::UI_Error:
+      return "ERROR";
+    case message_group::Font_Warning:
+      return "FONT-WARNING";
+    case message_group::Export_Warning:
+      return "EXPORT-WARNING";
+    case message_group::Export_Error:
+      return "EXPORT-ERROR";
+    case message_group::Parser_Error:
+      return "PARSER-ERROR";
+    case message_group::Trace:
+      return "TRACE";
+    case message_group::Deprecated:
+      return "DEPRECATED";
+    case message_group::Echo:
+      return "ECHO";
+    default:
+      assert(false && "Unhandled message group name");
+      return "";
   }
 }
 
-std::string getGroupColor(const enum message_group& group)
-{
+std::string getGroupColor(const enum message_group& group) {
   switch (group) {
-  case message_group::Warning:
-  case message_group::Deprecated:
-  case message_group::UI_Warning:
-  case message_group::Font_Warning:
-    return "#ffffb0";
-  case message_group::Error:
-  case message_group::UI_Error:
-  case message_group::Export_Error:
-  case message_group::Parser_Error:
-    return "#ffb0b0";
-  case message_group::Trace:
-    return "#d0d0ff";
-  default:
-    return "transparent";
+    case message_group::Warning:
+    case message_group::Deprecated:
+    case message_group::UI_Warning:
+    case message_group::Font_Warning:
+      return "#ffffb0";
+    case message_group::Error:
+    case message_group::UI_Error:
+    case message_group::Export_Error:
+    case message_group::Parser_Error:
+      return "#ffb0b0";
+    case message_group::Trace:
+      return "#d0d0ff";
+    default:
+      return "transparent";
   }
 }
 
-bool getGroupTextPlain(const enum message_group& group)
-{
+bool getGroupTextPlain(const enum message_group& group) {
   return group == message_group::NONE || group == message_group::Echo;
 }
 
-std::string
-quoteVar(const std::string& varname)
-{
+std::string quoteVar(const std::string& varname) {
   return '"' + varname + '"';
 }
diff --git a/src/utils/printutils.h b/src/utils/printutils.h
index d46d9c113..0fbd21e71 100644
--- a/src/utils/printutils.h
+++ b/src/utils/printutils.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <cstddef>
 #include <clocale>
+#include <cstddef>
 #include <initializer_list>
 #include <iostream>
 #include <list>
@@ -26,14 +26,16 @@
 
 #include "core/AST.h"
 
-// It seems standard practice to use underscore for gettext, even though it is reserved.
-// Not wanting to risk breaking translations by changing every usage of this,
-// I've opted to just disable the check in this case. - Hans L
+// It seems standard practice to use underscore for gettext, even though it is
+// reserved. Not wanting to risk breaking translations by changing every usage
+// of this, I've opted to just disable the check in this case. - Hans L
 // NOLINTBEGIN(bugprone-reserved-identifier)
-inline char *_(const char *msgid) { return gettext(msgid); }
-inline const char *_(const char *msgid, const char *msgctxt) {
+inline char* _(const char* msgid) {
+  return gettext(msgid);
+}
+inline const char* _(const char* msgid, const char* msgctxt) {
   /* The separator between msgctxt and msgid in a .mo file.  */
-  const char *GETTEXT_CONTEXT_GLUE = "\004";
+  const char* GETTEXT_CONTEXT_GLUE = "\004";
 
   std::string str = msgctxt;
   str += GETTEXT_CONTEXT_GLUE;
@@ -50,10 +52,20 @@ inline const char *_(const char *msgid, const char *msgctxt) {
 std::string quoteVar(const std::string& varname);
 
 enum class message_group {
-  NONE, Error, Warning, UI_Warning, Font_Warning, Export_Warning, Export_Error, UI_Error, Parser_Error, Trace, Deprecated, Echo
+  NONE,
+  Error,
+  Warning,
+  UI_Warning,
+  Font_Warning,
+  Export_Warning,
+  Export_Error,
+  UI_Error,
+  Parser_Error,
+  Trace,
+  Deprecated,
+  Echo
 };
 
-
 std::string getGroupName(const enum message_group& group);
 std::string getGroupColor(const enum message_group& group);
 bool getGroupTextPlain(const enum message_group& group);
@@ -65,27 +77,30 @@ struct Message {
   enum message_group group;
 
   Message()
-    : msg(""), loc(Location::NONE), docPath(""), group(message_group::NONE)
-  {
-  }
+      : msg(""), loc(Location::NONE), docPath(""), group(message_group::NONE) {}
 
-  Message(std::string msg, message_group group = message_group::NONE, Location loc = Location::NONE, std::string docPath = "")
-    : msg(std::move(msg)), loc(std::move(loc)), docPath(std::move(docPath)), group(group)
-  {
-  }
+  Message(std::string msg,
+          message_group group = message_group::NONE,
+          Location loc = Location::NONE,
+          std::string docPath = "")
+      : msg(std::move(msg)),
+        loc(std::move(loc)),
+        docPath(std::move(docPath)),
+        group(group) {}
 
   [[nodiscard]] std::string str() const {
-    const auto g = group == message_group::NONE ? "" : getGroupName(group) + ": ";
+    const auto g =
+        group == message_group::NONE ? "" : getGroupName(group) + ": ";
     const auto l = loc.isNone() ? "" : " " + loc.toRelativeString(docPath);
     return g + msg + l;
   }
 };
 
-using OutputHandlerFunc = void (const Message&, void *);
-using OutputHandlerFunc2 = void (const Message&, void *);
+using OutputHandlerFunc = void(const Message&, void*);
+using OutputHandlerFunc2 = void(const Message&, void*);
 
-extern OutputHandlerFunc *outputhandler;
-extern void *outputhandler_data;
+extern OutputHandlerFunc* outputhandler;
+extern void* outputhandler_data;
 
 namespace OpenSCAD {
 extern std::string debug;
@@ -95,9 +110,11 @@ extern int traceDepth;
 extern bool traceUsermoduleParameters;
 extern bool parameterCheck;
 extern bool rangeCheck;
-}
+}  // namespace OpenSCAD
 
-void set_output_handler(OutputHandlerFunc *newhandler, OutputHandlerFunc2 *newhandler2, void *userdata);
+void set_output_handler(OutputHandlerFunc* newhandler,
+                        OutputHandlerFunc2* newhandler2,
+                        void* userdata);
 void no_exceptions_for_warnings();
 bool would_have_thrown();
 
@@ -106,14 +123,16 @@ void print_messages_push();
 void print_messages_pop();
 void resetSuppressedMessages();
 
-
 /* PRINT statements come out in same window as ECHO.
    usage: PRINTB("Var1: %s Var2: %i", var1 % var2 ); */
 void PRINT(const Message& msgObj);
 
 void PRINT_NOCACHE(const Message& msgObj);
-#define PRINTB_NOCACHE(_fmt, _arg) do { } while (0)
-// #define PRINTB_NOCACHE(_fmt, _arg) do { PRINT_NOCACHE(str(boost::format(_fmt) % _arg)); } while (0)
+#define PRINTB_NOCACHE(_fmt, _arg) \
+  do {                             \
+  } while (0)
+// #define PRINTB_NOCACHE(_fmt, _arg) do { PRINT_NOCACHE(str(boost::format(_fmt)
+// % _arg)); } while (0)
 
 /*PRINTD: debugging/verbose output. Usage in code:
    CGAL_Point_3 p0(0,0,0),p1(1,0,0),p2(0,1,0);
@@ -124,15 +143,25 @@ void PRINT_NOCACHE(const Message& msgObj);
    openscad x.scad --debug=<srcfile> # prints only debug msgs from srcfile.*.cc
    (example: openscad --debug=export # prints only debug msgs from export.cc )
 
-   For a debug with heavy computation cost, you can guard so that the computation
-   only occurs when debugging is turned on. For example:
-   if (OpenSCAD::debug!="") PRINTDB("PolySet dump: %s",ps->dump());
+   For a debug with heavy computation cost, you can guard so that the
+   computation only occurs when debugging is turned on. For example: if
+   (OpenSCAD::debug!="") PRINTDB("PolySet dump: %s",ps->dump());
  */
 
 void PRINTDEBUG(const std::string& filename, const std::string& msg);
 // NOLINTBEGIN
-#define PRINTD(_arg) do { PRINTDEBUG(std::string(__FILE__), _arg); } while (0)
-#define PRINTDB(_fmt, _arg) do { try { PRINTDEBUG(std::string(__FILE__), str(boost::format(_fmt) % _arg)); } catch (const boost::io::format_error& e) { PRINTDEBUG(std::string(__FILE__), "bad PRINTDB usage"); } } while (0)
+#define PRINTD(_arg)                         \
+  do {                                       \
+    PRINTDEBUG(std::string(__FILE__), _arg); \
+  } while (0)
+#define PRINTDB(_fmt, _arg)                                               \
+  do {                                                                    \
+    try {                                                                 \
+      PRINTDEBUG(std::string(__FILE__), str(boost::format(_fmt) % _arg)); \
+    } catch (const boost::io::format_error& e) {                          \
+      PRINTDEBUG(std::string(__FILE__), "bad PRINTDB usage");             \
+    }                                                                     \
+  } while (0)
 // NOLINTEND
 
 std::string two_digit_exp_format(std::string doublestr);
@@ -142,16 +171,16 @@ const std::string& quoted_string(const std::string& str);
 // extremely simple logging, eventually replace with something like boost.log
 // usage: logstream out(5); openscad_loglevel=6; out << "hi";
 static int openscad_loglevel = 0;
-class logstream
-{
-public:
-  std::ostream *out;
+class logstream {
+ public:
+  std::ostream* out;
   int loglevel;
   logstream(int level = 0) {
     loglevel = level;
     out = &(std::cout);
   }
-  template <typename T> logstream& operator<<(T const& t) {
+  template <typename T>
+  logstream& operator<<(T const& t) {
     if (out && loglevel <= openscad_loglevel) {
       (*out) << t;
       out->flush();
@@ -167,30 +196,28 @@ inline std::string STR(std::ostringstream& oss) {
   return s;
 }
 
-template <typename T, typename ... Args>
-std::string STR(std::ostringstream& oss, T&& t, Args&& ... args) {
+template <typename T, typename... Args>
+std::string STR(std::ostringstream& oss, T&& t, Args&&... args) {
   oss << t;
   return STR(oss, std::forward<Args>(args)...);
 }
 
-template <typename T, typename ... Args>
-std::string STR(T&& t, Args&& ... args) {
-  // using thread_local here so that recursive template does not instantiate excessive ostringstreams
+template <typename T, typename... Args>
+std::string STR(T&& t, Args&&... args) {
+  // using thread_local here so that recursive template does not instantiate
+  // excessive ostringstreams
   thread_local std::ostringstream oss;
   oss << t;
   return STR(oss, std::forward<Args>(args)...);
 }
 
-template <typename ... Ts>
-class MessageClass
-{
-private:
+template <typename... Ts>
+class MessageClass {
+ private:
   std::string fmt;
   std::tuple<Ts...> args;
   template <std::size_t... Is>
-  [[nodiscard]] std::string format(const std::index_sequence<Is...>) const
-  {
-
+  [[nodiscard]] std::string format(const std::index_sequence<Is...>) const {
     std::string s;
     for (int i = 0; fmt[i] != '\0'; i++) {
       if (fmt[i] == '%' && !('0' <= fmt[i + 1] && fmt[i + 1] <= '9')) {
@@ -202,46 +229,53 @@ private:
 
     boost::format f(s);
     f.exceptions(boost::io::bad_format_string_bit);
-    static_cast<void>(std::initializer_list<char> {(static_cast<void>(f % std::get<Is>(args)), char{}) ...});
+    static_cast<void>(std::initializer_list<char>{
+        (static_cast<void>(f % std::get<Is>(args)), char{})...});
     return boost::str(f);
   }
 
-public:
-  template <typename ... Args>
-  MessageClass(std::string&& fmt, Args&&... args) : fmt(fmt), args(std::forward<Args>(args)...)
-  {
-  }
+ public:
+  template <typename... Args>
+  MessageClass(std::string&& fmt, Args&&... args)
+      : fmt(fmt), args(std::forward<Args>(args)...) {}
 
-  [[nodiscard]] std::string format() const
-  {
+  [[nodiscard]] std::string format() const {
     return format(std::index_sequence_for<Ts...>{});
   }
 };
 
 extern std::set<std::string> printedDeprecations;
 
-template <typename ... Args>
-void LOG(const message_group& msgGroup, Location loc, std::string docPath, std::string&& f, Args&&... args)
-{
-  auto formatted = MessageClass<Args...>{std::move(f), std::forward<Args>(args)...}.format();
-
-  //check for deprecations
-  if (msgGroup == message_group::Deprecated && printedDeprecations.find(formatted + loc.toRelativeString(docPath)) != printedDeprecations.end()) return;
-  if (msgGroup == message_group::Deprecated) printedDeprecations.insert(formatted + loc.toRelativeString(docPath));
-
-  Message msgObj{std::move(formatted), msgGroup, std::move(loc), std::move(docPath)};
+template <typename... Args>
+void LOG(const message_group& msgGroup,
+         Location loc,
+         std::string docPath,
+         std::string&& f,
+         Args&&... args) {
+  auto formatted =
+      MessageClass<Args...>{std::move(f), std::forward<Args>(args)...}.format();
+
+  // check for deprecations
+  if (msgGroup == message_group::Deprecated &&
+      printedDeprecations.find(formatted + loc.toRelativeString(docPath)) !=
+          printedDeprecations.end())
+    return;
+  if (msgGroup == message_group::Deprecated)
+    printedDeprecations.insert(formatted + loc.toRelativeString(docPath));
+
+  Message msgObj{std::move(formatted), msgGroup, std::move(loc),
+                 std::move(docPath)};
 
   PRINT(msgObj);
 }
 
-template <typename ... Args>
-void LOG(const message_group& msgGroup, std::string&& f, Args&&... args)
-{
+template <typename... Args>
+void LOG(const message_group& msgGroup, std::string&& f, Args&&... args) {
   LOG(msgGroup, Location::NONE, "", std::move(f), std::forward<Args>(args)...);
 }
 
-template <typename ... Args>
-void LOG(std::string&& f, Args&&... args)
-{
-  LOG(message_group::NONE, Location::NONE, "", std::move(f), std::forward<Args>(args)...);
+template <typename... Args>
+void LOG(std::string&& f, Args&&... args) {
+  LOG(message_group::NONE, Location::NONE, "", std::move(f),
+      std::forward<Args>(args)...);
 }
diff --git a/src/utils/scope_guard.hpp b/src/utils/scope_guard.hpp
index a342287e5..713af1a77 100644
--- a/src/utils/scope_guard.hpp
+++ b/src/utils/scope_guard.hpp
@@ -42,169 +42,165 @@
 #define SG_NODISCARD
 #endif
 
-namespace sg
-{
-namespace detail
-{
+namespace sg {
+namespace detail {
 /* --- Some custom type traits --- */
 
 // Type trait determining whether a type is callable with no arguments
 template <typename T, typename = void>
-struct is_noarg_callable_t
-  : public std::false_type
-{};     // in general, false
+struct is_noarg_callable_t : public std::false_type {};  // in general, false
 
 template <typename T>
 struct is_noarg_callable_t<T, decltype(std::declval<T&&>()())>
-  : public std::true_type
-{};     // only true when call expression valid
+    : public std::true_type {};  // only true when call expression valid
 
 // Type trait determining whether a no-argument callable returns void
 template <typename T>
 struct returns_void_t
-  : public std::is_same<void, decltype(std::declval<T&&>()())>
-{};
+    : public std::is_same<void, decltype(std::declval<T&&>()())> {};
 
 /* Type trait determining whether a no-arg callable is nothrow invocable if
    required. This is where SG_REQUIRE_NOEXCEPT logic is encapsulated. */
 template <typename T>
 struct is_nothrow_invocable_if_required_t
-  : public
+    : public
 #ifdef SG_REQUIRE_NOEXCEPT
-  std::is_nothrow_invocable<T>         /* Note: _r variants not enough to
-                                          confirm void return: any return can be
-                                          discarded so all returns are
-                                          compatible with void */
+      std::is_nothrow_invocable<T> /* Note: _r variants not enough to
+                                      confirm void return: any return can be
+                                      discarded so all returns are
+                                      compatible with void */
 #else
-  std::true_type
+      std::true_type
 #endif
-{};
+{
+};
 
 // logic AND of two or more type traits
-template <typename A, typename B, typename ... C>
-struct and_t : public and_t<A, and_t<B, C...>>
-{};     // for more than two arguments
+template <typename A, typename B, typename... C>
+struct and_t : public and_t<A, and_t<B, C...>> {
+};  // for more than two arguments
 
 template <typename A, typename B>
-struct and_t<A, B> : public std::conditional<A::value, B, A>::type
-{};     // for two arguments
+struct and_t<A, B> : public std::conditional<A::value, B, A>::type {
+};  // for two arguments
 
 // Type trait determining whether a type is a proper scope_guard callback.
 template <typename T>
 struct is_proper_sg_callback_t
-  : public and_t<is_noarg_callable_t<T>,
-                 returns_void_t<T>,
-                 is_nothrow_invocable_if_required_t<T>,
-                 std::is_nothrow_destructible<T>>
-{};
-
+    : public and_t<is_noarg_callable_t<T>,
+                   returns_void_t<T>,
+                   is_nothrow_invocable_if_required_t<T>,
+                   std::is_nothrow_destructible<T>> {};
 
 /* --- The actual scope_guard template --- */
 
 template <typename Callback,
           typename = typename std::enable_if<
-            is_proper_sg_callback_t<Callback>::value>::type>
+              is_proper_sg_callback_t<Callback>::value>::type>
 class scope_guard;
 
-
 /* --- Now the friend maker --- */
 
 template <typename Callback>
-detail::scope_guard<Callback> make_scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
-                                                                             we need this in the inner namespace due to MSVC bugs preventing
-                                                                             sg::detail::scope_guard from befriending a sg::make_scope_guard
-                                                                             template instance in the parent namespace (see https://is.gd/xFfFhE). */
-
+detail::scope_guard<Callback> make_scope_guard(Callback&& callback) noexcept(
+    std::is_nothrow_constructible<Callback, Callback&&>::
+        value); /*
+                   we need this in the inner namespace due to MSVC bugs
+                   preventing sg::detail::scope_guard from befriending a
+                   sg::make_scope_guard template instance in the parent
+                   namespace (see https://is.gd/xFfFhE). */
 
 /* --- The template specialization that actually defines the class --- */
 
 template <typename Callback>
-class SG_NODISCARD scope_guard<Callback> final
-{
-public:
+class SG_NODISCARD scope_guard<Callback> final {
+ public:
   using callback_type = Callback;
 
-  scope_guard(scope_guard&& other)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);
+  scope_guard(scope_guard&& other) noexcept(
+      std::is_nothrow_constructible<Callback, Callback&&>::value);
 
-  ~scope_guard() noexcept;     // highlight noexcept dtor
+  ~scope_guard() noexcept;  // highlight noexcept dtor
 
   void dismiss() noexcept;
 
-public:
+ public:
   scope_guard() = delete;
   scope_guard(const scope_guard&) = delete;
   scope_guard& operator=(const scope_guard&) = delete;
   scope_guard& operator=(scope_guard&&) = delete;
 
-private:
-  explicit scope_guard(Callback&& callback)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
-                                                                               meant for friends only */
+ private:
+  explicit scope_guard(Callback&& callback) noexcept(
+      std::is_nothrow_constructible<Callback, Callback&&>::
+          value); /*
+                     meant for friends only */
 
-  friend scope_guard<Callback> make_scope_guard<Callback>(Callback&&)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
-                                                                               only make_scope_guard can create scope_guards from scratch (i.e. non-move)
-                                                                             */
+  friend scope_guard<Callback> make_scope_guard<Callback>(Callback&&) noexcept(
+      std::is_nothrow_constructible<Callback, Callback&&>::
+          value); /*
+                     only make_scope_guard can create scope_guards from scratch
+                     (i.e. non-move)
+                   */
 
-private:
+ private:
   Callback m_callback;
   bool m_active;
-
 };
 
-}   // namespace detail
-
+}  // namespace detail
 
 /* --- Now the single public maker function --- */
 
-using detail::make_scope_guard;   // see comment on declaration above
+using detail::make_scope_guard;  // see comment on declaration above
 
-} // namespace sg
+}  // namespace sg
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
-  : m_callback(std::forward<Callback>(callback)) /* use () instead of {} because
-                                                    of DR 1467 (https://is.gd/WHmWuo), which still impacts older compilers
-                                                    (e.g. GCC 4.x and clang <=3.6, see https://godbolt.org/g/TE9tPJ and
-                                                    https://is.gd/Tsmh8G) */
-  , m_active{true}
-{}
+sg::detail::scope_guard<Callback>::scope_guard(Callback&& callback) noexcept(
+    std::is_nothrow_constructible<Callback, Callback&&>::value)
+    : m_callback(std::forward<Callback>(
+          callback)) /* use () instead of {} because
+                        of DR 1467 (https://is.gd/WHmWuo), which still impacts
+                        older compilers (e.g. GCC 4.x and clang <=3.6, see
+                        https://godbolt.org/g/TE9tPJ and https://is.gd/Tsmh8G)
+                      */
+      ,
+      m_active{true} {}
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard::~scope_guard() noexcept  /*
-                                                                            need the extra injected-class-name here to make different compilers happy */
+sg::detail::scope_guard<Callback>::scope_guard::
+    ~scope_guard() noexcept /*
+                               need the extra injected-class-name here to make
+                               different compilers happy */
 {
-  if (m_active)m_callback();
+  if (m_active)
+    m_callback();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard(scope_guard&& other)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
-  : m_callback(std::forward<Callback>(other.m_callback)) // idem
-  , m_active{other.m_active}
-{
+sg::detail::scope_guard<Callback>::scope_guard(scope_guard&& other) noexcept(
+    std::is_nothrow_constructible<Callback, Callback&&>::value)
+    : m_callback(std::forward<Callback>(other.m_callback))  // idem
+      ,
+      m_active{other.m_active} {
   other.m_active = false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-inline void sg::detail::scope_guard<Callback>::dismiss() noexcept
-{
+inline void sg::detail::scope_guard<Callback>::dismiss() noexcept {
   m_active = false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-inline auto sg::detail::make_scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
--> detail::scope_guard<Callback>
-{
+inline auto sg::detail::make_scope_guard(Callback&& callback) noexcept(
+    std::is_nothrow_constructible<Callback, Callback&&>::value)
+    -> detail::scope_guard<Callback> {
   return detail::scope_guard<Callback>{std::forward<Callback>(callback)};
 }
 
diff --git a/src/utils/svg.cc b/src/utils/svg.cc
index 2531ea2a3..b74c97f25 100644
--- a/src/utils/svg.cc
+++ b/src/utils/svg.cc
@@ -18,8 +18,7 @@ namespace OpenSCAD {
 int svg_px_width = SVG_PXW;
 int svg_px_height = SVG_PXH;
 
-std::string svg_header(int widthpx, int heightpx)
-{
+std::string svg_header(int widthpx, int heightpx) {
   std::ostringstream out;
   out << "<svg width='" << widthpx << "px' height='" << heightpx << "px'"
       << " xmlns='http://www.w3.org/2000/svg' version='1.1'>\n";
@@ -28,15 +27,14 @@ std::string svg_header(int widthpx, int heightpx)
   return out.str();
 }
 
-std::string svg_label(const std::string& s)
-{
+std::string svg_label(const std::string& s) {
   std::ostringstream out;
-  out << "   <text fill='black' x='20' y='40' font-size='24'>" << s << "</text>";
+  out << "   <text fill='black' x='20' y='40' font-size='24'>" << s
+      << "</text>";
   return out.str();
 }
 
-std::string svg_styleblock(const std::string& strokewidth)
-{
+std::string svg_styleblock(const std::string& strokewidth) {
   std::ostringstream out;
   // halfedge: f1/f0 = face mark, b1/b0 = body or hole, m1/m0 = halfedge mark
   out << "\
@@ -55,38 +53,36 @@ std::string svg_styleblock(const std::string& strokewidth)
   return tmp;
 }
 
-std::string svg_border()
-{
+std::string svg_border() {
   std::ostringstream out;
   out << " <!-- border -->\n";
-  out << "  <polyline points='0,0 "
-      << svg_px_width << ",0 "
-      << svg_px_width << "," << svg_px_height
-      << " 0," << svg_px_height << "'"
+  out << "  <polyline points='0,0 " << svg_px_width << ",0 " << svg_px_width
+      << "," << svg_px_height << " 0," << svg_px_height << "'"
       << " style='fill:none;stroke:black' />\n";
   out << " <!-- /border -->";
   return out.str();
 }
 
-std::string svg_axes()
-{
+std::string svg_axes() {
   std::ostringstream out;
   out << " <!-- axes -->\n";
-  out << "  <polyline points='10,455 10,475 10,465 18,465 2,465 10,465 14,461 6,469 10,465'"
+  out << "  <polyline points='10,455 10,475 10,465 18,465 2,465 10,465 14,461 "
+         "6,469 10,465'"
       << " style='fill:none;stroke:black;' />\n";
   out << " <!-- /axes -->";
   return out.str();
 }
 
-CGAL_Nef_polyhedron2::Explorer::Point project_svg_3to2(const CGAL_Point_3& p, const CGAL_Iso_cuboid_3& bbox)
-{
+CGAL_Nef_polyhedron2::Explorer::Point project_svg_3to2(
+    const CGAL_Point_3& p,
+    const CGAL_Iso_cuboid_3& bbox) {
   CGAL_Kernel3::FT screenw(svg_px_width);
   CGAL_Kernel3::FT screenh(svg_px_height);
   CGAL_Kernel3::FT screenxc = screenw / 2;
   CGAL_Kernel3::FT screenyc = screenh / 2;
-  CGAL_Kernel3::FT bboxx = (bbox.xmax() - bbox.xmin() );
-  CGAL_Kernel3::FT bboxy = (bbox.ymax() - bbox.ymin() );
-  CGAL_Kernel3::FT bboxz = (bbox.zmax() - bbox.zmin() );
+  CGAL_Kernel3::FT bboxx = (bbox.xmax() - bbox.xmin());
+  CGAL_Kernel3::FT bboxy = (bbox.ymax() - bbox.ymin());
+  CGAL_Kernel3::FT bboxz = (bbox.zmax() - bbox.zmin());
   CGAL_Kernel3::FT largest_dim = CGAL::max(CGAL::max(bboxx, bboxy), bboxz);
   CGAL_Kernel3::FT bboxxc = bboxx / 2 + bbox.xmin();
   CGAL_Kernel3::FT bboxyc = bboxy / 2 + bbox.ymin();
@@ -95,34 +91,36 @@ CGAL_Nef_polyhedron2::Explorer::Point project_svg_3to2(const CGAL_Point_3& p, co
   CGAL_Kernel3::FT yinbox = (p.y() - bboxyc) / largest_dim;
   CGAL_Kernel3::FT zinbox = (p.z() - bboxzc) / largest_dim;
   // do simple fake parallel projection
-  CGAL_Kernel3::FT tx = screenxc + xinbox * screenw / 1.618 + yinbox * screenh / 3.2;
-  CGAL_Kernel3::FT ty = screenyc - zinbox * screenh / 1.618 - yinbox * screenh / 3.2;
+  CGAL_Kernel3::FT tx =
+      screenxc + xinbox * screenw / 1.618 + yinbox * screenh / 3.2;
+  CGAL_Kernel3::FT ty =
+      screenyc - zinbox * screenh / 1.618 - yinbox * screenh / 3.2;
   return {CGAL::to_double(tx), CGAL::to_double(ty)};
 }
 
-CGAL_Point_2e project_svg_2to2(const CGAL_Point_2e& p, const CGAL_Iso_rectangle_2e& bbox)
-{
+CGAL_Point_2e project_svg_2to2(const CGAL_Point_2e& p,
+                               const CGAL_Iso_rectangle_2e& bbox) {
   double screenw = svg_px_width;
   double screenh = svg_px_height;
   double borderw = screenw * 0.1618;
   double borderh = screenh * 0.1618;
   double vizw = screenw - borderw * 2;
   double vizh = screenh - borderh * 2;
-  double bboxw = CGAL::to_double(bbox.xmax() - bbox.xmin() );
-  double bboxh = CGAL::to_double(bbox.ymax() - bbox.ymin() );
-  double xinbox = CGAL::to_double(p.x() ) - CGAL::to_double(bbox.xmin() );
-  double yinbox = CGAL::to_double(p.y() ) - CGAL::to_double(bbox.ymin() );
-  double tx = borderw + (xinbox / (bboxw == 0?1:bboxw) ) * (vizw);
-  double ty = screenh - borderh - (yinbox / (bboxh == 0?1:bboxh) ) * (vizh);
+  double bboxw = CGAL::to_double(bbox.xmax() - bbox.xmin());
+  double bboxh = CGAL::to_double(bbox.ymax() - bbox.ymin());
+  double xinbox = CGAL::to_double(p.x()) - CGAL::to_double(bbox.xmin());
+  double yinbox = CGAL::to_double(p.y()) - CGAL::to_double(bbox.ymin());
+  double tx = borderw + (xinbox / (bboxw == 0 ? 1 : bboxw)) * (vizw);
+  double ty = screenh - borderh - (yinbox / (bboxh == 0 ? 1 : bboxh)) * (vizh);
   return {tx, ty};
 }
 
 std::string dump_cgal_nef_polyhedron2_face_svg(
-  CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c1,
-  CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c2,
-  const CGAL_Nef_polyhedron2::Explorer& explorer,
-  bool facemark, bool body)
-{
+    CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c1,
+    CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c2,
+    const CGAL_Nef_polyhedron2::Explorer& explorer,
+    bool facemark,
+    bool body) {
   std::ostringstream style;
   style << "halfedge_f" << facemark << "_b" << body << "_m";
   auto styleclass = style.str();
@@ -130,8 +128,8 @@ std::string dump_cgal_nef_polyhedron2_face_svg(
   std::ostringstream out;
   CGAL_For_all(c1, c2) {
     if (explorer.is_standard(explorer.target(c1))) {
-      auto source = explorer.point(explorer.source(c1) );
-      auto target = explorer.point(explorer.target(c1) );
+      auto source = explorer.point(explorer.source(c1));
+      auto target = explorer.point(explorer.target(c1));
       out << "    <!-- Halfedge. Mark: " << c1->mark() << " -->\n";
       auto he_mark = boost::lexical_cast<std::string>(c1->mark());
       out << "     <line"
@@ -147,20 +145,21 @@ std::string dump_cgal_nef_polyhedron2_face_svg(
   return out.str();
 }
 
-static CGAL_Iso_rectangle_2e bounding_box(const CGAL_Nef_polyhedron2& N)
-{
+static CGAL_Iso_rectangle_2e bounding_box(const CGAL_Nef_polyhedron2& N) {
   auto explorer = N.explorer();
   std::vector<CGAL_Point_2e> points;
   // can be optimized by rewriting bounding_box to accept vertices
-  for (auto vi = explorer.vertices_begin(); vi != explorer.vertices_end(); ++vi) {
-    if (explorer.is_standard(vi)) points.push_back(explorer.point(vi));
+  for (auto vi = explorer.vertices_begin(); vi != explorer.vertices_end();
+       ++vi) {
+    if (explorer.is_standard(vi))
+      points.push_back(explorer.point(vi));
   }
-  if (points.size() > 0) return CGAL::bounding_box(points.begin(), points.end());
+  if (points.size() > 0)
+    return CGAL::bounding_box(points.begin(), points.end());
   return {0, 0, 0, 0};
 }
 
-std::string dump_svg(const CGAL_Nef_polyhedron2& N)
-{
+std::string dump_svg(const CGAL_Nef_polyhedron2& N) {
   std::ostringstream out;
   auto explorer = N.explorer();
   auto bbox = bounding_box(N);
@@ -175,13 +174,17 @@ std::string dump_svg(const CGAL_Nef_polyhedron2& N)
     out << "   <!-- body begin -->\n";
     auto c1(explorer.face_cycle(i));
     auto c2(c1);
-    out << dump_cgal_nef_polyhedron2_face_svg(c1, c2, explorer, i->mark(), true);
+    out << dump_cgal_nef_polyhedron2_face_svg(c1, c2, explorer, i->mark(),
+                                              true);
     out << "   <!-- body end -->\n";
 
     for (auto j = explorer.holes_begin(i); j != explorer.holes_end(i); ++j) {
       out << "   <!-- hole begin. mark: " << j->mark() << " -->\n";
-      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c3(j), c4(c3);
-      out << dump_cgal_nef_polyhedron2_face_svg(c3, c4, explorer, j->mark(), false);
+      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c3(
+          j),
+          c4(c3);
+      out << dump_cgal_nef_polyhedron2_face_svg(c3, c4, explorer, j->mark(),
+                                                false);
       out << "   <!-- hole end -->\n";
     }
     out << "  <!-- face end -->\n";
@@ -192,40 +195,34 @@ std::string dump_svg(const CGAL_Nef_polyhedron2& N)
   return tmp;
 }
 
-std::string point_dump(const CGAL_Point_3& p)
-{
+std::string point_dump(const CGAL_Point_3& p) {
   std::ostringstream out;
-  out << CGAL::to_double(p.x()) << ","
-      << CGAL::to_double(p.y()) << ","
+  out << CGAL::to_double(p.x()) << "," << CGAL::to_double(p.y()) << ","
       << CGAL::to_double(p.z());
   return out.str();
 }
 
-std::string point_dump(const CGAL::Sphere_point<CGAL_Kernel3>& p)
-{
+std::string point_dump(const CGAL::Sphere_point<CGAL_Kernel3>& p) {
   std::ostringstream out;
-  out << CGAL::to_double(p.x()) << ","
-      << CGAL::to_double(p.y()) << ","
+  out << CGAL::to_double(p.x()) << "," << CGAL::to_double(p.y()) << ","
       << CGAL::to_double(p.z());
   return out.str();
 }
 
-std::string vert_dump(CGAL_Nef_polyhedron3::Vertex_const_handle vch)
-{
-  return point_dump(vch->point() );
+std::string vert_dump(CGAL_Nef_polyhedron3::Vertex_const_handle vch) {
+  return point_dump(vch->point());
 }
 
-std::string vert_dump(CGAL_Nef_polyhedron3::Nef_polyhedron_S2::SVertex_const_handle vch)
-{
-  return point_dump(vch->point() );
+std::string vert_dump(
+    CGAL_Nef_polyhedron3::Nef_polyhedron_S2::SVertex_const_handle vch) {
+  return point_dump(vch->point());
 }
 
 /*
    Dump the 'sphere map' of every vertex in a CGAL Nef Polyhedron3
    see http://doc.cgal.org/latest/Nef_3/index.html
  */
-std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
-{
+std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N) {
   std::ostringstream out;
   using Vertex_const_iterator = CGAL_Nef_polyhedron3::Vertex_const_iterator;
   using Nef_polyhedron_S2 = CGAL_Nef_polyhedron3::Nef_polyhedron_S2;
@@ -233,13 +230,15 @@ std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
   using SHalfedge_const_handle = Nef_polyhedron_S2::SHalfedge_const_handle;
   using SHalfloop_const_handle = Nef_polyhedron_S2::SHalfloop_const_handle;
   using SFace_const_iterator = Nef_polyhedron_S2::SFace_const_iterator;
-  using SFace_cycle_const_iterator = Nef_polyhedron_S2::SFace_cycle_const_iterator;
+  using SFace_cycle_const_iterator =
+      Nef_polyhedron_S2::SFace_cycle_const_iterator;
   Vertex_const_iterator v;
   out << "<!-- sphere map begin -->\n";
   int counter = 0;
   for (v = N.vertices_begin(); v != N.vertices_end(); ++v) {
     counter++;
-    out << "<!-- vertex sphere map begin. vertex counter is " << counter << "\n";
+    out << "<!-- vertex sphere map begin. vertex counter is " << counter
+        << "\n";
     out << "     vertex coordinates: " << vert_dump(v) << "-->\n";
     Nef_polyhedron_S2 S(N.get_sphere_map(v));
 
@@ -248,26 +247,31 @@ std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
     out << "  number of shalfedges: " << S.number_of_shalfedges() << std::endl;
     out << "  number of shalfloops: " << S.number_of_shalfloops() << std::endl;
     out << "  number of sfaces: " << S.number_of_sfaces() << std::endl;
-    out << "  number of sface cycles: " << S.number_of_sface_cycles() << std::endl;
-    out << "  connected_components: " << S.number_of_connected_components() << "\n";
+    out << "  number of sface cycles: " << S.number_of_sface_cycles()
+        << std::endl;
+    out << "  connected_components: " << S.number_of_connected_components()
+        << "\n";
     out << "  integrity check...(asserts if not OK)\n";
     S.check_integrity_and_topological_planarity();
-// S.print_statistics( out );
+    // S.print_statistics( out );
     int i = 0;
     SFace_const_iterator sf;
     for (sf = S.sfaces_begin(); sf != S.sfaces_end(); ++sf) {
       SFace_cycle_const_iterator it;
       out << " the sface cycles of sface " << i++ << " start with an\n";
       for (it = sf->sface_cycles_begin(); it != sf->sface_cycles_end(); ++it) {
-        if (it.is_svertex()) out << "  svertex at position "
-                                 << vert_dump(SVertex_const_handle(it) ) << "\n";
+        if (it.is_svertex())
+          out << "  svertex at position " << vert_dump(SVertex_const_handle(it))
+              << "\n";
         else if (it.is_shalfedge())
           out << "  shalfedge from "
-              << vert_dump(SHalfedge_const_handle(it)->source() ) << " to "
-              << vert_dump(SHalfedge_const_handle(it)->target() ) << std::endl;
-        else if (it.is_shalfloop()) out << "  shalfloop lying in the plane "
-                                        << SHalfloop_const_handle(it)->circle() << std::endl;
-        else out << "  unknown bug\n";
+              << vert_dump(SHalfedge_const_handle(it)->source()) << " to "
+              << vert_dump(SHalfedge_const_handle(it)->target()) << std::endl;
+        else if (it.is_shalfloop())
+          out << "  shalfloop lying in the plane "
+              << SHalfloop_const_handle(it)->circle() << std::endl;
+        else
+          out << "  unknown bug\n";
       }
     }
     out << "\n  vertex sphere map end -->\n";
@@ -276,44 +280,38 @@ std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
   return out.str();
 }
 
-// This uses the Shell Explorer pattern from the CGAL Manual to dump the 3d Nef Polyhedron information
+// This uses the Shell Explorer pattern from the CGAL Manual to dump the 3d Nef
+// Polyhedron information
 // http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Nef_3/Chapter_main.html#Subsection_29.7.2
-class NefPoly3_dumper_svg
-{
-public:
+class NefPoly3_dumper_svg {
+ public:
   std::ostringstream out;
   CGAL_Iso_cuboid_3 bbox;
-  NefPoly3_dumper_svg(const CGAL_Nef_polyhedron3& N)
-  {
+  NefPoly3_dumper_svg(const CGAL_Nef_polyhedron3& N) {
     bbox = CGALUtils::boundingBox(N);
   }
-  void visit(CGAL_Nef_polyhedron3::Vertex_const_handle vch)
-  {
+  void visit(CGAL_Nef_polyhedron3::Vertex_const_handle vch) {
     auto p = vch->point();
     out << "     <!-- vertex " << point_dump(p) << " -->\n";
   }
-  void visit(CGAL_Nef_polyhedron3::Halfedge_const_handle)
-  {
+  void visit(CGAL_Nef_polyhedron3::Halfedge_const_handle) {
     out << "  <!-- halfedge --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SHalfedge_const_handle)
-  {
+  void visit(CGAL_Nef_polyhedron3::SHalfedge_const_handle) {
     out << "  <!-- shalfedge --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SHalfloop_const_handle)
-  {
+  void visit(CGAL_Nef_polyhedron3::SHalfloop_const_handle) {
     out << "  <!-- shalfloop --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SFace_const_handle)
-  {
+  void visit(CGAL_Nef_polyhedron3::SFace_const_handle) {
     out << "  <!-- sface --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
-  {
+  void visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet) {
     int contour_count = 0;
     out << "  <!-- Halffacet visit. Mark: " << (*hfacet).mark() << " -->\n";
     std::string color = "gold";
-    if (!(*hfacet).mark()) color = "green";
+    if (!(*hfacet).mark())
+      color = "green";
     CGAL_Nef_polyhedron3::Halffacet_cycle_const_iterator i;
     CGAL_forall_facet_cycles_of(i, hfacet) {
       CGAL_Nef_polyhedron3::SHalfloop_const_handle shl_handle;
@@ -323,24 +321,28 @@ public:
       } else {
         out << "    <!-- Hole contour:--> \n";
       }
-      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(i), c2(c1);
+      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(i),
+          c2(c1);
       CGAL_For_all(c1, c2) {
-        // don't know why we use source()->source(), except that's what CGAL does internally
+        // don't know why we use source()->source(), except that's what CGAL
+        // does internally
         auto source = c1->source()->source()->point();
         auto target = c1->source()->target()->point();
         auto tp1 = project_svg_3to2(source, bbox);
         auto tp2 = project_svg_3to2(target, bbox);
         out << "     <!-- " << CGAL::to_double(source.x()) << ","
-            << CGAL::to_double(source.y()) << ","
-            << CGAL::to_double(source.z()) << " -->\n";
+            << CGAL::to_double(source.y()) << "," << CGAL::to_double(source.z())
+            << " -->\n";
         out << "     <line "
             << "x1='" << CGAL::to_double(tp1.x()) << "' "
             << "y1='" << CGAL::to_double(tp1.y()) << "' "
             << "x2='" << CGAL::to_double(tp2.x()) << "' "
             << "y2='" << CGAL::to_double(tp2.y()) << "' "
             << " stroke='" << color << "'";
-        if (!(*hfacet).mark()) out << " stroke-dasharray='4 4' />\n";
-        else out << " />\n";
+        if (!(*hfacet).mark())
+          out << " stroke-dasharray='4 4' />\n";
+        else
+          out << " />\n";
       }
       contour_count++;
       out << "   <!-- Halffacet cycle end -->\n";
@@ -349,9 +351,7 @@ public:
   }
 };
 
-
-std::string dump_svg(const CGAL_Nef_polyhedron3& N)
-{
+std::string dump_svg(const CGAL_Nef_polyhedron3& N) {
   std::ostringstream out;
   std::string linewidth = "0.05";
   out << "<!--CGAL_Nef_polyhedron3 dump begin-->\n";
@@ -362,9 +362,8 @@ std::string dump_svg(const CGAL_Nef_polyhedron3& N)
       << "\nnumber of halfedges " << N.number_of_halfedges()
       << "\nnumber of edges " << N.number_of_edges()
       << "\nnumber of halffacets " << N.number_of_halffacets()
-      << "\nnumber of facets " << N.number_of_facets()
-      << "\nnumber of volumes " << N.number_of_volumes()
-      << "\nis_simple()? " << N.is_simple()
+      << "\nnumber of facets " << N.number_of_facets() << "\nnumber of volumes "
+      << N.number_of_volumes() << "\nis_simple()? " << N.is_simple()
       << "\nis_valid()? " << (const_cast<CGAL_Nef_polyhedron3&>(N)).is_valid()
       << "\n -->\n";
   out << "<!-- CGAL Nef Polyhedron sphere map: -->\n";
@@ -378,7 +377,8 @@ std::string dump_svg(const CGAL_Nef_polyhedron3& N)
     CGAL_forall_shells_of(it, c) {
       out << "  <!--Shell begin-->\n";
       NefPoly3_dumper_svg dumper_svg(N);
-      N.visit_shell_objects(CGAL_Nef_polyhedron3::SFace_const_handle(it), dumper_svg);
+      N.visit_shell_objects(CGAL_Nef_polyhedron3::SFace_const_handle(it),
+                            dumper_svg);
       out << dumper_svg.out.str();
       out << "  <!--Shell end-->\n";
     }
@@ -391,6 +391,6 @@ std::string dump_svg(const CGAL_Nef_polyhedron3& N)
   return tmp;
 }
 
-} // namespace
+}  // namespace OpenSCAD
 
-#endif // ENABLE_CGAL
+#endif  // ENABLE_CGAL
diff --git a/src/utils/svg.h b/src/utils/svg.h
index 62ae893dd..f65ab505b 100644
--- a/src/utils/svg.h
+++ b/src/utils/svg.h
@@ -23,4 +23,4 @@ std::string svg_axes();
 std::string dump_svg(const CGAL_Nef_polyhedron2& N);
 std::string dump_svg(const CGAL_Nef_polyhedron3& N);
 
-} // namespace
+}  // namespace OpenSCAD
diff --git a/src/utils/version_check.h b/src/utils/version_check.h
index eff3cf315..dbed50e7e 100644
--- a/src/utils/version_check.h
+++ b/src/utils/version_check.h
@@ -18,46 +18,43 @@
 
 #ifndef OPENSCAD_SKIP_VERSION_CHECK
 
-#include <cstddef> // Needed by gmp.h under OS X 10.10
 #include <gmp.h>
+#include <cstddef>  // Needed by gmp.h under OS X 10.10
 // set minimum numbers here.
 #define GMPMAJOR 5
 #define GMPMINOR 0
 #define GMPPATCH 0
-#define SYS_GMP_VER  (__GNU_MP_VERSION * 10000 + __GNU_MP_VERSION_MINOR * 100 + __GNU_MP_VERSION_PATCHLEVEL * 1)
+#define SYS_GMP_VER                                          \
+  (__GNU_MP_VERSION * 10000 + __GNU_MP_VERSION_MINOR * 100 + \
+   __GNU_MP_VERSION_PATCHLEVEL * 1)
 #if SYS_GMP_VER < GMPMAJOR * 10000 + GMPMINOR * 100 + GMPPATCH * 1
 #error GNU GMP library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <mpfr.h>
 #if MPFR_VERSION < MPFR_VERSION_NUM(3, 0, 0)
 #error GNU MPFR library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <Eigen/Core>
 #if !EIGEN_VERSION_AT_LEAST(3, 0, 0)
 #error eigen library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <boost/version.hpp>
 // boost 1.55 = 105500
 #if BOOST_VERSION < 105500
 #error boost library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #ifdef ENABLE_CGAL
 #include <CGAL/version.h>
 
 #if CGAL_VERSION_NR < 1040900000
 #error CGAL library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
-#endif //ENABLE_CGAL
+#endif  // ENABLE_CGAL
 #else
 
-
 #if defined(ENABLE_OPENCSG) && defined(OPENCSG_GLEW)
 #include <GL/glew.h>
 // kludge - GLEW doesn't have compiler-accessible version numbering
@@ -65,43 +62,39 @@
 #error GLEW library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <opencsg.h>
 // 1.4.2 -> 0x0142
 #if OPENCSG_VERSION < 0x0142
 #error OPENCSG library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
-#endif // ENABLE_OPENCSG
-
+#endif  // ENABLE_OPENCSG
 
 #ifndef OPENSCAD_NOGUI
 #include <QtCore/qglobal.h>
 #if QT_VERSION < QT_VERSION_CHECK(5, 12, 0)
 #error QT library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
-#endif // QT
+#endif  // QT
 #endif
 
-
 #ifdef ENABLE_OPENCSG
-#endif // OpenCSG
-#endif // GLEW
-#endif // ENABLE_OPENCSG
+#endif  // OpenCSG
+#endif  // GLEW
+#endif  // ENABLE_OPENCSG
 
 #ifdef ENABLE_CGAL
-#endif // CGAL error
-#endif // ENABLE_CGAL
+#endif  // CGAL error
+#endif  // ENABLE_CGAL
 
-#endif // Boost
-#endif // Eigen
-#endif // MPFR
-#endif // GMP
+#endif  // Boost
+#endif  // Eigen
+#endif  // MPFR
+#endif  // GMP
 
 // see github issue #552
-#define GCC_VERSION (__GNUC__ * 10000 \
-                     + __GNUC_MINOR__ * 100 \
-                     + __GNUC_PATCHLEVEL__)
+#define GCC_VERSION \
+  (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
 #if GCC_VERSION == 40802
 #warning "gcc 4.8.2 contains a bug causing a crash in CGAL."
 #endif
 
-#endif // OPENSCAD_SKIP_VERSION_CHECK
+#endif  // OPENSCAD_SKIP_VERSION_CHECK
diff --git a/src/utils/version_helper.h b/src/utils/version_helper.h
index f578b4f6b..9f25e4eb1 100644
--- a/src/utils/version_helper.h
+++ b/src/utils/version_helper.h
@@ -5,34 +5,39 @@
 
 namespace OpenSCAD {
 
-struct library_version_number
-{
+struct library_version_number {
   const unsigned int major;
   const unsigned int minor;
   const unsigned int micro;
 };
 
-const auto get_version_string = [](const library_version_number& header_version, const library_version_number& runtime_version)
-  {
-    std::ostringstream version_stream;
-
-    version_stream << header_version.major << '.' << header_version.minor << '.' << header_version.micro;
-    const bool match = (header_version.major == runtime_version.major && header_version.minor == runtime_version.minor && header_version.micro == runtime_version.micro);
-    if (!match) {
-      version_stream << " (runtime: " << runtime_version.major << '.' << runtime_version.minor << '.' << runtime_version.micro << ')';
-    }
-    return version_stream.str();
-  };
-
-const auto get_version = [](const std::string& header_version, const std::string& runtime_version)
-  {
-    std::ostringstream version_stream;
-
-    version_stream << header_version;
-    if (header_version != runtime_version) {
-      version_stream << " (runtime: " << runtime_version << ')';
-    }
-    return version_stream.str();
-  };
-
-} // namespace OpenSCAD
+const auto get_version_string =
+    [](const library_version_number& header_version,
+       const library_version_number& runtime_version) {
+      std::ostringstream version_stream;
+
+      version_stream << header_version.major << '.' << header_version.minor
+                     << '.' << header_version.micro;
+      const bool match = (header_version.major == runtime_version.major &&
+                          header_version.minor == runtime_version.minor &&
+                          header_version.micro == runtime_version.micro);
+      if (!match) {
+        version_stream << " (runtime: " << runtime_version.major << '.'
+                       << runtime_version.minor << '.' << runtime_version.micro
+                       << ')';
+      }
+      return version_stream.str();
+    };
+
+const auto get_version = [](const std::string& header_version,
+                            const std::string& runtime_version) {
+  std::ostringstream version_stream;
+
+  version_stream << header_version;
+  if (header_version != runtime_version) {
+    version_stream << " (runtime: " << runtime_version << ')';
+  }
+  return version_stream.str();
+};
+
+}  // namespace OpenSCAD
diff --git a/src/version.cc b/src/version.cc
index cc27518a5..fb14974d1 100644
--- a/src/version.cc
+++ b/src/version.cc
@@ -28,7 +28,7 @@
 
 #include <string>
 
-#define QUOTE(x__) # x__
+#define QUOTE(x__) #x__
 #define QUOTED(x__) QUOTE(x__)
 
 std::string openscad_shortversionnumber = QUOTED(OPENSCAD_SHORTVERSION);
@@ -36,15 +36,14 @@ std::string openscad_versionnumber = QUOTED(OPENSCAD_VERSION);
 
 std::string openscad_displayversionnumber =
 #ifdef OPENSCAD_COMMIT
-  QUOTED(OPENSCAD_VERSION)
-  " (git " QUOTED(OPENSCAD_COMMIT) ")";
+    QUOTED(OPENSCAD_VERSION) " (git " QUOTED(OPENSCAD_COMMIT) ")";
 #else
-  QUOTED(OPENSCAD_SHORTVERSION);
+    QUOTED(OPENSCAD_SHORTVERSION);
 #endif
 
 std::string openscad_detailedversionnumber =
 #ifdef OPENSCAD_COMMIT
-  openscad_displayversionnumber;
+    openscad_displayversionnumber;
 #else
-  openscad_versionnumber;
+    openscad_versionnumber;
 #endif
